#pragma once
#include "detours/detours.h"
#include <timeapi.h>
#include <winnt.h>

#pragma comment(lib,"Kernel32.lib")
#pragma comment(lib,"Winmm.lib")

static FAccuracySettings OldAccuracy{};
static FAccuracySettings NewAccuracy{};

static BOOL(WINAPI* originalQueryPerformanceCounter)(LARGE_INTEGER* performanceCounter) = QueryPerformanceCounter;
static DWORD(WINAPI* originalGetTickCount)() = GetTickCount;
static ULONGLONG(WINAPI* originalGetTickCount64)() = GetTickCount64;
static DWORD(WINAPI* originalTimeGetTime)() = timeGetTime;

template<class T>
class SpeedHackClass
{
private:
	int speed = 0;
	T initialoffset;
	T initialtime;
public:
	SpeedHackClass()
	{
		speed = 1.0;
	}
	SpeedHackClass(T _initialtime, T _initialoffset, int _speed = 1.0)
	{
		speed = _speed;
		initialoffset = _initialoffset;
		initialtime = _initialtime;
	}

	int get_speed() const { return speed; }

	T get(T currentTime)
	{
		T false_val = (T)((currentTime - initialtime) * speed) + initialoffset;
		return (T)false_val;
	}

	void set_speed(int _speed)
	{
		speed = _speed;
	}
};


SpeedHackClass<LONGLONG> h_QueryPerformanceCounter;
SpeedHackClass<DWORD> h_GetTickCount;
SpeedHackClass<ULONGLONG> h_GetTickCount64;
SpeedHackClass<DWORD> h_GetTime;

int lastspeed = 1; // Game speed lastspeed

BOOL WINAPI newQueryPerformanceCounter(LARGE_INTEGER* counter) {
	LARGE_INTEGER currentLi;
	LARGE_INTEGER falseLi;
	originalQueryPerformanceCounter(&currentLi);
	falseLi.QuadPart = h_QueryPerformanceCounter.get(currentLi.QuadPart);

	*counter = falseLi;
	return true;
}

DWORD WINAPI newGetTickCount() {
	auto res = h_GetTickCount.get(originalGetTickCount());

	return res;
}

ULONGLONG WINAPI newGetTickCount64() {
	auto res = h_GetTickCount64.get(originalGetTickCount64());

	return res;
}

DWORD WINAPI newTimeGetTime() {
	return h_GetTime.get(originalTimeGetTime());
}

LARGE_INTEGER initialtime64;
LARGE_INTEGER initialoffset64;

bool hooked, hook_once = false;
void doSpeedhack(bool state)
{
	// This is the QPC hook, it needs to be called only once.
	if (!hook_once)
	{
		// Set initial values for hooked calculations
		originalQueryPerformanceCounter(&initialtime64);
		initialoffset64 = initialtime64;

		h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart);
		h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), originalGetTickCount());
		h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), originalGetTickCount64());
		h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), originalTimeGetTime());

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)originalQueryPerformanceCounter, newQueryPerformanceCounter);
		DetourAttach(&(PVOID&)originalGetTickCount, newGetTickCount);
		DetourAttach(&(PVOID&)originalGetTickCount64, newGetTickCount64);
		DetourAttach(&(PVOID&)originalTimeGetTime, newTimeGetTime);
		DetourTransactionCommit();
		hook_once = true;
	}

	if (state && !hooked)
	{
		if (lastspeed != config_system.item.speed)
		{
			originalQueryPerformanceCounter(&initialtime64);
			newQueryPerformanceCounter(&initialoffset64);

			h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart, config_system.item.speed);
			h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), newGetTickCount(), config_system.item.speed);
			h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), newGetTickCount64(), config_system.item.speed);
			h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), newTimeGetTime(), config_system.item.speed);

			lastspeed = config_system.item.speed;
		}
		hooked = true;
	}
	// When we disable the speehack, we make the speed 1.
	else if (!state && hooked) {
		if (lastspeed != 1)
		{
			originalQueryPerformanceCounter(&initialtime64);
			newQueryPerformanceCounter(&initialoffset64);

			h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart, 1);
			h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), newGetTickCount(), 1);
			h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), newGetTickCount64(), 1);
			h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), newTimeGetTime(), 1);

			lastspeed = 1;
		}
		hooked = false;
	}
}


bool saved_spread = false;
void setSpread(bool state)
{
	if (!saved_spread)
	{
		OldAccuracy = Globals::LocalWeapon->m_AccuracySettings;
		saved_spread = true;
	}

	if (state)
	{
		NewAccuracy.bUsesAdvancedAccuracy = true;
		NewAccuracy.fAccuracyGainPerSec = 0.0f;
		NewAccuracy.fMaxAccuracy = 1.0f;
		NewAccuracy.fMinAccuracy = 1.0f;
		Globals::LocalWeapon->m_AccuracySettings = NewAccuracy;
	}
	else if (!state && saved_spread)
	{
		Globals::LocalWeapon->m_AccuracySettings = OldAccuracy;
	}
}

void Exploits() {
	ATgPawn* LocalPawn = (ATgPawn*)Globals::LocalPawn;

	if (!Globals::LocalWeapon ||
		!Globals::LocalPawn ||
		!Globals::LocalController) {
		return;
	}

	// TODO: Fix Speedhack lags
	if (config_system.item.speedhack)
		doSpeedhack(true);
	else
		doSpeedhack(false);

	if (config_system.item.glow)
		LocalPawn->r_bIsWallHacking = true;
	else
		LocalPawn->r_bIsWallHacking = false;

	if (config_system.item.spread)
		setSpread(true);
	else
		setSpread(false);

	if (config_system.item.recoil)
		LocalPawn->m_bUsesRecoil = false;
	else
		LocalPawn->m_bUsesRecoil = true;

	if (config_system.item.thirdPerson)
		Globals::LocalWeapon->m_fForce3PPersistTimer = 5;
	else
		Globals::LocalWeapon->m_fForce3PPersistTimer = 0;
}