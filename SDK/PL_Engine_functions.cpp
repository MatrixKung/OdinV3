// Paladins (5.6) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "PL_Engine_parameters.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Functions
//---------------------------------------------------------------------------

// Function Engine.Actor.UpdateReverbVolume
// (PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 WorldLocation                  (Parm)
// class AReverbVolume*           VolumeTouched                  (OptionalParm, Parm)

void AActor::UpdateReverbVolume(const struct FVector& WorldLocation, class AReverbVolume* VolumeTouched)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.UpdateReverbVolume"));

	AActor_UpdateReverbVolume_Params params;
	params.WorldLocation = WorldLocation;
	params.VolumeTouched = VolumeTouched;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetAux
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   AuxBusName                     (Parm)
// float                          Level                          (Parm)

void AActor::SetAux(const struct FName& AuxBusName, float Level)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetAux"));

	AActor_SetAux_Params params;
	params.AuxBusName = AuxBusName;
	params.Level = Level;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetActorSpriteComponent
// (Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class USpriteComponent*        ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class USpriteComponent* AActor::STATIC_GetActorSpriteComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetActorSpriteComponent"));

	AActor_GetActorSpriteComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorMetrics
// (Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EActorMetricsType> MetricsType                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AActor::STATIC_GetActorMetrics(TEnumAsByte<EActorMetricsType> MetricsType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetActorMetrics"));

	AActor_GetActorMetrics_Params params;
	params.MetricsType = MetricsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.OnMobileTouch
// (Defined, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       InPC                           (Parm)
// struct FVector2D               TouchLocation                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::OnMobileTouch(class APlayerController* InPC, const struct FVector2D& TouchLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnMobileTouch"));

	AActor_OnMobileTouch_Params params;
	params.InPC = InPC;
	params.TouchLocation = TouchLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsMobileTouchEnabled
// (Final, Iterator, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsMobileTouchEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsMobileTouchEnabled"));

	AActor_IsMobileTouchEnabled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ShouldBeHiddenBySHOW_NavigationNodes
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::ShouldBeHiddenBySHOW_NavigationNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ShouldBeHiddenBySHOW_NavigationNodes"));

	AActor_ShouldBeHiddenBySHOW_NavigationNodes_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.WillOverlap
// (Final, Defined, PreOperator, Net, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FVector                 PosA                           (Parm)
// struct FVector                 VelA                           (Parm)
// struct FVector                 PosB                           (Parm)
// struct FVector                 VelB                           (Parm)
// float                          StepSize                       (Parm)
// float                          Radius                         (Parm)
// float                          Time                           (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::WillOverlap(const struct FVector& PosA, const struct FVector& VelA, const struct FVector& PosB, const struct FVector& VelB, float StepSize, float Radius, float* Time)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.WillOverlap"));

	AActor_WillOverlap_Params params;
	params.PosA = PosA;
	params.VelA = VelA;
	params.PosB = PosB;
	params.VelB = VelB;
	params.StepSize = StepSize;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Time != nullptr)
		*Time = params.Time;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAvoidanceVector
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<class AActor*>          Obstacles                      (Const, Parm, OutParm, NeedCtorLink)
// struct FVector                 GoalLocation                   (Parm)
// float                          CollisionRadius                (Parm)
// float                          MaxSpeed                       (Parm)
// int                            NumSamples                     (OptionalParm, Parm)
// float                          VelocityStepRate               (OptionalParm, Parm)
// float                          MaxTimeTilOverlap              (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::STATIC_GetAvoidanceVector(const struct FVector& GoalLocation, float CollisionRadius, float MaxSpeed, int NumSamples, float VelocityStepRate, float MaxTimeTilOverlap, TArray<class AActor*>* Obstacles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetAvoidanceVector"));

	AActor_GetAvoidanceVector_Params params;
	params.GoalLocation = GoalLocation;
	params.CollisionRadius = CollisionRadius;
	params.MaxSpeed = MaxSpeed;
	params.NumSamples = NumSamples;
	params.VelocityStepRate = VelocityStepRate;
	params.MaxTimeTilOverlap = MaxTimeTilOverlap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Obstacles != nullptr)
		*Obstacles = params.Obstacles;

	return params.ReturnValue;
}


// Function Engine.Actor.ReplicationEnded
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AActor::ReplicationEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ReplicationEnded"));

	AActor_ReplicationEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostTimeLapse
// (Defined, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bPlayOfTheGame                 (Parm)

void AActor::PostTimeLapse(bool bPlayOfTheGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostTimeLapse"));

	AActor_PostTimeLapse_Params params;
	params.bPlayOfTheGame = bPlayOfTheGame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PreTimeLapse
// (Final, Defined, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bPlayOfTheGame                 (Parm)

void AActor::PreTimeLapse(bool bPlayOfTheGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PreTimeLapse"));

	AActor_PreTimeLapse_Params params;
	params.bPlayOfTheGame = bPlayOfTheGame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostDemoRewind
// (Defined, Latent, Net, Exec, Native, HasOptionalParms)

void AActor::PostDemoRewind()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostDemoRewind"));

	AActor_PostDemoRewind_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PreDemoRewind
// (Defined, Iterator, PreOperator, Net, Exec, Native, HasOptionalParms)

void AActor::PreDemoRewind()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PreDemoRewind"));

	AActor_PreDemoRewind_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AnimTreeUpdated
// (Defined, Iterator, Simulated, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelMesh                       (Parm, EditInline)

void AActor::AnimTreeUpdated(class USkeletalMeshComponent* SkelMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AnimTreeUpdated"));

	AActor_AnimTreeUpdated_Params params;
	params.SkelMesh = SkelMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SupportsKismetModification
// (Defined, Net, Native, Event, HasOptionalParms)
// Parameters:
// class USequenceOp*             AskingOp                       (Parm)
// struct FString                 Reason                         (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SupportsKismetModification(class USequenceOp* AskingOp, struct FString* Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SupportsKismetModification"));

	AActor_SupportsKismetModification_Params params;
	params.AskingOp = AskingOp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Reason != nullptr)
		*Reason = params.Reason;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAnimTrailParticleSystem
// (Defined, Iterator, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// class UAnimNotify_Trails*      AnimNotifyData                 (Const, Parm)
// class UParticleSystem*         ReturnValue                    (Parm, OutParm, ReturnParm)

class UParticleSystem* AActor::STATIC_GetAnimTrailParticleSystem(class UAnimNotify_Trails* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetAnimTrailParticleSystem"));

	AActor_GetAnimTrailParticleSystem_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.TrailsNotifyEnd
// (Final, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_Trails*      AnimNotifyData                 (Const, Parm)

void AActor::TrailsNotifyEnd(class UAnimNotify_Trails* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TrailsNotifyEnd"));

	AActor_TrailsNotifyEnd_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.TrailsNotifyTick
// (Defined, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_Trails*      AnimNotifyData                 (Const, Parm)

void AActor::TrailsNotifyTick(class UAnimNotify_Trails* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TrailsNotifyTick"));

	AActor_TrailsNotifyTick_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.TrailsNotify
// (Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_Trails*      AnimNotifyData                 (Const, Parm)

void AActor::TrailsNotify(class UAnimNotify_Trails* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TrailsNotify"));

	AActor_TrailsNotify_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.CreateForceField
// (Defined, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_ForceField*  AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CreateForceField(class UAnimNotify_ForceField* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CreateForceField"));

	AActor_CreateForceField_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PlayParticleEffect
// (Final, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_PlayParticleEffect* AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlayParticleEffect"));

	AActor_PlayParticleEffect_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAimAdhesionExtent
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// float                          Width                          (Parm, OutParm)
// float                          Height                         (Parm, OutParm)
// struct FVector                 Center                         (Parm, OutParm)

void AActor::STATIC_GetAimAdhesionExtent(float* Width, float* Height, struct FVector* Center)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetAimAdhesionExtent"));

	AActor_GetAimAdhesionExtent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Width != nullptr)
		*Width = params.Width;
	if (Height != nullptr)
		*Height = params.Height;
	if (Center != nullptr)
		*Center = params.Center;
}


// Function Engine.Actor.CanApplyEffects
// (Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CanApplyEffects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CanApplyEffects"));

	AActor_CanApplyEffects_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsInPersistentLevel
// (Iterator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           bIncludeLevelStreamingPersistent (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsInPersistentLevel(bool bIncludeLevelStreamingPersistent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsInPersistentLevel"));

	AActor_IsInPersistentLevel_Params params;
	params.bIncludeLevelStreamingPersistent = bIncludeLevelStreamingPersistent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.OnRigidBodySpringOverextension
// (Defined, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class URB_BodyInstance*        BodyInstance                   (Parm)

void AActor::OnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnRigidBodySpringOverextension"));

	AActor_OnRigidBodySpringOverextension_Params params;
	params.BodyInstance = BodyInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetPackageGuid
// (Final, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FName                   PackageName                    (Parm)
// struct FGuid                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FGuid AActor::STATIC_GetPackageGuid(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetPackageGuid"));

	AActor_GetPackageGuid_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PostInitAnimTree
// (Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void AActor::PostInitAnimTree(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostInitAnimTree"));

	AActor_PostInitAnimTree_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RootMotionExtracted
// (Final, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)
// struct FBoneAtom               ExtractedRootMotionDelta       (Parm, OutParm)

void AActor::RootMotionExtracted(class USkeletalMeshComponent* SkelComp, struct FBoneAtom* ExtractedRootMotionDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RootMotionExtracted"));

	AActor_RootMotionExtracted_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ExtractedRootMotionDelta != nullptr)
		*ExtractedRootMotionDelta = params.ExtractedRootMotionDelta;
}


// Function Engine.Actor.RootMotionProcessed
// (Final, Defined, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void AActor::RootMotionProcessed(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RootMotionProcessed"));

	AActor_RootMotionProcessed_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RootMotionModeChanged
// (Defined, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void AActor::RootMotionModeChanged(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RootMotionModeChanged"));

	AActor_RootMotionModeChanged_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostRenderFor
// (PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)
// class UCanvas*                 Canvas                         (Parm)
// struct FVector                 CameraPosition                 (Parm)
// struct FVector                 CameraDir                      (Parm)

void AActor::PostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostRenderFor"));

	AActor_PostRenderFor_Params params;
	params.PC = PC;
	params.Canvas = Canvas;
	params.CameraPosition = CameraPosition;
	params.CameraDir = CameraDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.NativePostRenderFor
// (Iterator, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// class APlayerController*       PC                             (Parm)
// class UCanvas*                 Canvas                         (Parm)
// struct FVector                 CameraPosition                 (Parm)
// struct FVector                 CameraDir                      (Parm)

void AActor::STATIC_NativePostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.NativePostRenderFor"));

	AActor_NativePostRenderFor_Params params;
	params.PC = PC;
	params.Canvas = Canvas;
	params.CameraPosition = CameraPosition;
	params.CameraDir = CameraDir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetHUDLocation
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewHUDLocation                 (Parm)

void AActor::SetHUDLocation(const struct FVector& NewHUDLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetHUDLocation"));

	AActor_SetHUDLocation_Params params;
	params.NewHUDLocation = NewHUDLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRanOver
// (Iterator, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// class ASVehicle*               Vehicle                        (Parm)
// class UPrimitiveComponent*     RunOverComponent               (Parm, EditInline)
// int                            WheelIndex                     (Parm)

void AActor::OnRanOver(class ASVehicle* Vehicle, class UPrimitiveComponent* RunOverComponent, int WheelIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnRanOver"));

	AActor_OnRanOver_Params params;
	params.Vehicle = Vehicle;
	params.RunOverComponent = RunOverComponent;
	params.WheelIndex = WheelIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RigidBodyCollision
// (Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     HitComponent                   (Parm, EditInline)
// class UPrimitiveComponent*     OtherComponent                 (Parm, EditInline)
// struct FCollisionImpactData    RigidCollisionData             (Const, Parm, OutParm, NeedCtorLink)
// int                            ContactIndex                   (Parm)

void AActor::RigidBodyCollision(class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int ContactIndex, struct FCollisionImpactData* RigidCollisionData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RigidBodyCollision"));

	AActor_RigidBodyCollision_Params params;
	params.HitComponent = HitComponent;
	params.OtherComponent = OtherComponent;
	params.ContactIndex = ContactIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (RigidCollisionData != nullptr)
		*RigidCollisionData = params.RigidCollisionData;
}


// Function Engine.Actor.InterpolationChanged
// (Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void AActor::InterpolationChanged(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.InterpolationChanged"));

	AActor_InterpolationChanged_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.InterpolationFinished
// (Final, Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void AActor::InterpolationFinished(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.InterpolationFinished"));

	AActor_InterpolationFinished_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.InterpolationStarted
// (Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)
// class UInterpGroupInst*        GroupInst                      (Parm)

void AActor::InterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.InterpolationStarted"));

	AActor_InterpolationStarted_Params params;
	params.InterpAction = InterpAction;
	params.GroupInst = GroupInst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SpawnedByKismet
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void AActor::SpawnedByKismet()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SpawnedByKismet"));

	AActor_SpawnedByKismet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetTargetLocation
// (Defined, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  RequestedBy                    (OptionalParm, Parm)
// bool                           bRequestAlternateLoc           (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::STATIC_GetTargetLocation(class AActor* RequestedBy, bool bRequestAlternateLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTargetLocation"));

	AActor_GetTargetLocation_Params params;
	params.RequestedBy = RequestedBy;
	params.bRequestAlternateLoc = bRequestAlternateLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.FindGoodEndView
// (Final, Defined, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class APlayerController*       PC                             (Parm)
// struct FRotator                GoodRotation                   (Parm, OutParm)

void AActor::STATIC_FindGoodEndView(class APlayerController* PC, struct FRotator* GoodRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FindGoodEndView"));

	AActor_FindGoodEndView_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (GoodRotation != nullptr)
		*GoodRotation = params.GoodRotation;
}


// Function Engine.Actor.NotifyLocalPlayerTeamReceived
// (Defined, Iterator, Latent, Net, Simulated, Exec, Event, Operator, Static)

void AActor::STATIC_NotifyLocalPlayerTeamReceived()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.NotifyLocalPlayerTeamReceived"));

	AActor_NotifyLocalPlayerTeamReceived_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ScriptGetTeamNum
// (PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char AActor::ScriptGetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ScriptGetTeamNum"));

	AActor_ScriptGetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char AActor::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTeamNum"));

	AActor_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PawnBaseDied
// (Final, Defined, Iterator, Simulated, Exec, Native, Event, Operator, Static)

void AActor::STATIC_PawnBaseDied()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PawnBaseDied"));

	AActor_PawnBaseDied_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.IsPlayerOwned
// (Final, Defined, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsPlayerOwned()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsPlayerOwned"));

	AActor_IsPlayerOwned_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorEyesViewPoint
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void AActor::GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetActorEyesViewPoint"));

	AActor_GetActorEyesViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.Actor.IsStationary
// (Final, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsStationary()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsStationary"));

	AActor_IsStationary_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorFaceFXAsset
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAsset*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UFaceFXAsset* AActor::GetActorFaceFXAsset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetActorFaceFXAsset"));

	AActor_GetActorFaceFXAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.CanActorPlayFaceFXAnim
// (Defined, Iterator, Latent, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CanActorPlayFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CanActorPlayFaceFXAnim"));

	AActor_CanActorPlayFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsActorPlayingFaceFXAnim
// (Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsActorPlayingFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsActorPlayingFaceFXAnim"));

	AActor_IsActorPlayingFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.TickSkelControl
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)
// class USkelControlBase*        SkelCtrl                       (Parm)

void AActor::TickSkelControl(float DeltaTime, class USkeletalMeshComponent* SkelComp, class USkelControlBase* SkelCtrl)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TickSkelControl"));

	AActor_TickSkelControl_Params params;
	params.DeltaTime = DeltaTime;
	params.SkelComp = SkelComp;
	params.SkelCtrl = SkelCtrl;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetSkelControlScale
// (Defined, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void AActor::SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetSkelControlScale"));

	AActor_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetMorphWeight
// (Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void AActor::SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetMorphWeight"));

	AActor_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.StopActorFaceFXAnim
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AActor::StopActorFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.StopActorFaceFXAnim"));

	AActor_StopActorFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PlayActorFaceFXAnim
// (Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// struct FString                 SeqName                        (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::PlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlayActorFaceFXAnim"));

	AActor_PlayActorFaceFXAnim_Params params;
	params.AnimSet = AnimSet;
	params.GroupName = GroupName;
	params.SeqName = SeqName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.FinishAnimControl
// (Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void AActor::FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FinishAnimControl"));

	AActor_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetAnimPosition
// (Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void AActor::SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetAnimPosition"));

	AActor_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.BeginAnimControl
// (Final, Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void AActor::BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BeginAnimControl"));

	AActor_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnAnimPlay
// (Final, Defined, Iterator, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)

void AActor::OnAnimPlay(class UAnimNodeSequence* SeqNode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnAnimPlay"));

	AActor_OnAnimPlay_Params params;
	params.SeqNode = SeqNode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnAnimEnd
// (Iterator, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)
// float                          PlayedTime                     (Parm)
// float                          ExcessTime                     (Parm)

void AActor::OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnAnimEnd"));

	AActor_OnAnimEnd_Params params;
	params.SeqNode = SeqNode;
	params.PlayedTime = PlayedTime;
	params.ExcessTime = ExcessTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DoKismetAttachment
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class AActor*                  Attachment                     (Parm)
// class USeqAct_AttachToActor*   Action                         (Parm)

void AActor::STATIC_DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DoKismetAttachment"));

	AActor_DoKismetAttachment_Params params;
	params.Attachment = Attachment;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnAttachToActor
// (Defined, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_AttachToActor*   Action                         (Parm)

void AActor::STATIC_OnAttachToActor(class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnAttachToActor"));

	AActor_OnAttachToActor_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnToggleHidden
// (Final, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleHidden*    Action                         (Parm)

void AActor::STATIC_OnToggleHidden(class USeqAct_ToggleHidden* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnToggleHidden"));

	AActor_OnToggleHidden_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnChangeCollision
// (Defined, Iterator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ChangeCollision* Action                         (Parm)

void AActor::STATIC_OnChangeCollision(class USeqAct_ChangeCollision* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnChangeCollision"));

	AActor_OnChangeCollision_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnSetPhysics
// (Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetPhysics*      Action                         (Parm)

void AActor::STATIC_OnSetPhysics(class USeqAct_SetPhysics* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnSetPhysics"));

	AActor_OnSetPhysics_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnSetBlockRigidBody
// (Final, Defined, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetBlockRigidBody* Action                         (Parm)

void AActor::STATIC_OnSetBlockRigidBody(class USeqAct_SetBlockRigidBody* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnSetBlockRigidBody"));

	AActor_OnSetBlockRigidBody_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnSetVelocity
// (Iterator, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetVelocity*     Action                         (Parm)

void AActor::STATIC_OnSetVelocity(class USeqAct_SetVelocity* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnSetVelocity"));

	AActor_OnSetVelocity_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnTeleport
// (Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Teleport*        Action                         (Parm)

void AActor::STATIC_OnTeleport(class USeqAct_Teleport* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnTeleport"));

	AActor_OnTeleport_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnModifyHealth
// (Final, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ModifyHealth*    Action                         (Parm)

void AActor::STATIC_OnModifyHealth(class USeqAct_ModifyHealth* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnModifyHealth"));

	AActor_OnModifyHealth_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PrestreamTextures
// (Final, Defined, Latent, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// float                          Seconds                        (Parm)
// bool                           bEnableStreaming               (Parm)
// TArray<unsigned char>          CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void AActor::PrestreamTextures(float Seconds, bool bEnableStreaming, TArray<unsigned char> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PrestreamTextures"));

	AActor_PrestreamTextures_Params params;
	params.Seconds = Seconds;
	params.bEnableStreaming = bEnableStreaming;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void AActor::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ShutDown"));

	AActor_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetNetUpdateTime
// (Final, Iterator, PreOperator, Event, HasOptionalParms)
// Parameters:
// float                          NewUpdateTime                  (Parm)

void AActor::SetNetUpdateTime(float NewUpdateTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetNetUpdateTime"));

	AActor_SetNetUpdateTime_Params params;
	params.NewUpdateTime = NewUpdateTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ForceNetRelevant
// (Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)

void AActor::ForceNetRelevant()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ForceNetRelevant"));

	AActor_ForceNetRelevant_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnDestroy
// (Final, Defined, Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Destroy*         Action                         (Parm)

void AActor::STATIC_OnDestroy(class USeqAct_Destroy* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnDestroy"));

	AActor_OnDestroy_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ClearLatentAction
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class UClass*                  actionClass                    (Parm)
// bool                           bAborted                       (OptionalParm, Parm)
// class USeqAct_Latent*          exceptionAction                (OptionalParm, Parm)

void AActor::ClearLatentAction(class UClass* actionClass, bool bAborted, class USeqAct_Latent* exceptionAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ClearLatentAction"));

	AActor_ClearLatentAction_Params params;
	params.actionClass = actionClass;
	params.bAborted = bAborted;
	params.exceptionAction = exceptionAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FindEventsOfClass
// (Final, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class UClass*                  EventClass                     (Parm)
// TArray<class USequenceEvent*>  out_EventList                  (OptionalParm, Parm, OutParm, NeedCtorLink)
// bool                           bIncludeDisabled               (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_FindEventsOfClass(class UClass* EventClass, bool bIncludeDisabled, TArray<class USequenceEvent*>* out_EventList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FindEventsOfClass"));

	AActor_FindEventsOfClass_Params params;
	params.EventClass = EventClass;
	params.bIncludeDisabled = bIncludeDisabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_EventList != nullptr)
		*out_EventList = params.out_EventList;

	return params.ReturnValue;
}


// Function Engine.Actor.ActivateEventClass
// (Singular, Simulated, Exec, Native, Event)
// Parameters:
// class UClass*                  InClass                        (Parm)
// class AActor*                  InInstigator                   (Parm)
// TArray<class USequenceEvent*>  EventList                      (Const, Parm, OutParm, NeedCtorLink)
// TArray<int>                    ActivateIndices                (Const, OptionalParm, Parm, OutParm, NeedCtorLink)
// bool                           bTest                          (OptionalParm, Parm)
// TArray<class USequenceEvent*>  ActivatedEvents                (OptionalParm, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::ActivateEventClass(class UClass* InClass, class AActor* InInstigator, bool bTest, TArray<class USequenceEvent*>* EventList, TArray<int>* ActivateIndices, TArray<class USequenceEvent*>* ActivatedEvents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ActivateEventClass"));

	AActor_ActivateEventClass_Params params;
	params.InClass = InClass;
	params.InInstigator = InInstigator;
	params.bTest = bTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EventList != nullptr)
		*EventList = params.EventList;
	if (ActivateIndices != nullptr)
		*ActivateIndices = params.ActivateIndices;
	if (ActivatedEvents != nullptr)
		*ActivatedEvents = params.ActivatedEvents;

	return params.ReturnValue;
}


// Function Engine.Actor.TriggerGlobalEventClass
// (Final, Latent, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UClass*                  InEventClass                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// int                            ActivateIndex                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::TriggerGlobalEventClass(class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TriggerGlobalEventClass"));

	AActor_TriggerGlobalEventClass_Params params;
	params.InEventClass = InEventClass;
	params.InInstigator = InInstigator;
	params.ActivateIndex = ActivateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ReceivedNewEvent
// (Final, Latent, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USequenceEvent*          Evt                            (Parm)

void AActor::ReceivedNewEvent(class USequenceEvent* Evt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ReceivedNewEvent"));

	AActor_ReceivedNewEvent_Params params;
	params.Evt = Evt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.TriggerEventClass
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UClass*                  InEventClass                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// int                            ActivateIndex                  (OptionalParm, Parm)
// bool                           bTest                          (OptionalParm, Parm)
// TArray<class USequenceEvent*>  ActivatedEvents                (OptionalParm, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::TriggerEventClass(class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex, bool bTest, TArray<class USequenceEvent*>* ActivatedEvents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TriggerEventClass"));

	AActor_TriggerEventClass_Params params;
	params.InEventClass = InEventClass;
	params.InInstigator = InInstigator;
	params.ActivateIndex = ActivateIndex;
	params.bTest = bTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActivatedEvents != nullptr)
		*ActivatedEvents = params.ActivatedEvents;

	return params.ReturnValue;
}


// Function Engine.Actor.DebugMessagePlayer
// (Final, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)

void AActor::DebugMessagePlayer(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DebugMessagePlayer"));

	AActor_DebugMessagePlayer_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ImpactEffectIsRelevant
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Operator, Static)
// Parameters:
// class APawn*                   EffectInstigator               (Parm)
// struct FVector                 SpawnLocation                  (Parm)
// bool                           bForceDedicated                (Parm)
// float                          VisibleCullDistance            (OptionalParm, Parm)
// float                          HiddenCullDistance             (OptionalParm, Parm)
// bool                           bSkipLOSCheck                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_ImpactEffectIsRelevant(class APawn* EffectInstigator, const struct FVector& SpawnLocation, bool bForceDedicated, float VisibleCullDistance, float HiddenCullDistance, bool bSkipLOSCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ImpactEffectIsRelevant"));

	AActor_ImpactEffectIsRelevant_Params params;
	params.EffectInstigator = EffectInstigator;
	params.SpawnLocation = SpawnLocation;
	params.bForceDedicated = bForceDedicated;
	params.VisibleCullDistance = VisibleCullDistance;
	params.HiddenCullDistance = HiddenCullDistance;
	params.bSkipLOSCheck = bSkipLOSCheck;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ActorEffectIsRelevant
// (Final, Defined, Latent, Net, Simulated, Exec, Native, Event)
// Parameters:
// class APawn*                   EffectInstigator               (Parm)
// bool                           bForceDedicated                (Parm)
// float                          VisibleCullDistance            (OptionalParm, Parm)
// float                          HiddenCullDistance             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::ActorEffectIsRelevant(class APawn* EffectInstigator, bool bForceDedicated, float VisibleCullDistance, float HiddenCullDistance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ActorEffectIsRelevant"));

	AActor_ActorEffectIsRelevant_Params params;
	params.EffectInstigator = EffectInstigator;
	params.bForceDedicated = bForceDedicated;
	params.VisibleCullDistance = VisibleCullDistance;
	params.HiddenCullDistance = HiddenCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.EffectIsRelevant
// (Iterator, PreOperator, Net, Simulated, Exec, Native, Static)
// Parameters:
// struct FVector                 SpawnLocation                  (Parm)
// bool                           bForceDedicated                (Parm)
// float                          VisibleCullDistance            (OptionalParm, Parm)
// float                          HiddenCullDistance             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_EffectIsRelevant(const struct FVector& SpawnLocation, bool bForceDedicated, float VisibleCullDistance, float HiddenCullDistance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.EffectIsRelevant"));

	AActor_EffectIsRelevant_Params params;
	params.SpawnLocation = SpawnLocation;
	params.bForceDedicated = bForceDedicated;
	params.VisibleCullDistance = VisibleCullDistance;
	params.HiddenCullDistance = HiddenCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ApplyFluidSurfaceImpact
// (Defined, PreOperator, Singular, NetReliable, Simulated, Operator)
// Parameters:
// class AFluidSurfaceActor*      Fluid                          (Parm)
// struct FVector                 HitLocation                    (Parm)

void AActor::ApplyFluidSurfaceImpact(class AFluidSurfaceActor* Fluid, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ApplyFluidSurfaceImpact"));

	AActor_ApplyFluidSurfaceImpact_Params params;
	params.Fluid = Fluid;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.CanSplash
// (Final, Iterator, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CanSplash()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CanSplash"));

	AActor_CanSplash_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PlayTeleportEffect
// (Final, Latent, Singular, NetReliable, HasOptionalParms)
// Parameters:
// bool                           bOut                           (Parm)
// bool                           bSound                         (Parm)

void AActor::PlayTeleportEffect(bool bOut, bool bSound)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlayTeleportEffect"));

	AActor_PlayTeleportEffect_Params params;
	params.bOut = bOut;
	params.bSound = bSound;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.IsInPain
// (Final, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsInPain()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsInPain"));

	AActor_IsInPain_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AActor::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Reset"));

	AActor_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetFaceFXAudioComponent
// (Final, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAudioComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UAudioComponent* AActor::GetFaceFXAudioComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetFaceFXAudioComponent"));

	AActor_GetFaceFXAudioComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ModifyHearSoundComponent
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)

void AActor::ModifyHearSoundComponent(class UAudioComponent* AC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ModifyHearSoundComponent"));

	AActor_ModifyHearSoundComponent_Params params;
	params.AC = AC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetPhysicsName
// (Defined, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetPhysicsName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetPhysicsName"));

	AActor_GetPhysicsName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AActor::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DisplayDebug"));

	AActor_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Actor.GetDebugName
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetDebugName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetDebugName"));

	AActor_GetDebugName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.MatchStarting
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, Operator, Static)

void AActor::STATIC_MatchStarting()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.MatchStarting"));

	AActor_MatchStarting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetLocalString
// (Defined, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetLocalString(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetLocalString"));

	AActor_GetLocalString_Params params;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ReplaceText
// (Final, Iterator, Latent, PreOperator, Singular, Native, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, OutParm, NeedCtorLink)
// struct FString                 Replace                        (Parm, NeedCtorLink)
// struct FString                 With                           (Parm, NeedCtorLink)

void AActor::ReplaceText(const struct FString& Replace, const struct FString& With, struct FString* Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ReplaceText"));

	AActor_ReplaceText_Params params;
	params.Replace = Replace;
	params.With = With;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Text != nullptr)
		*Text = params.Text;
}


// Function Engine.Actor.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetHumanReadableName"));

	AActor_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetItemName
// (Defined, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 FullName                       (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetItemName(const struct FString& FullName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetItemName"));

	AActor_GetItemName_Params params;
	params.FullName = FullName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.CalcCamera
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// float                          fDeltaTime                     (Parm)
// struct FVector                 out_CamLoc                     (Parm, OutParm)
// struct FRotator                out_CamRot                     (Parm, OutParm)
// float                          out_FOV                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CalcCamera"));

	AActor_CalcCamera_Params params;
	params.fDeltaTime = fDeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_CamLoc != nullptr)
		*out_CamLoc = params.out_CamLoc;
	if (out_CamRot != nullptr)
		*out_CamRot = params.out_CamRot;
	if (out_FOV != nullptr)
		*out_FOV = params.out_FOV;

	return params.ReturnValue;
}


// Function Engine.Actor.EndViewTarget
// (Defined, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AActor::EndViewTarget(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.EndViewTarget"));

	AActor_EndViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.BecomeViewTarget
// (Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AActor::BecomeViewTarget(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BecomeViewTarget"));

	AActor_BecomeViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.CheckForErrors
// (Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CheckForErrors()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CheckForErrors"));

	AActor_CheckForErrors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.DebugFreezeGame
// (Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  ActorToLookAt                  (OptionalParm, Parm)

void AActor::DebugFreezeGame(class AActor* ActorToLookAt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DebugFreezeGame"));

	AActor_DebugFreezeGame_Params params;
	params.ActorToLookAt = ActorToLookAt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetGravityZ
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetGravityZ()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetGravityZ"));

	AActor_GetGravityZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.CheckHitInfo
// (PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FTraceHitInfo           HitInfo                        (Parm, OutParm)
// class UPrimitiveComponent*     FallBackComponent              (Parm, EditInline)
// struct FVector                 Dir                            (Parm)
// struct FVector                 out_HitLocation                (Parm, OutParm)

void AActor::CheckHitInfo(class UPrimitiveComponent* FallBackComponent, const struct FVector& Dir, struct FTraceHitInfo* HitInfo, struct FVector* out_HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CheckHitInfo"));

	AActor_CheckHitInfo_Params params;
	params.FallBackComponent = FallBackComponent;
	params.Dir = Dir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;
	if (out_HitLocation != nullptr)
		*out_HitLocation = params.out_HitLocation;
}


// Function Engine.Actor.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AActor::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TakeRadiusDamage"));

	AActor_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.HealDamage
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            Amount                         (Parm)
// class AController*             Healer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::HealDamage(int Amount, class AController* Healer, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.HealDamage"));

	AActor_HealDamage_Params params;
	params.Amount = Amount;
	params.Healer = Healer;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            DamageAmount                   (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AActor::TakeDamage(int DamageAmount, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TakeDamage"));

	AActor_TakeDamage_Params params;
	params.DamageAmount = DamageAmount;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.KilledBy
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   EventInstigator                (Parm)

void AActor::KilledBy(class APawn* EventInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.KilledBy"));

	AActor_KilledBy_Params params;
	params.EventInstigator = EventInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.HurtRadius
// (Final, Defined, Iterator, Latent, PreOperator, Net, Operator, Static)
// Parameters:
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// class AActor*                  IgnoredActor                   (OptionalParm, Parm)
// class AController*             InstigatedByController         (OptionalParm, Parm)
// bool                           bDoFullDamage                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_HurtRadius(float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, class AActor* IgnoredActor, class AController* InstigatedByController, bool bDoFullDamage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.HurtRadius"));

	AActor_HurtRadius_Params params;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.IgnoredActor = IgnoredActor;
	params.InstigatedByController = InstigatedByController;
	params.bDoFullDamage = bDoFullDamage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.StopsProjectile
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AProjectile*             P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::StopsProjectile(class AProjectile* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.StopsProjectile"));

	AActor_StopsProjectile_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.NotifySkelControlBeyondLimit
// (Defined, Exec, Native, HasOptionalParms)
// Parameters:
// class USkelControlLookAt*      LookAt                         (Parm)

void AActor::NotifySkelControlBeyondLimit(class USkelControlLookAt* LookAt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.NotifySkelControlBeyondLimit"));

	AActor_NotifySkelControlBeyondLimit_Params params;
	params.LookAt = LookAt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ConstraintBrokenNotify
// (Defined, Latent, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  ConOwner                       (Parm)
// class URB_ConstraintSetup*     ConSetup                       (Parm)
// class URB_ConstraintInstance*  ConInstance                    (Parm)

void AActor::ConstraintBrokenNotify(class AActor* ConOwner, class URB_ConstraintSetup* ConSetup, class URB_ConstraintInstance* ConInstance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ConstraintBrokenNotify"));

	AActor_ConstraintBrokenNotify_Params params;
	params.ConOwner = ConOwner;
	params.ConSetup = ConSetup;
	params.ConInstance = ConInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetInitialState
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)

void AActor::SetInitialState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetInitialState"));

	AActor_SetInitialState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostBeginPlay"));

	AActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.BroadcastLocalizedTeamMessage
// (Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            TeamIndex                      (Parm)
// class UClass*                  InMessageClass                 (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AActor::BroadcastLocalizedTeamMessage(int TeamIndex, class UClass* InMessageClass, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BroadcastLocalizedTeamMessage"));

	AActor_BroadcastLocalizedTeamMessage_Params params;
	params.TeamIndex = TeamIndex;
	params.InMessageClass = InMessageClass;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.BroadcastLocalizedMessage
// (Defined, Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  InMessageClass                 (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AActor::BroadcastLocalizedMessage(class UClass* InMessageClass, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BroadcastLocalizedMessage"));

	AActor_BroadcastLocalizedMessage_Params params;
	params.InMessageClass = InMessageClass;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PreBeginPlay
// (Latent, Net, Simulated)

void AActor::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PreBeginPlay"));

	AActor_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetTeleportDestination
// (Defined, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 Destination                    (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_GetTeleportDestination(struct FVector* Destination)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTeleportDestination"));

	AActor_GetTeleportDestination_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Destination != nullptr)
		*Destination = params.Destination;

	return params.ReturnValue;
}


// Function Engine.Actor.RecalculateMaterial
// (Final, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// bool                           bIsFriendlyWithLocalPawn       (Parm)
// bool                           bForce                         (OptionalParm, Parm)

void AActor::RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RecalculateMaterial"));

	AActor_RecalculateMaterial_Params params;
	params.bIsFriendlyWithLocalPawn = bIsFriendlyWithLocalPawn;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ForceRecalculateMaterial
// (Iterator, Net, NetReliable, Simulated, Exec, Event, Static)

void AActor::STATIC_ForceRecalculateMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ForceRecalculateMaterial"));

	AActor_ForceRecalculateMaterial_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.IsEnemy
// (Final, Defined, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  pOther                         (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsEnemy(class AActor* pOther)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsEnemy"));

	AActor_IsEnemy_Params params;
	params.pOther = pOther;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ForceNetIrrelevant
// (Defined, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_ForceNetIrrelevant()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ForceNetIrrelevant"));

	AActor_ForceNetIrrelevant_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetALocalPlayerController
// (Final, Defined, Iterator, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// class APlayerController*       ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerController* AActor::STATIC_GetALocalPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetALocalPlayerController"));

	AActor_GetALocalPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.LocalPlayerControllers
// (Final, Iterator, Singular, Simulated, Native, Operator, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class APlayerController*       PC                             (Parm, OutParm)

void AActor::STATIC_LocalPlayerControllers(class UClass* BaseClass, class APlayerController** PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.LocalPlayerControllers"));

	AActor_LocalPlayerControllers_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PC != nullptr)
		*PC = params.PC;
}


// Function Engine.Actor.AllOwnedComponents
// (Final, Defined, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class UActorComponent*         OutComponent                   (Parm, OutParm, EditInline)

void AActor::AllOwnedComponents(class UClass* BaseClass, class UActorComponent** OutComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AllOwnedComponents"));

	AActor_AllOwnedComponents_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponent != nullptr)
		*OutComponent = params.OutComponent;
}


// Function Engine.Actor.ComponentList
// (Final, Defined, Singular, Simulated, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class UActorComponent*         out_Component                  (Parm, OutParm, EditInline)

void AActor::STATIC_ComponentList(class UClass* BaseClass, class UActorComponent** out_Component)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ComponentList"));

	AActor_ComponentList_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Component != nullptr)
		*out_Component = params.out_Component;
}


// Function Engine.Actor.OverlappingActors
// (PreOperator, Exec, Native, Event, Operator, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  out_Actor                      (Parm, OutParm)
// float                          Radius                         (Parm)
// struct FVector                 Loc                            (OptionalParm, Parm)
// bool                           bIgnoreHidden                  (OptionalParm, Parm)

void AActor::STATIC_OverlappingActors(class UClass* BaseClass, float Radius, const struct FVector& Loc, bool bIgnoreHidden, class AActor** out_Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OverlappingActors"));

	AActor_OverlappingActors_Params params;
	params.BaseClass = BaseClass;
	params.Radius = Radius;
	params.Loc = Loc;
	params.bIgnoreHidden = bIgnoreHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Actor != nullptr)
		*out_Actor = params.out_Actor;
}


// Function Engine.Actor.CollidingActors
// (Final, Defined, Net, NetReliable, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// float                          Radius                         (Parm)
// struct FVector                 Loc                            (OptionalParm, Parm)
// bool                           bUseOverlapCheck               (OptionalParm, Parm)
// class UClass*                  InterfaceClass                 (OptionalParm, Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm, OutParm)

void AActor::STATIC_CollidingActors(class UClass* BaseClass, float Radius, const struct FVector& Loc, bool bUseOverlapCheck, class UClass* InterfaceClass, class AActor** Actor, struct FTraceHitInfo* HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CollidingActors"));

	AActor_CollidingActors_Params params;
	params.BaseClass = BaseClass;
	params.Radius = Radius;
	params.Loc = Loc;
	params.bUseOverlapCheck = bUseOverlapCheck;
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;
}


// Function Engine.Actor.VisibleCollidingActors
// (Final, Iterator, Latent, PreOperator, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// float                          Radius                         (Parm)
// struct FVector                 Loc                            (OptionalParm, Parm)
// bool                           bIgnoreHidden                  (OptionalParm, Parm)
// struct FVector                 Extent                         (OptionalParm, Parm)
// bool                           bTraceActors                   (OptionalParm, Parm)
// class UClass*                  InterfaceClass                 (OptionalParm, Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm, OutParm)

void AActor::VisibleCollidingActors(class UClass* BaseClass, float Radius, const struct FVector& Loc, bool bIgnoreHidden, const struct FVector& Extent, bool bTraceActors, class UClass* InterfaceClass, class AActor** Actor, struct FTraceHitInfo* HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.VisibleCollidingActors"));

	AActor_VisibleCollidingActors_Params params;
	params.BaseClass = BaseClass;
	params.Radius = Radius;
	params.Loc = Loc;
	params.bIgnoreHidden = bIgnoreHidden;
	params.Extent = Extent;
	params.bTraceActors = bTraceActors;
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;
}


// Function Engine.Actor.VisibleActors
// (Final, Defined, Latent, PreOperator, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// float                          Radius                         (OptionalParm, Parm)
// struct FVector                 Loc                            (OptionalParm, Parm)

void AActor::VisibleActors(class UClass* BaseClass, float Radius, const struct FVector& Loc, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.VisibleActors"));

	AActor_VisibleActors_Params params;
	params.BaseClass = BaseClass;
	params.Radius = Radius;
	params.Loc = Loc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.TraceActors
// (Iterator, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// struct FVector                 HitLoc                         (Parm, OutParm)
// struct FVector                 HitNorm                        (Parm, OutParm)
// struct FVector                 End                            (Parm)
// struct FVector                 Start                          (OptionalParm, Parm)
// struct FVector                 Extent                         (OptionalParm, Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm, OutParm)
// int                            ExtraTraceFlags                (OptionalParm, Parm)

void AActor::TraceActors(class UClass* BaseClass, const struct FVector& End, const struct FVector& Start, const struct FVector& Extent, int ExtraTraceFlags, class AActor** Actor, struct FVector* HitLoc, struct FVector* HitNorm, struct FTraceHitInfo* HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TraceActors"));

	AActor_TraceActors_Params params;
	params.BaseClass = BaseClass;
	params.End = End;
	params.Start = Start;
	params.Extent = Extent;
	params.ExtraTraceFlags = ExtraTraceFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
	if (HitLoc != nullptr)
		*HitLoc = params.HitLoc;
	if (HitNorm != nullptr)
		*HitNorm = params.HitNorm;
	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;
}


// Function Engine.Actor.TouchingActors
// (Final, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)

void AActor::TouchingActors(class UClass* BaseClass, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TouchingActors"));

	AActor_TouchingActors_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.BasedActors
// (Latent, Singular, Simulated, Exec, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)

void AActor::BasedActors(class UClass* BaseClass, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BasedActors"));

	AActor_BasedActors_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.ChildActors
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)

void AActor::ChildActors(class UClass* BaseClass, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ChildActors"));

	AActor_ChildActors_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.DynamicActors
// (Latent, Singular, NetReliable, Exec, Native, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// class UClass*                  InterfaceClass                 (OptionalParm, Parm)

void AActor::STATIC_DynamicActors(class UClass* BaseClass, class UClass* InterfaceClass, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DynamicActors"));

	AActor_DynamicActors_Params params;
	params.BaseClass = BaseClass;
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.AllActors
// (Final, Latent, PreOperator, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AActor*                  Actor                          (Parm, OutParm)
// class UClass*                  InterfaceClass                 (OptionalParm, Parm)

void AActor::AllActors(class UClass* BaseClass, class UClass* InterfaceClass, class AActor** Actor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AllActors"));

	AActor_AllActors_Params params;
	params.BaseClass = BaseClass;
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actor != nullptr)
		*Actor = params.Actor;
}


// Function Engine.Actor.GetURLMap
// (Final, Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_GetURLMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetURLMap"));

	AActor_GetURLMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PostTeleport
// (Final, Iterator, Latent, PreOperator, Simulated, HasOptionalParms)
// Parameters:
// class ATeleporter*             OutTeleporter                  (Parm)

void AActor::PostTeleport(class ATeleporter* OutTeleporter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostTeleport"));

	AActor_PostTeleport_Params params;
	params.OutTeleporter = OutTeleporter;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PreTeleport
// (Iterator, Latent, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// class ATeleporter*             InTeleporter                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::PreTeleport(class ATeleporter* InTeleporter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PreTeleport"));

	AActor_PreTeleport_Params params;
	params.InTeleporter = InTeleporter;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetDestination
// (Final, Defined, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AController*             C                              (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::STATIC_GetDestination(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetDestination"));

	AActor_GetDestination_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.CalculateMinSpeedTrajectory
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// struct FVector                 out_Velocity                   (Parm, OutParm)
// struct FVector                 End                            (Parm)
// struct FVector                 Start                          (Parm)
// float                          MaxTossSpeed                   (Parm)
// float                          MinTossSpeed                   (Parm)
// struct FVector                 CollisionSize                  (OptionalParm, Parm)
// float                          TerminalVelocity               (OptionalParm, Parm)
// float                          GravityZ                       (OptionalParm, Parm)
// bool                           bOnlyTraceUp                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::CalculateMinSpeedTrajectory(const struct FVector& End, const struct FVector& Start, float MaxTossSpeed, float MinTossSpeed, const struct FVector& CollisionSize, float TerminalVelocity, float GravityZ, bool bOnlyTraceUp, struct FVector* out_Velocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CalculateMinSpeedTrajectory"));

	AActor_CalculateMinSpeedTrajectory_Params params;
	params.End = End;
	params.Start = Start;
	params.MaxTossSpeed = MaxTossSpeed;
	params.MinTossSpeed = MinTossSpeed;
	params.CollisionSize = CollisionSize;
	params.TerminalVelocity = TerminalVelocity;
	params.GravityZ = GravityZ;
	params.bOnlyTraceUp = bOnlyTraceUp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Velocity != nullptr)
		*out_Velocity = params.out_Velocity;

	return params.ReturnValue;
}


// Function Engine.Actor.SuggestTossVelocity
// (Defined, Latent, PreOperator, Singular, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 TossVelocity                   (Parm, OutParm)
// struct FVector                 Destination                    (Parm)
// struct FVector                 Start                          (Parm)
// float                          TossSpeed                      (Parm)
// float                          BaseTossZ                      (OptionalParm, Parm)
// float                          DesiredZPct                    (OptionalParm, Parm)
// struct FVector                 CollisionSize                  (OptionalParm, Parm)
// float                          TerminalVelocity               (OptionalParm, Parm)
// float                          OverrideGravityZ               (OptionalParm, Parm)
// bool                           bOnlyTraceUp                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SuggestTossVelocity(const struct FVector& Destination, const struct FVector& Start, float TossSpeed, float BaseTossZ, float DesiredZPct, const struct FVector& CollisionSize, float TerminalVelocity, float OverrideGravityZ, bool bOnlyTraceUp, struct FVector* TossVelocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SuggestTossVelocity"));

	AActor_SuggestTossVelocity_Params params;
	params.Destination = Destination;
	params.Start = Start;
	params.TossSpeed = TossSpeed;
	params.BaseTossZ = BaseTossZ;
	params.DesiredZPct = DesiredZPct;
	params.CollisionSize = CollisionSize;
	params.TerminalVelocity = TerminalVelocity;
	params.OverrideGravityZ = OverrideGravityZ;
	params.bOnlyTraceUp = bOnlyTraceUp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (TossVelocity != nullptr)
		*TossVelocity = params.TossVelocity;

	return params.ReturnValue;
}


// Function Engine.Actor.PlayerCanSeeMe
// (Singular, Net, HasOptionalParms)
// Parameters:
// bool                           bForceLOSCheck                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::PlayerCanSeeMe(bool bForceLOSCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlayerCanSeeMe"));

	AActor_PlayerCanSeeMe_Params params;
	params.bForceLOSCheck = bForceLOSCheck;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.MakeNoise
// (Defined, PreOperator, Net, Exec, Native, Operator, Static)
// Parameters:
// float                          Loudness                       (Parm)
// struct FName                   NoiseType                      (OptionalParm, Parm)

void AActor::STATIC_MakeNoise(float Loudness, const struct FName& NoiseType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.MakeNoise"));

	AActor_MakeNoise_Params params;
	params.Loudness = Loudness;
	params.NoiseType = NoiseType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.CheckOcclusion
// (Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::CheckOcclusion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CheckOcclusion"));

	AActor_CheckOcclusion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.StopAllAkEvents
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void AActor::StopAllAkEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.StopAllAkEvents"));

	AActor_StopAllAkEvents_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ActivateOcclusion
// (Final, Iterator, Singular, Simulated, Exec, Native, Event)
// Parameters:
// bool                           bInActivate                    (Parm)

void AActor::ActivateOcclusion(bool bInActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ActivateOcclusion"));

	AActor_ActivateOcclusion_Params params;
	params.bInActivate = bInActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostTrigger
// (Defined, Iterator, Latent, PreOperator, Simulated, HasOptionalParms)
// Parameters:
// struct FName                   InTrigger                      (Parm)

void AActor::PostTrigger(const struct FName& InTrigger)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostTrigger"));

	AActor_PostTrigger_Params params;
	params.InTrigger = InTrigger;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetAkSwitch
// (Final, Defined, Iterator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   InSwitchGroup                  (Parm)
// struct FName                   InSwitch                       (Parm)

void AActor::SetAkSwitch(const struct FName& InSwitchGroup, const struct FName& InSwitch)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetAkSwitch"));

	AActor_SetAkSwitch_Params params;
	params.InSwitchGroup = InSwitchGroup;
	params.InSwitch = InSwitch;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetAkState
// (Defined, Iterator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   InStateGroup                   (Parm)
// struct FName                   InState                        (Parm)

void AActor::SetAkState(const struct FName& InStateGroup, const struct FName& InState)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetAkState"));

	AActor_SetAkState_Params params;
	params.InStateGroup = InStateGroup;
	params.InState = InState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetRTPCValue
// (Final, Defined, Iterator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 InRTPC                         (Const, Parm, NeedCtorLink)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_GetRTPCValue(const struct FString& InRTPC, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetRTPCValue"));

	AActor_GetRTPCValue_Params params;
	params.InRTPC = InRTPC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.Actor.SetRTPCValue
// (Final, Defined, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FString                 InRTPC                         (Const, Parm, NeedCtorLink)
// float                          TargetValue                    (Parm)

void AActor::SetRTPCValue(const struct FString& InRTPC, float TargetValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetRTPCValue"));

	AActor_SetRTPCValue_Params params;
	params.InRTPC = InRTPC;
	params.TargetValue = TargetValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostAkEventOnBone
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// class UAkEvent*                InAkEvent                      (Parm)
// struct FName                   BoneName                       (Parm)

void AActor::PostAkEventOnBone(class UAkEvent* InAkEvent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostAkEventOnBone"));

	AActor_PostAkEventOnBone_Params params;
	params.InAkEvent = InAkEvent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostAkEvent
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// class UAkEvent*                InAkEvent                      (Parm)

void AActor::PostAkEvent(class UAkEvent* InAkEvent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostAkEvent"));

	AActor_PostAkEvent_Params params;
	params.InAkEvent = InAkEvent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PlaySoundBase
// (Final, Defined, Iterator, Singular, NetReliable, HasOptionalParms)
// Parameters:
// class UAkBaseSoundObject*      InSoundCue                     (Parm)
// bool                           bNotReplicated                 (OptionalParm, Parm)
// bool                           bNoRepToOwner                  (OptionalParm, Parm)
// bool                           bStopWhenOwnerDestroyed        (OptionalParm, Parm)
// struct FVector                 SoundLocation                  (OptionalParm, Parm)
// bool                           bNoRepToRelevant               (OptionalParm, Parm)

void AActor::PlaySoundBase(class UAkBaseSoundObject* InSoundCue, bool bNotReplicated, bool bNoRepToOwner, bool bStopWhenOwnerDestroyed, const struct FVector& SoundLocation, bool bNoRepToRelevant)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlaySoundBase"));

	AActor_PlaySoundBase_Params params;
	params.InSoundCue = InSoundCue;
	params.bNotReplicated = bNotReplicated;
	params.bNoRepToOwner = bNoRepToOwner;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.SoundLocation = SoundLocation;
	params.bNoRepToRelevant = bNoRepToRelevant;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PlayAkEvent
// (Final, Defined, Net, HasOptionalParms)
// Parameters:
// class UAkEvent*                InSoundCue                     (Parm)
// bool                           bNotReplicated                 (OptionalParm, Parm)
// bool                           bNoRepToOwner                  (OptionalParm, Parm)
// bool                           bStopWhenOwnerDestroyed        (OptionalParm, Parm)
// struct FVector                 SoundLocation                  (OptionalParm, Parm)
// bool                           bNoRepToRelevant               (OptionalParm, Parm)

void AActor::PlayAkEvent(class UAkEvent* InSoundCue, bool bNotReplicated, bool bNoRepToOwner, bool bStopWhenOwnerDestroyed, const struct FVector& SoundLocation, bool bNoRepToRelevant)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlayAkEvent"));

	AActor_PlayAkEvent_Params params;
	params.InSoundCue = InSoundCue;
	params.bNotReplicated = bNotReplicated;
	params.bNoRepToOwner = bNoRepToOwner;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.SoundLocation = SoundLocation;
	params.bNoRepToRelevant = bNoRepToRelevant;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PlaySound
// (Final, Latent, Net, NetReliable, Simulated, Exec, Operator, HasOptionalParms)
// Parameters:
// class USoundCue*               InSoundCue                     (Parm)
// bool                           bNotReplicated                 (OptionalParm, Parm)
// bool                           bNoRepToOwner                  (OptionalParm, Parm)
// bool                           bStopWhenOwnerDestroyed        (OptionalParm, Parm)
// struct FVector                 SoundLocation                  (OptionalParm, Parm)
// bool                           bNoRepToRelevant               (OptionalParm, Parm)

void AActor::PlaySound(class USoundCue* InSoundCue, bool bNotReplicated, bool bNoRepToOwner, bool bStopWhenOwnerDestroyed, const struct FVector& SoundLocation, bool bNoRepToRelevant)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PlaySound"));

	AActor_PlaySound_Params params;
	params.InSoundCue = InSoundCue;
	params.bNotReplicated = bNotReplicated;
	params.bNoRepToOwner = bNoRepToOwner;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.SoundLocation = SoundLocation;
	params.bNoRepToRelevant = bNoRepToRelevant;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AudioComponentAttached
// (Final, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)
// int                            DatabaseID                     (OptionalParm, Parm)
// int                            LoopIndex                      (OptionalParm, Parm)

void AActor::AudioComponentAttached(class UAudioComponent* AC, int DatabaseID, int LoopIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AudioComponentAttached"));

	AActor_AudioComponentAttached_Params params;
	params.AC = AC;
	params.DatabaseID = DatabaseID;
	params.LoopIndex = LoopIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.CreateAudioComponent
// (Exec, Static)
// Parameters:
// class USoundCue*               InSoundCue                     (Parm)
// bool                           bPlay                          (OptionalParm, Parm)
// bool                           bStopWhenOwnerDestroyed        (OptionalParm, Parm)
// bool                           bUseLocation                   (OptionalParm, Parm)
// struct FVector                 SourceLocation                 (OptionalParm, Parm)
// bool                           bAttachToSelf                  (OptionalParm, Parm)
// class UAudioComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UAudioComponent* AActor::STATIC_CreateAudioComponent(class USoundCue* InSoundCue, bool bPlay, bool bStopWhenOwnerDestroyed, bool bUseLocation, const struct FVector& SourceLocation, bool bAttachToSelf)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CreateAudioComponent"));

	AActor_CreateAudioComponent_Params params;
	params.InSoundCue = InSoundCue;
	params.bPlay = bPlay;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.bUseLocation = bUseLocation;
	params.SourceLocation = SourceLocation;
	params.bAttachToSelf = bAttachToSelf;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ResetTimerTimeDilation
// (Defined, Latent, NetReliable, Native, HasOptionalParms)
// Parameters:
// struct FName                   TimerName                      (Const, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::ResetTimerTimeDilation(const struct FName& TimerName, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ResetTimerTimeDilation"));

	AActor_ResetTimerTimeDilation_Params params;
	params.TimerName = TimerName;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ModifyTimerTimeDilation
// (Final, Defined, Latent, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// struct FName                   TimerName                      (Const, Parm)
// float                          InTimerTimeDilation            (Const, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::STATIC_ModifyTimerTimeDilation(const struct FName& TimerName, float InTimerTimeDilation, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ModifyTimerTimeDilation"));

	AActor_ModifyTimerTimeDilation_Params params;
	params.TimerName = TimerName;
	params.InTimerTimeDilation = InTimerTimeDilation;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetTimerPercent
// (Iterator, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   TimerFuncName                  (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetTimerPercent(const struct FName& TimerFuncName, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTimerPercent"));

	AActor_GetTimerPercent_Params params;
	params.TimerFuncName = TimerFuncName;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetRemainingTimeForTimer
// (Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   TimerFuncName                  (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetRemainingTimeForTimer(const struct FName& TimerFuncName, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetRemainingTimeForTimer"));

	AActor_GetRemainingTimeForTimer_Params params;
	params.TimerFuncName = TimerFuncName;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetTimerRate
// (Final, Iterator, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   TimerFuncName                  (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetTimerRate(const struct FName& TimerFuncName, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTimerRate"));

	AActor_GetTimerRate_Params params;
	params.TimerFuncName = TimerFuncName;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetTimerCount
// (Final, Defined, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   inTimerFunc                    (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetTimerCount(const struct FName& inTimerFunc, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTimerCount"));

	AActor_GetTimerCount_Params params;
	params.inTimerFunc = inTimerFunc;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsTimerActive
// (Final, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// struct FName                   inTimerFunc                    (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsTimerActive(const struct FName& inTimerFunc, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsTimerActive"));

	AActor_IsTimerActive_Params params;
	params.inTimerFunc = inTimerFunc;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PauseTimer
// (Final, Iterator, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// bool                           bPause                         (Parm)
// struct FName                   inTimerFunc                    (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::STATIC_PauseTimer(bool bPause, const struct FName& inTimerFunc, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PauseTimer"));

	AActor_PauseTimer_Params params;
	params.bPause = bPause;
	params.inTimerFunc = inTimerFunc;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ClearAllTimers
// (Defined, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::ClearAllTimers(class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ClearAllTimers"));

	AActor_ClearAllTimers_Params params;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ClearTimer
// (Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FName                   inTimerFunc                    (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::ClearTimer(const struct FName& inTimerFunc, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ClearTimer"));

	AActor_ClearTimer_Params params;
	params.inTimerFunc = inTimerFunc;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetTimer
// (Final, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// float                          InRate                         (Parm)
// bool                           inbLoop                        (OptionalParm, Parm)
// struct FName                   inTimerFunc                    (OptionalParm, Parm)
// class UObject*                 inObj                          (OptionalParm, Parm)

void AActor::SetTimer(float InRate, bool inbLoop, const struct FName& inTimerFunc, class UObject* inObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetTimer"));

	AActor_SetTimer_Params params;
	params.InRate = InRate;
	params.inbLoop = inbLoop;
	params.inTimerFunc = inTimerFunc;
	params.inObj = inObj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.TornOff
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AActor::TornOff()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TornOff"));

	AActor_TornOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Destroy
// (Final, Iterator, PreOperator, Singular, NetReliable, Native, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_Destroy()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Destroy"));

	AActor_Destroy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.Spawn
// (Defined, Latent, PreOperator, Net, NetReliable, Exec)
// Parameters:
// class UClass*                  SpawnClass                     (Parm)
// class AActor*                  SpawnOwner                     (OptionalParm, Parm)
// struct FName                   SpawnTag                       (OptionalParm, Parm)
// struct FVector                 SpawnLocation                  (OptionalParm, Parm)
// struct FRotator                SpawnRotation                  (OptionalParm, Parm)
// class AActor*                  ActorTemplate                  (OptionalParm, Parm)
// bool                           bNoCollisionFail               (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm, CoerceParm)

class AActor* AActor::Spawn(class UClass* SpawnClass, class AActor* SpawnOwner, const struct FName& SpawnTag, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* ActorTemplate, bool bNoCollisionFail)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Spawn"));

	AActor_Spawn_Params params;
	params.SpawnClass = SpawnClass;
	params.SpawnOwner = SpawnOwner;
	params.SpawnTag = SpawnTag;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;
	params.ActorTemplate = ActorTemplate;
	params.bNoCollisionFail = bNoCollisionFail;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsBlockedBy
// (Final, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsBlockedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsBlockedBy"));

	AActor_IsBlockedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.BoxCircleTest
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Event, Operator)
// Parameters:
// struct FVector                 CircleCenter                   (Parm)
// float                          CircleRadius                   (Parm)
// struct FVector                 BoxCenter                      (Parm)
// struct FVector                 BoxExtent                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::BoxCircleTest(const struct FVector& CircleCenter, float CircleRadius, const struct FVector& BoxCenter, const struct FVector& BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BoxCircleTest"));

	AActor_BoxCircleTest_Params params;
	params.CircleCenter = CircleCenter;
	params.CircleRadius = CircleRadius;
	params.BoxCenter = BoxCenter;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetBoundingCylinder
// (Final, Defined, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          CollisionRadius                (Parm, OutParm)
// float                          CollisionHeight                (Parm, OutParm)

void AActor::STATIC_GetBoundingCylinder(float* CollisionRadius, float* CollisionHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetBoundingCylinder"));

	AActor_GetBoundingCylinder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CollisionRadius != nullptr)
		*CollisionRadius = params.CollisionRadius;
	if (CollisionHeight != nullptr)
		*CollisionHeight = params.CollisionHeight;
}


// Function Engine.Actor.GetComponentsBoundingBox
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FBox                    ActorBox                       (Parm, OutParm)

void AActor::STATIC_GetComponentsBoundingBox(struct FBox* ActorBox)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetComponentsBoundingBox"));

	AActor_GetComponentsBoundingBox_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActorBox != nullptr)
		*ActorBox = params.ActorBox;
}


// Function Engine.Actor.IsOverlapping
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsOverlapping(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsOverlapping"));

	AActor_IsOverlapping_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ContainsPoint
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Static)
// Parameters:
// struct FVector                 Spot                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_ContainsPoint(const struct FVector& Spot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ContainsPoint"));

	AActor_ContainsPoint_Params params;
	params.Spot = Spot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.FindSpot
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 BoxExtent                      (Parm)
// struct FVector                 SpotLocation                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_FindSpot(const struct FVector& BoxExtent, struct FVector* SpotLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FindSpot"));

	AActor_FindSpot_Params params;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SpotLocation != nullptr)
		*SpotLocation = params.SpotLocation;

	return params.ReturnValue;
}


// Function Engine.Actor.TraceAllPhysicsAssetInteractions
// (Final, Iterator, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelMeshComp                   (Parm, EditInline)
// struct FVector                 EndTrace                       (Parm)
// struct FVector                 StartTrace                     (Parm)
// TArray<struct FImpactInfo>     out_Hits                       (Parm, OutParm, NeedCtorLink)
// struct FVector                 Extent                         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::TraceAllPhysicsAssetInteractions(class USkeletalMeshComponent* SkelMeshComp, const struct FVector& EndTrace, const struct FVector& StartTrace, const struct FVector& Extent, TArray<struct FImpactInfo>* out_Hits)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TraceAllPhysicsAssetInteractions"));

	AActor_TraceAllPhysicsAssetInteractions_Params params;
	params.SkelMeshComp = SkelMeshComp;
	params.EndTrace = EndTrace;
	params.StartTrace = StartTrace;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Hits != nullptr)
		*out_Hits = params.out_Hits;

	return params.ReturnValue;
}


// Function Engine.Actor.FastTrace
// (Final, Iterator, PreOperator, Singular, Exec, Event, Static)
// Parameters:
// struct FVector                 TraceEnd                       (Parm)
// struct FVector                 TraceStart                     (OptionalParm, Parm)
// struct FVector                 BoxExtent                      (OptionalParm, Parm)
// bool                           bTraceBullet                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_FastTrace(const struct FVector& TraceEnd, const struct FVector& TraceStart, const struct FVector& BoxExtent, bool bTraceBullet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FastTrace"));

	AActor_FastTrace_Params params;
	params.TraceEnd = TraceEnd;
	params.TraceStart = TraceStart;
	params.BoxExtent = BoxExtent;
	params.bTraceBullet = bTraceBullet;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.PointCheckComponent
// (Latent, Net, NetReliable, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     InComponent                    (Parm, EditInline)
// struct FVector                 PointLocation                  (Parm)
// struct FVector                 PointExtent                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::PointCheckComponent(class UPrimitiveComponent* InComponent, const struct FVector& PointLocation, const struct FVector& PointExtent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PointCheckComponent"));

	AActor_PointCheckComponent_Params params;
	params.InComponent = InComponent;
	params.PointLocation = PointLocation;
	params.PointExtent = PointExtent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.TraceComponent
// (Defined, Iterator, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 HitLocation                    (Parm, OutParm)
// struct FVector                 HitNormal                      (Parm, OutParm)
// class UPrimitiveComponent*     InComponent                    (Parm, EditInline)
// struct FVector                 TraceEnd                       (Parm)
// struct FVector                 TraceStart                     (OptionalParm, Parm)
// struct FVector                 Extent                         (OptionalParm, Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm, OutParm)
// bool                           bComplexCollision              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::TraceComponent(class UPrimitiveComponent* InComponent, const struct FVector& TraceEnd, const struct FVector& TraceStart, const struct FVector& Extent, bool bComplexCollision, struct FVector* HitLocation, struct FVector* HitNormal, struct FTraceHitInfo* HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.TraceComponent"));

	AActor_TraceComponent_Params params;
	params.InComponent = InComponent;
	params.TraceEnd = TraceEnd;
	params.TraceStart = TraceStart;
	params.Extent = Extent;
	params.bComplexCollision = bComplexCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;

	return params.ReturnValue;
}


// Function Engine.Actor.Trace
// (Final, Defined, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 HitLocation                    (Parm, OutParm)
// struct FVector                 HitNormal                      (Parm, OutParm)
// struct FVector                 TraceEnd                       (Parm)
// struct FVector                 TraceStart                     (OptionalParm, Parm)
// bool                           bTraceActors                   (OptionalParm, Parm)
// struct FVector                 Extent                         (OptionalParm, Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm, OutParm)
// int                            ExtraTraceFlags                (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AActor::Trace(const struct FVector& TraceEnd, const struct FVector& TraceStart, bool bTraceActors, const struct FVector& Extent, int ExtraTraceFlags, struct FVector* HitLocation, struct FVector* HitNormal, struct FTraceHitInfo* HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Trace"));

	AActor_Trace_Params params;
	params.TraceEnd = TraceEnd;
	params.TraceStart = TraceStart;
	params.bTraceActors = bTraceActors;
	params.Extent = Extent;
	params.ExtraTraceFlags = ExtraTraceFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (HitInfo != nullptr)
		*HitInfo = params.HitInfo;

	return params.ReturnValue;
}


// Function Engine.Actor.VolumeBasedDestroy
// (Final, Defined, PreOperator, Singular, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class APhysicsVolume*          PV                             (Parm)

void AActor::VolumeBasedDestroy(class APhysicsVolume* PV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.VolumeBasedDestroy"));

	AActor_VolumeBasedDestroy_Params params;
	params.PV = PV;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OutsideWorldBounds
// (Final, Iterator, PreOperator, Singular, Exec, Native, HasOptionalParms)

void AActor::OutsideWorldBounds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OutsideWorldBounds"));

	AActor_OutsideWorldBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void AActor::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FellOutOfWorld"));

	AActor_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.UsedBy
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   User                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::UsedBy(class APawn* User)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.UsedBy"));

	AActor_UsedBy_Params params;
	params.User = User;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.OverRotated
// (Defined, Iterator, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// struct FRotator                out_Desired                    (Parm, OutParm)
// struct FRotator                out_Actual                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::OverRotated(struct FRotator* out_Desired, struct FRotator* out_Actual)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OverRotated"));

	AActor_OverRotated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Desired != nullptr)
		*out_Desired = params.out_Desired;
	if (out_Actual != nullptr)
		*out_Actual = params.out_Actual;

	return params.ReturnValue;
}


// Function Engine.Actor.ClampRotation
// (Latent, PreOperator, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FRotator                out_Rot                        (Parm, OutParm)
// struct FRotator                rBase                          (Parm)
// struct FRotator                rUpperLimits                   (Parm)
// struct FRotator                rLowerLimits                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::ClampRotation(const struct FRotator& rBase, const struct FRotator& rUpperLimits, const struct FRotator& rLowerLimits, struct FRotator* out_Rot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ClampRotation"));

	AActor_ClampRotation_Params params;
	params.rBase = rBase;
	params.rUpperLimits = rUpperLimits;
	params.rLowerLimits = rLowerLimits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Rot != nullptr)
		*out_Rot = params.out_Rot;

	return params.ReturnValue;
}


// Function Engine.Actor.OnSleepRBPhysics
// (Defined, Iterator, Latent, Singular, Exec, Native, HasOptionalParms)

void AActor::OnSleepRBPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnSleepRBPhysics"));

	AActor_OnSleepRBPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnWakeRBPhysics
// (Final, Defined, PreOperator, Singular, Exec, Native, HasOptionalParms)

void AActor::OnWakeRBPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.OnWakeRBPhysics"));

	AActor_OnWakeRBPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RanInto
// (Final, Defined, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::RanInto(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.RanInto"));

	AActor_RanInto_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.EncroachedBy
// (Final, Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::EncroachedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.EncroachedBy"));

	AActor_EncroachedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.EncroachingOn
// (Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::EncroachingOn(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.EncroachingOn"));

	AActor_EncroachingOn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void AActor::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.CollisionChanged"));

	AActor_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SpecialHandling
// (Final, Defined, Net, Simulated)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AActor::SpecialHandling(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SpecialHandling"));

	AActor_SpecialHandling_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.Detach
// (Final, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::Detach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Detach"));

	AActor_Detach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Attach
// (Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::Attach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Attach"));

	AActor_Attach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.BaseChange
// (Final, Defined, Iterator, PreOperator, Singular, Simulated)

void AActor::BaseChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BaseChange"));

	AActor_BaseChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Bump
// (Iterator, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitNormal                      (Parm)

void AActor::Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Bump"));

	AActor_Bump_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.UnTouch
// (Final, Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::UnTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.UnTouch"));

	AActor_UnTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PostTouch
// (Final, Defined, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::PostTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PostTouch"));

	AActor_PostTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AActor::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Touch"));

	AActor_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PhysicsVolumeChange
// (Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APhysicsVolume*          NewVolume                      (Parm)

void AActor::PhysicsVolumeChange(class APhysicsVolume* NewVolume)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.PhysicsVolumeChange"));

	AActor_PhysicsVolumeChange_Params params;
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Landed
// (Final, PreOperator, Singular, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  FloorActor                     (Parm)

void AActor::Landed(const struct FVector& HitNormal, class AActor* FloorActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Landed"));

	AActor_Landed_Params params;
	params.HitNormal = HitNormal;
	params.FloorActor = FloorActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Falling
// (PreOperator, Singular, Simulated)

void AActor::Falling()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Falling"));

	AActor_Falling_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.HitWall
// (Final, Defined, Iterator, Latent, Singular, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  Wall                           (Parm)
// class UPrimitiveComponent*     WallComp                       (Parm, EditInline)

void AActor::HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.HitWall"));

	AActor_HitWall_Params params;
	params.HitNormal = HitNormal;
	params.Wall = Wall;
	params.WallComp = WallComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Timer
// (Defined, Latent, PreOperator, Singular, NetReliable, Native)

void AActor::Timer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Timer"));

	AActor_Timer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void AActor::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Tick"));

	AActor_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.LostChild
// (Defined, Iterator, Latent, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::LostChild(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.LostChild"));

	AActor_LostChild_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GainedChild
// (Final, Iterator, Latent, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AActor::GainedChild(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GainedChild"));

	AActor_GainedChild_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AActor::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Destroyed"));

	AActor_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetTickIsDisabled
// (Final, Defined, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bInDisabled                    (Parm)

void AActor::SetTickIsDisabled(bool bInDisabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetTickIsDisabled"));

	AActor_SetTickIsDisabled_Params params;
	params.bInDisabled = bInDisabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetTickGroup
// (Defined, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ETickingGroup>     NewTickGroup                   (Parm)

void AActor::SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetTickGroup"));

	AActor_SetTickGroup_Params params;
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReattachComponent
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// class UActorComponent*         ComponentToReattach            (Parm, EditInline)

void AActor::ReattachComponent(class UActorComponent* ComponentToReattach)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ReattachComponent"));

	AActor_ReattachComponent_Params params;
	params.ComponentToReattach = ComponentToReattach;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DetachComponent
// (Final, Iterator, Net, NetReliable, Native, Static)
// Parameters:
// class UActorComponent*         ExComponent                    (Parm, EditInline)

void AActor::STATIC_DetachComponent(class UActorComponent* ExComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DetachComponent"));

	AActor_DetachComponent_Params params;
	params.ExComponent = ExComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AttachComponent
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UActorComponent*         NewComponent                   (Parm, EditInline)

void AActor::AttachComponent(class UActorComponent* NewComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AttachComponent"));

	AActor_AttachComponent_Params params;
	params.NewComponent = NewComponent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.UnClock
// (Latent, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// float                          Time                           (Parm, OutParm)

void AActor::UnClock(float* Time)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.UnClock"));

	AActor_UnClock_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Time != nullptr)
		*Time = params.Time;
}


// Function Engine.Actor.Clock
// (Final, Defined, Iterator, Net, Static)
// Parameters:
// float                          Time                           (Parm, OutParm)

void AActor::STATIC_Clock(float* Time)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Clock"));

	AActor_Clock_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Time != nullptr)
		*Time = params.Time;
}


// Function Engine.Actor.SetPhysics
// (Defined, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)

void AActor::SetPhysics(TEnumAsByte<EPhysics> newPhysics)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetPhysics"));

	AActor_SetPhysics_Params params;
	params.newPhysics = newPhysics;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetOnlyOwnerSee
// (Final, Iterator, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bNewOnlyOwnerSee               (Parm)

void AActor::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetOnlyOwnerSee"));

	AActor_SetOnlyOwnerSee_Params params;
	params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetHidden
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewHidden                     (Parm)

void AActor::SetHidden(bool bNewHidden)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetHidden"));

	AActor_SetHidden_Params params;
	params.bNewHidden = bNewHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ChartData
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 DataName                       (Parm, NeedCtorLink)
// float                          DataValue                      (Parm)

void AActor::ChartData(const struct FString& DataName, float DataValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ChartData"));

	AActor_ChartData_Params params;
	params.DataName = DataName;
	params.DataValue = DataValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FlushDebugStrings
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void AActor::STATIC_FlushDebugStrings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FlushDebugStrings"));

	AActor_FlushDebugStrings_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugFrustrum
// (Defined, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FMatrix                 FrustumToWorld                 (Const, Parm, OutParm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugFrustrum(unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines, struct FMatrix* FrustumToWorld)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugFrustrum"));

	AActor_DrawDebugFrustrum_Params params;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FrustumToWorld != nullptr)
		*FrustumToWorld = params.FrustumToWorld;
}


// Function Engine.Actor.DrawDebugString
// (Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 TextLocation                   (Parm)
// struct FString                 Text                           (Parm, CoerceParm, NeedCtorLink)
// class AActor*                  TestBaseActor                  (OptionalParm, Parm)
// struct FColor                  TextColor                      (OptionalParm, Parm)
// float                          Duration                       (OptionalParm, Parm)

void AActor::STATIC_DrawDebugString(const struct FVector& TextLocation, const struct FString& Text, class AActor* TestBaseActor, const struct FColor& TextColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugString"));

	AActor_DrawDebugString_Params params;
	params.TextLocation = TextLocation;
	params.Text = Text;
	params.TestBaseActor = TestBaseActor;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugCone
// (Final, Defined, Iterator, Latent, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Origin                         (Parm)
// struct FVector                 Direction                      (Parm)
// float                          Length                         (Parm)
// float                          AngleWidth                     (Parm)
// float                          AngleHeight                    (Parm)
// int                            NumSides                       (Parm)
// struct FColor                  DrawColor                      (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugCone(const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FColor& DrawColor, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugCone"));

	AActor_DrawDebugCone_Params params;
	params.Origin = Origin;
	params.Direction = Direction;
	params.Length = Length;
	params.AngleWidth = AngleWidth;
	params.AngleHeight = AngleHeight;
	params.NumSides = NumSides;
	params.DrawColor = DrawColor;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugCylinder
// (Final, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Start                          (Parm)
// struct FVector                 End                            (Parm)
// float                          Radius                         (Parm)
// int                            Segments                       (Parm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugCylinder(const struct FVector& Start, const struct FVector& End, float Radius, int Segments, unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugCylinder"));

	AActor_DrawDebugCylinder_Params params;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.Segments = Segments;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugSphere
// (Defined, Iterator, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Center                         (Parm)
// float                          Radius                         (Parm)
// int                            Segments                       (Parm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugSphere(const struct FVector& Center, float Radius, int Segments, unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugSphere"));

	AActor_DrawDebugSphere_Params params;
	params.Center = Center;
	params.Radius = Radius;
	params.Segments = Segments;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugCoordinateSystem
// (PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 AxisLoc                        (Parm)
// struct FRotator                AxisRot                        (Parm)
// float                          Scale                          (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugCoordinateSystem(const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugCoordinateSystem"));

	AActor_DrawDebugCoordinateSystem_Params params;
	params.AxisLoc = AxisLoc;
	params.AxisRot = AxisRot;
	params.Scale = Scale;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugStar
// (Final, Defined, Iterator, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Position                       (Parm)
// float                          Size                           (Parm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugStar(const struct FVector& Position, float Size, unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugStar"));

	AActor_DrawDebugStar_Params params;
	params.Position = Position;
	params.Size = Size;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugBox
// (Defined, Iterator, Latent, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Center                         (Parm)
// struct FVector                 Extent                         (Parm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugBox(const struct FVector& Center, const struct FVector& Extent, unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugBox"));

	AActor_DrawDebugBox_Params params;
	params.Center = Center;
	params.Extent = Extent;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugPoint
// (Final, Iterator, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Position                       (Parm)
// float                          Size                           (Parm)
// struct FLinearColor            PointColor                     (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugPoint(const struct FVector& Position, float Size, const struct FLinearColor& PointColor, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugPoint"));

	AActor_DrawDebugPoint_Params params;
	params.Position = Position;
	params.Size = Size;
	params.PointColor = PointColor;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DrawDebugLine
// (Iterator, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 LineStart                      (Parm)
// struct FVector                 LineEnd                        (Parm)
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// bool                           bPersistentLines               (OptionalParm, Parm)

void AActor::STATIC_DrawDebugLine(const struct FVector& LineStart, const struct FVector& LineEnd, unsigned char R, unsigned char G, unsigned char B, bool bPersistentLines)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.DrawDebugLine"));

	AActor_DrawDebugLine_Params params;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.R = R;
	params.G = G;
	params.B = B;
	params.bPersistentLines = bPersistentLines;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FlushPersistentDebugLines
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void AActor::STATIC_FlushPersistentDebugLines()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FlushPersistentDebugLines"));

	AActor_FlushPersistentDebugLines_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetBotRankId
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            RankId                         (Parm)

void AActor::SetBotRankId(int RankId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetBotRankId"));

	AActor_SetBotRankId_Params params;
	params.RankId = RankId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetBasedPosition
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FBasedPosition          BP                             (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::STATIC_GetBasedPosition(const struct FBasedPosition& BP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetBasedPosition"));

	AActor_GetBasedPosition_Params params;
	params.BP = BP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetBasedPosition
// (Final, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FBasedPosition          BP                             (Parm, OutParm)
// struct FVector                 pos                            (Parm)
// class AActor*                  ForcedBase                     (OptionalParm, Parm)

void AActor::SetBasedPosition(const struct FVector& pos, class AActor* ForcedBase, struct FBasedPosition* BP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetBasedPosition"));

	AActor_SetBasedPosition_Params params;
	params.pos = pos;
	params.ForcedBase = ForcedBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BP != nullptr)
		*BP = params.BP;
}


// Function Engine.Actor.BP2Vect
// (Iterator, Singular, Net, NetReliable, Simulated, Event, Operator)
// Parameters:
// struct FBasedPosition          BP                             (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::BP2Vect(const struct FBasedPosition& BP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.BP2Vect"));

	AActor_BP2Vect_Params params;
	params.BP = BP;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.Vect2BP
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FBasedPosition          BP                             (Parm, OutParm)
// struct FVector                 pos                            (Parm)
// class AActor*                  ForcedBase                     (OptionalParm, Parm)

void AActor::Vect2BP(const struct FVector& pos, class AActor* ForcedBase, struct FBasedPosition* BP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Vect2BP"));

	AActor_Vect2BP_Params params;
	params.pos = pos;
	params.ForcedBase = ForcedBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BP != nullptr)
		*BP = params.BP;
}


// Function Engine.Actor.SetForcedInitialReplicatedProperty
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UProperty*               PropToReplicate                (Parm)
// bool                           bAdd                           (Parm)

void AActor::SetForcedInitialReplicatedProperty(class UProperty* PropToReplicate, bool bAdd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetForcedInitialReplicatedProperty"));

	AActor_SetForcedInitialReplicatedProperty_Params params;
	params.PropToReplicate = PropToReplicate;
	params.bAdd = bAdd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ReplicatedEvent"));

	AActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetAggregateBaseVelocity
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  TestBase                       (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AActor::STATIC_GetAggregateBaseVelocity(class AActor* TestBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetAggregateBaseVelocity"));

	AActor_GetAggregateBaseVelocity_Params params;
	params.TestBase = TestBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsOwnedBy
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  TestActor                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsOwnedBy(class AActor* TestActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsOwnedBy"));

	AActor_IsOwnedBy_Params params;
	params.TestActor = TestActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetBaseMost
// (Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AActor::STATIC_GetBaseMost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetBaseMost"));

	AActor_GetBaseMost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsBasedOn
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  TestActor                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_IsBasedOn(class AActor* TestActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.IsBasedOn"));

	AActor_IsBasedOn_Params params;
	params.TestActor = TestActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SearchForBaseBelow
// (Final, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// float                          HeightBelow                    (Parm)
// class AActor*                  NewBase                        (Parm, OutParm)
// struct FVector                 HitNormal                      (Parm, OutParm)

void AActor::SearchForBaseBelow(float HeightBelow, class AActor** NewBase, struct FVector* HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SearchForBaseBelow"));

	AActor_SearchForBaseBelow_Params params;
	params.HeightBelow = HeightBelow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewBase != nullptr)
		*NewBase = params.NewBase;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
}


// Function Engine.Actor.FindBase
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, Static)

void AActor::STATIC_FindBase()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FindBase"));

	AActor_FindBase_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetOwner
// (Final, Singular, Event, HasOptionalParms)
// Parameters:
// class AActor*                  NewOwner                       (Parm)

void AActor::SetOwner(class AActor* NewOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetOwner"));

	AActor_SetOwner_Params params;
	params.NewOwner = NewOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetBase
// (Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  NewBase                        (Parm)
// struct FVector                 NewFloor                       (OptionalParm, Parm)
// class USkeletalMeshComponent*  SkelComp                       (OptionalParm, Parm, EditInline)
// struct FName                   AttachName                     (OptionalParm, Parm)

void AActor::SetBase(class AActor* NewBase, const struct FVector& NewFloor, class USkeletalMeshComponent* SkelComp, const struct FName& AttachName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetBase"));

	AActor_SetBase_Params params;
	params.NewBase = NewBase;
	params.NewFloor = NewFloor;
	params.SkelComp = SkelComp;
	params.AttachName = AttachName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.GetTerminalVelocity
// (Final, Defined, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AActor::STATIC_GetTerminalVelocity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.GetTerminalVelocity"));

	AActor_GetTerminalVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.AutonomousPhysics
// (Final, Defined, Iterator, PreOperator, Net, Exec, Operator)
// Parameters:
// float                          DeltaSeconds                   (Parm)

void AActor::AutonomousPhysics(float DeltaSeconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.AutonomousPhysics"));

	AActor_AutonomousPhysics_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.MoveSmooth
// (Iterator, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FVector                 Delta                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_MoveSmooth(const struct FVector& Delta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.MoveSmooth"));

	AActor_MoveSmooth_Params params;
	params.Delta = Delta;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.fixedTurn
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Event, Static)
// Parameters:
// int                            Current                        (Parm)
// int                            Desired                        (Parm)
// int                            DeltaRate                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AActor::STATIC_fixedTurn(int Current, int Desired, int DeltaRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.fixedTurn"));

	AActor_fixedTurn_Params params;
	params.Current = Current;
	params.Desired = Desired;
	params.DeltaRate = DeltaRate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetShadowParentOnAllAttachedComponents
// (Final, Defined, Iterator, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     MyPrimComp                     (Parm, EditInline)
// class ULightEnvironmentComponent* MyLightEnv                     (Parm, EditInline)

void AActor::SetShadowParentOnAllAttachedComponents(class UPrimitiveComponent* MyPrimComp, class ULightEnvironmentComponent* MyLightEnv)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetShadowParentOnAllAttachedComponents"));

	AActor_SetShadowParentOnAllAttachedComponents_Params params;
	params.MyPrimComp = MyPrimComp;
	params.MyLightEnv = MyLightEnv;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetHardAttach
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewHardAttach                 (OptionalParm, Parm)

void AActor::SetHardAttach(bool bNewHardAttach)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetHardAttach"));

	AActor_SetHardAttach_Params params;
	params.bNewHardAttach = bNewHardAttach;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetRelativeLocation
// (Defined, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SetRelativeLocation(const struct FVector& NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetRelativeLocation"));

	AActor_SetRelativeLocation_Params params;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetRelativeRotation
// (Final, Defined, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SetRelativeRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetRelativeRotation"));

	AActor_SetRelativeRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetZone
// (Final, Defined, PreOperator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bForceRefresh                  (Parm)

void AActor::SetZone(bool bForceRefresh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetZone"));

	AActor_SetZone_Params params;
	params.bForceRefresh = bForceRefresh;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.MovingWhichWay
// (Iterator, PreOperator, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// float                          Amount                         (Parm, OutParm)
// TEnumAsByte<EMoveDir>          ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EMoveDir> AActor::STATIC_MovingWhichWay(float* Amount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.MovingWhichWay"));

	AActor_MovingWhichWay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Amount != nullptr)
		*Amount = params.Amount;

	return params.ReturnValue;
}


// Function Engine.Actor.SetRotation
// (Defined, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SetRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetRotation"));

	AActor_SetRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetLocation
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::SetLocation(const struct FVector& NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetLocation"));

	AActor_SetLocation_Params params;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.Move
// (Iterator, Latent, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FVector                 Delta                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AActor::STATIC_Move(const struct FVector& Delta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Move"));

	AActor_Move_Params params;
	params.Delta = Delta;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.SetDrawScale3D
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewScale3D                     (Parm)

void AActor::SetDrawScale3D(const struct FVector& NewScale3D)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetDrawScale3D"));

	AActor_SetDrawScale3D_Params params;
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetDrawScale
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewScale                       (Parm)

void AActor::SetDrawScale(float NewScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetDrawScale"));

	AActor_SetDrawScale_Params params;
	params.NewScale = NewScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetCollisionType
// (Final, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<ECollisionType>    NewCollisionType               (Parm)

void AActor::SetCollisionType(TEnumAsByte<ECollisionType> NewCollisionType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetCollisionType"));

	AActor_SetCollisionType_Params params;
	params.NewCollisionType = NewCollisionType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetCollisionSize
// (PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewRadius                      (Parm)
// float                          NewHeight                      (Parm)

void AActor::SetCollisionSize(float NewRadius, float NewHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetCollisionSize"));

	AActor_SetCollisionSize_Params params;
	params.NewRadius = NewRadius;
	params.NewHeight = NewHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetCollision
// (Defined, Latent, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bNewColActors                  (OptionalParm, Parm)
// bool                           bNewBlockActors                (OptionalParm, Parm)
// bool                           bNewIgnoreEncroachers          (OptionalParm, Parm)

void AActor::SetCollision(bool bNewColActors, bool bNewBlockActors, bool bNewIgnoreEncroachers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.SetCollision"));

	AActor_SetCollision_Params params;
	params.bNewColActors = bNewColActors;
	params.bNewBlockActors = bNewBlockActors;
	params.bNewIgnoreEncroachers = bNewIgnoreEncroachers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FinishAnim
// (Defined, Net, NetReliable, Exec, Event, Static)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)
// bool                           bFinishOnBlendOut              (OptionalParm, Parm)

void AActor::STATIC_FinishAnim(class UAnimNodeSequence* SeqNode, bool bFinishOnBlendOut)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.FinishAnim"));

	AActor_FinishAnim_Params params;
	params.SeqNode = SeqNode;
	params.bFinishOnBlendOut = bFinishOnBlendOut;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.Sleep
// (Iterator, PreOperator, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// float                          Seconds                        (Parm)

void AActor::Sleep(float Seconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.Sleep"));

	AActor_Sleep_Params params;
	params.Seconds = Seconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ConsoleCommand
// (Iterator, Latent, Singular, Net, Simulated, Static)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)
// bool                           bWriteToLog                    (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AActor::STATIC_ConsoleCommand(const struct FString& Command, bool bWriteToLog)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ConsoleCommand"));

	AActor_ConsoleCommand_Params params;
	params.Command = Command;
	params.bWriteToLog = bWriteToLog;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ForceUpdateComponents
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// bool                           bCollisionUpdate               (OptionalParm, Parm)
// bool                           bTransformOnly                 (OptionalParm, Parm)

void AActor::STATIC_ForceUpdateComponents(bool bCollisionUpdate, bool bTransformOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Actor.ForceUpdateComponents"));

	AActor_ForceUpdateComponents_Params params;
	params.bCollisionUpdate = bCollisionUpdate;
	params.bTransformOnly = bTransformOnly;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsRecordingTimelapse
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsRecordingTimelapse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsRecordingTimelapse"));

	AWorldInfo_IsRecordingTimelapse_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsTimelapsePlayOfTheGame
// (Latent, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsTimelapsePlayOfTheGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsTimelapsePlayOfTheGame"));

	AWorldInfo_IsTimelapsePlayOfTheGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsPlayingTimelapse
// (Defined, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPlayingTimelapse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPlayingTimelapse"));

	AWorldInfo_IsPlayingTimelapse_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.ClearObjectPools
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)

void AWorldInfo::ClearObjectPools()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ClearObjectPools"));

	AWorldInfo_ClearObjectPools_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.ToggleHostMigration
// (Latent, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bEnabled                       (Parm)

void AWorldInfo::ToggleHostMigration(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ToggleHostMigration"));

	AWorldInfo_ToggleHostMigration_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.NotifyHostMigrationStateChanged
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EHostMigrationProgress> NewState                       (Parm)
// TEnumAsByte<EHostMigrationProgress> OldState                       (Parm)

void AWorldInfo::NotifyHostMigrationStateChanged(TEnumAsByte<EHostMigrationProgress> NewState, TEnumAsByte<EHostMigrationProgress> OldState)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.NotifyHostMigrationStateChanged"));

	AWorldInfo_NotifyHostMigrationStateChanged_Params params;
	params.NewState = NewState;
	params.OldState = OldState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.BeginHostMigration
// (Final, Defined, Iterator, Latent, Simulated, Native, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::BeginHostMigration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.BeginHostMigration"));

	AWorldInfo_BeginHostMigration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.CanBeginHostMigration
// (Final, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::CanBeginHostMigration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.CanBeginHostMigration"));

	AWorldInfo_CanBeginHostMigration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.FindEnvironmentVolume
// (PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 TestLocation                   (Parm)
// class AEnvironmentVolume*      ReturnValue                    (Parm, OutParm, ReturnParm)

class AEnvironmentVolume* AWorldInfo::STATIC_FindEnvironmentVolume(const struct FVector& TestLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.FindEnvironmentVolume"));

	AWorldInfo_FindEnvironmentVolume_Params params;
	params.TestLocation = TestLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetWorldInfo
// (Defined, Iterator, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AWorldInfo*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AWorldInfo* AWorldInfo::STATIC_GetWorldInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetWorldInfo"));

	AWorldInfo_GetWorldInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetWorldFractureSettings
// (Final, Iterator, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FWorldFractureSettings  ReturnValue                    (Parm, OutParm, ReturnParm)

struct FWorldFractureSettings AWorldInfo::STATIC_GetWorldFractureSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetWorldFractureSettings"));

	AWorldInfo_GetWorldFractureSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.DoMemoryTracking
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void AWorldInfo::STATIC_DoMemoryTracking()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.DoMemoryTracking"));

	AWorldInfo_DoMemoryTracking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.GetDemoRewindPoints
// (Defined, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TArray<int>                    OutRewindPoints                (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_GetDemoRewindPoints(TArray<int>* OutRewindPoints)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetDemoRewindPoints"));

	AWorldInfo_GetDemoRewindPoints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRewindPoints != nullptr)
		*OutRewindPoints = params.OutRewindPoints;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetDemoFrameInfo
// (Final, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            CurrentFrame                   (OptionalParm, Parm, OutParm)
// int                            TotalFrames                    (OptionalParm, Parm, OutParm)

void AWorldInfo::STATIC_GetDemoFrameInfo(int* CurrentFrame, int* TotalFrames)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetDemoFrameInfo"));

	AWorldInfo_GetDemoFrameInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CurrentFrame != nullptr)
		*CurrentFrame = params.CurrentFrame;
	if (TotalFrames != nullptr)
		*TotalFrames = params.TotalFrames;
}


// Function Engine.WorldInfo.IsPlayingDemo
// (Final, Defined, Iterator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPlayingDemo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPlayingDemo"));

	AWorldInfo_IsPlayingDemo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsRecordingDemo
// (Defined, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsRecordingDemo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsRecordingDemo"));

	AWorldInfo_IsRecordingDemo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetDetailMode
// (Defined, Iterator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EDetailMode>       ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EDetailMode> AWorldInfo::STATIC_GetDetailMode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetDetailMode"));

	AWorldInfo_GetDetailMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetMapName
// (Defined, Iterator, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// bool                           bIncludePrefix                 (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AWorldInfo::STATIC_GetMapName(bool bIncludePrefix)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetMapName"));

	AWorldInfo_GetMapName_Params params;
	params.bIncludePrefix = bIncludePrefix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.SetMapInfo
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UMapInfo*                NewMapInfo                     (Parm)

void AWorldInfo::SetMapInfo(class UMapInfo* NewMapInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.SetMapInfo"));

	AWorldInfo_SetMapInfo_Params params;
	params.NewMapInfo = NewMapInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.GetMapInfo
// (Final, Iterator, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// class UMapInfo*                ReturnValue                    (Parm, OutParm, ReturnParm)

class UMapInfo* AWorldInfo::STATIC_GetMapInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetMapInfo"));

	AWorldInfo_GetMapInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.SetSeamlessTravelMidpointPause
// (Defined, Iterator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bNowPaused                     (Parm)

void AWorldInfo::SetSeamlessTravelMidpointPause(bool bNowPaused)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.SetSeamlessTravelMidpointPause"));

	AWorldInfo_SetSeamlessTravelMidpointPause_Params params;
	params.bNowPaused = bNowPaused;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsInSeamlessTravel
// (Final, Iterator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsInSeamlessTravel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsInSeamlessTravel"));

	AWorldInfo_IsInSeamlessTravel_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.SeamlessTravel
// (Final, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           bAbsolute                      (OptionalParm, Parm)
// struct FGuid                   MapPackageGuid                 (OptionalParm, Parm, AlwaysInit)

void AWorldInfo::SeamlessTravel(const struct FString& URL, bool bAbsolute, const struct FGuid& MapPackageGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.SeamlessTravel"));

	AWorldInfo_SeamlessTravel_Params params;
	params.URL = URL;
	params.bAbsolute = bAbsolute;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.CommitMapChange
// (Iterator, Simulated, Static)

void AWorldInfo::STATIC_CommitMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.CommitMapChange"));

	AWorldInfo_CommitMapChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.CancelPendingMapChange
// (Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Operator)

void AWorldInfo::CancelPendingMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.CancelPendingMapChange"));

	AWorldInfo_CancelPendingMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsMapChangeReady
// (Final, Defined, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsMapChangeReady()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsMapChangeReady"));

	AWorldInfo_IsMapChangeReady_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsPreparingMapChange
// (Final, Iterator, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPreparingMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPreparingMapChange"));

	AWorldInfo_IsPreparingMapChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.PrepareMapChange
// (Final, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// TArray<struct FName>           LevelNames                     (Const, Parm, OutParm, NeedCtorLink)

void AWorldInfo::PrepareMapChange(TArray<struct FName>* LevelNames)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.PrepareMapChange"));

	AWorldInfo_PrepareMapChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LevelNames != nullptr)
		*LevelNames = params.LevelNames;
}


// Function Engine.WorldInfo.NotifyMatchStarted
// (Defined, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// bool                           bShouldActivateLevelStartupEvents (OptionalParm, Parm)
// bool                           bShouldActivateLevelBeginningEvents (OptionalParm, Parm)
// bool                           bShouldActivateLevelLoadedEvents (OptionalParm, Parm)

void AWorldInfo::STATIC_NotifyMatchStarted(bool bShouldActivateLevelStartupEvents, bool bShouldActivateLevelBeginningEvents, bool bShouldActivateLevelLoadedEvents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.NotifyMatchStarted"));

	AWorldInfo_NotifyMatchStarted_Params params;
	params.bShouldActivateLevelStartupEvents = bShouldActivateLevelStartupEvents;
	params.bShouldActivateLevelBeginningEvents = bShouldActivateLevelBeginningEvents;
	params.bShouldActivateLevelLoadedEvents = bShouldActivateLevelLoadedEvents;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.AllClientConnections
// (Defined, Iterator, Latent, PreOperator, NetReliable, Operator)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm, OutParm)
// struct FIpAddr                 ClientIP                       (Parm, OutParm)
// int                            ClientPort                     (Parm, OutParm)

void AWorldInfo::AllClientConnections(class UPlayer** ClientConnection, struct FIpAddr* ClientIP, int* ClientPort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.AllClientConnections"));

	AWorldInfo_AllClientConnections_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ClientConnection != nullptr)
		*ClientConnection = params.ClientConnection;
	if (ClientIP != nullptr)
		*ClientIP = params.ClientIP;
	if (ClientPort != nullptr)
		*ClientPort = params.ClientPort;
}


// Function Engine.WorldInfo.AllPawns
// (Iterator, Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class APawn*                   P                              (Parm, OutParm)
// struct FVector                 TestLocation                   (OptionalParm, Parm)
// float                          TestRadius                     (OptionalParm, Parm)

void AWorldInfo::AllPawns(class UClass* BaseClass, const struct FVector& TestLocation, float TestRadius, class APawn** P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.AllPawns"));

	AWorldInfo_AllPawns_Params params;
	params.BaseClass = BaseClass;
	params.TestLocation = TestLocation;
	params.TestRadius = TestRadius;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (P != nullptr)
		*P = params.P;
}


// Function Engine.WorldInfo.AllControllers
// (Final, Singular, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AController*             C                              (Parm, OutParm)

void AWorldInfo::AllControllers(class UClass* BaseClass, class AController** C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.AllControllers"));

	AWorldInfo_AllControllers_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (C != nullptr)
		*C = params.C;
}


// Function Engine.WorldInfo.NavigationPointCheck
// (Latent, PreOperator, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// struct FVector                 Point                          (Parm)
// struct FVector                 Extent                         (Parm)
// TArray<class ANavigationPoint*> Navs                           (OptionalParm, Parm, OutParm, NeedCtorLink)
// TArray<class UReachSpec*>      Specs                          (OptionalParm, Parm, OutParm, NeedCtorLink)

void AWorldInfo::STATIC_NavigationPointCheck(const struct FVector& Point, const struct FVector& Extent, TArray<class ANavigationPoint*>* Navs, TArray<class UReachSpec*>* Specs)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.NavigationPointCheck"));

	AWorldInfo_NavigationPointCheck_Params params;
	params.Point = Point;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Navs != nullptr)
		*Navs = params.Navs;
	if (Specs != nullptr)
		*Specs = params.Specs;
}


// Function Engine.WorldInfo.RadiusNavigationPoints
// (Final, Defined, Iterator, Singular, NetReliable, Exec, HasOptionalParms)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class ANavigationPoint*        N                              (Parm, OutParm)
// struct FVector                 Point                          (Parm)
// float                          Radius                         (Parm)

void AWorldInfo::RadiusNavigationPoints(class UClass* BaseClass, const struct FVector& Point, float Radius, class ANavigationPoint** N)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.RadiusNavigationPoints"));

	AWorldInfo_RadiusNavigationPoints_Params params;
	params.BaseClass = BaseClass;
	params.Point = Point;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (N != nullptr)
		*N = params.N;
}


// Function Engine.WorldInfo.AllNavigationPoints
// (Defined, Iterator, Singular, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class ANavigationPoint*        N                              (Parm, OutParm)

void AWorldInfo::AllNavigationPoints(class UClass* BaseClass, class ANavigationPoint** N)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.AllNavigationPoints"));

	AWorldInfo_AllNavigationPoints_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (N != nullptr)
		*N = params.N;
}


// Function Engine.WorldInfo.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AWorldInfo::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.Reset"));

	AWorldInfo_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AWorldInfo::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.PostBeginPlay"));

	AWorldInfo_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.PreBeginPlay
// (Latent, Net, Simulated)

void AWorldInfo::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.PreBeginPlay"));

	AWorldInfo_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.ThisIsNeverExecuted
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// class ADefaultPhysicsVolume*   P                              (Parm)

void AWorldInfo::ThisIsNeverExecuted(class ADefaultPhysicsVolume* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ThisIsNeverExecuted"));

	AWorldInfo_ThisIsNeverExecuted_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.ServerTravel
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           bAbsolute                      (OptionalParm, Parm)
// bool                           bShouldSkipGameNotify          (OptionalParm, Parm)

void AWorldInfo::ServerTravel(const struct FString& URL, bool bAbsolute, bool bShouldSkipGameNotify)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ServerTravel"));

	AWorldInfo_ServerTravel_Params params;
	params.URL = URL;
	params.bAbsolute = bAbsolute;
	params.bShouldSkipGameNotify = bShouldSkipGameNotify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.GetGameClass
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* AWorldInfo::STATIC_GetGameClass()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetGameClass"));

	AWorldInfo_GetGameClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetAddressURL
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AWorldInfo::STATIC_GetAddressURL()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetAddressURL"));

	AWorldInfo_GetAddressURL_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.VerifyNavList
// (Defined, Iterator, Latent, Singular, Operator, HasOptionalParms)

void AWorldInfo::VerifyNavList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.VerifyNavList"));

	AWorldInfo_VerifyNavList_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.ForceGarbageCollection
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// bool                           bFullPurge                     (OptionalParm, Parm)

void AWorldInfo::STATIC_ForceGarbageCollection(bool bFullPurge)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ForceGarbageCollection"));

	AWorldInfo_ForceGarbageCollection_Params params;
	params.bFullPurge = bFullPurge;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsOverridePlatform
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// TEnumAsByte<EConsoleType>      ConsoleType                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsOverridePlatform(TEnumAsByte<EConsoleType> ConsoleType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsOverridePlatform"));

	AWorldInfo_IsOverridePlatform_Params params;
	params.ConsoleType = ConsoleType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsPlayInMobilePreview
// (Final, Defined, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPlayInMobilePreview()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPlayInMobilePreview"));

	AWorldInfo_IsPlayInMobilePreview_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsPlayInPreview
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPlayInPreview()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPlayInPreview"));

	AWorldInfo_IsPlayInPreview_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsPlayInEditor
// (Final, Iterator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsPlayInEditor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsPlayInEditor"));

	AWorldInfo_IsPlayInEditor_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsWithGFx
// (Defined, Iterator, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsWithGFx()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsWithGFx"));

	AWorldInfo_IsWithGFx_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsTencentBuild
// (Final, Defined, Iterator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsTencentBuild()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsTencentBuild"));

	AWorldInfo_IsTencentBuild_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsConsoleBuild
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// TEnumAsByte<EConsoleType>      ConsoleType                    (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsConsoleBuild(TEnumAsByte<EConsoleType> ConsoleType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsConsoleBuild"));

	AWorldInfo_IsConsoleBuild_Params params;
	params.ConsoleType = ConsoleType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.IsDemoBuild
// (Iterator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsDemoBuild()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsDemoBuild"));

	AWorldInfo_IsDemoBuild_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetLocalURL
// (Final, Defined, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AWorldInfo::STATIC_GetLocalURL()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetLocalURL"));

	AWorldInfo_GetLocalURL_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.SetLevelRBGravity
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewGrav                        (Parm)

void AWorldInfo::SetLevelRBGravity(const struct FVector& NewGrav)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.SetLevelRBGravity"));

	AWorldInfo_SetLevelRBGravity_Params params;
	params.NewGrav = NewGrav;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.GetAllRootSequences
// (Defined, Iterator, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<class USequence*>       ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<class USequence*> AWorldInfo::STATIC_GetAllRootSequences()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetAllRootSequences"));

	AWorldInfo_GetAllRootSequences_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetGameSequence
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class USequence*               ReturnValue                    (Parm, OutParm, ReturnParm)

class USequence* AWorldInfo::STATIC_GetGameSequence()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetGameSequence"));

	AWorldInfo_GetGameSequence_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetGravityZ
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AWorldInfo::STATIC_GetGravityZ()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetGravityZ"));

	AWorldInfo_GetGravityZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.UpdateMusicTrack
// (Final, Iterator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FMusicTrackStruct       NewMusicTrack                  (Parm, NeedCtorLink)

void AWorldInfo::UpdateMusicTrack(const struct FMusicTrackStruct& NewMusicTrack)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.UpdateMusicTrack"));

	AWorldInfo_UpdateMusicTrack_Params params;
	params.NewMusicTrack = NewMusicTrack;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.SetMusicVolume
// (Iterator, Latent, Event, HasOptionalParms)
// Parameters:
// float                          VolumeMultiplier               (Parm)

void AWorldInfo::SetMusicVolume(float VolumeMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.SetMusicVolume"));

	AWorldInfo_SetMusicVolume_Params params;
	params.VolumeMultiplier = VolumeMultiplier;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsMenuLevel
// (Iterator, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FString                 MapName                        (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsMenuLevel(const struct FString& MapName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsMenuLevel"));

	AWorldInfo_IsMenuLevel_Params params;
	params.MapName = MapName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.AddOnScreenDebugMessage
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// int                            Key                            (Parm)
// float                          TimeToDisplay                  (Parm)
// struct FColor                  DisplayColor                   (Parm)
// struct FString                 DebugMessage                   (Parm, NeedCtorLink)

void AWorldInfo::AddOnScreenDebugMessage(int Key, float TimeToDisplay, const struct FColor& DisplayColor, const struct FString& DebugMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.AddOnScreenDebugMessage"));

	AWorldInfo_AddOnScreenDebugMessage_Params params;
	params.Key = Key;
	params.TimeToDisplay = TimeToDisplay;
	params.DisplayColor = DisplayColor;
	params.DebugMessage = DebugMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AWorldInfo::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ReplicatedEvent"));

	AWorldInfo_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.GetNavMeshPathGoalEvaluatorFromCache
// (Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class UClass*                  GoalEvalClass                  (Parm)
// class UNavigationHandle*       Requestor                      (Parm)
// class UNavMeshPathGoalEvaluator* ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshPathGoalEvaluator* AWorldInfo::STATIC_GetNavMeshPathGoalEvaluatorFromCache(class UClass* GoalEvalClass, class UNavigationHandle* Requestor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetNavMeshPathGoalEvaluatorFromCache"));

	AWorldInfo_GetNavMeshPathGoalEvaluatorFromCache_Params params;
	params.GoalEvalClass = GoalEvalClass;
	params.Requestor = Requestor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.GetNavMeshPathConstraintFromCache
// (Final, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class UClass*                  ConstraintClass                (Parm)
// class UNavigationHandle*       Requestor                      (Parm)
// class UNavMeshPathConstraint*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshPathConstraint* AWorldInfo::STATIC_GetNavMeshPathConstraintFromCache(class UClass* ConstraintClass, class UNavigationHandle* Requestor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.GetNavMeshPathConstraintFromCache"));

	AWorldInfo_GetNavMeshPathConstraintFromCache_Params params;
	params.ConstraintClass = ConstraintClass;
	params.Requestor = Requestor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldInfo.ReleaseCachedConstraintsAndEvaluators
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void AWorldInfo::ReleaseCachedConstraintsAndEvaluators()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.ReleaseCachedConstraintsAndEvaluators"));

	AWorldInfo_ReleaseCachedConstraintsAndEvaluators_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldInfo.IsExperimentOn
// (Iterator, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FString                 sName                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWorldInfo::STATIC_IsExperimentOn(const struct FString& sName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldInfo.IsExperimentOn"));

	AWorldInfo_IsExperimentOn_Params params;
	params.sName = sName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DownloadableContentEnumerator.TriggerFindDLCDelegates
// (Latent, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)

void UDownloadableContentEnumerator::TriggerFindDLCDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.TriggerFindDLCDelegates"));

	UDownloadableContentEnumerator_TriggerFindDLCDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.InstallDLC
// (Latent, Singular, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// struct FString                 DLCName                        (Parm, NeedCtorLink)

void UDownloadableContentEnumerator::STATIC_InstallDLC(const struct FString& DLCName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.InstallDLC"));

	UDownloadableContentEnumerator_InstallDLC_Params params;
	params.DLCName = DLCName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.InstallAllDLC
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Operator, Static)

void UDownloadableContentEnumerator::STATIC_InstallAllDLC()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.InstallAllDLC"));

	UDownloadableContentEnumerator_InstallAllDLC_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.DeleteDLC
// (Defined, Iterator, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FString                 DLCName                        (Parm, NeedCtorLink)

void UDownloadableContentEnumerator::STATIC_DeleteDLC(const struct FString& DLCName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.DeleteDLC"));

	UDownloadableContentEnumerator_DeleteDLC_Params params;
	params.DLCName = DLCName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.ClearFindDLCDelegate
// (Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UDownloadableContentEnumerator::ClearFindDLCDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.ClearFindDLCDelegate"));

	UDownloadableContentEnumerator_ClearFindDLCDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.AddFindDLCDelegate
// (Final, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UDownloadableContentEnumerator::AddFindDLCDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.AddFindDLCDelegate"));

	UDownloadableContentEnumerator_AddFindDLCDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.OnFindDLCComplete
// (Final, Defined, PreOperator, Exec, Native, HasOptionalParms)

void UDownloadableContentEnumerator::OnFindDLCComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.OnFindDLCComplete"));

	UDownloadableContentEnumerator_OnFindDLCComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentEnumerator.FindDLC
// (Final, Iterator, Latent, NetReliable, Exec, Event, Static)

void UDownloadableContentEnumerator::STATIC_FindDLC()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentEnumerator.FindDLC"));

	UDownloadableContentEnumerator_FindDLC_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.OnRefreshComplete
// (Final, Defined, Singular, Exec, Native, HasOptionalParms)

void UDownloadableContentManager::OnRefreshComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.OnRefreshComplete"));

	UDownloadableContentManager_OnRefreshComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.AddPackagesToFullyLoad
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UDownloadableContentManager::AddPackagesToFullyLoad(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.AddPackagesToFullyLoad"));

	UDownloadableContentManager_AddPackagesToFullyLoad_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.RefreshDLCEnumComplete
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void UDownloadableContentManager::RefreshDLCEnumComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.RefreshDLCEnumComplete"));

	UDownloadableContentManager_RefreshDLCEnumComplete_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.RefreshDLC
// (Defined, Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UDownloadableContentManager::RefreshDLC()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.RefreshDLC"));

	UDownloadableContentManager_RefreshDLC_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.AuthorizeDLCRefresh
// (Iterator, Latent, Simulated, Native, HasOptionalParms)

void UDownloadableContentManager::AuthorizeDLCRefresh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.AuthorizeDLCRefresh"));

	UDownloadableContentManager_AuthorizeDLCRefresh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.OnContentChange
// (Defined, Latent, NetReliable, Native, Event, Operator, Static)

void UDownloadableContentManager::STATIC_OnContentChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.OnContentChange"));

	UDownloadableContentManager_OnContentChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.OnStorageDeviceChange
// (Final, Defined, Iterator, Latent, Exec, Native, Event, Static)

void UDownloadableContentManager::STATIC_OnStorageDeviceChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.OnStorageDeviceChange"));

	UDownloadableContentManager_OnStorageDeviceChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UDownloadableContentManager::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.OnLoginChange"));

	UDownloadableContentManager_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UDownloadableContentManager::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.Init"));

	UDownloadableContentManager_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.InstallNonPackageFiles
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// struct FOnlineContent          DLCBundle                      (Const, Parm, OutParm, NeedCtorLink)

void UDownloadableContentManager::STATIC_InstallNonPackageFiles(struct FOnlineContent* DLCBundle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.InstallNonPackageFiles"));

	UDownloadableContentManager_InstallNonPackageFiles_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DLCBundle != nullptr)
		*DLCBundle = params.DLCBundle;
}


// Function Engine.DownloadableContentManager.InstallPackages
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// struct FOnlineContent          DLCBundle                      (Const, Parm, OutParm, NeedCtorLink)

void UDownloadableContentManager::STATIC_InstallPackages(struct FOnlineContent* DLCBundle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.InstallPackages"));

	UDownloadableContentManager_InstallPackages_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DLCBundle != nullptr)
		*DLCBundle = params.DLCBundle;
}


// Function Engine.DownloadableContentManager.UpdateObjectLists
// (Final, Defined, Iterator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void UDownloadableContentManager::UpdateObjectLists()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.UpdateObjectLists"));

	UDownloadableContentManager_UpdateObjectLists_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.MarkPerObjectConfigPendingKill
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, Operator, Static)
// Parameters:
// struct FString                 Section                        (Parm, NeedCtorLink)

void UDownloadableContentManager::STATIC_MarkPerObjectConfigPendingKill(const struct FString& Section)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.MarkPerObjectConfigPendingKill"));

	UDownloadableContentManager_MarkPerObjectConfigPendingKill_Params params;
	params.Section = Section;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.AddSectionToObjectList
// (Final, Defined, Latent, PreOperator, Operator)
// Parameters:
// struct FString                 Section                        (Parm, NeedCtorLink)

void UDownloadableContentManager::AddSectionToObjectList(const struct FString& Section)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.AddSectionToObjectList"));

	UDownloadableContentManager_AddSectionToObjectList_Params params;
	params.Section = Section;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.GetDLCNonPackageFilePath
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   NonPackageFileName             (Parm)
// struct FString                 Path                           (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UDownloadableContentManager::STATIC_GetDLCNonPackageFilePath(const struct FName& NonPackageFileName, struct FString* Path)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.GetDLCNonPackageFilePath"));

	UDownloadableContentManager_GetDLCNonPackageFilePath_Params params;
	params.NonPackageFileName = NonPackageFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Path != nullptr)
		*Path = params.Path;

	return params.ReturnValue;
}


// Function Engine.DownloadableContentManager.ClearDLC
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)

void UDownloadableContentManager::ClearDLC()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.ClearDLC"));

	UDownloadableContentManager_ClearDLC_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DownloadableContentManager.InstallDLCs
// (Final, Latent, Singular, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// TArray<struct FOnlineContent>  DLCBundles                     (Const, Parm, OutParm, NeedCtorLink)

void UDownloadableContentManager::STATIC_InstallDLCs(TArray<struct FOnlineContent>* DLCBundles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.InstallDLCs"));

	UDownloadableContentManager_InstallDLCs_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DLCBundles != nullptr)
		*DLCBundles = params.DLCBundles;
}


// Function Engine.DownloadableContentManager.InstallDLC
// (Latent, Singular, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// struct FOnlineContent          DLCBundle                      (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UDownloadableContentManager::STATIC_InstallDLC(struct FOnlineContent* DLCBundle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DownloadableContentManager.InstallDLC"));

	UDownloadableContentManager_InstallDLC_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DLCBundle != nullptr)
		*DLCBundle = params.DLCBundle;

	return params.ReturnValue;
}


// Function Engine.Engine.GetSystemSettingFloat
// (Final, Defined, Iterator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 SettingName                    (Parm, NeedCtorLink)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UEngine::STATIC_GetSystemSettingFloat(const struct FString& SettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetSystemSettingFloat"));

	UEngine_GetSystemSettingFloat_Params params;
	params.SettingName = SettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetSystemSettingInt
// (Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 SettingName                    (Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UEngine::STATIC_GetSystemSettingInt(const struct FString& SettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetSystemSettingInt"));

	UEngine_GetSystemSettingInt_Params params;
	params.SettingName = SettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetSystemSettingBool
// (Defined, Iterator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 SettingName                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_GetSystemSettingBool(const struct FString& SettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetSystemSettingBool"));

	UEngine_GetSystemSettingBool_Params params;
	params.SettingName = SettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.LaunchURL
// (PreOperator, Native, Operator, Static)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)

void UEngine::STATIC_LaunchURL(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.LaunchURL"));

	UEngine_LaunchURL_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.BasicLoadObject
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Operator)
// Parameters:
// class UObject*                 Obj                            (Parm)
// struct FString                 PathName                       (Parm, NeedCtorLink)
// bool                           bIsSaveGame                    (Parm)
// int                            Version                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::BasicLoadObject(class UObject* Obj, const struct FString& PathName, bool bIsSaveGame, int Version)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.BasicLoadObject"));

	UEngine_BasicLoadObject_Params params;
	params.Obj = Obj;
	params.PathName = PathName;
	params.bIsSaveGame = bIsSaveGame;
	params.Version = Version;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.BasicSaveObject
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Operator)
// Parameters:
// class UObject*                 Obj                            (Parm)
// struct FString                 PathName                       (Parm, NeedCtorLink)
// bool                           bIsSaveGame                    (Parm)
// int                            Version                        (Parm)
// bool                           bEncrypt                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::BasicSaveObject(class UObject* Obj, const struct FString& PathName, bool bIsSaveGame, int Version, bool bEncrypt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.BasicSaveObject"));

	UEngine_BasicSaveObject_Params params;
	params.Obj = Obj;
	params.PathName = PathName;
	params.bIsSaveGame = bIsSaveGame;
	params.Version = Version;
	params.bEncrypt = bEncrypt;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.AddTextureStreamingSlaveLoc
// (Defined, PreOperator, Singular, Operator)
// Parameters:
// struct FVector                 InLoc                          (Parm)
// float                          BoostFactor                    (Parm)
// bool                           bOverrideLocation              (Parm)
// float                          OverrideDuration               (Parm)

void UEngine::AddTextureStreamingSlaveLoc(const struct FVector& InLoc, float BoostFactor, bool bOverrideLocation, float OverrideDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.AddTextureStreamingSlaveLoc"));

	UEngine_AddTextureStreamingSlaveLoc_Params params;
	params.InLoc = InLoc;
	params.BoostFactor = BoostFactor;
	params.bOverrideLocation = bOverrideLocation;
	params.OverrideDuration = OverrideDuration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.GetWorldPostProcessChain
// (Final, Defined, Iterator, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UPostProcessChain*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPostProcessChain* UEngine::STATIC_GetWorldPostProcessChain()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetWorldPostProcessChain"));

	UEngine_GetWorldPostProcessChain_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetDefaultPostProcessChain
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UPostProcessChain*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPostProcessChain* UEngine::STATIC_GetDefaultPostProcessChain()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetDefaultPostProcessChain"));

	UEngine_GetDefaultPostProcessChain_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetEngine
// (Final, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UEngine*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UEngine* UEngine::STATIC_GetEngine()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetEngine"));

	UEngine_GetEngine_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsRealDStereoEnabled
// (Final, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_IsRealDStereoEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsRealDStereoEnabled"));

	UEngine_IsRealDStereoEnabled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.AddOverlayWrapped
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UFont*                   Font                           (Parm)
// struct FString                 Text                           (Parm, NeedCtorLink)
// float                          X                              (Parm)
// float                          Y                              (Parm)
// float                          ScaleX                         (Parm)
// float                          ScaleY                         (Parm)
// float                          WrapWidth                      (Parm)

void UEngine::AddOverlayWrapped(class UFont* Font, const struct FString& Text, float X, float Y, float ScaleX, float ScaleY, float WrapWidth)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.AddOverlayWrapped"));

	UEngine_AddOverlayWrapped_Params params;
	params.Font = Font;
	params.Text = Text;
	params.X = X;
	params.Y = Y;
	params.ScaleX = ScaleX;
	params.ScaleY = ScaleY;
	params.WrapWidth = WrapWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.AddOverlay
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UFont*                   Font                           (Parm)
// struct FString                 Text                           (Parm, NeedCtorLink)
// float                          X                              (Parm)
// float                          Y                              (Parm)
// float                          ScaleX                         (Parm)
// float                          ScaleY                         (Parm)
// bool                           bIsCentered                    (Parm)

void UEngine::AddOverlay(class UFont* Font, const struct FString& Text, float X, float Y, float ScaleX, float ScaleY, bool bIsCentered)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.AddOverlay"));

	UEngine_AddOverlay_Params params;
	params.Font = Font;
	params.Text = Text;
	params.X = X;
	params.Y = Y;
	params.ScaleX = ScaleX;
	params.ScaleY = ScaleY;
	params.bIsCentered = bIsCentered;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.RemoveAllOverlays
// (Final, Latent, Native, HasOptionalParms)

void UEngine::RemoveAllOverlays()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.RemoveAllOverlays"));

	UEngine_RemoveAllOverlays_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.StopMovie
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           bDelayStopUntilGameHasRendered (Parm)

void UEngine::StopMovie(bool bDelayStopUntilGameHasRendered)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.StopMovie"));

	UEngine_StopMovie_Params params;
	params.bDelayStopUntilGameHasRendered = bDelayStopUntilGameHasRendered;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.PlayLoadMapMovieByMapName
// (Defined, Singular, NetReliable, HasOptionalParms)
// Parameters:
// struct FString                 MovieName                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::PlayLoadMapMovieByMapName(const struct FString& MovieName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.PlayLoadMapMovieByMapName"));

	UEngine_PlayLoadMapMovieByMapName_Params params;
	params.MovieName = MovieName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.PlayLoadMapMovie
// (Final, Singular, NetReliable, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::PlayLoadMapMovie()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.PlayLoadMapMovie"));

	UEngine_PlayLoadMapMovie_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetLastMovieName
// (Final, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UEngine::STATIC_GetLastMovieName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetLastMovieName"));

	UEngine_GetLastMovieName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetAudioDevice
// (Defined, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// class UAudioDevice*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UAudioDevice* UEngine::STATIC_GetAudioDevice()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetAudioDevice"));

	UEngine_GetAudioDevice_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsUsingES2Renderer
// (Iterator, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_IsUsingES2Renderer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsUsingES2Renderer"));

	UEngine_IsUsingES2Renderer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsStereoscopic3D
// (Iterator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_IsStereoscopic3D()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsStereoscopic3D"));

	UEngine_IsStereoscopic3D_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsSplitScreen
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_IsSplitScreen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsSplitScreen"));

	UEngine_IsSplitScreen_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetAdditionalFont
// (Defined, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// int                            AdditionalFontIndex            (Parm)
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetAdditionalFont(int AdditionalFontIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetAdditionalFont"));

	UEngine_GetAdditionalFont_Params params;
	params.AdditionalFontIndex = AdditionalFontIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetSubtitleFont
// (Simulated, Exec, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetSubtitleFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetSubtitleFont"));

	UEngine_GetSubtitleFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetLargeFont
// (Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetLargeFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetLargeFont"));

	UEngine_GetLargeFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetMediumFont
// (Final, Defined, Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetMediumFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetMediumFont"));

	UEngine_GetMediumFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetSmallFont
// (Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetSmallFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetSmallFont"));

	UEngine_GetSmallFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetTinyFont
// (Final, Defined, Iterator, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UEngine::STATIC_GetTinyFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetTinyFont"));

	UEngine_GetTinyFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.ResetPeerNetDriver
// (Iterator, NetReliable, Native, HasOptionalParms)

void UEngine::ResetPeerNetDriver()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.ResetPeerNetDriver"));

	UEngine_ResetPeerNetDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.CleanUpPeerNetDriver
// (Defined, Iterator, Singular, Simulated, Exec, Native, Event, Operator)

void UEngine::CleanUpPeerNetDriver()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.CleanUpPeerNetDriver"));

	UEngine_CleanUpPeerNetDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.CreatePeerNetDriver
// (Final, Defined, PreOperator, Exec, Static)

void UEngine::STATIC_CreatePeerNetDriver()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.CreatePeerNetDriver"));

	UEngine_CreatePeerNetDriver_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Engine.HasNetworkConnection
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_HasNetworkConnection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.HasNetworkConnection"));

	UEngine_HasNetworkConnection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.BuildBugSubmissionString
// (Final, Defined, Singular, Net, Native, Event, Operator)
// Parameters:
// struct FString                 BugField                       (Parm, NeedCtorLink)
// struct FString                 BugFieldData                   (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UEngine::BuildBugSubmissionString(const struct FString& BugField, const struct FString& BugFieldData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.BuildBugSubmissionString"));

	UEngine_BuildBugSubmissionString_Params params;
	params.BugField = BugField;
	params.BugFieldData = BugFieldData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetDevicePushNotificationToken
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UEngine::STATIC_GetDevicePushNotificationToken()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetDevicePushNotificationToken"));

	UEngine_GetDevicePushNotificationToken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetOSVersion
// (Defined, Iterator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UEngine::STATIC_GetOSVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetOSVersion"));

	UEngine_GetOSVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetDeviceUUID
// (Final, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UEngine::STATIC_GetDeviceUUID()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetDeviceUUID"));

	UEngine_GetDeviceUUID_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetBuildDate
// (Iterator, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UEngine::STATIC_GetBuildDate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetBuildDate"));

	UEngine_GetBuildDate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.GetCurrentWorldInfo
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AWorldInfo*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AWorldInfo* UEngine::STATIC_GetCurrentWorldInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.GetCurrentWorldInfo"));

	UEngine_GetCurrentWorldInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsGame
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::STATIC_IsGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsGame"));

	UEngine_IsGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Engine.IsEditor
// (Final, Defined, Iterator, Singular, Net, NetReliable, Native, Event)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UEngine::IsEditor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Engine.IsEditor"));

	UEngine_IsEditor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameEngine.DecodeURLString
// (Final, PreOperator, NetReliable, Simulated, Exec, Static)
// Parameters:
// struct FString                 Str                            (Parm, OutParm, NeedCtorLink)

void UGameEngine::STATIC_DecodeURLString(struct FString* Str)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.DecodeURLString"));

	UGameEngine_DecodeURLString_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Str != nullptr)
		*Str = params.Str;
}


// Function Engine.GameEngine.EncodeURLString
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// struct FString                 Str                            (Parm, OutParm, NeedCtorLink)

void UGameEngine::STATIC_EncodeURLString(struct FString* Str)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.EncodeURLString"));

	UGameEngine_EncodeURLString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Str != nullptr)
		*Str = params.Str;
}


// Function Engine.GameEngine.HasSecondaryScreenActive
// (Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameEngine::STATIC_HasSecondaryScreenActive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.HasSecondaryScreenActive"));

	UGameEngine_HasSecondaryScreenActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameEngine.GetDLCManager
// (Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UDownloadableContentManager* ReturnValue                    (Parm, OutParm, ReturnParm)

class UDownloadableContentManager* UGameEngine::STATIC_GetDLCManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.GetDLCManager"));

	UGameEngine_GetDLCManager_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameEngine.GetDLCEnumerator
// (Final, Defined, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UDownloadableContentEnumerator* ReturnValue                    (Parm, OutParm, ReturnParm)

class UDownloadableContentEnumerator* UGameEngine::STATIC_GetDLCEnumerator()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.GetDLCEnumerator"));

	UGameEngine_GetDLCEnumerator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameEngine.GetOnlineSubsystem
// (Final, Defined, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UOnlineSubsystem*        ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineSubsystem* UGameEngine::STATIC_GetOnlineSubsystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.GetOnlineSubsystem"));

	UGameEngine_GetOnlineSubsystem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameEngine.DestroyNamedNetDriver
// (Final, Latent, PreOperator, Singular, NetReliable, Native, Static)
// Parameters:
// struct FName                   NetDriverName                  (Parm)

void UGameEngine::STATIC_DestroyNamedNetDriver(const struct FName& NetDriverName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.DestroyNamedNetDriver"));

	UGameEngine_DestroyNamedNetDriver_Params params;
	params.NetDriverName = NetDriverName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameEngine.CreateNamedNetDriver
// (Defined, Latent, Exec, Static)
// Parameters:
// struct FName                   NetDriverName                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameEngine::STATIC_CreateNamedNetDriver(const struct FName& NetDriverName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameEngine.CreateNamedNetDriver"));

	UGameEngine_CreateNamedNetDriver_Params params;
	params.NetDriverName = NetDriverName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Volume.ProcessActorSetVolume
// (Iterator, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AVolume::ProcessActorSetVolume(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.ProcessActorSetVolume"));

	AVolume_ProcessActorSetVolume_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Volume.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void AVolume::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.CollisionChanged"));

	AVolume_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Volume.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AVolume::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.OnToggle"));

	AVolume_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Volume.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AVolume::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.DisplayDebug"));

	AVolume_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Volume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.PostBeginPlay"));

	AVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Volume.EncompassesPoint
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// struct FVector                 Loc                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVolume::STATIC_EncompassesPoint(const struct FVector& Loc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.EncompassesPoint"));

	AVolume_EncompassesPoint_Params params;
	params.Loc = Loc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Volume.Encompasses
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVolume::STATIC_Encompasses(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Volume.Encompasses"));

	AVolume_Encompasses_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlockingVolume.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ABlockingVolume::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BlockingVolume.OnToggle"));

	ABlockingVolume_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicBlockingVolume.OnChangeCollision
// (Defined, Iterator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ChangeCollision* Action                         (Parm)

void ADynamicBlockingVolume::STATIC_OnChangeCollision(class USeqAct_ChangeCollision* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.OnChangeCollision"));

	ADynamicBlockingVolume_OnChangeCollision_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicBlockingVolume.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void ADynamicBlockingVolume::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.CollisionChanged"));

	ADynamicBlockingVolume_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicBlockingVolume.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ADynamicBlockingVolume_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ADynamicBlockingVolume::ApplyCheckpointRecord(struct ADynamicBlockingVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.ApplyCheckpointRecord"));

	ADynamicBlockingVolume_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.DynamicBlockingVolume.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ADynamicBlockingVolume_FCheckpointRecord Record                         (Parm, OutParm)

void ADynamicBlockingVolume::STATIC_CreateCheckpointRecord(struct ADynamicBlockingVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.CreateCheckpointRecord"));

	ADynamicBlockingVolume_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.DynamicBlockingVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADynamicBlockingVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.PostBeginPlay"));

	ADynamicBlockingVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicBlockingVolume.UnRegisterObstacle
// (Final, Defined, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void ADynamicBlockingVolume::UnRegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.UnRegisterObstacle"));

	ADynamicBlockingVolume_UnRegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicBlockingVolume.RegisterObstacle
// (Final, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void ADynamicBlockingVolume::RegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicBlockingVolume.RegisterObstacle"));

	ADynamicBlockingVolume_RegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreamingVolume.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ALevelStreamingVolume_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ALevelStreamingVolume::ApplyCheckpointRecord(struct ALevelStreamingVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LevelStreamingVolume.ApplyCheckpointRecord"));

	ALevelStreamingVolume_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.LevelStreamingVolume.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ALevelStreamingVolume_FCheckpointRecord Record                         (Parm, OutParm)

void ALevelStreamingVolume::STATIC_CreateCheckpointRecord(struct ALevelStreamingVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LevelStreamingVolume.CreateCheckpointRecord"));

	ALevelStreamingVolume_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.LevelStreamingVolume.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ALevelStreamingVolume::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LevelStreamingVolume.OnToggle"));

	ALevelStreamingVolume_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct APhysicsVolume_FCheckpointRecord Record                         (Const, Parm, OutParm)

void APhysicsVolume::ApplyCheckpointRecord(struct APhysicsVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.ApplyCheckpointRecord"));

	APhysicsVolume_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.PhysicsVolume.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct APhysicsVolume_FCheckpointRecord Record                         (Parm, OutParm)

void APhysicsVolume::STATIC_CreateCheckpointRecord(struct APhysicsVolume_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.CreateCheckpointRecord"));

	APhysicsVolume_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.PhysicsVolume.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APhysicsVolume::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.ShouldSaveForCheckpoint"));

	APhysicsVolume_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsVolume.OnSetDamageInstigator
// (Final, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetDamageInstigator* Action                         (Parm)

void APhysicsVolume::STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.OnSetDamageInstigator"));

	APhysicsVolume_OnSetDamageInstigator_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.NotifyPawnBecameViewTarget
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// class APlayerController*       PC                             (Parm)

void APhysicsVolume::STATIC_NotifyPawnBecameViewTarget(class APawn* P, class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.NotifyPawnBecameViewTarget"));

	APhysicsVolume_NotifyPawnBecameViewTarget_Params params;
	params.P = P;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.ModifyPlayer
// (Final, Latent, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// class APawn*                   PlayerPawn                     (Parm)

void APhysicsVolume::STATIC_ModifyPlayer(class APawn* PlayerPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.ModifyPlayer"));

	APhysicsVolume_ModifyPlayer_Params params;
	params.PlayerPawn = PlayerPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.CausePainTo
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)

void APhysicsVolume::CausePainTo(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.CausePainTo"));

	APhysicsVolume_CausePainTo_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void APhysicsVolume::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.Touch"));

	APhysicsVolume_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.TimerPop
// (Defined, Latent, Singular, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// class AVolumeTimer*            T                              (Parm)

void APhysicsVolume::TimerPop(class AVolumeTimer* T)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.TimerPop"));

	APhysicsVolume_TimerPop_Params params;
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void APhysicsVolume::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.CollisionChanged"));

	APhysicsVolume_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void APhysicsVolume::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.OnToggle"));

	APhysicsVolume_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.PawnLeavingVolume
// (Final, Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)

void APhysicsVolume::PawnLeavingVolume(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.PawnLeavingVolume"));

	APhysicsVolume_PawnLeavingVolume_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.PawnEnteredVolume
// (Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)

void APhysicsVolume::PawnEnteredVolume(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.PawnEnteredVolume"));

	APhysicsVolume_PawnEnteredVolume_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.ActorLeavingVolume
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void APhysicsVolume::ActorLeavingVolume(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.ActorLeavingVolume"));

	APhysicsVolume_ActorLeavingVolume_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.ActorEnteredVolume
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void APhysicsVolume::ActorEnteredVolume(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.ActorEnteredVolume"));

	APhysicsVolume_ActorEnteredVolume_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.PhysicsChangedFor
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void APhysicsVolume::PhysicsChangedFor(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.PhysicsChangedFor"));

	APhysicsVolume_PhysicsChangedFor_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APhysicsVolume::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.Reset"));

	APhysicsVolume_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void APhysicsVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.PostBeginPlay"));

	APhysicsVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsVolume.GetZoneVelocityForActor
// (Final, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  TheActor                       (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APhysicsVolume::STATIC_GetZoneVelocityForActor(class AActor* TheActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.GetZoneVelocityForActor"));

	APhysicsVolume_GetZoneVelocityForActor_Params params;
	params.TheActor = TheActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsVolume.GetGravityZ
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APhysicsVolume::STATIC_GetGravityZ()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsVolume.GetGravityZ"));

	APhysicsVolume_GetGravityZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DefaultPhysicsVolume.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ADefaultPhysicsVolume::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DefaultPhysicsVolume.Destroyed"));

	ADefaultPhysicsVolume_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LadderVolume.PhysicsChangedFor
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void ALadderVolume::PhysicsChangedFor(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LadderVolume.PhysicsChangedFor"));

	ALadderVolume_PhysicsChangedFor_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LadderVolume.PawnLeavingVolume
// (Final, Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void ALadderVolume::PawnLeavingVolume(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LadderVolume.PawnLeavingVolume"));

	ALadderVolume_PawnLeavingVolume_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LadderVolume.PawnEnteredVolume
// (Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void ALadderVolume::PawnEnteredVolume(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LadderVolume.PawnEnteredVolume"));

	ALadderVolume_PawnEnteredVolume_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LadderVolume.InUse
// (Final, Defined, Iterator, PreOperator, Net, Exec, Operator, Static)
// Parameters:
// class APawn*                   Ignored                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALadderVolume::STATIC_InUse(class APawn* Ignored)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LadderVolume.InUse"));

	ALadderVolume_InUse_Params params;
	params.Ignored = Ignored;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LadderVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ALadderVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LadderVolume.PostBeginPlay"));

	ALadderVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PostProcessVolume.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void APostProcessVolume::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PostProcessVolume.OnToggle"));

	APostProcessVolume_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ReverbVolume.UnTouch
// (Final, Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AReverbVolume::UnTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReverbVolume.UnTouch"));

	AReverbVolume_UnTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ReverbVolume.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AReverbVolume::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReverbVolume.Touch"));

	AReverbVolume_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TriggerVolume.StopsProjectile
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AProjectile*             P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATriggerVolume::StopsProjectile(class AProjectile* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggerVolume.StopsProjectile"));

	ATriggerVolume_StopsProjectile_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TriggerVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ATriggerVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggerVolume.PostBeginPlay"));

	ATriggerVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Portal.GetDestinationEdge
// (Iterator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 EdgeStart                      (Parm, OutParm)
// struct FVector                 EdgeEnd                        (Parm, OutParm)

void APortal::STATIC_GetDestinationEdge(struct FVector* EdgeStart, struct FVector* EdgeEnd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Portal.GetDestinationEdge"));

	APortal_GetDestinationEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EdgeStart != nullptr)
		*EdgeStart = params.EdgeStart;
	if (EdgeEnd != nullptr)
		*EdgeEnd = params.EdgeEnd;
}


// Function Engine.Portal.GetSourceEdge
// (Final, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 EdgeStart                      (Parm, OutParm)
// struct FVector                 EdgeEnd                        (Parm, OutParm)

void APortal::STATIC_GetSourceEdge(struct FVector* EdgeStart, struct FVector* EdgeEnd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Portal.GetSourceEdge"));

	APortal_GetSourceEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EdgeStart != nullptr)
		*EdgeStart = params.EdgeStart;
	if (EdgeEnd != nullptr)
		*EdgeEnd = params.EdgeEnd;
}


// Function Engine.Portal.IsValidPortal
// (Final, Defined, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APortal::STATIC_IsValidPortal()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Portal.IsValidPortal"));

	APortal_IsValidPortal_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DroppedPickup.RecheckValidTouch
// (Defined, NetReliable, Simulated, Exec, HasOptionalParms)

void ADroppedPickup::RecheckValidTouch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.RecheckValidTouch"));

	ADroppedPickup_RecheckValidTouch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.PickedUpBy
// (Final, Defined, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void ADroppedPickup::PickedUpBy(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.PickedUpBy"));

	ADroppedPickup_PickedUpBy_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.GiveTo
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class APawn*                   P                              (Parm)

void ADroppedPickup::STATIC_GiveTo(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.GiveTo"));

	ADroppedPickup_GiveTo_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.Landed
// (Final, PreOperator, Singular, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  FloorActor                     (Parm)

void ADroppedPickup::Landed(const struct FVector& HitNormal, class AActor* FloorActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.Landed"));

	ADroppedPickup_Landed_Params params;
	params.HitNormal = HitNormal;
	params.FloorActor = FloorActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.DetourWeight
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// float                          PathWeight                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ADroppedPickup::DetourWeight(class APawn* Other, float PathWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.DetourWeight"));

	ADroppedPickup_DetourWeight_Params params;
	params.Other = Other;
	params.PathWeight = PathWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DroppedPickup.EncroachedBy
// (Final, Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void ADroppedPickup::EncroachedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.EncroachedBy"));

	ADroppedPickup_EncroachedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.SetPickupParticles
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PickupParticles                (Parm, EditInline)

void ADroppedPickup::SetPickupParticles(class UParticleSystemComponent* PickupParticles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.SetPickupParticles"));

	ADroppedPickup_SetPickupParticles_Params params;
	params.PickupParticles = PickupParticles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.SetPickupMesh
// (Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     PickupMesh                     (Parm, EditInline)

void ADroppedPickup::SetPickupMesh(class UPrimitiveComponent* PickupMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.SetPickupMesh"));

	ADroppedPickup_SetPickupMesh_Params params;
	params.PickupMesh = PickupMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void ADroppedPickup::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.Reset"));

	ADroppedPickup_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ADroppedPickup::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.ReplicatedEvent"));

	ADroppedPickup_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ADroppedPickup::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.Destroyed"));

	ADroppedPickup_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.RemoveFromNavigation
// (Final, Defined, PreOperator, Native, HasOptionalParms)

void ADroppedPickup::RemoveFromNavigation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.RemoveFromNavigation"));

	ADroppedPickup_RemoveFromNavigation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DroppedPickup.AddToNavigation
// (Final, Defined, PreOperator, Singular, Operator)

void ADroppedPickup::AddToNavigation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DroppedPickup.AddToNavigation"));

	ADroppedPickup_AddToNavigation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.OnChangeCollision
// (Defined, Iterator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ChangeCollision* Action                         (Parm)

void ADynamicSMActor::STATIC_OnChangeCollision(class USeqAct_ChangeCollision* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.OnChangeCollision"));

	ADynamicSMActor_OnChangeCollision_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void ADynamicSMActor::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.CollisionChanged"));

	ADynamicSMActor_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.SetLightEnvironmentToNotBeDynamic
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)

void ADynamicSMActor::SetLightEnvironmentToNotBeDynamic()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.SetLightEnvironmentToNotBeDynamic"));

	ADynamicSMActor_SetLightEnvironmentToNotBeDynamic_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.Detach
// (Final, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void ADynamicSMActor::Detach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.Detach"));

	ADynamicSMActor_Detach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.Attach
// (Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void ADynamicSMActor::Attach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.Attach"));

	ADynamicSMActor_Attach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.CanBasePawn
// (Final, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ADynamicSMActor::CanBasePawn(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.CanBasePawn"));

	ADynamicSMActor_CanBasePawn_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DynamicSMActor.SetStaticMesh
// (Defined, NetReliable, Event, HasOptionalParms)
// Parameters:
// class UStaticMesh*             NewMesh                        (Parm)
// struct FVector                 NewTranslation                 (OptionalParm, Parm)
// struct FRotator                NewRotation                    (OptionalParm, Parm)
// struct FVector                 NewScale3D                     (OptionalParm, Parm)

void ADynamicSMActor::SetStaticMesh(class UStaticMesh* NewMesh, const struct FVector& NewTranslation, const struct FRotator& NewRotation, const struct FVector& NewScale3D)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.SetStaticMesh"));

	ADynamicSMActor_SetStaticMesh_Params params;
	params.NewMesh = NewMesh;
	params.NewTranslation = NewTranslation;
	params.NewRotation = NewRotation;
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.OnSetMaterial
// (Defined, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetMaterial*     Action                         (Parm)

void ADynamicSMActor::STATIC_OnSetMaterial(class USeqAct_SetMaterial* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.OnSetMaterial"));

	ADynamicSMActor_OnSetMaterial_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.OnSetMesh
// (Iterator, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class USeqAct_SetMesh*         Action                         (Parm)

void ADynamicSMActor::OnSetMesh(class USeqAct_SetMesh* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.OnSetMesh"));

	ADynamicSMActor_OnSetMesh_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ADynamicSMActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.ReplicatedEvent"));

	ADynamicSMActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADynamicSMActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.PostBeginPlay"));

	ADynamicSMActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.UnRegisterObstacle
// (Final, Defined, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void ADynamicSMActor::UnRegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.UnRegisterObstacle"));

	ADynamicSMActor_UnRegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicSMActor.RegisterObstacle
// (Final, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void ADynamicSMActor::RegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicSMActor.RegisterObstacle"));

	ADynamicSMActor_RegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct AInterpActor_FCheckpointRecord Record                         (Const, Parm, OutParm)

void AInterpActor::ApplyCheckpointRecord(struct AInterpActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.ApplyCheckpointRecord"));

	AInterpActor_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.InterpActor.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct AInterpActor_FCheckpointRecord Record                         (Parm, OutParm)

void AInterpActor::STATIC_CreateCheckpointRecord(struct AInterpActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.CreateCheckpointRecord"));

	AInterpActor_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.InterpActor.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInterpActor::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.ShouldSaveForCheckpoint"));

	AInterpActor_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InterpActor.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void AInterpActor::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.ShutDown"));

	AInterpActor_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.InterpolationChanged
// (Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void AInterpActor::InterpolationChanged(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.InterpolationChanged"));

	AInterpActor_InterpolationChanged_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.InterpolationFinished
// (Final, Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void AInterpActor::InterpolationFinished(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.InterpolationFinished"));

	AInterpActor_InterpolationFinished_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.InterpolationStarted
// (Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)
// class UInterpGroupInst*        GroupInst                      (Parm)

void AInterpActor::InterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.InterpolationStarted"));

	AInterpActor_InterpolationStarted_Params params;
	params.InterpAction = InterpAction;
	params.GroupInst = GroupInst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.PlayMovingSound
// (Final, Defined, Singular, NetReliable, HasOptionalParms)
// Parameters:
// bool                           bClosing                       (Parm)

void AInterpActor::PlayMovingSound(bool bClosing)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.PlayMovingSound"));

	AInterpActor_PlayMovingSound_Params params;
	params.bClosing = bClosing;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.FinishedOpen
// (Iterator, Net, NetReliable, Exec, Event, Static)

void AInterpActor::STATIC_FinishedOpen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.FinishedOpen"));

	AInterpActor_FinishedOpen_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.Restart
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Native, HasOptionalParms)

void AInterpActor::Restart()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.Restart"));

	AInterpActor_Restart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.Detach
// (Final, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AInterpActor::Detach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.Detach"));

	AInterpActor_Detach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.Attach
// (Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AInterpActor::Attach(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.Attach"));

	AInterpActor_Attach_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.RanInto
// (Final, Defined, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AInterpActor::RanInto(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.RanInto"));

	AInterpActor_RanInto_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpActor.EncroachingOn
// (Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInterpActor::EncroachingOn(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.EncroachingOn"));

	AInterpActor_EncroachingOn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InterpActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AInterpActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InterpActor.PostBeginPlay"));

	AInterpActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.HideSelf
// (Defined, Latent, PreOperator, Operator, Static)

void AEmitter::STATIC_HideSelf()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.HideSelf"));

	AEmitter_HideSelf_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct AEmitter_FCheckpointRecord Record                         (Const, Parm, OutParm)

void AEmitter::ApplyCheckpointRecord(struct AEmitter_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.ApplyCheckpointRecord"));

	AEmitter_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.Emitter.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct AEmitter_FCheckpointRecord Record                         (Parm, OutParm)

void AEmitter::STATIC_CreateCheckpointRecord(struct AEmitter_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.CreateCheckpointRecord"));

	AEmitter_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.Emitter.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AEmitter::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.ShouldSaveForCheckpoint"));

	AEmitter_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Emitter.OnSetParticleSysParam
// (Final, Defined, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetParticleSysParam* Action                         (Parm)

void AEmitter::STATIC_OnSetParticleSysParam(class USeqAct_SetParticleSysParam* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.OnSetParticleSysParam"));

	AEmitter_OnSetParticleSysParam_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetActorParameter
// (Final, Defined, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class AActor*                  Param                          (Parm)

void AEmitter::SetActorParameter(const struct FName& ParameterName, class AActor* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetActorParameter"));

	AEmitter_SetActorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetExtColorParameter
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// unsigned char                  Red                            (Parm)
// unsigned char                  Green                          (Parm)
// unsigned char                  Blue                           (Parm)
// unsigned char                  Alpha                          (Parm)

void AEmitter::SetExtColorParameter(const struct FName& ParameterName, unsigned char Red, unsigned char Green, unsigned char Blue, unsigned char Alpha)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetExtColorParameter"));

	AEmitter_SetExtColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Red = Red;
	params.Green = Green;
	params.Blue = Blue;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetColorParameter
// (Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FColor                  Param                          (Parm)

void AEmitter::SetColorParameter(const struct FName& ParameterName, const struct FColor& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetColorParameter"));

	AEmitter_SetColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetVectorParameter
// (Final, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FVector                 Param                          (Parm)

void AEmitter::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetVectorParameter"));

	AEmitter_SetVectorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetFloatParameter
// (Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Param                          (Parm)

void AEmitter::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetFloatParameter"));

	AEmitter_SetFloatParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void AEmitter::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.ShutDown"));

	AEmitter_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.OnParticleEventGenerator
// (Defined, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ParticleEventGenerator* Action                         (Parm)

void AEmitter::STATIC_OnParticleEventGenerator(class USeqAct_ParticleEventGenerator* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.OnParticleEventGenerator"));

	AEmitter_OnParticleEventGenerator_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.Deactivate
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Static)

void AEmitter::STATIC_Deactivate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.Deactivate"));

	AEmitter_Deactivate_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.Activate
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, Event)

void AEmitter::Activate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.Activate"));

	AEmitter_Activate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AEmitter::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.OnToggle"));

	AEmitter_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.OnParticleSystemFinished
// (Final, Defined, Latent, PreOperator, Singular, Native)
// Parameters:
// class UParticleSystemComponent* FinishedComponent              (Parm, EditInline)

void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.OnParticleSystemFinished"));

	AEmitter_OnParticleSystemFinished_Params params;
	params.FinishedComponent = FinishedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AEmitter::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.ReplicatedEvent"));

	AEmitter_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AEmitter::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.PostBeginPlay"));

	AEmitter_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetTemplate
// (Final, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystem*         NewTemplate                    (Parm)
// bool                           bDestroyOnFinish               (OptionalParm, Parm)

void AEmitter::SetTemplate(class UParticleSystem* NewTemplate, bool bDestroyOnFinish)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Emitter.SetTemplate"));

	AEmitter_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;
	params.bDestroyOnFinish = bDestroyOnFinish;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.PreBeginPlay
// (Latent, Net, Simulated)

void AEmitterPool::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.PreBeginPlay"));

	AEmitterPool_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.ActivateSpawnedEmitter
// (Latent, Singular, Simulated, Exec, Native, Event)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void AEmitterPool::ActivateSpawnedEmitter(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.ActivateSpawnedEmitter"));

	AEmitterPool_ActivateSpawnedEmitter_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.CreateInitialPooledComponents
// (Latent, Exec, Static)

void AEmitterPool::STATIC_CreateInitialPooledComponents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.CreateInitialPooledComponents"));

	AEmitterPool_CreateInitialPooledComponents_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.SpawnEmitterCustomLifetime
// (Final, Defined, Iterator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// class UParticleSystem*         EmitterTemplate                (Parm)
// bool                           bSkipAutoActivate              (OptionalParm, Parm)
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* AEmitterPool::SpawnEmitterCustomLifetime(class UParticleSystem* EmitterTemplate, bool bSkipAutoActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.SpawnEmitterCustomLifetime"));

	AEmitterPool_SpawnEmitterCustomLifetime_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.bSkipAutoActivate = bSkipAutoActivate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.SpawnEmitterMeshAttachment
// (Latent, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// class UParticleSystem*         EmitterTemplate                (Parm)
// class USkeletalMeshComponent*  Mesh                           (Parm, EditInline)
// struct FName                   AttachPointName                (Parm)
// bool                           bAttachToSocket                (OptionalParm, Parm)
// struct FVector                 RelativeLoc                    (OptionalParm, Parm)
// struct FRotator                RelativeRot                    (OptionalParm, Parm)
// struct FParticleChannelContainer PSysChannels                   (OptionalParm, Parm)
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* AEmitterPool::SpawnEmitterMeshAttachment(class UParticleSystem* EmitterTemplate, class USkeletalMeshComponent* Mesh, const struct FName& AttachPointName, bool bAttachToSocket, const struct FVector& RelativeLoc, const struct FRotator& RelativeRot, const struct FParticleChannelContainer& PSysChannels)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.SpawnEmitterMeshAttachment"));

	AEmitterPool_SpawnEmitterMeshAttachment_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.Mesh = Mesh;
	params.AttachPointName = AttachPointName;
	params.bAttachToSocket = bAttachToSocket;
	params.RelativeLoc = RelativeLoc;
	params.RelativeRot = RelativeRot;
	params.PSysChannels = PSysChannels;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.SpawnEmitter
// (Defined, Iterator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// class UParticleSystem*         EmitterTemplate                (Parm)
// struct FVector                 SpawnLocation                  (Parm)
// struct FRotator                SpawnRotation                  (OptionalParm, Parm)
// class AActor*                  AttachToActor                  (OptionalParm, Parm)
// class AActor*                  InInstigator                   (OptionalParm, Parm)
// int                            MaxDLEPooledReuses             (OptionalParm, Parm)
// bool                           bInheritScaleFromBase          (OptionalParm, Parm)
// struct FParticleChannelContainer PSysChannels                   (OptionalParm, Parm)
// bool                           bSkipAutoActivate              (OptionalParm, Parm)
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* AEmitterPool::SpawnEmitter(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* AttachToActor, class AActor* InInstigator, int MaxDLEPooledReuses, bool bInheritScaleFromBase, const struct FParticleChannelContainer& PSysChannels, bool bSkipAutoActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.SpawnEmitter"));

	AEmitterPool_SpawnEmitter_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;
	params.AttachToActor = AttachToActor;
	params.InInstigator = InInstigator;
	params.MaxDLEPooledReuses = MaxDLEPooledReuses;
	params.bInheritScaleFromBase = bInheritScaleFromBase;
	params.PSysChannels = PSysChannels;
	params.bSkipAutoActivate = bSkipAutoActivate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.GetPooledComponent
// (Iterator, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class UParticleSystem*         EmitterTemplate                (Parm)
// bool                           bAutoActivate                  (Parm)
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* AEmitterPool::STATIC_GetPooledComponent(class UParticleSystem* EmitterTemplate, bool bAutoActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.GetPooledComponent"));

	AEmitterPool_GetPooledComponent_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.bAutoActivate = bAutoActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.GetFreeMatInstConsts
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bCreateNewObject               (OptionalParm, Parm)
// class UMaterialInstanceConstant* ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInstanceConstant* AEmitterPool::STATIC_GetFreeMatInstConsts(bool bCreateNewObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.GetFreeMatInstConsts"));

	AEmitterPool_GetFreeMatInstConsts_Params params;
	params.bCreateNewObject = bCreateNewObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.FreeMaterialInstanceConstants
// (Final, Iterator, PreOperator, Singular, Native, Event, Static)
// Parameters:
// class UStaticMeshComponent*    SMC                            (Parm, EditInline)

void AEmitterPool::STATIC_FreeMaterialInstanceConstants(class UStaticMeshComponent* SMC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.FreeMaterialInstanceConstants"));

	AEmitterPool_FreeMaterialInstanceConstants_Params params;
	params.SMC = SMC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.GetFreeStaticMeshComponent
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bCreateNewObject               (OptionalParm, Parm)
// class UStaticMeshComponent*    ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UStaticMeshComponent* AEmitterPool::STATIC_GetFreeStaticMeshComponent(bool bCreateNewObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.GetFreeStaticMeshComponent"));

	AEmitterPool_GetFreeStaticMeshComponent_Params params;
	params.bCreateNewObject = bCreateNewObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EmitterPool.FreeStaticMeshComponents
// (Iterator, Latent, PreOperator, Singular, Native, Event, Static)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void AEmitterPool::STATIC_FreeStaticMeshComponents(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.FreeStaticMeshComponents"));

	AEmitterPool_FreeStaticMeshComponents_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.ReturnToPool
// (Defined, PreOperator, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void AEmitterPool::ReturnToPool(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.ReturnToPool"));

	AEmitterPool_ReturnToPool_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.ClearPoolComponents
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           bClearActive                   (OptionalParm, Parm)

void AEmitterPool::ClearPoolComponents(bool bClearActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.ClearPoolComponents"));

	AEmitterPool_ClearPoolComponents_Params params;
	params.bClearActive = bClearActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterPool.OnParticleSystemFinished
// (Final, Defined, Latent, PreOperator, Singular, Native)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void AEmitterPool::OnParticleSystemFinished(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterPool.OnParticleSystemFinished"));

	AEmitterPool_OnParticleSystemFinished_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.OnLostFocusPause
// (Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnable                        (Parm)

void AHUD::OnLostFocusPause(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.OnLostFocusPause"));

	AHUD_OnLostFocusPause_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.NotifyBindPostProcessEffects
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)

void AHUD::STATIC_NotifyBindPostProcessEffects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.NotifyBindPostProcessEffects"));

	AHUD_NotifyBindPostProcessEffects_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.PlayerOwnerDied
// (Iterator, NetReliable, HasOptionalParms)

void AHUD::PlayerOwnerDied()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.PlayerOwnerDied"));

	AHUD_PlayerOwnerDied_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.GetFontSizeIndex
// (Final, Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            FontSize                       (Parm)
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* AHUD::STATIC_GetFontSizeIndex(int FontSize)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.GetFontSizeIndex"));

	AHUD_GetFontSizeIndex_Params params;
	params.FontSize = FontSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.DrawText
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Static)
// Parameters:
// struct FString                 Text                           (Parm, NeedCtorLink)
// struct FVector2D               Position                       (Parm)
// class UFont*                   TextFont                       (Parm)
// struct FVector2D               FontScale                      (Parm)
// struct FColor                  TextColor                      (Parm)
// struct FFontRenderInfo         RenderInfo                     (Const, OptionalParm, Parm, OutParm)

void AHUD::STATIC_DrawText(const struct FString& Text, const struct FVector2D& Position, class UFont* TextFont, const struct FVector2D& FontScale, const struct FColor& TextColor, struct FFontRenderInfo* RenderInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawText"));

	AHUD_DrawText_Params params;
	params.Text = Text;
	params.Position = Position;
	params.TextFont = TextFont;
	params.FontScale = FontScale;
	params.TextColor = TextColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (RenderInfo != nullptr)
		*RenderInfo = params.RenderInfo;
}


// Function Engine.HUD.DisplayKismetMessages
// (Final, Defined, Latent, PreOperator, Simulated, Native, Static)

void AHUD::STATIC_DisplayKismetMessages()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DisplayKismetMessages"));

	AHUD_DisplayKismetMessages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DisplayLocalMessages
// (Final, Iterator, Latent, PreOperator, Simulated, Native, Static)

void AHUD::STATIC_DisplayLocalMessages()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DisplayLocalMessages"));

	AHUD_DisplayLocalMessages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawMessageText
// (Latent, Net, Exec, Native, Static)
// Parameters:
// struct FHudLocalizedMessage    LocalMessage                   (Parm, NeedCtorLink)
// float                          ScreenX                        (Parm)
// float                          ScreenY                        (Parm)

void AHUD::STATIC_DrawMessageText(const struct FHudLocalizedMessage& LocalMessage, float ScreenX, float ScreenY)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawMessageText"));

	AHUD_DrawMessageText_Params params;
	params.LocalMessage = LocalMessage;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawMessage
// (Final, Defined, Iterator, Net, Exec, Native, Static)
// Parameters:
// int                            I                              (Parm)
// float                          PosY                           (Parm)
// float                          DX                             (Parm, OutParm)
// float                          DY                             (Parm, OutParm)

void AHUD::STATIC_DrawMessage(int I, float PosY, float* DX, float* DY)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawMessage"));

	AHUD_DrawMessage_Params params;
	params.I = I;
	params.PosY = PosY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DX != nullptr)
		*DX = params.DX;
	if (DY != nullptr)
		*DY = params.DY;
}


// Function Engine.HUD.GetScreenCoords
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          PosY                           (Parm)
// float                          ScreenX                        (Parm, OutParm)
// float                          ScreenY                        (Parm, OutParm)
// struct FHudLocalizedMessage    InMessage                      (Parm, OutParm, NeedCtorLink)

void AHUD::STATIC_GetScreenCoords(float PosY, float* ScreenX, float* ScreenY, struct FHudLocalizedMessage* InMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.GetScreenCoords"));

	AHUD_GetScreenCoords_Params params;
	params.PosY = PosY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ScreenX != nullptr)
		*ScreenX = params.ScreenX;
	if (ScreenY != nullptr)
		*ScreenY = params.ScreenY;
	if (InMessage != nullptr)
		*InMessage = params.InMessage;
}


// Function Engine.HUD.AddLocalizedMessage
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// int                            Index                          (Parm)
// class UClass*                  InMessageClass                 (Parm)
// struct FString                 CriticalString                 (Parm, NeedCtorLink)
// int                            Switch                         (Parm)
// float                          Position                       (Parm)
// float                          Lifetime                       (Parm)
// int                            FontSize                       (Parm)
// struct FColor                  DrawColor                      (Parm)
// int                            MessageCount                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AHUD::AddLocalizedMessage(int Index, class UClass* InMessageClass, const struct FString& CriticalString, int Switch, float Position, float Lifetime, int FontSize, const struct FColor& DrawColor, int MessageCount, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.AddLocalizedMessage"));

	AHUD_AddLocalizedMessage_Params params;
	params.Index = Index;
	params.InMessageClass = InMessageClass;
	params.CriticalString = CriticalString;
	params.Switch = Switch;
	params.Position = Position;
	params.Lifetime = Lifetime;
	params.FontSize = FontSize;
	params.DrawColor = DrawColor;
	params.MessageCount = MessageCount;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.LocalizedMessage
// (Latent, PreOperator, Simulated, Native, Operator, Static)
// Parameters:
// class UClass*                  InMessageClass                 (Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (Parm)
// struct FString                 CriticalString                 (Parm, NeedCtorLink)
// int                            Switch                         (Parm)
// float                          Position                       (Parm)
// float                          Lifetime                       (Parm)
// int                            FontSize                       (Parm)
// struct FColor                  DrawColor                      (Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AHUD::STATIC_LocalizedMessage(class UClass* InMessageClass, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, const struct FString& CriticalString, int Switch, float Position, float Lifetime, int FontSize, const struct FColor& DrawColor, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.LocalizedMessage"));

	AHUD_LocalizedMessage_Params params;
	params.InMessageClass = InMessageClass;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.CriticalString = CriticalString;
	params.Switch = Switch;
	params.Position = Position;
	params.Lifetime = Lifetime;
	params.FontSize = FontSize;
	params.DrawColor = DrawColor;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.AddConsoleMessage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FString                 M                              (Parm, NeedCtorLink)
// class UClass*                  InMessageClass                 (Parm)
// class APlayerReplicationInfo*  PRI                            (Parm)
// float                          Lifetime                       (OptionalParm, Parm)

void AHUD::AddConsoleMessage(const struct FString& M, class UClass* InMessageClass, class APlayerReplicationInfo* PRI, float Lifetime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.AddConsoleMessage"));

	AHUD_AddConsoleMessage_Params params;
	params.M = M;
	params.InMessageClass = InMessageClass;
	params.PRI = PRI;
	params.Lifetime = Lifetime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShouldShowConsoleMessage
// (Defined, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// struct FConsoleMessage         InConsoleMessage               (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AHUD::ShouldShowConsoleMessage(const struct FConsoleMessage& InConsoleMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ShouldShowConsoleMessage"));

	AHUD_ShouldShowConsoleMessage_Params params;
	params.InConsoleMessage = InConsoleMessage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.DisplayConsoleMessages
// (Defined, Iterator, PreOperator, Simulated, Native, Static)

void AHUD::STATIC_DisplayConsoleMessages()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DisplayConsoleMessages"));

	AHUD_DisplayConsoleMessages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.Message
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   MsgType                        (Parm)
// float                          Lifetime                       (OptionalParm, Parm)

void AHUD::Message(class APlayerReplicationInfo* PRI, const struct FString& msg, const struct FName& MsgType, float Lifetime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.Message"));

	AHUD_Message_Params params;
	params.PRI = PRI;
	params.msg = msg;
	params.MsgType = MsgType;
	params.Lifetime = Lifetime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ClearMessage
// (Final, Defined, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FHudLocalizedMessage    M                              (Parm, OutParm, NeedCtorLink)

void AHUD::ClearMessage(struct FHudLocalizedMessage* M)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ClearMessage"));

	AHUD_ClearMessage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (M != nullptr)
		*M = params.M;
}


// Function Engine.HUD.DisplayBadConnectionAlert
// (Iterator, PreOperator, Simulated, Native, Static)

void AHUD::STATIC_DisplayBadConnectionAlert()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DisplayBadConnectionAlert"));

	AHUD_DisplayBadConnectionAlert_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawHUD
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Static)

void AHUD::STATIC_DrawHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawHUD"));

	AHUD_DrawHUD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.PostRender
// (Final, Defined, Iterator, Latent, Net, Exec, Native, HasOptionalParms)

void AHUD::PostRender()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.PostRender"));

	AHUD_PostRender_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.PreCalcValues
// (Final, Net, Simulated, HasOptionalParms)

void AHUD::PreCalcValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.PreCalcValues"));

	AHUD_PreCalcValues_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawRoute
// (Defined, Iterator, PreOperator, Net, Exec, Native, Static)
// Parameters:
// class APawn*                   Target                         (Parm)

void AHUD::STATIC_DrawRoute(class APawn* Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawRoute"));

	AHUD_DrawRoute_Params params;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowDebugInfo
// (Defined, Iterator, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AHUD::ShowDebugInfo(float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ShowDebugInfo"));

	AHUD_ShowDebugInfo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.HUD.ToggleDirectorInfoDebug
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void AHUD::ToggleDirectorInfoDebug()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ToggleDirectorInfoDebug"));

	AHUD_ToggleDirectorInfoDebug_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ToggleDirectorInfoHUD
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void AHUD::ToggleDirectorInfoHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ToggleDirectorInfoHUD"));

	AHUD_ToggleDirectorInfoHUD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShouldDisplayDebug
// (Simulated, Event, HasOptionalParms)
// Parameters:
// struct FName                   DebugType                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AHUD::ShouldDisplayDebug(const struct FName& DebugType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ShouldDisplayDebug"));

	AHUD_ShouldDisplayDebug_Params params;
	params.DebugType = DebugType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.SetShowScores
// (PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bNewValue                      (Parm)

void AHUD::SetShowScores(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.SetShowScores"));

	AHUD_SetShowScores_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowScores
// (Defined, Iterator, PreOperator, Singular, Simulated, Event, HasOptionalParms)

void AHUD::ShowScores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ShowScores"));

	AHUD_ShowScores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.IsHidden
// (Final, Defined, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AHUD::IsHidden()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.IsHidden"));

	AHUD_IsHidden_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.HideHUD
// (Final, Defined, Iterator, PreOperator, Operator, Static)

void AHUD::STATIC_HideHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.HideHUD"));

	AHUD_HideHUD_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowHUD
// (Final, Defined, Singular, Simulated, Event, HasOptionalParms)

void AHUD::ShowHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ShowHUD"));

	AHUD_ShowHUD_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ToggleHUD
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void AHUD::ToggleHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.ToggleHUD"));

	AHUD_ToggleHUD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.AddPostRenderedActor
// (Final, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class AActor*                  A                              (Parm)

void AHUD::AddPostRenderedActor(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.AddPostRenderedActor"));

	AHUD_AddPostRenderedActor_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.RemovePostRenderedActor
// (Defined, Iterator, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// class AActor*                  A                              (Parm)

void AHUD::RemovePostRenderedActor(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.RemovePostRenderedActor"));

	AHUD_RemovePostRenderedActor_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawActorOverlays
// (Defined, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 ViewPoint                      (Parm)
// struct FRotator                ViewRotation                   (Parm)

void AHUD::STATIC_DrawActorOverlays(const struct FVector& ViewPoint, const struct FRotator& ViewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.DrawActorOverlays"));

	AHUD_DrawActorOverlays_Params params;
	params.ViewPoint = ViewPoint;
	params.ViewRotation = ViewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AHUD::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.PostBeginPlay"));

	AHUD_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.Draw2DLine
// (Singular, Exec, Native, Static)
// Parameters:
// int                            X1                             (Parm)
// int                            Y1                             (Parm)
// int                            X2                             (Parm)
// int                            Y2                             (Parm)
// struct FColor                  LineColor                      (Parm)

void AHUD::STATIC_Draw2DLine(int X1, int Y1, int X2, int Y2, const struct FColor& LineColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.Draw2DLine"));

	AHUD_Draw2DLine_Params params;
	params.X1 = X1;
	params.Y1 = Y1;
	params.X2 = X2;
	params.Y2 = Y2;
	params.LineColor = LineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.Draw3DLine
// (Final, Singular, Exec, Native, Static)
// Parameters:
// struct FVector                 Start                          (Parm)
// struct FVector                 End                            (Parm)
// struct FColor                  LineColor                      (Parm)

void AHUD::STATIC_Draw3DLine(const struct FVector& Start, const struct FVector& End, const struct FColor& LineColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HUD.Draw3DLine"));

	AHUD_Draw3DLine_Params params;
	params.Start = Start;
	params.End = End;
	params.LineColor = LineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.CheckForSentinelRun
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAutoTestManager::CheckForSentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.CheckForSentinelRun"));

	AAutoTestManager_CheckForSentinelRun_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AutoTestManager.StartMatch
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)

void AAutoTestManager::StartMatch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.StartMatch"));

	AAutoTestManager_StartMatch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.GetNextAutomatedTestingMap
// (Defined, Iterator, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AAutoTestManager::STATIC_GetNextAutomatedTestingMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.GetNextAutomatedTestingMap"));

	AAutoTestManager_GetNextAutomatedTestingMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AutoTestManager.IncrementNumberOfMatchesPlayed
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)

void AAutoTestManager::STATIC_IncrementNumberOfMatchesPlayed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.IncrementNumberOfMatchesPlayed"));

	AAutoTestManager_IncrementNumberOfMatchesPlayed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.IncrementAutomatedTestingMapIndex
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)

void AAutoTestManager::STATIC_IncrementAutomatedTestingMapIndex()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.IncrementAutomatedTestingMapIndex"));

	AAutoTestManager_IncrementAutomatedTestingMapIndex_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.CloseAutomatedMapTestTimer
// (Latent, Net, Static)

void AAutoTestManager::STATIC_CloseAutomatedMapTestTimer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.CloseAutomatedMapTestTimer"));

	AAutoTestManager_CloseAutomatedMapTestTimer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.StartAutomatedMapTestTimerWorker
// (Iterator, Latent, PreOperator, Simulated, Exec, Event, HasOptionalParms)

void AAutoTestManager::StartAutomatedMapTestTimerWorker()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.StartAutomatedMapTestTimerWorker"));

	AAutoTestManager_StartAutomatedMapTestTimerWorker_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.StartAutomatedMapTestTimer
// (Final, Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AAutoTestManager::StartAutomatedMapTestTimer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.StartAutomatedMapTestTimer"));

	AAutoTestManager_StartAutomatedMapTestTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.DoMemoryTracking
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void AAutoTestManager::STATIC_DoMemoryTracking()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoMemoryTracking"));

	AAutoTestManager_DoMemoryTracking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.EndTimeBasedSentinelStatGatheringAndExit
// (Final, Defined, Iterator, Singular, Event, Static)

void AAutoTestManager::STATIC_EndTimeBasedSentinelStatGatheringAndExit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.EndTimeBasedSentinelStatGatheringAndExit"));

	AAutoTestManager_EndTimeBasedSentinelStatGatheringAndExit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.DoTimeBasedSentinelStatGathering
// (Defined, Iterator, Exec, Native, Static)

void AAutoTestManager::STATIC_DoTimeBasedSentinelStatGathering()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoTimeBasedSentinelStatGathering"));

	AAutoTestManager_DoTimeBasedSentinelStatGathering_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.DoSentinel_ViewDependentMemoryAtSpecificLocation
// (Iterator, Exec, Native, Static)
// Parameters:
// struct FVector                 InLocation                     (Const, Parm, OutParm)
// struct FRotator                InRotation                     (Const, Parm, OutParm)

void AAutoTestManager::STATIC_DoSentinel_ViewDependentMemoryAtSpecificLocation(struct FVector* InLocation, struct FRotator* InRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoSentinel_ViewDependentMemoryAtSpecificLocation"));

	AAutoTestManager_DoSentinel_ViewDependentMemoryAtSpecificLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InLocation != nullptr)
		*InLocation = params.InLocation;
	if (InRotation != nullptr)
		*InRotation = params.InRotation;
}


// Function Engine.AutoTestManager.DoSentinel_PerfAtSpecificLocation
// (Final, Defined, Exec, Native, Static)
// Parameters:
// struct FVector                 InLocation                     (Const, Parm, OutParm)
// struct FRotator                InRotation                     (Const, Parm, OutParm)

void AAutoTestManager::STATIC_DoSentinel_PerfAtSpecificLocation(struct FVector* InLocation, struct FRotator* InRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoSentinel_PerfAtSpecificLocation"));

	AAutoTestManager_DoSentinel_PerfAtSpecificLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InLocation != nullptr)
		*InLocation = params.InLocation;
	if (InRotation != nullptr)
		*InRotation = params.InRotation;
}


// Function Engine.AutoTestManager.DoSentinel_MemoryAtSpecificLocation
// (Defined, Exec, Native, Static)
// Parameters:
// struct FVector                 InLocation                     (Const, Parm)
// struct FRotator                InRotation                     (Const, Parm)

void AAutoTestManager::STATIC_DoSentinel_MemoryAtSpecificLocation(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoSentinel_MemoryAtSpecificLocation"));

	AAutoTestManager_DoSentinel_MemoryAtSpecificLocation_Params params;
	params.InLocation = InLocation;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.GetTravelLocations
// (Final, Defined, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   LevelName                      (Parm)
// class APlayerController*       PC                             (Parm)
// TArray<struct FVector>         TravelPoints                   (Parm, OutParm, NeedCtorLink)

void AAutoTestManager::STATIC_GetTravelLocations(const struct FName& LevelName, class APlayerController* PC, TArray<struct FVector>* TravelPoints)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.GetTravelLocations"));

	AAutoTestManager_GetTravelLocations_Params params;
	params.LevelName = LevelName;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (TravelPoints != nullptr)
		*TravelPoints = params.TravelPoints;
}


// Function Engine.AutoTestManager.HandlePerLoadedMapAudioStats
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)

void AAutoTestManager::STATIC_HandlePerLoadedMapAudioStats()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.HandlePerLoadedMapAudioStats"));

	AAutoTestManager_HandlePerLoadedMapAudioStats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.DoSentinelActionPerLoadedMap
// (Final, Iterator, Exec, Native, Static)

void AAutoTestManager::STATIC_DoSentinelActionPerLoadedMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoSentinelActionPerLoadedMap"));

	AAutoTestManager_DoSentinelActionPerLoadedMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.DoTravelTheWorld
// (Latent, Exec, Native, Static)

void AAutoTestManager::STATIC_DoTravelTheWorld()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.DoTravelTheWorld"));

	AAutoTestManager_DoTravelTheWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.EndSentinelRun
// (Defined, Singular, Event, Static)
// Parameters:
// TEnumAsByte<EAutomatedRunResult> RunResult                      (Parm)

void AAutoTestManager::STATIC_EndSentinelRun(TEnumAsByte<EAutomatedRunResult> RunResult)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.EndSentinelRun"));

	AAutoTestManager_EndSentinelRun_Params params;
	params.RunResult = RunResult;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.AddSentinelPerTimePeriodStats
// (Final, Iterator, Latent, PreOperator, Operator)
// Parameters:
// struct FVector                 InLocation                     (Const, Parm)
// struct FRotator                InRotation                     (Const, Parm)

void AAutoTestManager::AddSentinelPerTimePeriodStats(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.AddSentinelPerTimePeriodStats"));

	AAutoTestManager_AddSentinelPerTimePeriodStats_Params params;
	params.InLocation = InLocation;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.BeginSentinelRun
// (Iterator, PreOperator, Simulated, Native, Operator)
// Parameters:
// struct FString                 TaskDescription                (Const, Parm, NeedCtorLink)
// struct FString                 TaskParameter                  (Const, Parm, NeedCtorLink)
// struct FString                 TagDesc                        (Const, Parm, NeedCtorLink)

void AAutoTestManager::BeginSentinelRun(const struct FString& TaskDescription, const struct FString& TaskParameter, const struct FString& TagDesc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.BeginSentinelRun"));

	AAutoTestManager_BeginSentinelRun_Params params;
	params.TaskDescription = TaskDescription;
	params.TaskParameter = TaskParameter;
	params.TagDesc = TagDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.InitializeOptions
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Operator, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)

void AAutoTestManager::STATIC_InitializeOptions(const struct FString& Options)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.InitializeOptions"));

	AAutoTestManager_InitializeOptions_Params params;
	params.Options = Options;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.Timer
// (Defined, Latent, PreOperator, Singular, NetReliable, Native)

void AAutoTestManager::Timer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.Timer"));

	AAutoTestManager_Timer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AutoTestManager.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AAutoTestManager::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AutoTestManager.PostBeginPlay"));

	AAutoTestManager_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverGroup.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ACoverGroup::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverGroup.OnToggle"));

	ACoverGroup_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverGroup.ToggleGroup
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void ACoverGroup::ToggleGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverGroup.ToggleGroup"));

	ACoverGroup_ToggleGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverGroup.DisableGroup
// (Final, Defined, Iterator, Simulated, Native, Static)

void ACoverGroup::STATIC_DisableGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverGroup.DisableGroup"));

	ACoverGroup_DisableGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverGroup.EnableGroup
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void ACoverGroup::STATIC_EnableGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverGroup.EnableGroup"));

	ACoverGroup_EnableGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FileWriter.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AFileWriter::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileWriter.Destroyed"));

	AFileWriter_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FileWriter.Logf
// (Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// struct FString                 logString                      (Parm, CoerceParm, NeedCtorLink)

void AFileWriter::STATIC_Logf(const struct FString& logString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileWriter.Logf"));

	AFileWriter_Logf_Params params;
	params.logString = logString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FileWriter.CloseFile
// (Final, Defined, Latent, Net, Static)

void AFileWriter::STATIC_CloseFile()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileWriter.CloseFile"));

	AFileWriter_CloseFile_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FileWriter.OpenFile
// (Defined, PreOperator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 InFilename                     (Parm, CoerceParm, NeedCtorLink)
// TEnumAsByte<EFWFileType>       InFileType                     (OptionalParm, Parm)
// struct FString                 InExtension                    (OptionalParm, Parm, NeedCtorLink)
// bool                           bUnique                        (OptionalParm, Parm)
// bool                           bIncludeTimeStamp              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFileWriter::STATIC_OpenFile(const struct FString& InFilename, TEnumAsByte<EFWFileType> InFileType, const struct FString& InExtension, bool bUnique, bool bIncludeTimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileWriter.OpenFile"));

	AFileWriter_OpenFile_Params params;
	params.InFilename = InFilename;
	params.InFileType = InFileType;
	params.InExtension = InExtension;
	params.bUnique = bUnique;
	params.bIncludeTimeStamp = bIncludeTimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FileLog.CloseLog
// (Iterator, Latent, Net, Static)

void AFileLog::STATIC_CloseLog()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileLog.CloseLog"));

	AFileLog_CloseLog_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FileLog.OpenLog
// (Iterator, PreOperator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 LogFilename                    (Parm, CoerceParm, NeedCtorLink)
// struct FString                 extension                      (OptionalParm, Parm, NeedCtorLink)
// bool                           bUnique                        (OptionalParm, Parm)

void AFileLog::STATIC_OpenLog(const struct FString& LogFilename, const struct FString& extension, bool bUnique)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FileLog.OpenLog"));

	AFileLog_OpenLog_Params params;
	params.LogFilename = LogFilename;
	params.extension = extension;
	params.bUnique = bUnique;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetPhaseValueText
// (Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AGameInfo::GetPhaseValueText()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetPhaseValueText"));

	AGameInfo_GetPhaseValueText_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ClearOnlineDelegates
// (Final, Latent, Singular, Simulated, Native, HasOptionalParms)

void AGameInfo::ClearOnlineDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ClearOnlineDelegates"));

	AGameInfo_ClearOnlineDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.InitCrowdPopulationManager
// (Final, Defined, PreOperator, Net, Simulated, Operator, Static)

void AGameInfo::STATIC_InitCrowdPopulationManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.InitCrowdPopulationManager"));

	AGameInfo_InitCrowdPopulationManager_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnEngineHasLoaded
// (Final, PreOperator, Exec, Native, HasOptionalParms)

void AGameInfo::OnEngineHasLoaded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnEngineHasLoaded"));

	AGameInfo_OnEngineHasLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnDestroyOnlineGameComplete
// (Final, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void AGameInfo::OnDestroyOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnDestroyOnlineGameComplete"));

	AGameInfo_OnDestroyOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StandbyCheatDetected
// (Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EStandbyType>      StandbyType                    (Parm)

void AGameInfo::StandbyCheatDetected(TEnumAsByte<EStandbyType> StandbyType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StandbyCheatDetected"));

	AGameInfo_StandbyCheatDetected_Params params;
	params.StandbyType = StandbyType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.EnableStandbyCheatDetection
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// bool                           bIsEnabled                     (Parm)

void AGameInfo::STATIC_EnableStandbyCheatDetection(bool bIsEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.EnableStandbyCheatDetection"));

	AGameInfo_EnableStandbyCheatDetection_Params params;
	params.bIsEnabled = bIsEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.InvokeEndSentinelRun
// (Final, Latent, PreOperator, Singular, Net, Exec, Operator, Static)

void AGameInfo::STATIC_InvokeEndSentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.InvokeEndSentinelRun"));

	AGameInfo_InvokeEndSentinelRun_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.InvokeStartSentinelRun
// (Defined, Latent, PreOperator, Singular, Net, Exec, Operator, Static)

void AGameInfo::STATIC_InvokeStartSentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.InvokeStartSentinelRun"));

	AGameInfo_InvokeStartSentinelRun_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.BeginBVT
// (Defined, Iterator, Latent, Simulated, Native, Operator)
// Parameters:
// struct FString                 TagDesc                        (OptionalParm, Parm, CoerceParm, NeedCtorLink)

void AGameInfo::BeginBVT(const struct FString& TagDesc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BeginBVT"));

	AGameInfo_BeginBVT_Params params;
	params.TagDesc = TagDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.EndSentinelRun
// (Defined, Singular, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_EndSentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.EndSentinelRun"));

	AGameInfo_EndSentinelRun_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.StartSentinelRun
// (Defined, Latent, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::StartSentinelRun(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartSentinelRun"));

	AGameInfo_StartSentinelRun_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.CheckForSentinelRun
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CheckForSentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CheckForSentinelRun"));

	AGameInfo_CheckForSentinelRun_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ShouldAutoContinueToNextRound
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ShouldAutoContinueToNextRound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ShouldAutoContinueToNextRound"));

	AGameInfo_ShouldAutoContinueToNextRound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.IsDoingASentinelRun
// (Final, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_IsDoingASentinelRun()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.IsDoingASentinelRun"));

	AGameInfo_IsDoingASentinelRun_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.IsCheckingForMemLeaks
// (Defined, Iterator, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_IsCheckingForMemLeaks()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.IsCheckingForMemLeaks"));

	AGameInfo_IsCheckingForMemLeaks_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.IsCheckingForFragmentation
// (Final, Iterator, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_IsCheckingForFragmentation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.IsCheckingForFragmentation"));

	AGameInfo_IsCheckingForFragmentation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.IsAutomatedPerfTesting
// (Defined, Iterator, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_IsAutomatedPerfTesting()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.IsAutomatedPerfTesting"));

	AGameInfo_IsAutomatedPerfTesting_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.SetBandwidthLimit
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          AsyncIOBandwidthLimit          (Parm)

void AGameInfo::SetBandwidthLimit(float AsyncIOBandwidthLimit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetBandwidthLimit"));

	AGameInfo_SetBandwidthLimit_Params params;
	params.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.DoTravelTheWorld
// (Latent, Exec, Native, Static)

void AGameInfo::STATIC_DoTravelTheWorld()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DoTravelTheWorld"));

	AGameInfo_DoTravelTheWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.TellClientsToTravelToSession
// (Final, Iterator, Latent, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// class UClass*                  SearchClass                    (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm)

void AGameInfo::TellClientsToTravelToSession(const struct FName& SessionName, class UClass* SearchClass, unsigned char PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.TellClientsToTravelToSession"));

	AGameInfo_TellClientsToTravelToSession_Params params;
	params.SessionName = SessionName;
	params.SearchClass = SearchClass;
	params.PlatformSpecificInfo = PlatformSpecificInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.TellClientsPartyHostIsLeaving
// (Final, Defined, Latent, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PartyHostPlayerId              (Parm)

void AGameInfo::TellClientsPartyHostIsLeaving(const struct FUniqueNetId& PartyHostPlayerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.TellClientsPartyHostIsLeaving"));

	AGameInfo_TellClientsPartyHostIsLeaving_Params params;
	params.PartyHostPlayerId = PartyHostPlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.TellClientsToReturnToPartyHost
// (Iterator, Latent, Singular, Net, NetReliable, Native, Event, HasOptionalParms)

void AGameInfo::TellClientsToReturnToPartyHost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.TellClientsToReturnToPartyHost"));

	AGameInfo_TellClientsToReturnToPartyHost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnServerCreateComplete
// (Defined, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void AGameInfo::STATIC_OnServerCreateComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnServerCreateComplete"));

	AGameInfo_OnServerCreateComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RegisterServer
// (Latent, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void AGameInfo::RegisterServer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RegisterServer"));

	AGameInfo_RegisterServer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void AGameInfo::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnLoginChange"));

	AGameInfo_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnLoginFailed
// (PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EOnlineServerConnectionStatus> ErrorCode                      (Parm)

void AGameInfo::STATIC_OnLoginFailed(unsigned char LocalUserNum, TEnumAsByte<EOnlineServerConnectionStatus> ErrorCode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnLoginFailed"));

	AGameInfo_OnLoginFailed_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ErrorCode = ErrorCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ClearAutoLoginDelegates
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void AGameInfo::ClearAutoLoginDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ClearAutoLoginDelegates"));

	AGameInfo_ClearAutoLoginDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ProcessServerLogin
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ProcessServerLogin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ProcessServerLogin"));

	AGameInfo_ProcessServerLogin_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.MatineeCancelled
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AGameInfo::MatineeCancelled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.MatineeCancelled"));

	AGameInfo_MatineeCancelled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RecalculateSkillRating
// (Defined, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)

void AGameInfo::RecalculateSkillRating()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RecalculateSkillRating"));

	AGameInfo_RecalculateSkillRating_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.UpdateGameplayMuteList
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AGameInfo::UpdateGameplayMuteList(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UpdateGameplayMuteList"));

	AGameInfo_UpdateGameplayMuteList_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.NotifyArbitratedMatchEnd
// (Iterator, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)

void AGameInfo::STATIC_NotifyArbitratedMatchEnd()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.NotifyArbitratedMatchEnd"));

	AGameInfo_NotifyArbitratedMatchEnd_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.MatchIsInProgress
// (Defined, Latent, PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_MatchIsInProgress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.MatchIsInProgress"));

	AGameInfo_MatchIsInProgress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ArbitrationRegistrationComplete
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Operator)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void AGameInfo::ArbitrationRegistrationComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ArbitrationRegistrationComplete"));

	AGameInfo_ArbitrationRegistrationComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RegisterServerForArbitration
// (Final, Latent, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void AGameInfo::RegisterServerForArbitration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RegisterServerForArbitration"));

	AGameInfo_RegisterServerForArbitration_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartArbitratedMatch
// (Final, Latent, PreOperator, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartArbitratedMatch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartArbitratedMatch"));

	AGameInfo_StartArbitratedMatch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartArbitrationRegistration
// (Defined, Latent, PreOperator, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartArbitrationRegistration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartArbitrationRegistration"));

	AGameInfo_StartArbitrationRegistration_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ProcessClientRegistrationCompletion
// (Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)
// bool                           bWasSuccessful                 (Parm)

void AGameInfo::ProcessClientRegistrationCompletion(class APlayerController* PC, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ProcessClientRegistrationCompletion"));

	AGameInfo_ProcessClientRegistrationCompletion_Params params;
	params.PC = PC;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.UpdateGameSettingsCounts
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void AGameInfo::UpdateGameSettingsCounts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UpdateGameSettingsCounts"));

	AGameInfo_UpdateGameSettingsCounts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.SetSeamlessTravelViewTarget
// (Final, Defined, Iterator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AGameInfo::SetSeamlessTravelViewTarget(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetSeamlessTravelViewTarget"));

	AGameInfo_SetSeamlessTravelViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.HandleSeamlessTravelPlayer
// (Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AController*             C                              (Parm, OutParm)

void AGameInfo::HandleSeamlessTravelPlayer(class AController** C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.HandleSeamlessTravelPlayer"));

	AGameInfo_HandleSeamlessTravelPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (C != nullptr)
		*C = params.C;
}


// Function Engine.GameInfo.UpdateGameSettings
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void AGameInfo::UpdateGameSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UpdateGameSettings"));

	AGameInfo_UpdateGameSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PostSeamlessTravel
// (Final, PreOperator, Net, Exec, Native, HasOptionalParms)

void AGameInfo::PostSeamlessTravel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PostSeamlessTravel"));

	AGameInfo_PostSeamlessTravel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.SwapPlayerControllers
// (Final, Defined, PreOperator, Net, Native, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       OldPC                          (Parm)
// class APlayerController*       NewPC                          (Parm)

void AGameInfo::SwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SwapPlayerControllers"));

	AGameInfo_SwapPlayerControllers_Params params;
	params.OldPC = OldPC;
	params.NewPC = NewPC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetSeamlessTravelActorList
// (Defined, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bToEntry                       (Parm)
// TArray<class AActor*>          ActorList                      (Parm, OutParm, NeedCtorLink)

void AGameInfo::GetSeamlessTravelActorList(bool bToEntry, TArray<class AActor*>* ActorList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetSeamlessTravelActorList"));

	AGameInfo_GetSeamlessTravelActorList_Params params;
	params.bToEntry = bToEntry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActorList != nullptr)
		*ActorList = params.ActorList;
}


// Function Engine.GameInfo.OverridePRI
// (Latent, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// class APlayerController*       PC                             (Parm)
// class APlayerReplicationInfo*  OldPRI                         (Parm)

void AGameInfo::STATIC_OverridePRI(class APlayerController* PC, class APlayerReplicationInfo* OldPRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OverridePRI"));

	AGameInfo_OverridePRI_Params params;
	params.PC = PC;
	params.OldPRI = OldPRI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.FindInactivePRI
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class APlayerController*       PC                             (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_FindInactivePRI(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.FindInactivePRI"));

	AGameInfo_FindInactivePRI_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.AddInactivePRI
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)
// class APlayerController*       PC                             (Parm)

void AGameInfo::AddInactivePRI(class APlayerReplicationInfo* PRI, class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AddInactivePRI"));

	AGameInfo_AddInactivePRI_Params params;
	params.PRI = PRI;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PostCommitMapChange
// (Latent, Net, Exec, Native, HasOptionalParms)

void AGameInfo::PostCommitMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PostCommitMapChange"));

	AGameInfo_PostCommitMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PreCommitMapChange
// (Final, Iterator, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 PreviousMapName                (Parm, NeedCtorLink)
// struct FString                 NextMapName                    (Parm, NeedCtorLink)

void AGameInfo::PreCommitMapChange(const struct FString& PreviousMapName, const struct FString& NextMapName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PreCommitMapChange"));

	AGameInfo_PreCommitMapChange_Params params;
	params.PreviousMapName = PreviousMapName;
	params.NextMapName = NextMapName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.AllowPausing
// (Iterator, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// class APlayerController*       PC                             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::AllowPausing(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AllowPausing"));

	AGameInfo_AllowPausing_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.AllowCheats
// (Defined, Latent, Singular, NetReliable, Operator)
// Parameters:
// class APlayerController*       P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::AllowCheats(class APlayerController* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AllowCheats"));

	AGameInfo_AllowCheats_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.AllowMutator
// (Defined, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// struct FString                 MutatorClassName               (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::AllowMutator(const struct FString& MutatorClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AllowMutator"));

	AGameInfo_AllowMutator_Params params;
	params.MutatorClassName = MutatorClassName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.PlayerCanRestart
// (Defined, Iterator, Latent, PreOperator, Net, HasOptionalParms)
// Parameters:
// class APlayerController*       aPlayer                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::PlayerCanRestart(class APlayerController* aPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PlayerCanRestart"));

	AGameInfo_PlayerCanRestart_Params params;
	params.aPlayer = aPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.PlayerCanRestartGame
// (Final, Defined, Iterator, Latent, PreOperator, Net, HasOptionalParms)
// Parameters:
// class APlayerController*       aPlayer                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::PlayerCanRestartGame(class APlayerController* aPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PlayerCanRestartGame"));

	AGameInfo_PlayerCanRestartGame_Params params;
	params.aPlayer = aPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.DriverLeftVehicle
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)

void AGameInfo::STATIC_DriverLeftVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DriverLeftVehicle"));

	AGameInfo_DriverLeftVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.CanLeaveVehicle
// (Defined, Iterator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CanLeaveVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CanLeaveVehicle"));

	AGameInfo_CanLeaveVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.DriverEnteredVehicle
// (Final, Defined, Iterator, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)

void AGameInfo::STATIC_DriverEnteredVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DriverEnteredVehicle"));

	AGameInfo_DriverEnteredVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ModifyScoreKill
// (Defined, Latent, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Other                          (Parm)

void AGameInfo::STATIC_ModifyScoreKill(class AController* Killer, class AController* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ModifyScoreKill"));

	AGameInfo_ModifyScoreKill_Params params;
	params.Killer = Killer;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ScoreKill
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Other                          (Parm)
// bool                           bFakeDeath                     (OptionalParm, Parm)

void AGameInfo::ScoreKill(class AController* Killer, class AController* Other, bool bFakeDeath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ScoreKill"));

	AGameInfo_ScoreKill_Params params;
	params.Killer = Killer;
	params.Other = Other;
	params.bFakeDeath = bFakeDeath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.CheckScore
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class APlayerReplicationInfo*  Scorer                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CheckScore(class APlayerReplicationInfo* Scorer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CheckScore"));

	AGameInfo_CheckScore_Params params;
	params.Scorer = Scorer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ScoreObjective
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  Scorer                         (Parm)
// int                            Score                          (Parm)

void AGameInfo::ScoreObjective(class APlayerReplicationInfo* Scorer, int Score)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ScoreObjective"));

	AGameInfo_ScoreObjective_Params params;
	params.Scorer = Scorer;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.AddObjectiveScore
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class APlayerReplicationInfo*  Scorer                         (Parm)
// int                            Score                          (Parm)

void AGameInfo::AddObjectiveScore(class APlayerReplicationInfo* Scorer, int Score)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AddObjectiveScore"));

	AGameInfo_AddObjectiveScore_Params params;
	params.Scorer = Scorer;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RatePlayerStart
// (PreOperator, Net, NetReliable, Exec, HasOptionalParms)
// Parameters:
// class APlayerStart*            P                              (Parm)
// unsigned char                  Team                           (Parm)
// class AController*             Player                         (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AGameInfo::RatePlayerStart(class APlayerStart* P, unsigned char Team, class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RatePlayerStart"));

	AGameInfo_RatePlayerStart_Params params;
	params.P = P;
	params.Team = Team;
	params.Player = Player;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ChoosePlayerStart
// (Final, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class AController*             Player                         (Parm)
// unsigned char                  InTeam                         (OptionalParm, Parm)
// class APlayerStart*            ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerStart* AGameInfo::ChoosePlayerStart(class AController* Player, unsigned char InTeam)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ChoosePlayerStart"));

	AGameInfo_ChoosePlayerStart_Params params;
	params.Player = Player;
	params.InTeam = InTeam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.FindPlayerStart
// (Final, Defined, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class AController*             Player                         (Parm)
// unsigned char                  InTeam                         (OptionalParm, Parm)
// struct FString                 IncomingName                   (OptionalParm, Parm, NeedCtorLink)
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* AGameInfo::STATIC_FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.FindPlayerStart"));

	AGameInfo_FindPlayerStart_Params params;
	params.Player = Player;
	params.InTeam = InTeam;
	params.IncomingName = IncomingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ShouldSpawnAtStartSpot
// (Final, Defined, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// class AController*             Player                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ShouldSpawnAtStartSpot(class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ShouldSpawnAtStartSpot"));

	AGameInfo_ShouldSpawnAtStartSpot_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.EndLogging
// (Defined, Iterator, Latent, Event, Static)
// Parameters:
// struct FString                 Reason                         (Parm, NeedCtorLink)

void AGameInfo::STATIC_EndLogging(const struct FString& Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.EndLogging"));

	AGameInfo_EndLogging_Params params;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GameEventsPoll
// (Defined, Latent, Singular, Net, NetReliable, Native, Event, Static)

void AGameInfo::STATIC_GameEventsPoll()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GameEventsPoll"));

	AGameInfo_GameEventsPoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.EndOnlineGame
// (Final, PreOperator, Event, Static)

void AGameInfo::STATIC_EndOnlineGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.EndOnlineGame"));

	AGameInfo_EndOnlineGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PerformEndGameHandling
// (PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator, Static)

void AGameInfo::STATIC_PerformEndGameHandling()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PerformEndGameHandling"));

	AGameInfo_PerformEndGameHandling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.EndGame
// (Final, Latent, Event, Static)
// Parameters:
// class APlayerReplicationInfo*  Winner                         (Parm)
// struct FString                 Reason                         (Parm, NeedCtorLink)

void AGameInfo::STATIC_EndGame(class APlayerReplicationInfo* Winner, const struct FString& Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.EndGame"));

	AGameInfo_EndGame_Params params;
	params.Winner = Winner;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.WriteOnlinePlayerScores
// (Final, Iterator, NetReliable, Simulated, Operator, HasOptionalParms)

void AGameInfo::WriteOnlinePlayerScores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.WriteOnlinePlayerScores"));

	AGameInfo_WriteOnlinePlayerScores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.WriteOnlineStats
// (Defined, Iterator, NetReliable, Simulated, Operator, HasOptionalParms)

void AGameInfo::WriteOnlineStats()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.WriteOnlineStats"));

	AGameInfo_WriteOnlineStats_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.CheckEndGame
// (Final, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class APlayerReplicationInfo*  Winner                         (Parm)
// struct FString                 Reason                         (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CheckEndGame(class APlayerReplicationInfo* Winner, const struct FString& Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CheckEndGame"));

	AGameInfo_CheckEndGame_Params params;
	params.Winner = Winner;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.CheckModifiedEndGame
// (Defined, Iterator, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class APlayerReplicationInfo*  Winner                         (Parm)
// struct FString                 Reason                         (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CheckModifiedEndGame(class APlayerReplicationInfo* Winner, const struct FString& Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CheckModifiedEndGame"));

	AGameInfo_CheckModifiedEndGame_Params params;
	params.Winner = Winner;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.BroadcastLocalizedTeam
// (Final, Defined, Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            TeamIndex                      (Parm)
// class AActor*                  Sender                         (Parm)
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AGameInfo::BroadcastLocalizedTeam(int TeamIndex, class AActor* Sender, class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BroadcastLocalizedTeam"));

	AGameInfo_BroadcastLocalizedTeam_Params params;
	params.TeamIndex = TeamIndex;
	params.Sender = Sender;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.BroadcastLocalized
// (Final, Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Sender                         (Parm)
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void AGameInfo::BroadcastLocalized(class AActor* Sender, class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BroadcastLocalized"));

	AGameInfo_BroadcastLocalized_Params params;
	params.Sender = Sender;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.BroadcastTeam
// (Latent, Singular, Net, NetReliable, Exec, Event, Operator)
// Parameters:
// class AController*             Sender                         (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void AGameInfo::BroadcastTeam(class AController* Sender, const struct FString& msg, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BroadcastTeam"));

	AGameInfo_BroadcastTeam_Params params;
	params.Sender = Sender;
	params.msg = msg;
	params.Type = Type;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.Broadcast
// (Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Sender                         (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void AGameInfo::Broadcast(class AActor* Sender, const struct FString& msg, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Broadcast"));

	AGameInfo_Broadcast_Params params;
	params.Sender = Sender;
	params.msg = msg;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RestartGame
// (Singular, NetReliable, Native, HasOptionalParms)

void AGameInfo::RestartGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RestartGame"));

	AGameInfo_RestartGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetTravelType
// (Iterator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_GetTravelType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetTravelType"));

	AGameInfo_GetTravelType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetNextMap
// (Latent, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AGameInfo::STATIC_GetNextMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetNextMap"));

	AGameInfo_GetNextMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.SendPlayer
// (PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       aPlayer                        (Parm)
// struct FString                 URL                            (Parm, NeedCtorLink)

void AGameInfo::SendPlayer(class APlayerController* aPlayer, const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SendPlayer"));

	AGameInfo_SendPlayer_Params params;
	params.aPlayer = aPlayer;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PickTeam
// (Defined, Iterator, HasOptionalParms)
// Parameters:
// unsigned char                  Current                        (Parm)
// class AController*             C                              (Parm)
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char AGameInfo::PickTeam(unsigned char Current, class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PickTeam"));

	AGameInfo_PickTeam_Params params;
	params.Current = Current;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ChangeTeam
// (Final, Iterator, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AController*             Other                          (Parm)
// int                            N                              (Parm)
// bool                           bNewTeam                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ChangeTeam(class AController* Other, int N, bool bNewTeam)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ChangeTeam"));

	AGameInfo_ChangeTeam_Params params;
	params.Other = Other;
	params.N = N;
	params.bNewTeam = bNewTeam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ChangeName
// (Final, Defined, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AController*             Other                          (Parm)
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)
// bool                           bNameChange                    (Parm)

void AGameInfo::ChangeName(class AController* Other, const struct FString& S, bool bNameChange)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ChangeName"));

	AGameInfo_ChangeName_Params params;
	params.Other = Other;
	params.S = S;
	params.bNameChange = bNameChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.DiscardInventory
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AController*             Killer                         (OptionalParm, Parm)

void AGameInfo::DiscardInventory(class APawn* Other, class AController* Killer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DiscardInventory"));

	AGameInfo_DiscardInventory_Params params;
	params.Other = Other;
	params.Killer = Killer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PickupQuery
// (Final, Defined, Iterator, Latent, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// class UClass*                  ItemClass                      (Parm)
// class AActor*                  Pickup                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::PickupQuery(class APawn* Other, class UClass* ItemClass, class AActor* Pickup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PickupQuery"));

	AGameInfo_PickupQuery_Params params;
	params.Other = Other;
	params.ItemClass = ItemClass;
	params.Pickup = Pickup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ShouldRespawn
// (Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// class APickupFactory*          Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ShouldRespawn(class APickupFactory* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ShouldRespawn"));

	AGameInfo_ShouldRespawn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.CheckRelevance
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CheckRelevance(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CheckRelevance"));

	AGameInfo_CheckRelevance_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ReduceDamage
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm, OutParm)
// class APawn*                   injured                        (Parm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm, OutParm)
// class UClass*                  DamageType                     (Parm)
// class AActor*                  DamageCauser                   (Parm)

void AGameInfo::ReduceDamage(class APawn* injured, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, class AActor* DamageCauser, int* Damage, struct FVector* Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ReduceDamage"));

	AGameInfo_ReduceDamage_Params params;
	params.injured = injured;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Damage != nullptr)
		*Damage = params.Damage;
	if (Momentum != nullptr)
		*Momentum = params.Momentum;
}


// Function Engine.GameInfo.CanSpectate
// (Iterator, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// class APlayerController*       Viewer                         (Parm)
// class APlayerReplicationInfo*  ViewTarget                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CanSpectate"));

	AGameInfo_CanSpectate_Params params;
	params.Viewer = Viewer;
	params.ViewTarget = ViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.KickBan
// (Iterator, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AGameInfo::STATIC_KickBan(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.KickBan"));

	AGameInfo_KickBan_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.Kick
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AGameInfo::STATIC_Kick(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Kick"));

	AGameInfo_Kick_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.BroadcastDeathMessage
// (Iterator, Singular, Net, NetReliable, Exec, Event, Operator)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Other                          (Parm)
// class UClass*                  DamageType                     (Parm)

void AGameInfo::BroadcastDeathMessage(class AController* Killer, class AController* Other, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BroadcastDeathMessage"));

	AGameInfo_BroadcastDeathMessage_Params params;
	params.Killer = Killer;
	params.Other = Other;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PreventDeath
// (Final, Iterator, Latent, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// class APawn*                   KilledPawn                     (Parm)
// class AController*             Killer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::PreventDeath(class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PreventDeath"));

	AGameInfo_PreventDeath_Params params;
	params.KilledPawn = KilledPawn;
	params.Killer = Killer;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.Killed
// (Iterator, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             KilledPlayer                   (Parm)
// class APawn*                   KilledPawn                     (Parm)
// class UClass*                  DamageType                     (Parm)

void AGameInfo::STATIC_Killed(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Killed"));

	AGameInfo_Killed_Params params;
	params.Killer = Killer;
	params.KilledPlayer = KilledPlayer;
	params.KilledPawn = KilledPawn;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.NotifyKilled
// (Iterator, Latent, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Killed                         (Parm)
// class APawn*                   KilledPawn                     (Parm)
// class UClass*                  DamageType                     (Parm)

void AGameInfo::STATIC_NotifyKilled(class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.NotifyKilled"));

	AGameInfo_NotifyKilled_Params params;
	params.Killer = Killer;
	params.Killed = Killed;
	params.KilledPawn = KilledPawn;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.SetPlayerDefaults
// (Final, Defined, Iterator, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class APawn*                   PlayerPawn                     (Parm)

void AGameInfo::SetPlayerDefaults(class APawn* PlayerPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetPlayerDefaults"));

	AGameInfo_SetPlayerDefaults_Params params;
	params.PlayerPawn = PlayerPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.Mutate
// (Final, Iterator, Latent, Singular, Simulated, Event, Operator, Static)
// Parameters:
// struct FString                 MutateString                   (Parm, NeedCtorLink)
// class APlayerController*       Sender                         (Parm)

void AGameInfo::STATIC_Mutate(const struct FString& MutateString, class APlayerController* Sender)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Mutate"));

	AGameInfo_Mutate_Params params;
	params.MutateString = MutateString;
	params.Sender = Sender;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.AddDefaultInventory
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void AGameInfo::AddDefaultInventory(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AddDefaultInventory"));

	AGameInfo_AddDefaultInventory_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.AcceptInventory
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class APawn*                   PlayerPawn                     (Parm)

void AGameInfo::AcceptInventory(class APawn* PlayerPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AcceptInventory"));

	AGameInfo_AcceptInventory_Params params;
	params.PlayerPawn = PlayerPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.UnregisterPlayer
// (Iterator, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AGameInfo::UnregisterPlayer(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UnregisterPlayer"));

	AGameInfo_UnregisterPlayer_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.Logout
// (Defined, Latent, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// class AController*             Exiting                        (Parm)

void AGameInfo::STATIC_Logout(class AController* Exiting)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Logout"));

	AGameInfo_Logout_Params params;
	params.Exiting = Exiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PreExit
// (Final, Defined, Iterator, PreOperator, Net, Exec, Native, HasOptionalParms)

void AGameInfo::PreExit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PreExit"));

	AGameInfo_PreExit_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.CalculatedNetSpeed
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AGameInfo::CalculatedNetSpeed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CalculatedNetSpeed"));

	AGameInfo_CalculatedNetSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.UpdateNetSpeeds
// (Defined, Iterator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void AGameInfo::UpdateNetSpeeds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UpdateNetSpeeds"));

	AGameInfo_UpdateNetSpeeds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PostLogin
// (Final, Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       NewPlayer                      (Parm)

void AGameInfo::PostLogin(class APlayerController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PostLogin"));

	AGameInfo_PostLogin_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.UpdateBestNextHosts
// (Iterator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void AGameInfo::UpdateBestNextHosts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.UpdateBestNextHosts"));

	AGameInfo_UpdateBestNextHosts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.BestNextHostSort
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Operator)
// Parameters:
// class APlayerController*       A                              (Parm)
// class APlayerController*       B                              (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AGameInfo::BestNextHostSort(class APlayerController* A, class APlayerController* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.BestNextHostSort"));

	AGameInfo_BestNextHostSort_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GenericPlayerInitialization
// (Final, Iterator, Latent, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AController*             C                              (Parm)

void AGameInfo::STATIC_GenericPlayerInitialization(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GenericPlayerInitialization"));

	AGameInfo_GenericPlayerInitialization_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ReplicateStreamingStatus
// (Final, PreOperator, Net, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AGameInfo::ReplicateStreamingStatus(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ReplicateStreamingStatus"));

	AGameInfo_ReplicateStreamingStatus_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetDefaultPlayerClass
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AController*             C                              (Parm)
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* AGameInfo::STATIC_GetDefaultPlayerClass(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetDefaultPlayerClass"));

	AGameInfo_GetDefaultPlayerClass_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.SpawnDefaultPawnFor
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, HasOptionalParms)
// Parameters:
// class AController*             NewPlayer                      (Parm)
// class ANavigationPoint*        StartSpot                      (Parm)
// class APawn*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class APawn* AGameInfo::SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SpawnDefaultPawnFor"));

	AGameInfo_SpawnDefaultPawnFor_Params params;
	params.NewPlayer = NewPlayer;
	params.StartSpot = StartSpot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.RestartPlayer
// (Final, Defined, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AController*             NewPlayer                      (Parm)

void AGameInfo::RestartPlayer(class AController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RestartPlayer"));

	AGameInfo_RestartPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartBots
// (Singular, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartBots()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartBots"));

	AGameInfo_StartBots_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartHumans
// (Iterator, Latent, Singular, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartHumans()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartHumans"));

	AGameInfo_StartHumans_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.OnStartOnlineGameComplete
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void AGameInfo::OnStartOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.OnStartOnlineGameComplete"));

	AGameInfo_OnStartOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartOnlineGame
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartOnlineGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartOnlineGame"));

	AGameInfo_StartOnlineGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.StartMatch
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)

void AGameInfo::StartMatch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.StartMatch"));

	AGameInfo_StartMatch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.Login
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Portal                         (Parm, NeedCtorLink)
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FUniqueNetId            UniqueId                       (Const, Parm)
// struct FString                 ErrorMessage                   (Parm, OutParm, NeedCtorLink)
// struct FUniqueNetId            ConsoleUniqueId                (Const, OptionalParm, Parm)
// class APlayerController*       ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerController* AGameInfo::Login(const struct FString& Portal, const struct FString& Options, const struct FUniqueNetId& UniqueId, const struct FUniqueNetId& ConsoleUniqueId, struct FString* ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Login"));

	AGameInfo_Login_Params params;
	params.Portal = Portal;
	params.Options = Options;
	params.UniqueId = UniqueId;
	params.ConsoleUniqueId = ConsoleUniqueId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ErrorMessage != nullptr)
		*ErrorMessage = params.ErrorMessage;

	return params.ReturnValue;
}


// Function Engine.GameInfo.SpawnPlayerController
// (Latent, PreOperator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// struct FVector                 SpawnLocation                  (Parm)
// struct FRotator                SpawnRotation                  (Parm)
// class APlayerController*       ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerController* AGameInfo::SpawnPlayerController(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SpawnPlayerController"));

	AGameInfo_SpawnPlayerController_Params params;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetNextPlayerID
// (Defined, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AGameInfo::STATIC_GetNextPlayerID()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetNextPlayerID"));

	AGameInfo_GetNextPlayerID_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.AtCapacity
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// bool                           bSpectator                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::AtCapacity(bool bSpectator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AtCapacity"));

	AGameInfo_AtCapacity_Params params;
	params.bSpectator = bSpectator;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.RejectLogin
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class UPlayer*                 InPlayer                       (Parm)
// struct FString                 Error                          (Parm, NeedCtorLink)

void AGameInfo::RejectLogin(class UPlayer* InPlayer, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RejectLogin"));

	AGameInfo_RejectLogin_Params params;
	params.InPlayer = InPlayer;
	params.Error = Error;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ResumeLogin
// (Final, Defined, Latent, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 InPlayer                       (Parm)

void AGameInfo::ResumeLogin(class UPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ResumeLogin"));

	AGameInfo_ResumeLogin_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.PauseLogin
// (Final, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// class UPlayer*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UPlayer* AGameInfo::STATIC_PauseLogin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PauseLogin"));

	AGameInfo_PauseLogin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.PreLogin
// (Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 Address                        (Parm, NeedCtorLink)
// struct FUniqueNetId            UniqueId                       (Const, Parm)
// bool                           bSupportsAuth                  (Parm)
// struct FString                 ErrorMessage                   (Parm, OutParm, NeedCtorLink)

void AGameInfo::PreLogin(const struct FString& Options, const struct FString& Address, const struct FUniqueNetId& UniqueId, bool bSupportsAuth, struct FString* ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PreLogin"));

	AGameInfo_PreLogin_Params params;
	params.Options = Options;
	params.Address = Address;
	params.UniqueId = UniqueId;
	params.bSupportsAuth = bSupportsAuth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ErrorMessage != nullptr)
		*ErrorMessage = params.ErrorMessage;
}


// Function Engine.GameInfo.RequiresPassword
// (Defined, Iterator, Latent, Singular, Net, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::RequiresPassword()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RequiresPassword"));

	AGameInfo_RequiresPassword_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ProcessClientTravel
// (Final, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, OutParm, NeedCtorLink)
// struct FGuid                   NextMapGuid                    (Parm)
// bool                           bSeamless                      (Parm)
// bool                           bAbsolute                      (Parm)
// class APlayerController*       ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerController* AGameInfo::ProcessClientTravel(const struct FGuid& NextMapGuid, bool bSeamless, bool bAbsolute, struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ProcessClientTravel"));

	AGameInfo_ProcessClientTravel_Params params;
	params.NextMapGuid = NextMapGuid;
	params.bSeamless = bSeamless;
	params.bAbsolute = bAbsolute;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ProcessServerTravel
// (Iterator, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           bAbsolute                      (OptionalParm, Parm)

void AGameInfo::ProcessServerTravel(const struct FString& URL, bool bAbsolute)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ProcessServerTravel"));

	AGameInfo_ProcessServerTravel_Params params;
	params.URL = URL;
	params.bAbsolute = bAbsolute;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.RemoveMutator
// (Final, Defined, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// class AMutator*                MutatorToRemove                (Parm)

void AGameInfo::RemoveMutator(class AMutator* MutatorToRemove)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.RemoveMutator"));

	AGameInfo_RemoveMutator_Params params;
	params.MutatorToRemove = MutatorToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.AddMutator
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FString                 mutname                        (Parm, NeedCtorLink)
// bool                           bUserAdded                     (OptionalParm, Parm)

void AGameInfo::AddMutator(const struct FString& mutname, bool bUserAdded)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.AddMutator"));

	AGameInfo_AddMutator_Params params;
	params.mutname = mutname;
	params.bUserAdded = bUserAdded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.NotifyPendingConnectionLost
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AGameInfo::NotifyPendingConnectionLost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.NotifyPendingConnectionLost"));

	AGameInfo_NotifyPendingConnectionLost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.InitGame
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 ErrorMessage                   (Parm, OutParm, NeedCtorLink)

void AGameInfo::InitGame(const struct FString& Options, struct FString* ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.InitGame"));

	AGameInfo_InitGame_Params params;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ErrorMessage != nullptr)
		*ErrorMessage = params.ErrorMessage;
}


// Function Engine.GameInfo.SetGameType
// (Final, Iterator, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 MapName                        (Parm, NeedCtorLink)
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 Portal                         (Parm, NeedCtorLink)
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* AGameInfo::SetGameType(const struct FString& MapName, const struct FString& Options, const struct FString& Portal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetGameType"));

	AGameInfo_SetGameType_Params params;
	params.MapName = MapName;
	params.Options = Options;
	params.Portal = Portal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetDefaultGameClassPath
// (Final, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 MapName                        (Parm, NeedCtorLink)
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 Portal                         (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AGameInfo::GetDefaultGameClassPath(const struct FString& MapName, const struct FString& Options, const struct FString& Portal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetDefaultGameClassPath"));

	AGameInfo_GetDefaultGameClassPath_Params params;
	params.MapName = MapName;
	params.Options = Options;
	params.Portal = Portal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetIntOption
// (Final, Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 ParseString                    (Parm, NeedCtorLink)
// int                            CurrentValue                   (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AGameInfo::STATIC_GetIntOption(const struct FString& Options, const struct FString& ParseString, int CurrentValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetIntOption"));

	AGameInfo_GetIntOption_Params params;
	params.Options = Options;
	params.ParseString = ParseString;
	params.CurrentValue = CurrentValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.HasOption
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 InKey                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_HasOption(const struct FString& Options, const struct FString& InKey)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.HasOption"));

	AGameInfo_HasOption_Params params;
	params.Options = Options;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.ParseOption
// (Defined, Iterator, Latent, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 InKey                          (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AGameInfo::STATIC_ParseOption(const struct FString& Options, const struct FString& InKey)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ParseOption"));

	AGameInfo_ParseOption_Params params;
	params.Options = Options;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetKeyValue
// (Final, Defined, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Pair                           (Parm, NeedCtorLink)
// struct FString                 Key                            (Parm, OutParm, NeedCtorLink)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)

void AGameInfo::STATIC_GetKeyValue(const struct FString& Pair, struct FString* Key, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetKeyValue"));

	AGameInfo_GetKeyValue_Params params;
	params.Pair = Pair;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Key != nullptr)
		*Key = params.Key;
	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.GameInfo.GrabOption
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Options                        (Parm, OutParm, NeedCtorLink)
// struct FString                 Result                         (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_GrabOption(struct FString* Options, struct FString* Result)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GrabOption"));

	AGameInfo_GrabOption_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Options != nullptr)
		*Options = params.Options;
	if (Result != nullptr)
		*Result = params.Result;

	return params.ReturnValue;
}


// Function Engine.GameInfo.SetGameSpeed
// (Iterator, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          T                              (Parm)

void AGameInfo::SetGameSpeed(float T)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetGameSpeed"));

	AGameInfo_SetGameSpeed_Params params;
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.DebugPause
// (Final, Iterator, Singular, Net, Simulated, Exec, Static)

void AGameInfo::STATIC_DebugPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DebugPause"));

	AGameInfo_DebugPause_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ForceClearUnpauseDelegates
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// class AActor*                  PauseActor                     (Parm)

void AGameInfo::STATIC_ForceClearUnpauseDelegates(class AActor* PauseActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ForceClearUnpauseDelegates"));

	AGameInfo_ForceClearUnpauseDelegates_Params params;
	params.PauseActor = PauseActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ClearPause
// (Defined, Latent, Singular, Simulated, Native, HasOptionalParms)

void AGameInfo::ClearPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ClearPause"));

	AGameInfo_ClearPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.SetPause
// (Final, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)
// struct FScriptDelegate         CanUnpauseDelegate             (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.SetPause"));

	AGameInfo_SetPause_Params params;
	params.PC = PC;
	params.CanUnpauseDelegate = CanUnpauseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.CanUnpause
// (Final, Iterator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::CanUnpause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.CanUnpause"));

	AGameInfo_CanUnpause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetNumPlayers
// (Final, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AGameInfo::STATIC_GetNumPlayers()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetNumPlayers"));

	AGameInfo_GetNumPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetNetworkNumber
// (Final, Defined, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AGameInfo::STATIC_GetNetworkNumber()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetNetworkNumber"));

	AGameInfo_GetNetworkNumber_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.InitGameReplicationInfo
// (Iterator, PreOperator, Net, Simulated, Operator, Static)

void AGameInfo::STATIC_InitGameReplicationInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.InitGameReplicationInfo"));

	AGameInfo_InitGameReplicationInfo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ForceKickPlayer
// (Final, Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)
// struct FString                 KickReason                     (Parm, NeedCtorLink)

void AGameInfo::ForceKickPlayer(class APlayerController* PC, const struct FString& KickReason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ForceKickPlayer"));

	AGameInfo_ForceKickPlayer_Params params;
	params.PC = PC;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.KickIdler
// (Final, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void AGameInfo::KickIdler(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.KickIdler"));

	AGameInfo_KickIdler_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GameEnding
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)

void AGameInfo::GameEnding()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GameEnding"));

	AGameInfo_GameEnding_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.NotifyNavigationChanged
// (Iterator, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ANavigationPoint*        N                              (Parm)

void AGameInfo::STATIC_NotifyNavigationChanged(class ANavigationPoint* N)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.NotifyNavigationChanged"));

	AGameInfo_NotifyNavigationChanged_Params params;
	params.N = N;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.DoNavFearCostFallOff
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Static)

void AGameInfo::STATIC_DoNavFearCostFallOff()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DoNavFearCostFallOff"));

	AGameInfo_DoNavFearCostFallOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ShouldStartInCinematicMode
// (Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            OutHidePlayer                  (Parm, OutParm)
// int                            OutHideHud                     (Parm, OutParm)
// int                            OutDisableMovement             (Parm, OutParm)
// int                            OutDisableTurning              (Parm, OutParm)
// int                            OutDisableInput                (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ShouldStartInCinematicMode(int* OutHidePlayer, int* OutHideHud, int* OutDisableMovement, int* OutDisableTurning, int* OutDisableInput)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ShouldStartInCinematicMode"));

	AGameInfo_ShouldStartInCinematicMode_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHidePlayer != nullptr)
		*OutHidePlayer = params.OutHidePlayer;
	if (OutHideHud != nullptr)
		*OutHideHud = params.OutHideHud;
	if (OutDisableMovement != nullptr)
		*OutDisableMovement = params.OutDisableMovement;
	if (OutDisableTurning != nullptr)
		*OutDisableTurning = params.OutDisableTurning;
	if (OutDisableInput != nullptr)
		*OutDisableInput = params.OutDisableInput;

	return params.ReturnValue;
}


// Function Engine.GameInfo.Timer
// (Defined, Latent, PreOperator, Singular, NetReliable, Native)

void AGameInfo::Timer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Timer"));

	AGameInfo_Timer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ResetLevel
// (NetReliable, Native, HasOptionalParms)

void AGameInfo::ResetLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ResetLevel"));

	AGameInfo_ResetLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.ShouldReset
// (Final, Defined, Simulated, Event, HasOptionalParms)
// Parameters:
// class AActor*                  ActorToReset                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::ShouldReset(class AActor* ActorToReset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.ShouldReset"));

	AGameInfo_ShouldReset_Params params;
	params.ActorToReset = ActorToReset;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AGameInfo::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.Reset"));

	AGameInfo_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AGameInfo::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.DisplayDebug"));

	AGameInfo_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.GameInfo.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AGameInfo::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PostBeginPlay"));

	AGameInfo_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetCoverReplicator
// (Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class ACoverReplicator*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ACoverReplicator* AGameInfo::STATIC_GetCoverReplicator()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetCoverReplicator"));

	AGameInfo_GetCoverReplicator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameInfo.PreBeginPlay
// (Latent, Net, Simulated)

void AGameInfo::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.PreBeginPlay"));

	AGameInfo_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInfo.GetMapCommonPackageName
// (Iterator, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FString                 InFilename                     (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 OutCommonPackageName           (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_GetMapCommonPackageName(struct FString* InFilename, struct FString* OutCommonPackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetMapCommonPackageName"));

	AGameInfo_GetMapCommonPackageName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InFilename != nullptr)
		*InFilename = params.InFilename;
	if (OutCommonPackageName != nullptr)
		*OutCommonPackageName = params.OutCommonPackageName;

	return params.ReturnValue;
}


// Function Engine.GameInfo.GetSupportedGameTypes
// (Final, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 InFilename                     (Const, Parm, OutParm, NeedCtorLink)
// struct FGameTypePrefix         OutGameType                    (Parm, OutParm, NeedCtorLink)
// bool                           bCheckExt                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameInfo::STATIC_GetSupportedGameTypes(bool bCheckExt, struct FString* InFilename, struct FGameTypePrefix* OutGameType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameInfo.GetSupportedGameTypes"));

	AGameInfo_GetSupportedGameTypes_Params params;
	params.bCheckExt = bCheckExt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InFilename != nullptr)
		*InFilename = params.InFilename;
	if (OutGameType != nullptr)
		*OutGameType = params.OutGameType;

	return params.ReturnValue;
}


// Function Engine.Mutator.NetDamage
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// int                            OriginalDamage                 (Parm)
// int                            Damage                         (Parm, OutParm)
// class APawn*                   injured                        (Parm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm, OutParm)
// class UClass*                  DamageType                     (Parm)
// class AActor*                  DamageCauser                   (Parm)

void AMutator::STATIC_NetDamage(int OriginalDamage, class APawn* injured, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, class AActor* DamageCauser, int* Damage, struct FVector* Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.NetDamage"));

	AMutator_NetDamage_Params params;
	params.OriginalDamage = OriginalDamage;
	params.injured = injured;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Damage != nullptr)
		*Damage = params.Damage;
	if (Momentum != nullptr)
		*Momentum = params.Momentum;
}


// Function Engine.Mutator.ScoreKill
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Killed                         (Parm)
// bool                           bFakeDeath                     (OptionalParm, Parm)

void AMutator::ScoreKill(class AController* Killer, class AController* Killed, bool bFakeDeath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.ScoreKill"));

	AMutator_ScoreKill_Params params;
	params.Killer = Killer;
	params.Killed = Killed;
	params.bFakeDeath = bFakeDeath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.ScoreObjective
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  Scorer                         (Parm)
// int                            Score                          (Parm)

void AMutator::ScoreObjective(class APlayerReplicationInfo* Scorer, int Score)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.ScoreObjective"));

	AMutator_ScoreObjective_Params params;
	params.Scorer = Scorer;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.PreventDeath
// (Final, Iterator, Latent, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// class APawn*                   Killed                         (Parm)
// class AController*             Killer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::PreventDeath(class APawn* Killed, class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.PreventDeath"));

	AMutator_PreventDeath_Params params;
	params.Killed = Killed;
	params.Killer = Killer;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.OverridePickupQuery
// (Iterator, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// class APawn*                   Other                          (Parm)
// class UClass*                  ItemClass                      (Parm)
// class AActor*                  Pickup                         (Parm)
// unsigned char                  bAllowPickup                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::STATIC_OverridePickupQuery(class APawn* Other, class UClass* ItemClass, class AActor* Pickup, unsigned char* bAllowPickup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.OverridePickupQuery"));

	AMutator_OverridePickupQuery_Params params;
	params.Other = Other;
	params.ItemClass = ItemClass;
	params.Pickup = Pickup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bAllowPickup != nullptr)
		*bAllowPickup = params.bAllowPickup;

	return params.ReturnValue;
}


// Function Engine.Mutator.CheckEndGame
// (Final, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class APlayerReplicationInfo*  Winner                         (Parm)
// struct FString                 Reason                         (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::CheckEndGame(class APlayerReplicationInfo* Winner, const struct FString& Reason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.CheckEndGame"));

	AMutator_CheckEndGame_Params params;
	params.Winner = Winner;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.HandleRestartGame
// (Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::STATIC_HandleRestartGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.HandleRestartGame"));

	AMutator_HandleRestartGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.FindPlayerStart
// (Final, Defined, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class AController*             Player                         (Parm)
// unsigned char                  InTeam                         (OptionalParm, Parm)
// struct FString                 IncomingName                   (OptionalParm, Parm, NeedCtorLink)
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* AMutator::STATIC_FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.FindPlayerStart"));

	AMutator_FindPlayerStart_Params params;
	params.Player = Player;
	params.InTeam = InTeam;
	params.IncomingName = IncomingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.GetSeamlessTravelActorList
// (Defined, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bToEntry                       (Parm)
// TArray<class AActor*>          ActorList                      (Parm, OutParm, NeedCtorLink)

void AMutator::GetSeamlessTravelActorList(bool bToEntry, TArray<class AActor*>* ActorList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.GetSeamlessTravelActorList"));

	AMutator_GetSeamlessTravelActorList_Params params;
	params.bToEntry = bToEntry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActorList != nullptr)
		*ActorList = params.ActorList;
}


// Function Engine.Mutator.InitMutator
// (Final, PreOperator, Singular, Net, Simulated, Operator, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 ErrorMessage                   (Parm, OutParm, NeedCtorLink)

void AMutator::STATIC_InitMutator(const struct FString& Options, struct FString* ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.InitMutator"));

	AMutator_InitMutator_Params params;
	params.Options = Options;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ErrorMessage != nullptr)
		*ErrorMessage = params.ErrorMessage;
}


// Function Engine.Mutator.DriverLeftVehicle
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)

void AMutator::STATIC_DriverLeftVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.DriverLeftVehicle"));

	AMutator_DriverLeftVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.CanLeaveVehicle
// (Defined, Iterator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::CanLeaveVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.CanLeaveVehicle"));

	AMutator_CanLeaveVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.DriverEnteredVehicle
// (Final, Defined, Iterator, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class AVehicle*                V                              (Parm)
// class APawn*                   P                              (Parm)

void AMutator::STATIC_DriverEnteredVehicle(class AVehicle* V, class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.DriverEnteredVehicle"));

	AMutator_DriverEnteredVehicle_Params params;
	params.V = V;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.NotifyLogin
// (Final, Defined, Iterator, Latent, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             NewPlayer                      (Parm)

void AMutator::STATIC_NotifyLogin(class AController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.NotifyLogin"));

	AMutator_NotifyLogin_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.NotifyLogout
// (PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             Exiting                        (Parm)

void AMutator::STATIC_NotifyLogout(class AController* Exiting)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.NotifyLogout"));

	AMutator_NotifyLogout_Params params;
	params.Exiting = Exiting;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.CheckReplacement
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::CheckReplacement(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.CheckReplacement"));

	AMutator_CheckReplacement_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.CheckRelevance
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::CheckRelevance(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.CheckRelevance"));

	AMutator_CheckRelevance_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.IsRelevant
// (Iterator, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::STATIC_IsRelevant(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.IsRelevant"));

	AMutator_IsRelevant_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.AlwaysKeep
// (PreOperator, Singular, Net, NetReliable, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::AlwaysKeep(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.AlwaysKeep"));

	AMutator_AlwaysKeep_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.AddMutator
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class AMutator*                M                              (Parm)

void AMutator::AddMutator(class AMutator* M)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.AddMutator"));

	AMutator_AddMutator_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.ModifyPlayer
// (Final, Latent, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// class APawn*                   Other                          (Parm)

void AMutator::STATIC_ModifyPlayer(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.ModifyPlayer"));

	AMutator_ModifyPlayer_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.ModifyLogin
// (Latent, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// struct FString                 Portal                         (Parm, OutParm, NeedCtorLink)
// struct FString                 Options                        (Parm, OutParm, NeedCtorLink)

void AMutator::STATIC_ModifyLogin(struct FString* Portal, struct FString* Options)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.ModifyLogin"));

	AMutator_ModifyLogin_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Portal != nullptr)
		*Portal = params.Portal;
	if (Options != nullptr)
		*Options = params.Options;
}


// Function Engine.Mutator.Mutate
// (Final, Iterator, Latent, Singular, Simulated, Event, Operator, Static)
// Parameters:
// struct FString                 MutateString                   (Parm, NeedCtorLink)
// class APlayerController*       Sender                         (Parm)

void AMutator::STATIC_Mutate(const struct FString& MutateString, class APlayerController* Sender)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.Mutate"));

	AMutator_Mutate_Params params;
	params.MutateString = MutateString;
	params.Sender = Sender;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AMutator::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.Destroyed"));

	AMutator_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Mutator.MutatorIsAllowed
// (PreOperator, Singular, Simulated, Event, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AMutator::STATIC_MutatorIsAllowed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.MutatorIsAllowed"));

	AMutator_MutatorIsAllowed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Mutator.PreBeginPlay
// (Latent, Net, Simulated)

void AMutator::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Mutator.PreBeginPlay"));

	AMutator_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PotentialClimbWatcher.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void APotentialClimbWatcher::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PotentialClimbWatcher.Tick"));

	APotentialClimbWatcher_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Route.MoveOntoRoutePath
// (Iterator, Latent, PreOperator, Net, NetReliable, Event, Operator, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// TEnumAsByte<ERouteDirection>   RouteDirection                 (OptionalParm, Parm)
// float                          DistFudgeFactor                (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ARoute::STATIC_MoveOntoRoutePath(class APawn* P, TEnumAsByte<ERouteDirection> RouteDirection, float DistFudgeFactor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Route.MoveOntoRoutePath"));

	ARoute_MoveOntoRoutePath_Params params;
	params.P = P;
	params.RouteDirection = RouteDirection;
	params.DistFudgeFactor = DistFudgeFactor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Route.ResolveRouteIndex
// (Final, PreOperator, NetReliable, Native, HasOptionalParms)
// Parameters:
// int                            Idx                            (Parm)
// TEnumAsByte<ERouteDirection>   RouteDirection                 (Parm)
// unsigned char                  out_bComplete                  (Parm, OutParm)
// unsigned char                  out_bReverse                   (Parm, OutParm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ARoute::ResolveRouteIndex(int Idx, TEnumAsByte<ERouteDirection> RouteDirection, unsigned char* out_bComplete, unsigned char* out_bReverse)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Route.ResolveRouteIndex"));

	ARoute_ResolveRouteIndex_Params params;
	params.Idx = Idx;
	params.RouteDirection = RouteDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_bComplete != nullptr)
		*out_bComplete = params.out_bComplete;
	if (out_bReverse != nullptr)
		*out_bReverse = params.out_bReverse;

	return params.ReturnValue;
}


// Function Engine.Inventory.GetLocalString
// (Defined, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AInventory::STATIC_GetLocalString(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.GetLocalString"));

	AInventory_GetLocalString_Params params;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Inventory.DropFrom
// (NetReliable, Exec, Native, Static)
// Parameters:
// struct FVector                 StartLocation                  (Parm)
// struct FVector                 StartVelocity                  (Parm)

void AInventory::STATIC_DropFrom(const struct FVector& StartLocation, const struct FVector& StartVelocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.DropFrom"));

	AInventory_DropFrom_Params params;
	params.StartLocation = StartLocation;
	params.StartVelocity = StartVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.DenyPickupQuery
// (Final, NetReliable, Native, Static)
// Parameters:
// class UClass*                  ItemClass                      (Parm)
// class AActor*                  Pickup                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInventory::STATIC_DenyPickupQuery(class UClass* ItemClass, class AActor* Pickup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.DenyPickupQuery"));

	AInventory_DenyPickupQuery_Params params;
	params.ItemClass = ItemClass;
	params.Pickup = Pickup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Inventory.ItemRemovedFromInvManager
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Exec, Operator, Static)

void AInventory::STATIC_ItemRemovedFromInvManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.ItemRemovedFromInvManager"));

	AInventory_ItemRemovedFromInvManager_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.ClientGivenTo
// (Defined, Iterator, Static)
// Parameters:
// class APawn*                   NewOwner                       (Parm)
// bool                           bDoNotActivate                 (Parm)

void AInventory::STATIC_ClientGivenTo(class APawn* NewOwner, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.ClientGivenTo"));

	AInventory_ClientGivenTo_Params params;
	params.NewOwner = NewOwner;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.GivenTo
// (Iterator, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class APawn*                   thisPawn                       (Parm)
// bool                           bDoNotActivate                 (OptionalParm, Parm)

void AInventory::STATIC_GivenTo(class APawn* thisPawn, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.GivenTo"));

	AInventory_GivenTo_Params params;
	params.thisPawn = thisPawn;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.AnnouncePickup
// (Defined, NetReliable, Simulated, Operator)
// Parameters:
// class APawn*                   Other                          (Parm)

void AInventory::AnnouncePickup(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.AnnouncePickup"));

	AInventory_AnnouncePickup_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.GiveTo
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class APawn*                   Other                          (Parm)

void AInventory::STATIC_GiveTo(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.GiveTo"));

	AInventory_GiveTo_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.DetourWeight
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// float                          PathWeight                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AInventory::DetourWeight(class APawn* Other, float PathWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.DetourWeight"));

	AInventory_DetourWeight_Params params;
	params.Other = Other;
	params.PathWeight = PathWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Inventory.BotDesireability
// (Iterator, Net, Simulated)
// Parameters:
// class AActor*                  PickupHolder                   (Parm)
// class APawn*                   P                              (Parm)
// class AController*             C                              (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AInventory::BotDesireability(class AActor* PickupHolder, class APawn* P, class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.BotDesireability"));

	AInventory_BotDesireability_Params params;
	params.PickupHolder = PickupHolder;
	params.P = P;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Inventory.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AInventory::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.Destroyed"));

	AInventory_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Inventory.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AInventory::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Inventory.GetHumanReadableName"));

	AInventory_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.GetAIRating
// (Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AWeapon::STATIC_GetAIRating()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.GetAIRating"));

	AWeapon_GetAIRating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.GetWeaponRating
// (Final, Defined, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AWeapon::STATIC_GetWeaponRating()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.GetWeaponRating"));

	AWeapon_GetWeaponRating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.HasAnyAmmo
// (Defined, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::STATIC_HasAnyAmmo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.HasAnyAmmo"));

	AWeapon_HasAnyAmmo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.TryPutDown
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::TryPutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.TryPutDown"));

	AWeapon_TryPutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.DenyClientWeaponSet
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::STATIC_DenyClientWeaponSet()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.DenyClientWeaponSet"));

	AWeapon_DenyClientWeaponSet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.HolderDied
// (Defined, Iterator, Latent, PreOperator, Singular, Operator, Static)

void AWeapon::STATIC_HolderDied()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.HolderDied"));

	AWeapon_HolderDied_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Weapon.Activate
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, Event)

void AWeapon::Activate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.Activate"));

	AWeapon_Activate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Weapon.DumpWeaponDebugToLog
// (Iterator, Latent, PreOperator, NetReliable, Exec, Native, Static)

void AWeapon::STATIC_DumpWeaponDebugToLog()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.DumpWeaponDebugToLog"));

	AWeapon_DumpWeaponDebugToLog_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Weapon.IsFiring
// (Final, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::IsFiring()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.IsFiring"));

	AWeapon_IsFiring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.ServerStopFire
// (Final, Latent, PreOperator, Simulated, Exec, Native, HasOptionalParms)

void AWeapon::ServerStopFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.ServerStopFire"));

	AWeapon_ServerStopFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Weapon.StopFire
// (Final, Defined, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)

void AWeapon::StopFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.StopFire"));

	AWeapon_StopFire_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Weapon.StartFire
// (Final, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::StartFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.StartFire"));

	AWeapon_StartFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Weapon.NativeIsFiring
// (Final, Defined, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AWeapon::STATIC_NativeIsFiring()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Weapon.NativeIsFiring"));

	AWeapon_NativeIsFiring_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.UpdateController
// (Defined, Iterator, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void AInventoryManager::UpdateController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.UpdateController"));

	AInventoryManager_UpdateController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.ClientWeaponSet
// (Final, Latent, PreOperator, Singular, Static)
// Parameters:
// class AWeapon*                 NewWeapon                      (Parm)
// bool                           bOptionalSet                   (Parm)
// bool                           bDoNotActivate                 (OptionalParm, Parm)

void AInventoryManager::STATIC_ClientWeaponSet(class AWeapon* NewWeapon, bool bOptionalSet, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.ClientWeaponSet"));

	AInventoryManager_ClientWeaponSet_Params params;
	params.NewWeapon = NewWeapon;
	params.bOptionalSet = bOptionalSet;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.ChangedWeapon
// (Defined, Singular, NetReliable, Exec, Native, Event, Operator)

void AInventoryManager::ChangedWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.ChangedWeapon"));

	AInventoryManager_ChangedWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.ClearPendingWeapon
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void AInventoryManager::ClearPendingWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.ClearPendingWeapon"));

	AInventoryManager_ClearPendingWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.CancelWeaponChange
// (Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInventoryManager::CancelWeaponChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.CancelWeaponChange"));

	AInventoryManager_CancelWeaponChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.SetPendingWeapon
// (PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class AWeapon*                 DesiredWeapon                  (Parm)

void AInventoryManager::SetPendingWeapon(class AWeapon* DesiredWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.SetPendingWeapon"));

	AInventoryManager_SetPendingWeapon_Params params;
	params.DesiredWeapon = DesiredWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.InternalSetCurrentWeapon
// (Defined, Iterator, PreOperator, Singular, Exec, Operator, Static)
// Parameters:
// class AWeapon*                 DesiredWeapon                  (Parm)

void AInventoryManager::STATIC_InternalSetCurrentWeapon(class AWeapon* DesiredWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.InternalSetCurrentWeapon"));

	AInventoryManager_InternalSetCurrentWeapon_Params params;
	params.DesiredWeapon = DesiredWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.NextWeapon
// (Final, Net, NetReliable, Exec, Event, Operator, Static)

void AInventoryManager::STATIC_NextWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.NextWeapon"));

	AInventoryManager_NextWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.PrevWeapon
// (Latent, NetReliable, Simulated, HasOptionalParms)

void AInventoryManager::PrevWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.PrevWeapon"));

	AInventoryManager_PrevWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.SwitchToBestWeapon
// (Final, Defined, Iterator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bForceADifferentWeapon         (OptionalParm, Parm)

void AInventoryManager::SwitchToBestWeapon(bool bForceADifferentWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.SwitchToBestWeapon"));

	AInventoryManager_SwitchToBestWeapon_Params params;
	params.bForceADifferentWeapon = bForceADifferentWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.GetBestWeapon
// (Final, Iterator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// bool                           bForceADifferentWeapon         (OptionalParm, Parm)
// class AWeapon*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class AWeapon* AInventoryManager::STATIC_GetBestWeapon(bool bForceADifferentWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.GetBestWeapon"));

	AInventoryManager_GetBestWeapon_Params params;
	params.bForceADifferentWeapon = bForceADifferentWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.GetWeaponRatingFor
// (Iterator, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AInventoryManager::STATIC_GetWeaponRatingFor(class AWeapon* W)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.GetWeaponRatingFor"));

	AInventoryManager_GetWeaponRatingFor_Params params;
	params.W = W;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.DrawHUD
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// class AHUD*                    H                              (Parm)

void AInventoryManager::STATIC_DrawHUD(class AHUD* H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.DrawHUD"));

	AInventoryManager_DrawHUD_Params params;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.OwnerDied
// (Defined, Iterator, PreOperator, Singular, Exec, Native, Event, Operator, Static)

void AInventoryManager::STATIC_OwnerDied()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.OwnerDied"));

	AInventoryManager_OwnerDied_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.DiscardInventory
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)

void AInventoryManager::DiscardInventory()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.DiscardInventory"));

	AInventoryManager_DiscardInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.RemoveFromInventory
// (Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AInventory*              ItemToRemove                   (Parm)

void AInventoryManager::RemoveFromInventory(class AInventory* ItemToRemove)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.RemoveFromInventory"));

	AInventoryManager_RemoveFromInventory_Params params;
	params.ItemToRemove = ItemToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.AddInventory
// (Defined, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class AInventory*              NewItem                        (Parm)
// bool                           bDoNotActivate                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInventoryManager::AddInventory(class AInventory* NewItem, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.AddInventory"));

	AInventoryManager_AddInventory_Params params;
	params.NewItem = NewItem;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.CreateInventory
// (Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  NewInventoryItemClass          (Parm)
// bool                           bDoNotActivate                 (OptionalParm, Parm)
// class AInventory*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AInventory* AInventoryManager::CreateInventory(class UClass* NewInventoryItemClass, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.CreateInventory"));

	AInventoryManager_CreateInventory_Params params;
	params.NewInventoryItemClass = NewInventoryItemClass;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.FindInventoryType
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  DesiredClass                   (Parm)
// bool                           bAllowSubclass                 (OptionalParm, Parm)
// class AInventory*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AInventory* AInventoryManager::FindInventoryType(class UClass* DesiredClass, bool bAllowSubclass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.FindInventoryType"));

	AInventoryManager_FindInventoryType_Params params;
	params.DesiredClass = DesiredClass;
	params.bAllowSubclass = bAllowSubclass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.HandlePickupQuery
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UClass*                  ItemClass                      (Parm)
// class AActor*                  Pickup                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInventoryManager::STATIC_HandlePickupQuery(class UClass* ItemClass, class AActor* Pickup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.HandlePickupQuery"));

	AInventoryManager_HandlePickupQuery_Params params;
	params.ItemClass = ItemClass;
	params.Pickup = Pickup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AInventoryManager::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.Destroyed"));

	AInventoryManager_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.SetupFor
// (Defined, Iterator, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void AInventoryManager::SetupFor(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.SetupFor"));

	AInventoryManager_SetupFor_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.InventoryActors
// (Final, Singular, Net, Exec, Operator, Static)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class AInventory*              Inv                            (Parm, OutParm)

void AInventoryManager::STATIC_InventoryActors(class UClass* BaseClass, class AInventory** Inv)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.InventoryActors"));

	AInventoryManager_InventoryActors_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Inv != nullptr)
		*Inv = params.Inv;
}


// Function Engine.InventoryManager.ClearAllPendingFire
// (PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)

void AInventoryManager::ClearAllPendingFire(class AWeapon* InWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.ClearAllPendingFire"));

	AInventoryManager_ClearAllPendingFire_Params params;
	params.InWeapon = InWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.IsPendingFire
// (Defined, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// int                            InFiringMode                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AInventoryManager::STATIC_IsPendingFire(class AWeapon* InWeapon, int InFiringMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.IsPendingFire"));

	AInventoryManager_IsPendingFire_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.ClearPendingFire
// (Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// int                            InFiringMode                   (Parm)

void AInventoryManager::ClearPendingFire(class AWeapon* InWeapon, int InFiringMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.ClearPendingFire"));

	AInventoryManager_ClearPendingFire_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.SetPendingFire
// (Final, Defined, Iterator, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// int                            InFiringMode                   (Parm)

void AInventoryManager::SetPendingFire(class AWeapon* InWeapon, int InFiringMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.SetPendingFire"));

	AInventoryManager_SetPendingFire_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InventoryManager.GetPendingFireLength
// (Defined, Iterator, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AInventoryManager::STATIC_GetPendingFireLength(class AWeapon* InWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.GetPendingFireLength"));

	AInventoryManager_GetPendingFireLength_Params params;
	params.InWeapon = InWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InventoryManager.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AInventoryManager::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InventoryManager.PostBeginPlay"));

	AInventoryManager_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.CheckPriorityRefresh
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)

void AMatineeActor::CheckPriorityRefresh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MatineeActor.CheckPriorityRefresh"));

	AMatineeActor_CheckPriorityRefresh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.Update
// (Final, Latent, Simulated, Exec, Native, HasOptionalParms)

void AMatineeActor::Update()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MatineeActor.Update"));

	AMatineeActor_Update_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.AddAIGroupActor
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// class UInterpGroupInstAI*      AIGroupInst                    (Parm)

void AMatineeActor::AddAIGroupActor(class UInterpGroupInstAI* AIGroupInst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MatineeActor.AddAIGroupActor"));

	AMatineeActor_AddAIGroupActor_Params params;
	params.AIGroupInst = AIGroupInst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationPoint.GetDebugAbbrev
// (Final, Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ANavigationPoint::GetDebugAbbrev()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetDebugAbbrev"));

	ANavigationPoint_GetDebugAbbrev_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ANavigationPoint_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ANavigationPoint::ApplyCheckpointRecord(struct ANavigationPoint_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.ApplyCheckpointRecord"));

	ANavigationPoint_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.NavigationPoint.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ANavigationPoint_FCheckpointRecord Record                         (Parm, OutParm)

void ANavigationPoint::STATIC_CreateCheckpointRecord(struct ANavigationPoint_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.CreateCheckpointRecord"));

	ANavigationPoint_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.NavigationPoint.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.ShouldSaveForCheckpoint"));

	ANavigationPoint_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void ANavigationPoint::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.ShutDown"));

	ANavigationPoint_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationPoint.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ANavigationPoint::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.OnToggle"));

	ANavigationPoint_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationPoint.IsOnDifferentNetwork
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// class ANavigationPoint*        Nav                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::STATIC_IsOnDifferentNetwork(class ANavigationPoint* Nav)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.IsOnDifferentNetwork"));

	ANavigationPoint_IsOnDifferentNetwork_Params params;
	params.Nav = Nav;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.GetAllNavInRadius
// (Iterator, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  ChkActor                       (Parm)
// struct FVector                 ChkPoint                       (Parm)
// float                          Radius                         (Parm)
// TArray<class ANavigationPoint*> out_NavList                    (Parm, OutParm, NeedCtorLink)
// bool                           bSkipBlocked                   (OptionalParm, Parm)
// int                            inNetworkID                    (OptionalParm, Parm)
// struct FCylinder               MinSize                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::STATIC_GetAllNavInRadius(class AActor* ChkActor, const struct FVector& ChkPoint, float Radius, bool bSkipBlocked, int inNetworkID, const struct FCylinder& MinSize, TArray<class ANavigationPoint*>* out_NavList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetAllNavInRadius"));

	ANavigationPoint_GetAllNavInRadius_Params params;
	params.ChkActor = ChkActor;
	params.ChkPoint = ChkPoint;
	params.Radius = Radius;
	params.bSkipBlocked = bSkipBlocked;
	params.inNetworkID = inNetworkID;
	params.MinSize = MinSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_NavList != nullptr)
		*out_NavList = params.out_NavList;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.GetNearestNavToPoint
// (Net, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  ChkActor                       (Parm)
// struct FVector                 ChkPoint                       (Parm)
// class UClass*                  RequiredClass                  (OptionalParm, Parm)
// TArray<class ANavigationPoint*> ExcludeList                    (OptionalParm, Parm, NeedCtorLink)
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* ANavigationPoint::STATIC_GetNearestNavToPoint(class AActor* ChkActor, const struct FVector& ChkPoint, class UClass* RequiredClass, TArray<class ANavigationPoint*> ExcludeList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetNearestNavToPoint"));

	ANavigationPoint_GetNearestNavToPoint_Params params;
	params.ChkActor = ChkActor;
	params.ChkPoint = ChkPoint;
	params.RequiredClass = RequiredClass;
	params.ExcludeList = ExcludeList;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.GetNearestNavToActor
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  ChkActor                       (Parm)
// class UClass*                  RequiredClass                  (OptionalParm, Parm)
// TArray<class ANavigationPoint*> ExcludeList                    (OptionalParm, Parm, NeedCtorLink)
// float                          MinDist                        (OptionalParm, Parm)
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* ANavigationPoint::STATIC_GetNearestNavToActor(class AActor* ChkActor, class UClass* RequiredClass, TArray<class ANavigationPoint*> ExcludeList, float MinDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetNearestNavToActor"));

	ANavigationPoint_GetNearestNavToActor_Params params;
	params.ChkActor = ChkActor;
	params.RequiredClass = RequiredClass;
	params.ExcludeList = ExcludeList;
	params.MinDist = MinDist;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.ProceedWithMove
// (Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::ProceedWithMove(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.ProceedWithMove"));

	ANavigationPoint_ProceedWithMove_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.SuggestMovePreparation"));

	ANavigationPoint_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.DetourWeight
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// float                          PathWeight                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ANavigationPoint::DetourWeight(class APawn* Other, float PathWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.DetourWeight"));

	ANavigationPoint_DetourWeight_Params params;
	params.Other = Other;
	params.PathWeight = PathWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.Accept
// (Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Incoming                       (Parm)
// class AActor*                  Source                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::Accept(class AActor* Incoming, class AActor* Source)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.Accept"));

	ANavigationPoint_Accept_Params params;
	params.Incoming = Incoming;
	params.Source = Source;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.SpecialCost
// (Defined, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Seeker                         (Parm)
// class UReachSpec*              Path                           (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ANavigationPoint::SpecialCost(class APawn* Seeker, class UReachSpec* Path)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.SpecialCost"));

	ANavigationPoint_SpecialCost_Params params;
	params.Seeker = Seeker;
	params.Path = Path;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.CanTeleport
// (Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::CanTeleport(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.CanTeleport"));

	ANavigationPoint_CanTeleport_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.IsUsableAnchorFor
// (Final, Defined, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavigationPoint::STATIC_IsUsableAnchorFor(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.IsUsableAnchorFor"));

	ANavigationPoint_IsUsableAnchorFor_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.GetReachSpecTo
// (Final, Iterator, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class ANavigationPoint*        Nav                            (Parm)
// class UClass*                  SpecClass                      (OptionalParm, Parm)
// class UReachSpec*              ReturnValue                    (Parm, OutParm, ReturnParm)

class UReachSpec* ANavigationPoint::STATIC_GetReachSpecTo(class ANavigationPoint* Nav, class UClass* SpecClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetReachSpecTo"));

	ANavigationPoint_GetReachSpecTo_Params params;
	params.Nav = Nav;
	params.SpecClass = SpecClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationPoint.GetBoundingCylinder
// (Final, Defined, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          CollisionRadius                (Parm, OutParm)
// float                          CollisionHeight                (Parm, OutParm)

void ANavigationPoint::STATIC_GetBoundingCylinder(float* CollisionRadius, float* CollisionHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationPoint.GetBoundingCylinder"));

	ANavigationPoint_GetBoundingCylinder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CollisionRadius != nullptr)
		*CollisionRadius = params.CollisionRadius;
	if (CollisionHeight != nullptr)
		*CollisionHeight = params.CollisionHeight;
}


// Function Engine.CoverLink.GetDebugAbbrev
// (Final, Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ACoverLink::GetDebugAbbrev()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetDebugAbbrev"));

	ACoverLink_GetDebugAbbrev_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetLocationDescription
// (Final, Iterator, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// TEnumAsByte<ECoverLocationDescription> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ECoverLocationDescription> ACoverLink::STATIC_GetLocationDescription(int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetLocationDescription"));

	ACoverLink_GetLocationDescription_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetDebugString
// (Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            SlotIdx                        (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ACoverLink::GetDebugString(int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetDebugString"));

	ACoverLink_GetDebugString_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.AddCoverSlot
// (Iterator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 SlotLocation                   (Parm)
// struct FRotator                SlotRotation                   (Parm)
// int                            SlotIdx                        (OptionalParm, Parm)
// bool                           bForceSlotUpdate               (OptionalParm, Parm)
// class AScout*                  Scout                          (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ACoverLink::AddCoverSlot(const struct FVector& SlotLocation, const struct FRotator& SlotRotation, int SlotIdx, bool bForceSlotUpdate, class AScout* Scout)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.AddCoverSlot"));

	ACoverLink_AddCoverSlot_Params params;
	params.SlotLocation = SlotLocation;
	params.SlotRotation = SlotRotation;
	params.SlotIdx = SlotIdx;
	params.bForceSlotUpdate = bForceSlotUpdate;
	params.Scout = Scout;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.BreakFracturedMeshes
// (Iterator, NetReliable, Exec, Event, Operator)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// float                          RBStrength                     (Parm)
// class UClass*                  DamageType                     (Parm)

void ACoverLink::BreakFracturedMeshes(const struct FVector& Origin, float Radius, float RBStrength, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.BreakFracturedMeshes"));

	ACoverLink_BreakFracturedMeshes_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.RBStrength = RBStrength;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.GetSwatTurnTarget
// (Final, Iterator, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// int                            Direction                      (Parm)
// struct FCoverInfo              out_Info                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_GetSwatTurnTarget(int SlotIdx, int Direction, struct FCoverInfo* out_Info)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSwatTurnTarget"));

	ACoverLink_GetSwatTurnTarget_Params params;
	params.SlotIdx = SlotIdx;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Info != nullptr)
		*out_Info = params.out_Info;

	return params.ReturnValue;
}


// Function Engine.CoverLink.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void ACoverLink::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.ShutDown"));

	ACoverLink_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ANavigationPoint_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ACoverLink::ApplyCheckpointRecord(struct ANavigationPoint_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.ApplyCheckpointRecord"));

	ACoverLink_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.CoverLink.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ANavigationPoint_FCheckpointRecord Record                         (Parm, OutParm)

void ACoverLink::STATIC_CreateCheckpointRecord(struct ANavigationPoint_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.CreateCheckpointRecord"));

	ACoverLink_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.CoverLink.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ACoverLink::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.OnToggle"));

	ACoverLink_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.IsEnabled
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::IsEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsEnabled"));

	ACoverLink_IsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.AutoAdjustSlot
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Operator)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bOnlyCheckLeans                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::AutoAdjustSlot(int SlotIdx, bool bOnlyCheckLeans)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.AutoAdjustSlot"));

	ACoverLink_AutoAdjustSlot_Params params;
	params.SlotIdx = SlotIdx;
	params.bOnlyCheckLeans = bOnlyCheckLeans;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.OnModifyCover
// (Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ModifyCover*     Action                         (Parm)

void ACoverLink::STATIC_OnModifyCover(class USeqAct_ModifyCover* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.OnModifyCover"));

	ACoverLink_OnModifyCover_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.SetSlotPlayerOnly
// (Iterator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bInPlayerOnly                  (Parm)

void ACoverLink::SetSlotPlayerOnly(int SlotIdx, bool bInPlayerOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.SetSlotPlayerOnly"));

	ACoverLink_SetSlotPlayerOnly_Params params;
	params.SlotIdx = SlotIdx;
	params.bInPlayerOnly = bInPlayerOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.NotifySlotOwnerCoverDisabled
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bAIOnly                        (OptionalParm, Parm)

void ACoverLink::STATIC_NotifySlotOwnerCoverDisabled(int SlotIdx, bool bAIOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.NotifySlotOwnerCoverDisabled"));

	ACoverLink_NotifySlotOwnerCoverDisabled_Params params;
	params.SlotIdx = SlotIdx;
	params.bAIOnly = bAIOnly;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.SetSlotEnabled
// (Final, Defined, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bEnable                        (Parm)

void ACoverLink::SetSlotEnabled(int SlotIdx, bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.SetSlotEnabled"));

	ACoverLink_SetSlotEnabled_Params params;
	params.SlotIdx = SlotIdx;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.SetDisabled
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewDisabled                   (Parm)

void ACoverLink::SetDisabled(bool bNewDisabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.SetDisabled"));

	ACoverLink_SetDisabled_Params params;
	params.bNewDisabled = bNewDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.GetSlotActions
// (Defined, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// TArray<TEnumAsByte<ECoverAction>> Actions                        (Parm, OutParm, NeedCtorLink)

void ACoverLink::STATIC_GetSlotActions(int SlotIdx, TArray<TEnumAsByte<ECoverAction>>* Actions)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotActions"));

	ACoverLink_GetSlotActions_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Actions != nullptr)
		*Actions = params.Actions;
}


// Function Engine.CoverLink.HasFireLinkTo
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// struct FCoverInfo              ChkCover                       (Parm)
// bool                           bAllowFallbackLinks            (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_HasFireLinkTo(int SlotIdx, const struct FCoverInfo& ChkCover, bool bAllowFallbackLinks)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.HasFireLinkTo"));

	ACoverLink_HasFireLinkTo_Params params;
	params.SlotIdx = SlotIdx;
	params.ChkCover = ChkCover;
	params.bAllowFallbackLinks = bAllowFallbackLinks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetFireLinkTo
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// struct FCoverInfo              ChkCover                       (Parm)
// TEnumAsByte<ECoverAction>      ChkAction                      (Parm)
// TEnumAsByte<ECoverType>        ChkType                        (Parm)
// int                            out_FireLinkIdx                (Parm, OutParm)
// TArray<int>                    out_Items                      (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_GetFireLinkTo(int SlotIdx, const struct FCoverInfo& ChkCover, TEnumAsByte<ECoverAction> ChkAction, TEnumAsByte<ECoverType> ChkType, int* out_FireLinkIdx, TArray<int>* out_Items)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetFireLinkTo"));

	ACoverLink_GetFireLinkTo_Params params;
	params.SlotIdx = SlotIdx;
	params.ChkCover = ChkCover;
	params.ChkAction = ChkAction;
	params.ChkType = ChkType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_FireLinkIdx != nullptr)
		*out_FireLinkIdx = params.out_FireLinkIdx;
	if (out_Items != nullptr)
		*out_Items = params.out_Items;

	return params.ReturnValue;
}


// Function Engine.CoverLink.AllowLeftTransition
// (Final, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::AllowLeftTransition(int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.AllowLeftTransition"));

	ACoverLink_AllowLeftTransition_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.AllowRightTransition
// (Final, Iterator, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::AllowRightTransition(int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.AllowRightTransition"));

	ACoverLink_AllowRightTransition_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetSlotIdxToRight
// (Iterator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// int                            Cnt                            (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ACoverLink::STATIC_GetSlotIdxToRight(int SlotIdx, int Cnt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotIdxToRight"));

	ACoverLink_GetSlotIdxToRight_Params params;
	params.SlotIdx = SlotIdx;
	params.Cnt = Cnt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetSlotIdxToLeft
// (Final, Defined, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// int                            Cnt                            (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ACoverLink::STATIC_GetSlotIdxToLeft(int SlotIdx, int Cnt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotIdxToLeft"));

	ACoverLink_GetSlotIdxToLeft_Params params;
	params.SlotIdx = SlotIdx;
	params.Cnt = Cnt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsRightEdgeSlot
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bIgnoreLeans                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsRightEdgeSlot(int SlotIdx, bool bIgnoreLeans)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsRightEdgeSlot"));

	ACoverLink_IsRightEdgeSlot_Params params;
	params.SlotIdx = SlotIdx;
	params.bIgnoreLeans = bIgnoreLeans;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsLeftEdgeSlot
// (Final, Defined, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bIgnoreLeans                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsLeftEdgeSlot(int SlotIdx, bool bIgnoreLeans)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsLeftEdgeSlot"));

	ACoverLink_IsLeftEdgeSlot_Params params;
	params.SlotIdx = SlotIdx;
	params.bIgnoreLeans = bIgnoreLeans;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsEdgeSlot
// (Defined, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bIgnoreLeans                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsEdgeSlot(int SlotIdx, bool bIgnoreLeans)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsEdgeSlot"));

	ACoverLink_IsEdgeSlot_Params params;
	params.SlotIdx = SlotIdx;
	params.bIgnoreLeans = bIgnoreLeans;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.FindSlots
// (Final, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 CheckLocation                  (Parm)
// float                          MaxDistance                    (Parm)
// int                            LeftSlotIdx                    (Parm, OutParm)
// int                            RightSlotIdx                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_FindSlots(const struct FVector& CheckLocation, float MaxDistance, int* LeftSlotIdx, int* RightSlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.FindSlots"));

	ACoverLink_FindSlots_Params params;
	params.CheckLocation = CheckLocation;
	params.MaxDistance = MaxDistance;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LeftSlotIdx != nullptr)
		*LeftSlotIdx = params.LeftSlotIdx;
	if (RightSlotIdx != nullptr)
		*RightSlotIdx = params.RightSlotIdx;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsStationarySlot
// (Defined, Simulated, Exec, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsStationarySlot(int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsStationarySlot"));

	ACoverLink_IsStationarySlot_Params params;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsValidClaimBetween
// (PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// class APawn*                   ChkClaim                       (Parm)
// int                            StartSlotIdx                   (Parm)
// int                            EndSlotIdx                     (Parm)
// bool                           bSkipTeamCheck                 (OptionalParm, Parm)
// bool                           bSkipOverlapCheck              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsValidClaimBetween(class APawn* ChkClaim, int StartSlotIdx, int EndSlotIdx, bool bSkipTeamCheck, bool bSkipOverlapCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsValidClaimBetween"));

	ACoverLink_IsValidClaimBetween_Params params;
	params.ChkClaim = ChkClaim;
	params.StartSlotIdx = StartSlotIdx;
	params.EndSlotIdx = EndSlotIdx;
	params.bSkipTeamCheck = bSkipTeamCheck;
	params.bSkipOverlapCheck = bSkipOverlapCheck;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.IsValidClaim
// (Final, Defined, Iterator, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// class APawn*                   ChkClaim                       (Parm)
// int                            SlotIdx                        (Parm)
// bool                           bSkipTeamCheck                 (OptionalParm, Parm)
// bool                           bSkipOverlapCheck              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsValidClaim(class APawn* ChkClaim, int SlotIdx, bool bSkipTeamCheck, bool bSkipOverlapCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsValidClaim"));

	ACoverLink_IsValidClaim_Params params;
	params.ChkClaim = ChkClaim;
	params.SlotIdx = SlotIdx;
	params.bSkipTeamCheck = bSkipTeamCheck;
	params.bSkipOverlapCheck = bSkipOverlapCheck;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.UnClaim
// (Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   OldClaim                       (Parm)
// int                            SlotIdx                        (Parm)
// bool                           bUnclaimAll                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::UnClaim(class APawn* OldClaim, int SlotIdx, bool bUnclaimAll)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.UnClaim"));

	ACoverLink_UnClaim_Params params;
	params.OldClaim = OldClaim;
	params.SlotIdx = SlotIdx;
	params.bUnclaimAll = bUnclaimAll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.Claim
// (Latent, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   NewClaim                       (Parm)
// int                            SlotIdx                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::Claim(class APawn* NewClaim, int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.Claim"));

	ACoverLink_Claim_Params params;
	params.NewClaim = NewClaim;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.SetInvalidUntil
// (PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SlotIdx                        (Parm)
// float                          TimeToBecomeValid              (Parm)

void ACoverLink::SetInvalidUntil(int SlotIdx, float TimeToBecomeValid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.SetInvalidUntil"));

	ACoverLink_SetInvalidUntil_Params params;
	params.SlotIdx = SlotIdx;
	params.TimeToBecomeValid = TimeToBecomeValid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverLink.IsExposedTo
// (Final, Iterator, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// struct FCoverInfo              ChkSlot                        (Parm)
// float                          out_ExposedScale               (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_IsExposedTo(int SlotIdx, const struct FCoverInfo& ChkSlot, float* out_ExposedScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.IsExposedTo"));

	ACoverLink_IsExposedTo_Params params;
	params.SlotIdx = SlotIdx;
	params.ChkSlot = ChkSlot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_ExposedScale != nullptr)
		*out_ExposedScale = params.out_ExposedScale;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetSlotViewPoint
// (Final, Defined, Iterator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// TEnumAsByte<ECoverType>        Type                           (OptionalParm, Parm)
// TEnumAsByte<ECoverAction>      Action                         (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector ACoverLink::STATIC_GetSlotViewPoint(int SlotIdx, TEnumAsByte<ECoverType> Type, TEnumAsByte<ECoverAction> Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotViewPoint"));

	ACoverLink_GetSlotViewPoint_Params params;
	params.SlotIdx = SlotIdx;
	params.Type = Type;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetSlotRotation
// (Defined, Iterator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bForceUseOffset                (OptionalParm, Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator ACoverLink::STATIC_GetSlotRotation(int SlotIdx, bool bForceUseOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotRotation"));

	ACoverLink_GetSlotRotation_Params params;
	params.SlotIdx = SlotIdx;
	params.bForceUseOffset = bForceUseOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetSlotLocation
// (Final, Iterator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// bool                           bForceUseOffset                (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector ACoverLink::STATIC_GetSlotLocation(int SlotIdx, bool bForceUseOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetSlotLocation"));

	ACoverLink_GetSlotLocation_Params params;
	params.SlotIdx = SlotIdx;
	params.bForceUseOffset = bForceUseOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.UnPackFireLinkInteractionInfo
// (Final, Defined, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  PackedByte                     (Const, Parm)
// TEnumAsByte<ECoverType>        SrcType                        (Parm, OutParm)
// TEnumAsByte<ECoverAction>      SrcAction                      (Parm, OutParm)
// TEnumAsByte<ECoverType>        DestType                       (Parm, OutParm)
// TEnumAsByte<ECoverAction>      DestAction                     (Parm, OutParm)

void ACoverLink::UnPackFireLinkInteractionInfo(unsigned char PackedByte, TEnumAsByte<ECoverType>* SrcType, TEnumAsByte<ECoverAction>* SrcAction, TEnumAsByte<ECoverType>* DestType, TEnumAsByte<ECoverAction>* DestAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.UnPackFireLinkInteractionInfo"));

	ACoverLink_UnPackFireLinkInteractionInfo_Params params;
	params.PackedByte = PackedByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SrcType != nullptr)
		*SrcType = params.SrcType;
	if (SrcAction != nullptr)
		*SrcAction = params.SrcAction;
	if (DestType != nullptr)
		*DestType = params.DestType;
	if (DestAction != nullptr)
		*DestAction = params.DestAction;
}


// Function Engine.CoverLink.PackFireLinkInteractionInfo
// (Final, PreOperator, Net, Exec, Native, Event, Operator, Static)
// Parameters:
// TEnumAsByte<ECoverType>        SrcType                        (Parm)
// TEnumAsByte<ECoverAction>      SrcAction                      (Parm)
// TEnumAsByte<ECoverType>        DestType                       (Parm)
// TEnumAsByte<ECoverAction>      DestAction                     (Parm)
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char ACoverLink::STATIC_PackFireLinkInteractionInfo(TEnumAsByte<ECoverType> SrcType, TEnumAsByte<ECoverAction> SrcAction, TEnumAsByte<ECoverType> DestType, TEnumAsByte<ECoverAction> DestAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.PackFireLinkInteractionInfo"));

	ACoverLink_PackFireLinkInteractionInfo_Params params;
	params.SrcType = SrcType;
	params.SrcAction = SrcAction;
	params.DestType = DestType;
	params.DestAction = DestAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CoverLink.GetFireLinkTargetCoverInfo
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            SlotIdx                        (Parm)
// int                            FireLinkIdx                    (Parm)
// struct FCoverInfo              out_Info                       (Parm, OutParm)
// TEnumAsByte<EFireLinkID>       ArrayID                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ACoverLink::STATIC_GetFireLinkTargetCoverInfo(int SlotIdx, int FireLinkIdx, TEnumAsByte<EFireLinkID> ArrayID, struct FCoverInfo* out_Info)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverLink.GetFireLinkTargetCoverInfo"));

	ACoverLink_GetFireLinkTargetCoverInfo_Params params;
	params.SlotIdx = SlotIdx;
	params.FireLinkIdx = FireLinkIdx;
	params.ArrayID = ArrayID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Info != nullptr)
		*out_Info = params.out_Info;

	return params.ReturnValue;
}


// Function Engine.DoorMarker.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ADoorMarker::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.SuggestMovePreparation"));

	ADoorMarker_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DoorMarker.ProceedWithMove
// (Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ADoorMarker::ProceedWithMove(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.ProceedWithMove"));

	ADoorMarker_ProceedWithMove_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DoorMarker.SpecialHandling
// (Final, Defined, Net, Simulated)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* ADoorMarker::SpecialHandling(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.SpecialHandling"));

	ADoorMarker_SpecialHandling_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DoorMarker.MoverClosed
// (Singular, Net, NetReliable, Event, Operator, Static)

void ADoorMarker::STATIC_MoverClosed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.MoverClosed"));

	ADoorMarker_MoverClosed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DoorMarker.MoverOpened
// (Final, Defined, Singular, Net, NetReliable, Event, Operator, Static)

void ADoorMarker::STATIC_MoverOpened()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.MoverOpened"));

	ADoorMarker_MoverOpened_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DoorMarker.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADoorMarker::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DoorMarker.PostBeginPlay"));

	ADoorMarker_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Ladder.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALadder::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Ladder.SuggestMovePreparation"));

	ALadder_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LiftCenter.ProceedWithMove
// (Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALiftCenter::ProceedWithMove(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftCenter.ProceedWithMove"));

	ALiftCenter_ProceedWithMove_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LiftCenter.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALiftCenter::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftCenter.SuggestMovePreparation"));

	ALiftCenter_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LiftCenter.SpecialHandling
// (Final, Defined, Net, Simulated)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* ALiftCenter::SpecialHandling(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftCenter.SpecialHandling"));

	ALiftCenter_SpecialHandling_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LiftCenter.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ALiftCenter::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftCenter.PostBeginPlay"));

	ALiftCenter_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LiftExit.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALiftExit::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftExit.SuggestMovePreparation"));

	ALiftExit_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LiftExit.WaitForLift
// (Final, Iterator, PreOperator, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)

void ALiftExit::WaitForLift(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftExit.WaitForLift"));

	ALiftExit_WaitForLift_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LiftExit.CanBeReachedFromLiftBy
// (Iterator, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ALiftExit::CanBeReachedFromLiftBy(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LiftExit.CanBeReachedFromLiftBy"));

	ALiftExit_CanBeReachedFromLiftBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PathNode.GetDebugAbbrev
// (Final, Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APathNode::GetDebugAbbrev()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathNode.GetDebugAbbrev"));

	APathNode_GetDebugAbbrev_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.DelayRespawn
// (Singular, Net, Native, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APickupFactory::STATIC_DelayRespawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.DelayRespawn"));

	APickupFactory_DelayRespawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.Destroyed
// (Iterator, Latent, Singular, Simulated)

void APickupFactory::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.Destroyed"));

	APickupFactory_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.SetPickupVisible
// (Defined, Iterator, PreOperator, Singular, Event, HasOptionalParms)

void APickupFactory::SetPickupVisible()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SetPickupVisible"));

	APickupFactory_SetPickupVisible_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.SetPickupHidden
// (Final, Iterator, PreOperator, Singular, Event, HasOptionalParms)

void APickupFactory::SetPickupHidden()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SetPickupHidden"));

	APickupFactory_SetPickupHidden_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.RespawnEffect
// (Defined, Latent, PreOperator, NetReliable, Native, HasOptionalParms)

void APickupFactory::RespawnEffect()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.RespawnEffect"));

	APickupFactory_RespawnEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.GetRespawnTime
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APickupFactory::STATIC_GetRespawnTime()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.GetRespawnTime"));

	APickupFactory_GetRespawnTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.RecheckValidTouch
// (Defined, NetReliable, Simulated, Exec, HasOptionalParms)

void APickupFactory::RecheckValidTouch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.RecheckValidTouch"));

	APickupFactory_RecheckValidTouch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.PickedUpBy
// (Final, Defined, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void APickupFactory::PickedUpBy(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.PickedUpBy"));

	APickupFactory_PickedUpBy_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.GiveTo
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class APawn*                   P                              (Parm)

void APickupFactory::STATIC_GiveTo(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.GiveTo"));

	APickupFactory_GiveTo_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.ReadyToPickup
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// float                          MaxWait                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APickupFactory::ReadyToPickup(float MaxWait)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.ReadyToPickup"));

	APickupFactory_ReadyToPickup_Params params;
	params.MaxWait = MaxWait;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.SpawnCopyFor
// (Final, Latent, PreOperator, Singular, Net, Exec, Event, HasOptionalParms)
// Parameters:
// class APawn*                   Recipient                      (Parm)

void APickupFactory::SpawnCopyFor(class APawn* Recipient)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SpawnCopyFor"));

	APickupFactory_SpawnCopyFor_Params params;
	params.Recipient = Recipient;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.DetourWeight
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// float                          PathWeight                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APickupFactory::DetourWeight(class APawn* Other, float PathWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.DetourWeight"));

	APickupFactory_DetourWeight_Params params;
	params.Other = Other;
	params.PathWeight = PathWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.StartSleeping
// (Defined, Iterator, Latent, Net, Simulated, Exec, Event, HasOptionalParms)

void APickupFactory::StartSleeping()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.StartSleeping"));

	APickupFactory_StartSleeping_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.SetRespawn
// (Defined, Iterator, PreOperator, Net, Event, HasOptionalParms)

void APickupFactory::SetRespawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SetRespawn"));

	APickupFactory_SetRespawn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.CheckForErrors
// (Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APickupFactory::CheckForErrors()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.CheckForErrors"));

	APickupFactory_CheckForErrors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PickupFactory.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APickupFactory::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.Reset"));

	APickupFactory_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.SetPickupMesh
// (Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)

void APickupFactory::SetPickupMesh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SetPickupMesh"));

	APickupFactory_SetPickupMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void APickupFactory::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.ShutDown"));

	APickupFactory_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.SetInitialState
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)

void APickupFactory::SetInitialState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.SetInitialState"));

	APickupFactory_SetInitialState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.InitializePickup
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Operator, Static)

void APickupFactory::STATIC_InitializePickup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.InitializePickup"));

	APickupFactory_InitializePickup_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.PreBeginPlay
// (Latent, Net, Simulated)

void APickupFactory::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.PreBeginPlay"));

	APickupFactory_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PickupFactory.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void APickupFactory::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PickupFactory.ReplicatedEvent"));

	APickupFactory_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerStart.PostRenderFor
// (PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)
// class UCanvas*                 Canvas                         (Parm)
// struct FVector                 CameraPosition                 (Parm)
// struct FVector                 CameraDir                      (Parm)

void APlayerStart::PostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerStart.PostRenderFor"));

	APlayerStart_PostRenderFor_Params params;
	params.PC = PC;
	params.Canvas = Canvas;
	params.CameraPosition = CameraPosition;
	params.CameraDir = CameraDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerStart.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void APlayerStart::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerStart.OnToggle"));

	APlayerStart_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PortalMarker.CanTeleport
// (Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APortalMarker::CanTeleport(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalMarker.CanTeleport"));

	APortalMarker_CanTeleport_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pylon.CanReachPylon
// (Final, Defined, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// class APylon*                  DestPylon                      (Parm)
// class AController*             C                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APylon::CanReachPylon(class APylon* DestPylon, class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.CanReachPylon"));

	APylon_CanReachPylon_Params params;
	params.DestPylon = DestPylon;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pylon.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void APylon::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.OnToggle"));

	APylon_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.IsEnabled
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APylon::IsEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.IsEnabled"));

	APylon_IsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pylon.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnabled                       (Parm)

void APylon::SetEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.SetEnabled"));

	APylon_SetEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.PostBeginPlay
// (Final, Latent, Net, Simulated)

void APylon::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.PostBeginPlay"));

	APylon_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.NotifyPathChanged
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void APylon::NotifyPathChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.NotifyPathChanged"));

	APylon_NotifyPathChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.VerifyTopLevelConnections
// (Defined, PreOperator, Singular, Operator, HasOptionalParms)

void APylon::VerifyTopLevelConnections()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.VerifyTopLevelConnections"));

	APylon_VerifyTopLevelConnections_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.GetTestPathExtent
// (PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APylon::STATIC_GetTestPathExtent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.GetTestPathExtent"));

	APylon_GetTestPathExtent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pylon.FlushDynamicEdges
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void APylon::STATIC_FlushDynamicEdges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.FlushDynamicEdges"));

	APylon_FlushDynamicEdges_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.UpdateMeshForPreExistingNavMeshObstacles
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void APylon::UpdateMeshForPreExistingNavMeshObstacles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.UpdateMeshForPreExistingNavMeshObstacles"));

	APylon_UpdateMeshForPreExistingNavMeshObstacles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pylon.OnPylonStatusChange
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)

void APylon::STATIC_OnPylonStatusChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pylon.OnPylonStatusChange"));

	APylon_OnPylonStatusChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AISwitchablePylon.IsEnabled
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAISwitchablePylon::IsEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AISwitchablePylon.IsEnabled"));

	AAISwitchablePylon_IsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AISwitchablePylon.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnabled                       (Parm)

void AAISwitchablePylon::SetEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AISwitchablePylon.SetEnabled"));

	AAISwitchablePylon_SetEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AISwitchablePylon.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AAISwitchablePylon::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AISwitchablePylon.PostBeginPlay"));

	AAISwitchablePylon_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPylon.StoppedMoving
// (PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void ADynamicPylon::StoppedMoving()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPylon.StoppedMoving"));

	ADynamicPylon_StoppedMoving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPylon.StartedMoving
// (Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void ADynamicPylon::StartedMoving()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPylon.StartedMoving"));

	ADynamicPylon_StartedMoving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPylon.FlushDynamicEdges
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void ADynamicPylon::STATIC_FlushDynamicEdges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPylon.FlushDynamicEdges"));

	ADynamicPylon_FlushDynamicEdges_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPylon.RebuildDynamicEdges
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, HasOptionalParms)

void ADynamicPylon::RebuildDynamicEdges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPylon.RebuildDynamicEdges"));

	ADynamicPylon_RebuildDynamicEdges_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPylon.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADynamicPylon::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPylon.PostBeginPlay"));

	ADynamicPylon_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Teleporter.SpecialHandling
// (Final, Defined, Net, Simulated)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* ATeleporter::SpecialHandling(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.SpecialHandling"));

	ATeleporter_SpecialHandling_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Teleporter.PostTouch
// (Final, Defined, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void ATeleporter::PostTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.PostTouch"));

	ATeleporter_PostTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Teleporter.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void ATeleporter::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.Touch"));

	ATeleporter_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Teleporter.Accept
// (Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Incoming                       (Parm)
// class AActor*                  Source                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATeleporter::Accept(class AActor* Incoming, class AActor* Source)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.Accept"));

	ATeleporter_Accept_Params params;
	params.Incoming = Incoming;
	params.Source = Source;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Teleporter.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ATeleporter::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.PostBeginPlay"));

	ATeleporter_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Teleporter.CanTeleport
// (Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATeleporter::CanTeleport(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Teleporter.CanTeleport"));

	ATeleporter_CanTeleport_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.ApplyFluidSurfaceImpact
// (Defined, PreOperator, Singular, NetReliable, Simulated, Operator)
// Parameters:
// class AFluidSurfaceActor*      Fluid                          (Parm)
// struct FVector                 HitLocation                    (Parm)

void AProjectile::ApplyFluidSurfaceImpact(class AFluidSurfaceActor* Fluid, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.ApplyFluidSurfaceImpact"));

	AProjectile_ApplyFluidSurfaceImpact_Params params;
	params.Fluid = Fluid;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.GetRange
// (Final, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AProjectile::STATIC_GetRange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.GetRange"));

	AProjectile_GetRange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.StaticGetTimeToLocation
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FVector                 TargetLoc                      (Parm)
// struct FVector                 StartLoc                       (Parm)
// class AController*             RequestedBy                    (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AProjectile::StaticGetTimeToLocation(const struct FVector& TargetLoc, const struct FVector& StartLoc, class AController* RequestedBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.StaticGetTimeToLocation"));

	AProjectile_StaticGetTimeToLocation_Params params;
	params.TargetLoc = TargetLoc;
	params.StartLoc = StartLoc;
	params.RequestedBy = RequestedBy;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.GetTimeToLocation
// (Defined, Iterator, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 TargetLoc                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AProjectile::STATIC_GetTimeToLocation(const struct FVector& TargetLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.GetTimeToLocation"));

	AProjectile_GetTimeToLocation_Params params;
	params.TargetLoc = TargetLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void AProjectile::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.FellOutOfWorld"));

	AProjectile_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.IsStationary
// (Final, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AProjectile::STATIC_IsStationary()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.IsStationary"));

	AProjectile_IsStationary_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.RandSpin
// (Final, Net, NetReliable, Exec, HasOptionalParms)
// Parameters:
// float                          spinRate                       (Parm)

void AProjectile::RandSpin(float spinRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.RandSpin"));

	AProjectile_RandSpin_Params params;
	params.spinRate = spinRate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.Explode
// (Final, Defined, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AProjectile::Explode(const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.Explode"));

	AProjectile_Explode_Params params;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.EncroachedBy
// (Final, Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AProjectile::EncroachedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.EncroachedBy"));

	AProjectile_EncroachedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.HitWall
// (Final, Defined, Iterator, Latent, Singular, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  Wall                           (Parm)
// class UPrimitiveComponent*     WallComp                       (Parm, EditInline)

void AProjectile::HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.HitWall"));

	AProjectile_HitWall_Params params;
	params.HitNormal = HitNormal;
	params.Wall = Wall;
	params.WallComp = WallComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.ProcessTouch
// (Latent, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AProjectile::ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.ProcessTouch"));

	AProjectile_ProcessTouch_Params params;
	params.Other = Other;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AProjectile::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.Touch"));

	AProjectile_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.HurtRadius
// (Final, Defined, Iterator, Latent, PreOperator, Net, Operator, Static)
// Parameters:
// float                          DamageAmount                   (Parm)
// float                          InDamageRadius                 (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// class AActor*                  IgnoredActor                   (OptionalParm, Parm)
// class AController*             InstigatedByController         (OptionalParm, Parm)
// bool                           bDoFullDamage                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AProjectile::STATIC_HurtRadius(float DamageAmount, float InDamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, class AActor* IgnoredActor, class AController* InstigatedByController, bool bDoFullDamage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.HurtRadius"));

	AProjectile_HurtRadius_Params params;
	params.DamageAmount = DamageAmount;
	params.InDamageRadius = InDamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.IgnoredActor = IgnoredActor;
	params.InstigatedByController = InstigatedByController;
	params.bDoFullDamage = bDoFullDamage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.ProjectileHurtRadius
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FVector                 HurtOrigin                     (Parm)
// struct FVector                 HitNormal                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AProjectile::ProjectileHurtRadius(const struct FVector& HurtOrigin, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.ProjectileHurtRadius"));

	AProjectile_ProjectileHurtRadius_Params params;
	params.HurtOrigin = HurtOrigin;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AProjectile::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.Reset"));

	AProjectile_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.CanSplash
// (Final, Iterator, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AProjectile::CanSplash()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.CanSplash"));

	AProjectile_CanSplash_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char AProjectile::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.GetTeamNum"));

	AProjectile_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Projectile.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// struct FVector                 Direction                      (Parm)

void AProjectile::Init(const struct FVector& Direction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.Init"));

	AProjectile_Init_Params params;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AProjectile::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.PostBeginPlay"));

	AProjectile_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.PreBeginPlay
// (Latent, Net, Simulated)

void AProjectile::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.PreBeginPlay"));

	AProjectile_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Projectile.EncroachingOn
// (Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AProjectile::EncroachingOn(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Projectile.EncroachingOn"));

	AProjectile_EncroachingOn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneCaptureActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ASceneCaptureActor::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCaptureActor.OnToggle"));

	ASceneCaptureActor_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PortalTeleporter.StopsProjectile
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AProjectile*             P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APortalTeleporter::StopsProjectile(class AProjectile* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalTeleporter.StopsProjectile"));

	APortalTeleporter_StopsProjectile_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PortalTeleporter.CreatePortalTexture
// (Iterator, PreOperator, Exec, Static)
// Parameters:
// class UTextureRenderTarget2D*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UTextureRenderTarget2D* APortalTeleporter::STATIC_CreatePortalTexture()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalTeleporter.CreatePortalTexture"));

	APortalTeleporter_CreatePortalTexture_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PortalTeleporter.TransformHitLocation
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APortalTeleporter::TransformHitLocation(const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalTeleporter.TransformHitLocation"));

	APortalTeleporter_TransformHitLocation_Params params;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PortalTeleporter.TransformVectorDir
// (Final, Defined, Iterator, Latent, Singular, Net, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 V                              (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APortalTeleporter::TransformVectorDir(const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalTeleporter.TransformVectorDir"));

	APortalTeleporter_TransformVectorDir_Params params;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PortalTeleporter.TransformActor
// (Final, Defined, Latent, PreOperator, Net, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APortalTeleporter::TransformActor(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PortalTeleporter.TransformActor"));

	APortalTeleporter_TransformActor_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMeshActor.PreBeginPlay
// (Latent, Net, Simulated)

void AStaticMeshActor::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshActor.PreBeginPlay"));

	AStaticMeshActor_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshActorBasedOnExtremeContent.SetMaterialBasedOnExtremeContent
// (Event, HasOptionalParms)

void AStaticMeshActorBasedOnExtremeContent::SetMaterialBasedOnExtremeContent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshActorBasedOnExtremeContent.SetMaterialBasedOnExtremeContent"));

	AStaticMeshActorBasedOnExtremeContent_SetMaterialBasedOnExtremeContent_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshActorBasedOnExtremeContent.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AStaticMeshActorBasedOnExtremeContent::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshActorBasedOnExtremeContent.PostBeginPlay"));

	AStaticMeshActorBasedOnExtremeContent_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Trigger.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ATrigger_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ATrigger::ApplyCheckpointRecord(struct ATrigger_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.ApplyCheckpointRecord"));

	ATrigger_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.Trigger.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ATrigger_FCheckpointRecord Record                         (Parm, OutParm)

void ATrigger::STATIC_CreateCheckpointRecord(struct ATrigger_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.CreateCheckpointRecord"));

	ATrigger_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.Trigger.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATrigger::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.ShouldSaveForCheckpoint"));

	ATrigger_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Trigger.StopsProjectile
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AProjectile*             P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATrigger::StopsProjectile(class AProjectile* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.StopsProjectile"));

	ATrigger_StopsProjectile_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Trigger.UnTrigger
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void ATrigger::UnTrigger()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.UnTrigger"));

	ATrigger_UnTrigger_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Trigger.NotifyTriggered
// (Final, Defined, Iterator, Singular, Net, Simulated, Exec, Event, Operator, Static)

void ATrigger::STATIC_NotifyTriggered()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.NotifyTriggered"));

	ATrigger_NotifyTriggered_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Trigger.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void ATrigger::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.Touch"));

	ATrigger_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Trigger.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ATrigger::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger.PostBeginPlay"));

	ATrigger_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.GetAParticleSystemComponent
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* UActorComponent::STATIC_GetAParticleSystemComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorComponent.GetAParticleSystemComponent"));

	UActorComponent_GetAParticleSystemComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.DetachFromAny
// (Latent, Net, NetReliable, Native, Static)

void UActorComponent::STATIC_DetachFromAny()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorComponent.DetachFromAny"));

	UActorComponent_DetachFromAny_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.ForceUpdate
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// bool                           bTransformOnly                 (Parm)

void UActorComponent::STATIC_ForceUpdate(bool bTransformOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorComponent.ForceUpdate"));

	UActorComponent_ForceUpdate_Params params;
	params.bTransformOnly = bTransformOnly;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetComponentRBFixed
// (Final, Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bFixed                         (Parm)

void UActorComponent::SetComponentRBFixed(bool bFixed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorComponent.SetComponentRBFixed"));

	UActorComponent_SetComponentRBFixed_Params params;
	params.bFixed = bFixed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetTickGroup
// (Defined, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ETickingGroup>     NewTickGroup                   (Parm)

void UActorComponent::SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorComponent.SetTickGroup"));

	UActorComponent_SetTickGroup_Params params;
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.OcclusionChanged
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Event, Operator, Static)
// Parameters:
// bool                           bNowOccluded                   (Parm)

void UAudioComponent::STATIC_OcclusionChanged(bool bNowOccluded)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.OcclusionChanged"));

	UAudioComponent_OcclusionChanged_Params params;
	params.bNowOccluded = bNowOccluded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.OnQueueSubtitles
// (Final, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// TArray<struct FSubtitleCue>    Subtitles                      (Parm, NeedCtorLink)
// float                          CueDuration                    (Parm)

void UAudioComponent::STATIC_OnQueueSubtitles(TArray<struct FSubtitleCue> Subtitles, float CueDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.OnQueueSubtitles"));

	UAudioComponent_OnQueueSubtitles_Params params;
	params.Subtitles = Subtitles;
	params.CueDuration = CueDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.OnAudioFinishedFX
// (Latent, PreOperator, Simulated, Native)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)

void UAudioComponent::OnAudioFinishedFX(class UAudioComponent* AC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.OnAudioFinishedFX"));

	UAudioComponent_OnAudioFinishedFX_Params params;
	params.AC = AC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.OnAudioFinished
// (Final, Iterator, PreOperator, Singular, NetReliable, Native)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)

void UAudioComponent::OnAudioFinished(class UAudioComponent* AC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.OnAudioFinished"));

	UAudioComponent_OnAudioFinished_Params params;
	params.AC = AC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.ResetToDefaults
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, Operator, HasOptionalParms)

void UAudioComponent::ResetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.ResetToDefaults"));

	UAudioComponent_ResetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetWaveParameter
// (Final, PreOperator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   InName                         (Parm)
// class USoundNodeWave*          InWave                         (Parm)

void UAudioComponent::SetWaveParameter(const struct FName& InName, class USoundNodeWave* InWave)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.SetWaveParameter"));

	UAudioComponent_SetWaveParameter_Params params;
	params.InName = InName;
	params.InWave = InWave;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetFloatParameter
// (Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   InName                         (Parm)
// float                          InFloat                        (Parm)

void UAudioComponent::SetFloatParameter(const struct FName& InName, float InFloat)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.SetFloatParameter"));

	UAudioComponent_SetFloatParameter_Params params;
	params.InName = InName;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.AdjustVolume
// (Final, Defined, PreOperator, Net, Operator)
// Parameters:
// float                          AdjustVolumeDuration           (Parm)
// float                          AdjustVolumeLevel              (Parm)

void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.AdjustVolume"));

	UAudioComponent_AdjustVolume_Params params;
	params.AdjustVolumeDuration = AdjustVolumeDuration;
	params.AdjustVolumeLevel = AdjustVolumeLevel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.FadeOut
// (Iterator, Exec, Event, Static)
// Parameters:
// float                          FadeOutDuration                (Parm)
// float                          FadeVolumeLevel                (Parm)
// float                          FadePitchLevel                 (OptionalParm, Parm)

void UAudioComponent::STATIC_FadeOut(float FadeOutDuration, float FadeVolumeLevel, float FadePitchLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.FadeOut"));

	UAudioComponent_FadeOut_Params params;
	params.FadeOutDuration = FadeOutDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;
	params.FadePitchLevel = FadePitchLevel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.FadeIn
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Event, Static)
// Parameters:
// float                          FadeInDuration                 (Parm)
// float                          FadeVolumeLevel                (Parm)

void UAudioComponent::STATIC_FadeIn(float FadeInDuration, float FadeVolumeLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.FadeIn"));

	UAudioComponent_FadeIn_Params params;
	params.FadeInDuration = FadeInDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.IsFadingOut
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAudioComponent::STATIC_IsFadingOut()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.IsFadingOut"));

	UAudioComponent_IsFadingOut_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.IsFadingIn
// (Defined, Iterator, Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAudioComponent::STATIC_IsFadingIn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.IsFadingIn"));

	UAudioComponent_IsFadingIn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.IsPlaying
// (Defined, Iterator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAudioComponent::STATIC_IsPlaying()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.IsPlaying"));

	UAudioComponent_IsPlaying_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.Stop
// (Final, Defined, Iterator, Latent, Singular, Net, Exec)
// Parameters:
// bool                           bFadeOut                       (OptionalParm, Parm)

void UAudioComponent::Stop(bool bFadeOut)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.Stop"));

	UAudioComponent_Stop_Params params;
	params.bFadeOut = bFadeOut;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.Play
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UAudioComponent::Play()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.Play"));

	UAudioComponent_Play_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.ApplyAdditionalPriority
// (Final, Latent, Singular, NetReliable, Simulated, Operator)

void UAudioComponent::ApplyAdditionalPriority()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioComponent.ApplyAdditionalPriority"));

	UAudioComponent_ApplyAdditionalPriority_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HeightFogComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void UHeightFogComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HeightFogComponent.SetEnabled"));

	UHeightFogComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.ClosestPointOnComponentToComponent
// (Defined, PreOperator, Net, Static)
// Parameters:
// class UPrimitiveComponent*     OtherComponent                 (Parm, OutParm, EditInline)
// struct FVector                 PointOnComponentA              (Parm, OutParm)
// struct FVector                 PointOnComponentB              (Parm, OutParm)
// TEnumAsByte<EGJKResult>        ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EGJKResult> UPrimitiveComponent::STATIC_ClosestPointOnComponentToComponent(class UPrimitiveComponent** OtherComponent, struct FVector* PointOnComponentA, struct FVector* PointOnComponentB)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.ClosestPointOnComponentToComponent"));

	UPrimitiveComponent_ClosestPointOnComponentToComponent_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OtherComponent != nullptr)
		*OtherComponent = params.OtherComponent;
	if (PointOnComponentA != nullptr)
		*PointOnComponentA = params.PointOnComponentA;
	if (PointOnComponentB != nullptr)
		*PointOnComponentB = params.PointOnComponentB;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.ClosestPointOnComponentToPoint
// (Final, Defined, PreOperator, Net, Static)
// Parameters:
// struct FVector                 POI                            (Parm, OutParm)
// struct FVector                 Extent                         (Parm, OutParm)
// struct FVector                 OutPointA                      (Parm, OutParm)
// struct FVector                 OutPointB                      (Parm, OutParm)
// TEnumAsByte<EGJKResult>        ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EGJKResult> UPrimitiveComponent::STATIC_ClosestPointOnComponentToPoint(struct FVector* POI, struct FVector* Extent, struct FVector* OutPointA, struct FVector* OutPointB)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.ClosestPointOnComponentToPoint"));

	UPrimitiveComponent_ClosestPointOnComponentToPoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (POI != nullptr)
		*POI = params.POI;
	if (Extent != nullptr)
		*Extent = params.Extent;
	if (OutPointA != nullptr)
		*OutPointA = params.OutPointA;
	if (OutPointB != nullptr)
		*OutPointB = params.OutPointB;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetRotation
// (Final, Iterator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator UPrimitiveComponent::STATIC_GetRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.GetRotation"));

	UPrimitiveComponent_GetRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPosition
// (Defined, Iterator, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UPrimitiveComponent::STATIC_GetPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.GetPosition"));

	UPrimitiveComponent_GetPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.SetAbsolute
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           NewAbsoluteTranslation         (OptionalParm, Parm)
// bool                           NewAbsoluteRotation            (OptionalParm, Parm)
// bool                           NewAbsoluteScale               (OptionalParm, Parm)

void UPrimitiveComponent::SetAbsolute(bool NewAbsoluteTranslation, bool NewAbsoluteRotation, bool NewAbsoluteScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetAbsolute"));

	UPrimitiveComponent_SetAbsolute_Params params;
	params.NewAbsoluteTranslation = NewAbsoluteTranslation;
	params.NewAbsoluteRotation = NewAbsoluteRotation;
	params.NewAbsoluteScale = NewAbsoluteScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetScale3D
// (Final, Iterator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewScale3D                     (Parm)

void UPrimitiveComponent::SetScale3D(const struct FVector& NewScale3D)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetScale3D"));

	UPrimitiveComponent_SetScale3D_Params params;
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetScale
// (Iterator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// float                          NewScale                       (Parm)

void UPrimitiveComponent::SetScale(float NewScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetScale"));

	UPrimitiveComponent_SetScale_Params params;
	params.NewScale = NewScale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRotation
// (Defined, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)

void UPrimitiveComponent::SetRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRotation"));

	UPrimitiveComponent_SetRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetTranslation
// (Final, Defined, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewTranslation                 (Parm)

void UPrimitiveComponent::SetTranslation(const struct FVector& NewTranslation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetTranslation"));

	UPrimitiveComponent_SetTranslation_Params params;
	params.NewTranslation = NewTranslation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetActorCollision
// (Defined, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           NewCollideActors               (Parm)
// bool                           NewBlockActors                 (Parm)
// bool                           NewAlwaysCheckCollision        (OptionalParm, Parm)

void UPrimitiveComponent::SetActorCollision(bool NewCollideActors, bool NewBlockActors, bool NewAlwaysCheckCollision)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetActorCollision"));

	UPrimitiveComponent_SetActorCollision_Params params;
	params.NewCollideActors = NewCollideActors;
	params.NewBlockActors = NewBlockActors;
	params.NewAlwaysCheckCollision = NewAlwaysCheckCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetTraceBlocking
// (Defined, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           NewBlockZeroExtent             (Parm)
// bool                           NewBlockNonZeroExtent          (Parm)

void UPrimitiveComponent::SetTraceBlocking(bool NewBlockZeroExtent, bool NewBlockNonZeroExtent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetTraceBlocking"));

	UPrimitiveComponent_SetTraceBlocking_Params params;
	params.NewBlockZeroExtent = NewBlockZeroExtent;
	params.NewBlockNonZeroExtent = NewBlockNonZeroExtent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetViewOwnerDepthPriorityGroup
// (Iterator, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bNewUseViewOwnerDepthPriorityGroup (Parm)
// TEnumAsByte<ESceneDepthPriorityGroup> NewViewOwnerDepthPriorityGroup (Parm)

void UPrimitiveComponent::SetViewOwnerDepthPriorityGroup(bool bNewUseViewOwnerDepthPriorityGroup, TEnumAsByte<ESceneDepthPriorityGroup> NewViewOwnerDepthPriorityGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetViewOwnerDepthPriorityGroup"));

	UPrimitiveComponent_SetViewOwnerDepthPriorityGroup_Params params;
	params.bNewUseViewOwnerDepthPriorityGroup = bNewUseViewOwnerDepthPriorityGroup;
	params.NewViewOwnerDepthPriorityGroup = NewViewOwnerDepthPriorityGroup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetDepthPriorityGroup
// (Singular, Net, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ESceneDepthPriorityGroup> NewDepthPriorityGroup          (Parm)

void UPrimitiveComponent::SetDepthPriorityGroup(TEnumAsByte<ESceneDepthPriorityGroup> NewDepthPriorityGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetDepthPriorityGroup"));

	UPrimitiveComponent_SetDepthPriorityGroup_Params params;
	params.NewDepthPriorityGroup = NewDepthPriorityGroup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetLightingChannels
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FLightingChannelContainer NewLightingChannels            (Parm)

void UPrimitiveComponent::SetLightingChannels(const struct FLightingChannelContainer& NewLightingChannels)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetLightingChannels"));

	UPrimitiveComponent_SetLightingChannels_Params params;
	params.NewLightingChannels = NewLightingChannels;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCullDistance
// (Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewCullDistance                (Parm)

void UPrimitiveComponent::SetCullDistance(float NewCullDistance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetCullDistance"));

	UPrimitiveComponent_SetCullDistance_Params params;
	params.NewCullDistance = NewCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetLightEnvironment
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ULightEnvironmentComponent* NewLightEnvironment            (Parm, EditInline)

void UPrimitiveComponent::SetLightEnvironment(class ULightEnvironmentComponent* NewLightEnvironment)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetLightEnvironment"));

	UPrimitiveComponent_SetLightEnvironment_Params params;
	params.NewLightEnvironment = NewLightEnvironment;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetShadowParent
// (Defined, Iterator, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     NewShadowParent                (Parm, EditInline)

void UPrimitiveComponent::SetShadowParent(class UPrimitiveComponent* NewShadowParent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetShadowParent"));

	UPrimitiveComponent_SetShadowParent_Params params;
	params.NewShadowParent = NewShadowParent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetIgnoreOwnerHidden
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewIgnoreOwnerHidden          (Parm)

void UPrimitiveComponent::SetIgnoreOwnerHidden(bool bNewIgnoreOwnerHidden)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetIgnoreOwnerHidden"));

	UPrimitiveComponent_SetIgnoreOwnerHidden_Params params;
	params.bNewIgnoreOwnerHidden = bNewIgnoreOwnerHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
// (Final, Iterator, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bNewOnlyOwnerSee               (Parm)

void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetOnlyOwnerSee"));

	UPrimitiveComponent_SetOnlyOwnerSee_Params params;
	params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetOwnerNoSee
// (Defined, Singular, Event, HasOptionalParms)
// Parameters:
// bool                           bNewOwnerNoSee                 (Parm)

void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetOwnerNoSee"));

	UPrimitiveComponent_SetOwnerNoSee_Params params;
	params.bNewOwnerNoSee = bNewOwnerNoSee;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetHidden
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           NewHidden                      (Parm)

void UPrimitiveComponent::SetHidden(bool NewHidden)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetHidden"));

	UPrimitiveComponent_SetHidden_Params params;
	params.NewHidden = NewHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.ShouldComponentAddToScene
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPrimitiveComponent::ShouldComponentAddToScene()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.ShouldComponentAddToScene"));

	UPrimitiveComponent_ShouldComponentAddToScene_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.SetRBDominanceGroup
// (Final, Iterator, Latent, Net, Event, HasOptionalParms)
// Parameters:
// unsigned char                  InDomGroup                     (Parm)

void UPrimitiveComponent::SetRBDominanceGroup(unsigned char InDomGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBDominanceGroup"));

	UPrimitiveComponent_SetRBDominanceGroup_Params params;
	params.InDomGroup = InDomGroup;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.GetRootBodyInstance
// (Iterator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class URB_BodyInstance*        ReturnValue                    (Parm, OutParm, ReturnParm)

class URB_BodyInstance* UPrimitiveComponent::STATIC_GetRootBodyInstance()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.GetRootBodyInstance"));

	UPrimitiveComponent_GetRootBodyInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
// (Iterator, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class UPhysicalMaterial*       NewPhysMaterial                (Parm)

void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetPhysMaterialOverride"));

	UPrimitiveComponent_SetPhysMaterialOverride_Params params;
	params.NewPhysMaterial = NewPhysMaterial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.InitRBPhys
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Operator, Static)

void UPrimitiveComponent::STATIC_InitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.InitRBPhys"));

	UPrimitiveComponent_InitRBPhys_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
// (Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bNewNotifyRigidBodyCollision   (Parm)

void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision"));

	UPrimitiveComponent_SetNotifyRigidBodyCollision_Params params;
	params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBChannel
// (Defined, Latent, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERBCollisionChannel> Channel                        (Parm)

void UPrimitiveComponent::SetRBChannel(TEnumAsByte<ERBCollisionChannel> Channel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBChannel"));

	UPrimitiveComponent_SetRBChannel_Params params;
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBCollisionChannels
// (Iterator, Latent, Net, Event, HasOptionalParms)
// Parameters:
// struct FRBCollisionChannelContainer Channels                       (Parm)

void UPrimitiveComponent::SetRBCollisionChannels(const struct FRBCollisionChannelContainer& Channels)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBCollisionChannels"));

	UPrimitiveComponent_SetRBCollisionChannels_Params params;
	params.Channels = Channels;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBCollidesWithChannel
// (Final, Defined, Latent, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERBCollisionChannel> Channel                        (Parm)
// bool                           bNewCollides                   (Parm)

void UPrimitiveComponent::SetRBCollidesWithChannel(TEnumAsByte<ERBCollisionChannel> Channel, bool bNewCollides)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBCollidesWithChannel"));

	UPrimitiveComponent_SetRBCollidesWithChannel_Params params;
	params.Channel = Channel;
	params.bNewCollides = bNewCollides;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetBlockRigidBody
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewBlockRigidBody             (Parm)

void UPrimitiveComponent::SetBlockRigidBody(bool bNewBlockRigidBody)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetBlockRigidBody"));

	UPrimitiveComponent_SetBlockRigidBody_Params params;
	params.bNewBlockRigidBody = bNewBlockRigidBody;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.RigidBodyIsAwake
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPrimitiveComponent::RigidBodyIsAwake(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.RigidBodyIsAwake"));

	UPrimitiveComponent_RigidBodyIsAwake_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
// (Final, Singular, Net, Exec, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::PutRigidBodyToSleep(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.PutRigidBodyToSleep"));

	UPrimitiveComponent_PutRigidBodyToSleep_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.WakeRigidBody
// (Latent, PreOperator, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::WakeRigidBody(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.WakeRigidBody"));

	UPrimitiveComponent_WakeRigidBody_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBRotation
// (PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRot                         (Parm)
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::SetRBRotation(const struct FRotator& NewRot, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBRotation"));

	UPrimitiveComponent_SetRBRotation_Params params;
	params.NewRot = NewRot;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBPosition
// (Final, Defined, Iterator, Latent, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewPos                         (Parm)
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::SetRBPosition(const struct FVector& NewPos, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBPosition"));

	UPrimitiveComponent_SetRBPosition_Params params;
	params.NewPos = NewPos;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.RetardRBLinearVelocity
// (Final, Iterator, Latent, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// struct FVector                 RetardDir                      (Parm)
// float                          VelScale                       (Parm)

void UPrimitiveComponent::RetardRBLinearVelocity(const struct FVector& RetardDir, float VelScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.RetardRBLinearVelocity"));

	UPrimitiveComponent_RetardRBLinearVelocity_Params params;
	params.RetardDir = RetardDir;
	params.VelScale = VelScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBAngularVelocity
// (Final, Latent, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewAngVel                      (Parm)
// bool                           bAddToCurrent                  (OptionalParm, Parm)

void UPrimitiveComponent::SetRBAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBAngularVelocity"));

	UPrimitiveComponent_SetRBAngularVelocity_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRBLinearVelocity
// (Defined, Iterator, Latent, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewVel                         (Parm)
// bool                           bAddToCurrent                  (OptionalParm, Parm)

void UPrimitiveComponent::SetRBLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.SetRBLinearVelocity"));

	UPrimitiveComponent_SetRBLinearVelocity_Params params;
	params.NewVel = NewVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddTorque
// (Final, Iterator, PreOperator, Singular, Operator)
// Parameters:
// struct FVector                 Torque                         (Parm)
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::AddTorque(const struct FVector& Torque, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.AddTorque"));

	UPrimitiveComponent_AddTorque_Params params;
	params.Torque = Torque;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddRadialForce
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// float                          Strength                       (Parm)
// TEnumAsByte<ERadialImpulseFalloff> Falloff                        (Parm)

void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.AddRadialForce"));

	UPrimitiveComponent_AddRadialForce_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddForce
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Force                          (Parm)
// struct FVector                 Position                       (OptionalParm, Parm)
// struct FName                   BoneName                       (OptionalParm, Parm)

void UPrimitiveComponent::AddForce(const struct FVector& Force, const struct FVector& Position, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.AddForce"));

	UPrimitiveComponent_AddForce_Params params;
	params.Force = Force;
	params.Position = Position;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddRadialImpulse
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// float                          Strength                       (Parm)
// TEnumAsByte<ERadialImpulseFalloff> Falloff                        (Parm)
// bool                           bVelChange                     (OptionalParm, Parm)

void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.AddRadialImpulse"));

	UPrimitiveComponent_AddRadialImpulse_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddImpulse
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Impulse                        (Parm)
// struct FVector                 Position                       (OptionalParm, Parm)
// struct FName                   BoneName                       (OptionalParm, Parm)
// bool                           bVelChange                     (OptionalParm, Parm)

void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, const struct FVector& Position, const struct FName& BoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrimitiveComponent.AddImpulse"));

	UPrimitiveComponent_AddImpulse_Params params;
	params.Impulse = Impulse;
	params.Position = Position;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CylinderComponent.SetCylinderSize
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewRadius                      (Parm)
// float                          NewHeight                      (Parm)

void UCylinderComponent::SetCylinderSize(float NewRadius, float NewHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CylinderComponent.SetCylinderSize"));

	UCylinderComponent_SetCylinderSize_Params params;
	params.NewRadius = NewRadius;
	params.NewHeight = NewHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpriteComponent.SetSpriteAndUV
// (Final, NetReliable, Event, HasOptionalParms)
// Parameters:
// class UTexture2D*              NewSprite                      (Parm)
// int                            NewU                           (Parm)
// int                            NewUL                          (Parm)
// int                            NewV                           (Parm)
// int                            NewVL                          (Parm)

void USpriteComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int NewU, int NewUL, int NewV, int NewVL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpriteComponent.SetSpriteAndUV"));

	USpriteComponent_SetSpriteAndUV_Params params;
	params.NewSprite = NewSprite;
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpriteComponent.SetUV
// (Defined, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            NewU                           (Parm)
// int                            NewUL                          (Parm)
// int                            NewV                           (Parm)
// int                            NewVL                          (Parm)

void USpriteComponent::SetUV(int NewU, int NewUL, int NewV, int NewVL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpriteComponent.SetUV"));

	USpriteComponent_SetUV_Params params;
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpriteComponent.SetSprite
// (NetReliable, Event, HasOptionalParms)
// Parameters:
// class UTexture2D*              NewSprite                      (Parm)

void USpriteComponent::SetSprite(class UTexture2D* NewSprite)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpriteComponent.SetSprite"));

	USpriteComponent_SetSprite_Params params;
	params.NewSprite = NewSprite;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TgSilhouetteComponent.SetDistance
// (Final, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InNearDistance                 (Parm)
// float                          InFarDistance                  (Parm)

void UTgSilhouetteComponent::SetDistance(float InNearDistance, float InFarDistance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TgSilhouetteComponent.SetDistance"));

	UTgSilhouetteComponent_SetDistance_Params params;
	params.InNearDistance = InNearDistance;
	params.InFarDistance = InFarDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TgSilhouetteComponent.SetNegative
// (Final, Defined, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bNegative                      (Parm)

void UTgSilhouetteComponent::SetNegative(bool bNegative)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TgSilhouetteComponent.SetNegative"));

	UTgSilhouetteComponent_SetNegative_Params params;
	params.bNegative = bNegative;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TgSilhouetteComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnabled                     (Parm)

void UTgSilhouetteComponent::SetEnabled(bool bInEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TgSilhouetteComponent.SetEnabled"));

	UTgSilhouetteComponent_SetEnabled_Params params;
	params.bInEnabled = bInEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.OnUpdatePropertyBlurOpacity
// (Final, Singular, Simulated, Native, Event, Operator, Static)

void URadialBlurComponent::STATIC_OnUpdatePropertyBlurOpacity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.OnUpdatePropertyBlurOpacity"));

	URadialBlurComponent_OnUpdatePropertyBlurOpacity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.OnUpdatePropertyBlurFalloffExponent
// (Singular, Simulated, Native, Event, Operator, Static)

void URadialBlurComponent::STATIC_OnUpdatePropertyBlurFalloffExponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.OnUpdatePropertyBlurFalloffExponent"));

	URadialBlurComponent_OnUpdatePropertyBlurFalloffExponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.OnUpdatePropertyBlurScale
// (Defined, Singular, Simulated, Native, Event, Operator, Static)

void URadialBlurComponent::STATIC_OnUpdatePropertyBlurScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.OnUpdatePropertyBlurScale"));

	URadialBlurComponent_OnUpdatePropertyBlurScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnabled                     (Parm)

void URadialBlurComponent::SetEnabled(bool bInEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.SetEnabled"));

	URadialBlurComponent_SetEnabled_Params params;
	params.bInEnabled = bInEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.SetBlurOpacity
// (Final, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InBlurOpacity                  (Parm)

void URadialBlurComponent::SetBlurOpacity(float InBlurOpacity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.SetBlurOpacity"));

	URadialBlurComponent_SetBlurOpacity_Params params;
	params.InBlurOpacity = InBlurOpacity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.SetBlurFalloffExponent
// (PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InBlurFalloffExponent          (Parm)

void URadialBlurComponent::SetBlurFalloffExponent(float InBlurFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.SetBlurFalloffExponent"));

	URadialBlurComponent_SetBlurFalloffExponent_Params params;
	params.InBlurFalloffExponent = InBlurFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.SetBlurScale
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InBlurScale                    (Parm)

void URadialBlurComponent::SetBlurScale(float InBlurScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.SetBlurScale"));

	URadialBlurComponent_SetBlurScale_Params params;
	params.InBlurScale = InBlurScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialBlurComponent.SetMaterial
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      InMaterial                     (Parm)

void URadialBlurComponent::SetMaterial(class UMaterialInterface* InMaterial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RadialBlurComponent.SetMaterial"));

	URadialBlurComponent_SetMaterial_Params params;
	params.InMaterial = InMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnable                        (Parm)

void USceneCaptureComponent::SetEnabled(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCaptureComponent.SetEnabled"));

	USceneCaptureComponent_SetEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.SetFrameRate
// (PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewFrameRate                   (Parm)

void USceneCaptureComponent::SetFrameRate(float NewFrameRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCaptureComponent.SetFrameRate"));

	USceneCaptureComponent_SetFrameRate_Params params;
	params.NewFrameRate = NewFrameRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapture2DComponent.SetView
// (Defined, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Parm)
// struct FRotator                NewRotation                    (Parm)

void USceneCapture2DComponent::SetView(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapture2DComponent.SetView"));

	USceneCapture2DComponent_SetView_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapture2DComponent.SetCaptureParameters
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UTextureRenderTarget2D*  NewTextureTarget               (OptionalParm, Parm)
// float                          NewFOV                         (OptionalParm, Parm)
// float                          NewNearPlane                   (OptionalParm, Parm)
// float                          NewFarPlane                    (OptionalParm, Parm)

void USceneCapture2DComponent::SetCaptureParameters(class UTextureRenderTarget2D* NewTextureTarget, float NewFOV, float NewNearPlane, float NewFarPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapture2DComponent.SetCaptureParameters"));

	USceneCapture2DComponent_SetCaptureParameters_Params params;
	params.NewTextureTarget = NewTextureTarget;
	params.NewFOV = NewFOV;
	params.NewNearPlane = NewNearPlane;
	params.NewFarPlane = NewFarPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapture2DHitMaskComponent.SetFadingStartTimeSinceHit
// (Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InFadingStartTimeSinceHit      (Const, Parm)

void USceneCapture2DHitMaskComponent::SetFadingStartTimeSinceHit(float InFadingStartTimeSinceHit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapture2DHitMaskComponent.SetFadingStartTimeSinceHit"));

	USceneCapture2DHitMaskComponent_SetFadingStartTimeSinceHit_Params params;
	params.InFadingStartTimeSinceHit = InFadingStartTimeSinceHit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapture2DHitMaskComponent.SetCaptureParameters
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InMaskPosition                 (Const, Parm)
// float                          InMaskRadius                   (Const, Parm)
// struct FVector                 InStartupPosition              (Const, Parm)
// bool                           bOnlyWhenFacing                (Const, Parm)

void USceneCapture2DHitMaskComponent::SetCaptureParameters(const struct FVector& InMaskPosition, float InMaskRadius, const struct FVector& InStartupPosition, bool bOnlyWhenFacing)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapture2DHitMaskComponent.SetCaptureParameters"));

	USceneCapture2DHitMaskComponent_SetCaptureParameters_Params params;
	params.InMaskPosition = InMaskPosition;
	params.InMaskRadius = InMaskRadius;
	params.InStartupPosition = InStartupPosition;
	params.bOnlyWhenFacing = bOnlyWhenFacing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapture2DHitMaskComponent.SetCaptureTargetTexture
// (Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UTextureRenderTarget2D*  InTextureTarget                (Const, Parm)

void USceneCapture2DHitMaskComponent::SetCaptureTargetTexture(class UTextureRenderTarget2D* InTextureTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapture2DHitMaskComponent.SetCaptureTargetTexture"));

	USceneCapture2DHitMaskComponent_SetCaptureTargetTexture_Params params;
	params.InTextureTarget = InTextureTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCapturePortalComponent.SetCaptureParameters
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UTextureRenderTarget2D*  NewTextureTarget               (OptionalParm, Parm)
// float                          NewScaleFOV                    (OptionalParm, Parm)
// class AActor*                  NewViewDest                    (OptionalParm, Parm)

void USceneCapturePortalComponent::SetCaptureParameters(class UTextureRenderTarget2D* NewTextureTarget, float NewScaleFOV, class AActor* NewViewDest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SceneCapturePortalComponent.SetCaptureParameters"));

	USceneCapturePortalComponent_SetCaptureParameters_Params params;
	params.NewTextureTarget = NewTextureTarget;
	params.NewScaleFOV = NewScaleFOV;
	params.NewViewDest = NewViewDest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorFactory.PostCreateActor
// (Final, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  NewActor                       (Parm)
// class USeqAct_ActorFactory*    ActorFactoryData               (Const, OptionalParm, Parm)

void UActorFactory::PostCreateActor(class AActor* NewActor, class USeqAct_ActorFactory* ActorFactoryData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ActorFactory.PostCreateActor"));

	UActorFactory_PostCreateActor_Params params;
	params.NewActor = NewActor;
	params.ActorFactoryData = ActorFactoryData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundCue.GetCueDuration
// (Iterator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USoundCue::STATIC_GetCueDuration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundCue.GetCueDuration"));

	USoundCue_GetCueDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.DrawDebugGraph
// (Final, Defined, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// struct FString                 Title                          (Parm, CoerceParm, NeedCtorLink)
// float                          ValueX                         (Parm)
// float                          ValueY                         (Parm)
// float                          UL_X                           (Parm)
// float                          UL_Y                           (Parm)
// float                          W                              (Parm)
// float                          H                              (Parm)
// struct FVector2D               RangeX                         (Parm)
// struct FVector2D               RangeY                         (Parm)

void UCanvas::STATIC_DrawDebugGraph(const struct FString& Title, float ValueX, float ValueY, float UL_X, float UL_Y, float W, float H, const struct FVector2D& RangeX, const struct FVector2D& RangeY)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawDebugGraph"));

	UCanvas_DrawDebugGraph_Params params;
	params.Title = Title;
	params.ValueX = ValueX;
	params.ValueY = ValueY;
	params.UL_X = UL_X;
	params.UL_Y = UL_Y;
	params.W = W;
	params.H = H;
	params.RangeX = RangeX;
	params.RangeY = RangeY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTextureDoubleLine
// (Defined, Singular, Net, Exec, Native, Static)
// Parameters:
// struct FVector                 StartPoint                     (Parm)
// struct FVector                 EndPoint                       (Parm)
// float                          Perc                           (Parm)
// float                          Spacing                        (Parm)
// float                          Width                          (Parm)
// struct FColor                  LineColor                      (Parm)
// struct FColor                  AltLineColor                   (Parm)
// class UTexture*                Tex                            (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)

void UCanvas::STATIC_DrawTextureDoubleLine(const struct FVector& StartPoint, const struct FVector& EndPoint, float Perc, float Spacing, float Width, const struct FColor& LineColor, const struct FColor& AltLineColor, class UTexture* Tex, float U, float V, float UL, float VL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTextureDoubleLine"));

	UCanvas_DrawTextureDoubleLine_Params params;
	params.StartPoint = StartPoint;
	params.EndPoint = EndPoint;
	params.Perc = Perc;
	params.Spacing = Spacing;
	params.Width = Width;
	params.LineColor = LineColor;
	params.AltLineColor = AltLineColor;
	params.Tex = Tex;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTextureLine
// (Final, Defined, Singular, Net, Exec, Native, Static)
// Parameters:
// struct FVector                 StartPoint                     (Parm)
// struct FVector                 EndPoint                       (Parm)
// float                          Perc                           (Parm)
// float                          Width                          (Parm)
// struct FColor                  LineColor                      (Parm)
// class UTexture*                LineTexture                    (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)

void UCanvas::STATIC_DrawTextureLine(const struct FVector& StartPoint, const struct FVector& EndPoint, float Perc, float Width, const struct FColor& LineColor, class UTexture* LineTexture, float U, float V, float UL, float VL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTextureLine"));

	UCanvas_DrawTextureLine_Params params;
	params.StartPoint = StartPoint;
	params.EndPoint = EndPoint;
	params.Perc = Perc;
	params.Width = Width;
	params.LineColor = LineColor;
	params.LineTexture = LineTexture;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.Draw2DLine
// (Singular, Exec, Native, Static)
// Parameters:
// float                          X1                             (Parm)
// float                          Y1                             (Parm)
// float                          X2                             (Parm)
// float                          Y2                             (Parm)
// struct FColor                  LineColor                      (Parm)

void UCanvas::STATIC_Draw2DLine(float X1, float Y1, float X2, float Y2, const struct FColor& LineColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.Draw2DLine"));

	UCanvas_Draw2DLine_Params params;
	params.X1 = X1;
	params.Y1 = Y1;
	params.X2 = X2;
	params.Y2 = Y2;
	params.LineColor = LineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.SetDrawColorStruct
// (Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FColor                  C                              (Parm)

void UCanvas::SetDrawColorStruct(const struct FColor& C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.SetDrawColorStruct"));

	UCanvas_SetDrawColorStruct_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.SetDrawColor
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  R                              (Parm)
// unsigned char                  G                              (Parm)
// unsigned char                  B                              (Parm)
// unsigned char                  A                              (OptionalParm, Parm)

void UCanvas::SetDrawColor(unsigned char R, unsigned char G, unsigned char B, unsigned char A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.SetDrawColor"));

	UCanvas_SetDrawColor_Params params;
	params.R = R;
	params.G = G;
	params.B = B;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawBox
// (Iterator, Singular, Exec, Native, Static)
// Parameters:
// float                          Width                          (Parm)
// float                          Height                         (Parm)

void UCanvas::STATIC_DrawBox(float Width, float Height)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawBox"));

	UCanvas_DrawBox_Params params;
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawRect
// (Final, Defined, PreOperator, Net, Exec, Native, Static)
// Parameters:
// float                          RectX                          (Parm)
// float                          RectY                          (Parm)
// class UTexture*                Tex                            (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawRect(float RectX, float RectY, class UTexture* Tex, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawRect"));

	UCanvas_DrawRect_Params params;
	params.RectX = RectX;
	params.RectY = RectY;
	params.Tex = Tex;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawIcon
// (Net, Exec, Native, Static)
// Parameters:
// struct FCanvasIcon             Icon                           (Parm)
// float                          X                              (Parm)
// float                          Y                              (Parm)
// float                          Scale                          (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawIcon(const struct FCanvasIcon& Icon, float X, float Y, float Scale, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawIcon"));

	UCanvas_DrawIcon_Params params;
	params.Icon = Icon;
	params.X = X;
	params.Y = Y;
	params.Scale = Scale;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawScaledIcon
// (Final, Latent, PreOperator, Net, Exec, Native, Static)
// Parameters:
// struct FCanvasIcon             Icon                           (Parm)
// float                          X                              (Parm)
// float                          Y                              (Parm)
// struct FVector                 Scale                          (Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawScaledIcon(const struct FCanvasIcon& Icon, float X, float Y, const struct FVector& Scale, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawScaledIcon"));

	UCanvas_DrawScaledIcon_Params params;
	params.Icon = Icon;
	params.X = X;
	params.Y = Y;
	params.Scale = Scale;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.MakeIcon
// (Final, PreOperator, Net, Exec, Native, Operator, Static)
// Parameters:
// class UTexture*                Texture                        (Parm)
// float                          U                              (OptionalParm, Parm)
// float                          V                              (OptionalParm, Parm)
// float                          UL                             (OptionalParm, Parm)
// float                          VL                             (OptionalParm, Parm)
// struct FCanvasIcon             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FCanvasIcon UCanvas::STATIC_MakeIcon(class UTexture* Texture, float U, float V, float UL, float VL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.MakeIcon"));

	UCanvas_MakeIcon_Params params;
	params.Texture = Texture;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.DrawBlendedTile
// (Final, Defined, Singular, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)
// TEnumAsByte<ECanvasBlendMode>  Blend                          (Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawBlendedTile(class UTexture* Tex, float XL, float YL, float U, float V, float UL, float VL, TEnumAsByte<ECanvasBlendMode> Blend, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawBlendedTile"));

	UCanvas_DrawBlendedTile_Params params;
	params.Tex = Tex;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.Blend = Blend;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTexture
// (Final, Singular, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// float                          Scale                          (Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawTexture(class UTexture* Tex, float Scale, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTexture"));

	UCanvas_DrawTexture_Params params;
	params.Tex = Tex;
	params.Scale = Scale;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.PopMaskRegion
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, HasOptionalParms)

void UCanvas::PopMaskRegion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.PopMaskRegion"));

	UCanvas_PopMaskRegion_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.PushMaskRegion
// (Defined, Iterator, Latent, PreOperator, Net, Exec, HasOptionalParms)
// Parameters:
// float                          X                              (Parm)
// float                          Y                              (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)

void UCanvas::PushMaskRegion(float X, float Y, float XL, float YL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.PushMaskRegion"));

	UCanvas_PushMaskRegion_Params params;
	params.X = X;
	params.Y = Y;
	params.XL = XL;
	params.YL = YL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.SetClip
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          X                              (Parm)
// float                          Y                              (Parm)

void UCanvas::SetClip(float X, float Y)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.SetClip"));

	UCanvas_SetClip_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.SetOrigin
// (Singular, Event, HasOptionalParms)
// Parameters:
// float                          X                              (Parm)
// float                          Y                              (Parm)

void UCanvas::SetOrigin(float X, float Y)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.SetOrigin"));

	UCanvas_SetOrigin_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.SetPos
// (Defined, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// float                          PosX                           (Parm)
// float                          PosY                           (Parm)
// float                          PosZ                           (OptionalParm, Parm)

void UCanvas::SetPos(float PosX, float PosY, float PosZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.SetPos"));

	UCanvas_SetPos_Params params;
	params.PosX = PosX;
	params.PosY = PosY;
	params.PosZ = PosZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.GetDefaultCanvasFont
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UFont*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class UFont* UCanvas::STATIC_GetDefaultCanvasFont()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.GetDefaultCanvasFont"));

	UCanvas_GetDefaultCanvasFont_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bKeepOrigin                    (OptionalParm, Parm)

void UCanvas::Reset(bool bKeepOrigin)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.Reset"));

	UCanvas_Reset_Params params;
	params.bKeepOrigin = bKeepOrigin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.PopTransform
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, HasOptionalParms)

void UCanvas::PopTransform()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.PopTransform"));

	UCanvas_PopTransform_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.PushTranslationMatrix
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, HasOptionalParms)
// Parameters:
// struct FVector                 TranslationVector              (Parm)

void UCanvas::PushTranslationMatrix(const struct FVector& TranslationVector)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.PushTranslationMatrix"));

	UCanvas_PushTranslationMatrix_Params params;
	params.TranslationVector = TranslationVector;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DeProject
// (Final, Defined, NetReliable, Native, Static)
// Parameters:
// struct FVector2D               ScreenPos                      (Parm)
// struct FVector                 WorldOrigin                    (Parm, OutParm)
// struct FVector                 WorldDirection                 (Parm, OutParm)

void UCanvas::STATIC_DeProject(const struct FVector2D& ScreenPos, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DeProject"));

	UCanvas_DeProject_Params params;
	params.ScreenPos = ScreenPos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldOrigin != nullptr)
		*WorldOrigin = params.WorldOrigin;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;
}


// Function Engine.Canvas.Project
// (Latent, PreOperator, Net, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FVector                 Location                       (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UCanvas::Project(const struct FVector& Location)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.Project"));

	UCanvas_Project_Params params;
	params.Location = Location;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.DrawText
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Static)
// Parameters:
// struct FString                 Text                           (Parm, CoerceParm, NeedCtorLink)
// bool                           CR                             (OptionalParm, Parm)
// float                          XScale                         (OptionalParm, Parm)
// float                          YScale                         (OptionalParm, Parm)
// struct FFontRenderInfo         RenderInfo                     (Const, OptionalParm, Parm, OutParm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawText(const struct FString& Text, bool CR, float XScale, float YScale, TEnumAsByte<EDisplayPlane> DisplayPlane, struct FFontRenderInfo* RenderInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawText"));

	UCanvas_DrawText_Params params;
	params.Text = Text;
	params.CR = CR;
	params.XScale = XScale;
	params.YScale = YScale;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (RenderInfo != nullptr)
		*RenderInfo = params.RenderInfo;
}


// Function Engine.Canvas.TextSize
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 String                         (Parm, CoerceParm, NeedCtorLink)
// float                          XL                             (Parm, OutParm)
// float                          YL                             (Parm, OutParm)
// float                          XScale                         (OptionalParm, Parm)
// float                          YScale                         (OptionalParm, Parm)

void UCanvas::TextSize(const struct FString& String, float XScale, float YScale, float* XL, float* YL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.TextSize"));

	UCanvas_TextSize_Params params;
	params.String = String;
	params.XScale = XScale;
	params.YScale = YScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (XL != nullptr)
		*XL = params.XL;
	if (YL != nullptr)
		*YL = params.YL;
}


// Function Engine.Canvas.StrLen
// (Defined, Iterator, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 String                         (Parm, CoerceParm, NeedCtorLink)
// float                          XL                             (Parm, OutParm)
// float                          YL                             (Parm, OutParm)

void UCanvas::StrLen(const struct FString& String, float* XL, float* YL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.StrLen"));

	UCanvas_StrLen_Params params;
	params.String = String;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (XL != nullptr)
		*XL = params.XL;
	if (YL != nullptr)
		*YL = params.YL;
}


// Function Engine.Canvas.CreateFontRenderInfo
// (Final, Iterator, Exec, Static)
// Parameters:
// bool                           bClipText                      (OptionalParm, Parm)
// bool                           bEnableShadow                  (OptionalParm, Parm)
// struct FLinearColor            GlowColor                      (OptionalParm, Parm)
// struct FVector2D               GlowOuterRadius                (OptionalParm, Parm)
// struct FVector2D               GlowInnerRadius                (OptionalParm, Parm)
// struct FFontRenderInfo         ReturnValue                    (Parm, OutParm, ReturnParm)

struct FFontRenderInfo UCanvas::STATIC_CreateFontRenderInfo(bool bClipText, bool bEnableShadow, const struct FLinearColor& GlowColor, const struct FVector2D& GlowOuterRadius, const struct FVector2D& GlowInnerRadius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.CreateFontRenderInfo"));

	UCanvas_CreateFontRenderInfo_Params params;
	params.bClipText = bClipText;
	params.bEnableShadow = bEnableShadow;
	params.GlowColor = GlowColor;
	params.GlowOuterRadius = GlowOuterRadius;
	params.GlowInnerRadius = GlowInnerRadius;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.DrawTris
// (Final, Defined, Latent, Singular, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// TArray<struct FCanvasUVTri>    Triangles                      (Parm, NeedCtorLink)
// struct FColor                  InColor                        (Parm)

void UCanvas::STATIC_DrawTris(class UTexture* Tex, TArray<struct FCanvasUVTri> Triangles, const struct FColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTris"));

	UCanvas_DrawTris_Params params;
	params.Tex = Tex;
	params.Triangles = Triangles;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTileStretched
// (Final, Iterator, Singular, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)
// struct FLinearColor            LColor                         (OptionalParm, Parm)
// bool                           bStretchHorizontally           (OptionalParm, Parm)
// bool                           bStretchVertically             (OptionalParm, Parm)
// float                          ScalingFactor                  (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawTileStretched(class UTexture* Tex, float XL, float YL, float U, float V, float UL, float VL, const struct FLinearColor& LColor, bool bStretchHorizontally, bool bStretchVertically, float ScalingFactor, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTileStretched"));

	UCanvas_DrawTileStretched_Params params;
	params.Tex = Tex;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.LColor = LColor;
	params.bStretchHorizontally = bStretchHorizontally;
	params.bStretchVertically = bStretchVertically;
	params.ScalingFactor = ScalingFactor;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTimer
// (Defined, Iterator, Singular, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// float                          StartTime                      (Parm)
// float                          TotalTime                      (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)
// struct FLinearColor            LColor                         (OptionalParm, Parm)
// TEnumAsByte<EBlendMode>        Blend                          (OptionalParm, Parm)

void UCanvas::STATIC_DrawTimer(class UTexture* Tex, float StartTime, float TotalTime, float XL, float YL, float U, float V, float UL, float VL, const struct FLinearColor& LColor, TEnumAsByte<EBlendMode> Blend)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTimer"));

	UCanvas_DrawTimer_Params params;
	params.Tex = Tex;
	params.StartTime = StartTime;
	params.TotalTime = TotalTime;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.LColor = LColor;
	params.Blend = Blend;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawRotatedMaterialTile
// (Iterator, PreOperator, Net, Exec, Native, Static)
// Parameters:
// class UMaterialInterface*      Mat                            (Parm)
// struct FRotator                Rotation                       (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (OptionalParm, Parm)
// float                          V                              (OptionalParm, Parm)
// float                          UL                             (OptionalParm, Parm)
// float                          VL                             (OptionalParm, Parm)
// float                          AnchorX                        (OptionalParm, Parm)
// float                          AnchorY                        (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawRotatedMaterialTile(class UMaterialInterface* Mat, const struct FRotator& Rotation, float XL, float YL, float U, float V, float UL, float VL, float AnchorX, float AnchorY, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawRotatedMaterialTile"));

	UCanvas_DrawRotatedMaterialTile_Params params;
	params.Mat = Mat;
	params.Rotation = Rotation;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.AnchorX = AnchorX;
	params.AnchorY = AnchorY;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawRotatedTile
// (Final, Iterator, PreOperator, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// struct FRotator                Rotation                       (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)
// float                          AnchorX                        (OptionalParm, Parm)
// float                          AnchorY                        (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawRotatedTile(class UTexture* Tex, const struct FRotator& Rotation, float XL, float YL, float U, float V, float UL, float VL, float AnchorX, float AnchorY, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawRotatedTile"));

	UCanvas_DrawRotatedTile_Params params;
	params.Tex = Tex;
	params.Rotation = Rotation;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.AnchorX = AnchorX;
	params.AnchorY = AnchorY;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawMaterialTile
// (Defined, Iterator, Net, Exec, Native, Static)
// Parameters:
// class UMaterialInterface*      Mat                            (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (OptionalParm, Parm)
// float                          V                              (OptionalParm, Parm)
// float                          UL                             (OptionalParm, Parm)
// float                          VL                             (OptionalParm, Parm)
// bool                           bClipTile                      (OptionalParm, Parm)

void UCanvas::STATIC_DrawMaterialTile(class UMaterialInterface* Mat, float XL, float YL, float U, float V, float UL, float VL, bool bClipTile)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawMaterialTile"));

	UCanvas_DrawMaterialTile_Params params;
	params.Mat = Mat;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.bClipTile = bClipTile;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.PreOptimizeDrawTiles
// (PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// int                            Num                            (Parm)
// class UTexture*                Tex                            (Parm)
// TEnumAsByte<EBlendMode>        Blend                          (OptionalParm, Parm)

void UCanvas::PreOptimizeDrawTiles(int Num, class UTexture* Tex, TEnumAsByte<EBlendMode> Blend)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.PreOptimizeDrawTiles"));

	UCanvas_PreOptimizeDrawTiles_Params params;
	params.Num = Num;
	params.Tex = Tex;
	params.Blend = Blend;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.DrawTile
// (Iterator, Singular, Net, Exec, Native, Static)
// Parameters:
// class UTexture*                Tex                            (Parm)
// float                          XL                             (Parm)
// float                          YL                             (Parm)
// float                          U                              (Parm)
// float                          V                              (Parm)
// float                          UL                             (Parm)
// float                          VL                             (Parm)
// struct FLinearColor            LColor                         (OptionalParm, Parm)
// bool                           ClipTile                       (OptionalParm, Parm)
// TEnumAsByte<EBlendMode>        Blend                          (OptionalParm, Parm)
// TEnumAsByte<EDisplayPlane>     DisplayPlane                   (OptionalParm, Parm)

void UCanvas::STATIC_DrawTile(class UTexture* Tex, float XL, float YL, float U, float V, float UL, float VL, const struct FLinearColor& LColor, bool ClipTile, TEnumAsByte<EBlendMode> Blend, TEnumAsByte<EDisplayPlane> DisplayPlane)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Canvas.DrawTile"));

	UCanvas_DrawTile_Params params;
	params.Tex = Tex;
	params.XL = XL;
	params.YL = YL;
	params.U = U;
	params.V = V;
	params.UL = UL;
	params.VL = VL;
	params.LColor = LColor;
	params.ClipTile = ClipTile;
	params.Blend = Blend;
	params.DisplayPlane = DisplayPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GeneratePathToLocation
// (Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Goal                           (Parm)
// float                          WithinDistance                 (OptionalParm, Parm)
// bool                           bAllowPartialPath              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::GeneratePathToLocation(const struct FVector& Goal, float WithinDistance, bool bAllowPartialPath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GeneratePathToLocation"));

	AController_GeneratePathToLocation_Params params;
	params.Goal = Goal;
	params.WithinDistance = WithinDistance;
	params.bAllowPartialPath = bAllowPartialPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GeneratePathToActor
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Goal                           (Parm)
// float                          WithinDistance                 (OptionalParm, Parm)
// bool                           bAllowPartialPath              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::GeneratePathToActor(class AActor* Goal, float WithinDistance, bool bAllowPartialPath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GeneratePathToActor"));

	AController_GeneratePathToActor_Params params;
	params.Goal = Goal;
	params.WithinDistance = WithinDistance;
	params.bAllowPartialPath = bAllowPartialPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.InterpolationFinished
// (Final, Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void AController::InterpolationFinished(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InterpolationFinished"));

	AController_InterpolationFinished_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.InterpolationStarted
// (Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)
// class UInterpGroupInst*        GroupInst                      (Parm)

void AController::InterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InterpolationStarted"));

	AController_InterpolationStarted_Params params;
	params.InterpAction = InterpAction;
	params.GroupInst = GroupInst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.InitNavigationHandle
// (Final, PreOperator, Singular, Simulated, Exec, Native, HasOptionalParms)

void AController::InitNavigationHandle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InitNavigationHandle"));

	AController_InitNavigationHandle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.Stun
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           bStunController                (Parm)
// TEnumAsByte<EStunType>         eType                          (OptionalParm, Parm)

void AController::Stun(bool bStunController, TEnumAsByte<EStunType> eType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.Stun"));

	AController_Stun_Params params;
	params.bStunController = bStunController;
	params.eType = eType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReadyForLift
// (Final, Iterator, PreOperator, Net, Simulated, Exec, HasOptionalParms)

void AController::ReadyForLift()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ReadyForLift"));

	AController_ReadyForLift_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SendMessage
// (Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  Recipient                      (Parm)
// struct FName                   MessageType                    (Parm)
// float                          Wait                           (Parm)
// class UClass*                  DamageType                     (OptionalParm, Parm)

void AController::SendMessage(class APlayerReplicationInfo* Recipient, const struct FName& MessageType, float Wait, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SendMessage"));

	AController_SendMessage_Params params;
	params.Recipient = Recipient;
	params.MessageType = MessageType;
	params.Wait = Wait;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.CurrentLevelUnloaded
// (Defined, Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)

void AController::CurrentLevelUnloaded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.CurrentLevelUnloaded"));

	AController_CurrentLevelUnloaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.IsInCombat
// (Iterator, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bForceCheck                    (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::IsInCombat(bool bForceCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsInCombat"));

	AController_IsInCombat_Params params;
	params.bForceCheck = bForceCheck;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsSpectating
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_IsSpectating()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsSpectating"));

	AController_IsSpectating_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.OnToggleHidden
// (Final, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleHidden*    Action                         (Parm)

void AController::STATIC_OnToggleHidden(class USeqAct_ToggleHidden* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnToggleHidden"));

	AController_OnToggleHidden_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyAddInventory
// (Final, Defined, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AInventory*              NewItem                        (Parm)

void AController::STATIC_NotifyAddInventory(class AInventory* NewItem)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyAddInventory"));

	AController_NotifyAddInventory_Params params;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnModifyHealth
// (Final, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ModifyHealth*    Action                         (Parm)

void AController::STATIC_OnModifyHealth(class USeqAct_ModifyHealth* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnModifyHealth"));

	AController_OnModifyHealth_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyCoverClaimViolation
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             NewClaim                       (Parm)
// class ACoverLink*              Link                           (Parm)
// int                            SlotIdx                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_NotifyCoverClaimViolation(class AController* NewClaim, class ACoverLink* Link, int SlotIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyCoverClaimViolation"));

	AController_NotifyCoverClaimViolation_Params params;
	params.NewClaim = NewClaim;
	params.Link = Link;
	params.SlotIdx = SlotIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyCoverAdjusted
// (PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::NotifyCoverAdjusted()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyCoverAdjusted"));

	AController_NotifyCoverAdjusted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyCoverDisabled
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// int                            SlotIdx                        (Parm)
// bool                           bAdjacentIdx                   (OptionalParm, Parm)

void AController::STATIC_NotifyCoverDisabled(class ACoverLink* Link, int SlotIdx, bool bAdjacentIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyCoverDisabled"));

	AController_NotifyCoverDisabled_Params params;
	params.Link = Link;
	params.SlotIdx = SlotIdx;
	params.bAdjacentIdx = bAdjacentIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnSetVelocity
// (Iterator, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetVelocity*     Action                         (Parm)

void AController::STATIC_OnSetVelocity(class USeqAct_SetVelocity* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnSetVelocity"));

	AController_OnSetVelocity_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnSetPhysics
// (Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetPhysics*      Action                         (Parm)

void AController::STATIC_OnSetPhysics(class USeqAct_SetPhysics* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnSetPhysics"));

	AController_OnSetPhysics_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnToggleGodMode
// (Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleGodMode*   inAction                       (Parm)

void AController::STATIC_OnToggleGodMode(class USeqAct_ToggleGodMode* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnToggleGodMode"));

	AController_OnToggleGodMode_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnAttachToActor
// (Defined, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_AttachToActor*   Action                         (Parm)

void AController::STATIC_OnAttachToActor(class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnAttachToActor"));

	AController_OnAttachToActor_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnTeleport
// (Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Teleport*        Action                         (Parm)

void AController::STATIC_OnTeleport(class USeqAct_Teleport* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnTeleport"));

	AController_OnTeleport_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.IsDead
// (Defined, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_IsDead()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsDead"));

	AController_IsDead_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString AController::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetHumanReadableName"));

	AController_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AController::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.DisplayDebug"));

	AController_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Controller.StopLatentExecution
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void AController::StopLatentExecution()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.StopLatentExecution"));

	AController_StopLatentExecution_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.InLatentExecution
// (NetReliable, Simulated, Operator, Static)
// Parameters:
// int                            LatentActionNumber             (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_InLatentExecution(int LatentActionNumber)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InLatentExecution"));

	AController_InLatentExecution_Params params;
	params.LatentActionNumber = LatentActionNumber;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.ReachedPreciseDestination
// (Final, Iterator, Singular, Net, Exec, Native, HasOptionalParms)

void AController::ReachedPreciseDestination()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ReachedPreciseDestination"));

	AController_ReachedPreciseDestination_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyMissedJump
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::NotifyMissedJump()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyMissedJump"));

	AController_NotifyMissedJump_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyJumpApex
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::NotifyJumpApex()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyJumpApex"));

	AController_NotifyJumpApex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyBump
// (Final, Iterator, Net, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// struct FVector                 HitNormal                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::NotifyBump(class AActor* Other, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyBump"));

	AController_NotifyBump_Params params;
	params.Other = Other;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyFallingHitWall
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  Wall                           (Parm)

void AController::NotifyFallingHitWall(const struct FVector& HitNormal, class AActor* Wall)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyFallingHitWall"));

	AController_NotifyFallingHitWall_Params params;
	params.HitNormal = HitNormal;
	params.Wall = Wall;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyHitWall
// (Final, Defined, Iterator, Net, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  Wall                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::NotifyHitWall(const struct FVector& HitNormal, class AActor* Wall)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyHitWall"));

	AController_NotifyHitWall_Params params;
	params.HitNormal = HitNormal;
	params.Wall = Wall;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyLanded
// (Defined, Iterator, Net, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  FloorActor                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::NotifyLanded(const struct FVector& HitNormal, class AActor* FloorActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyLanded"));

	AController_NotifyLanded_Params params;
	params.HitNormal = HitNormal;
	params.FloorActor = FloorActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyHeadVolumeChange
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APhysicsVolume*          NewVolume                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::NotifyHeadVolumeChange(class APhysicsVolume* NewVolume)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyHeadVolumeChange"));

	AController_NotifyHeadVolumeChange_Params params;
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyPhysicsVolumeChange
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APhysicsVolume*          NewVolume                      (Parm)

void AController::NotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyPhysicsVolumeChange"));

	AController_NotifyPhysicsVolumeChange_Params params;
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.LandingShake
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_LandingShake()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.LandingShake"));

	AController_LandingShake_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsAimingAt
// (Defined, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  ATarget                        (Parm)
// float                          Epsilon                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_IsAimingAt(class AActor* ATarget, float Epsilon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsAimingAt"));

	AController_IsAimingAt_Params params;
	params.ATarget = ATarget;
	params.Epsilon = Epsilon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GetActorEyesViewPoint
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void AController::GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetActorEyesViewPoint"));

	AController_GetActorEyesViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.Controller.GetPlayerViewPoint
// (Defined, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void AController::STATIC_GetPlayerViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetPlayerViewPoint"));

	AController_GetPlayerViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.Controller.HandlePathObstruction
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  BlockedBy                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::HandlePathObstruction(class AActor* BlockedBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.HandlePathObstruction"));

	AController_HandlePathObstruction_Params params;
	params.BlockedBy = BlockedBy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.UnderLift
// (Iterator, Latent, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class ALiftCenter*             Lift                           (Parm)

void AController::UnderLift(class ALiftCenter* Lift)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.UnderLift"));

	AController_UnderLift_Params params;
	params.Lift = Lift;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.MoverFinished
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::MoverFinished()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MoverFinished"));

	AController_MoverFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.WaitForMover
// (Defined, Iterator, PreOperator, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class AInterpActor*            M                              (Parm)

void AController::WaitForMover(class AInterpActor* M)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.WaitForMover"));

	AController_WaitForMover_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.AllowDetourTo
// (Iterator, Simulated, Native, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        N                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::AllowDetourTo(class ANavigationPoint* N)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.AllowDetourTo"));

	AController_AllowDetourTo_Params params;
	params.N = N;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.MayFall
// (Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// bool                           bFloor                         (Parm)
// struct FVector                 FloorNormal                    (Parm)

void AController::MayFall(bool bFloor, const struct FVector& FloorNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MayFall"));

	AController_MayFall_Params params;
	params.bFloor = bFloor;
	params.FloorNormal = FloorNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.EndClimbLadder
// (Final, Iterator, Event, Static)

void AController::STATIC_EndClimbLadder()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.EndClimbLadder"));

	AController_EndClimbLadder_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.LongFall
// (Defined, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::LongFall()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.LongFall"));

	AController_LongFall_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.WaitForLanding
// (Iterator, PreOperator, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// float                          waitDuration                   (OptionalParm, Parm)

void AController::WaitForLanding(float waitDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.WaitForLanding"));

	AController_WaitForLanding_Params params;
	params.waitDuration = waitDuration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.PickWallAdjust
// (Defined, PreOperator, HasOptionalParms)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::PickWallAdjust(const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PickWallAdjust"));

	AController_PickWallAdjust_Params params;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.MoveUnreachable
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 AttemptedDest                  (Parm)
// class AActor*                  AttemptedTarget                (Parm)

void AController::MoveUnreachable(const struct FVector& AttemptedDest, class AActor* AttemptedTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MoveUnreachable"));

	AController_MoveUnreachable_Params params;
	params.AttemptedDest = AttemptedDest;
	params.AttemptedTarget = AttemptedTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ActorReachable
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, Event)
// Parameters:
// class AActor*                  anActor                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::ActorReachable(class AActor* anActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ActorReachable"));

	AController_ActorReachable_Params params;
	params.anActor = anActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.PointReachable
// (Final, PreOperator, Net, NetReliable, HasOptionalParms)
// Parameters:
// struct FVector                 aPoint                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::PointReachable(const struct FVector& aPoint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PointReachable"));

	AController_PointReachable_Params params;
	params.aPoint = aPoint;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FindPathToIntercept
// (Defined, Iterator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// class AActor*                  InRouteGoal                    (Parm)
// bool                           bWeightDetours                 (OptionalParm, Parm)
// int                            MaxPathLength                  (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AController::STATIC_FindPathToIntercept(class APawn* P, class AActor* InRouteGoal, bool bWeightDetours, int MaxPathLength, bool bReturnPartial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FindPathToIntercept"));

	AController_FindPathToIntercept_Params params;
	params.P = P;
	params.InRouteGoal = InRouteGoal;
	params.bWeightDetours = bWeightDetours;
	params.MaxPathLength = MaxPathLength;
	params.bReturnPartial = bReturnPartial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FindRandomDest
// (Final, Defined, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* AController::STATIC_FindRandomDest()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FindRandomDest"));

	AController_FindRandomDest_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FindPathTowardNearest
// (Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class UClass*                  GoalClass                      (Parm)
// bool                           bWeightDetours                 (OptionalParm, Parm)
// int                            MaxPathLength                  (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AController::STATIC_FindPathTowardNearest(class UClass* GoalClass, bool bWeightDetours, int MaxPathLength, bool bReturnPartial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FindPathTowardNearest"));

	AController_FindPathTowardNearest_Params params;
	params.GoalClass = GoalClass;
	params.bWeightDetours = bWeightDetours;
	params.MaxPathLength = MaxPathLength;
	params.bReturnPartial = bReturnPartial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FindPathToward
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class AActor*                  anActor                        (Parm)
// bool                           bWeightDetours                 (OptionalParm, Parm)
// int                            MaxPathLength                  (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AController::STATIC_FindPathToward(class AActor* anActor, bool bWeightDetours, int MaxPathLength, bool bReturnPartial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FindPathToward"));

	AController_FindPathToward_Params params;
	params.anActor = anActor;
	params.bWeightDetours = bWeightDetours;
	params.MaxPathLength = MaxPathLength;
	params.bReturnPartial = bReturnPartial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FindPathTo
// (Final, Iterator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 aPoint                         (Parm)
// int                            MaxPathLength                  (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* AController::STATIC_FindPathTo(const struct FVector& aPoint, int MaxPathLength, bool bReturnPartial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FindPathTo"));

	AController_FindPathTo_Params params;
	params.aPoint = aPoint;
	params.MaxPathLength = MaxPathLength;
	params.bReturnPartial = bReturnPartial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FinishRotation
// (Final, Iterator, Net, NetReliable, Exec, Event, Static)

void AController::STATIC_FinishRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FinishRotation"));

	AController_FinishRotation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetupSpecialPathAbilities
// (Final, Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)

void AController::SetupSpecialPathAbilities()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetupSpecialPathAbilities"));

	AController_SetupSpecialPathAbilities_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.MoveToward
// (Iterator, Latent, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// class AActor*                  NewTarget                      (Parm)
// class AActor*                  ViewFocus                      (OptionalParm, Parm)
// float                          DestinationOffset              (OptionalParm, Parm)
// bool                           bUseStrafing                   (OptionalParm, Parm)
// bool                           bShouldWalk                    (OptionalParm, Parm)

void AController::STATIC_MoveToward(class AActor* NewTarget, class AActor* ViewFocus, float DestinationOffset, bool bUseStrafing, bool bShouldWalk)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MoveToward"));

	AController_MoveToward_Params params;
	params.NewTarget = NewTarget;
	params.ViewFocus = ViewFocus;
	params.DestinationOffset = DestinationOffset;
	params.bUseStrafing = bUseStrafing;
	params.bShouldWalk = bShouldWalk;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.MoveToDirectNonPathPos
// (Final, Defined, Latent, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FVector                 NewDestination                 (Parm)
// class AActor*                  ViewFocus                      (OptionalParm, Parm)
// float                          DestinationOffset              (OptionalParm, Parm)
// bool                           bShouldWalk                    (OptionalParm, Parm)

void AController::STATIC_MoveToDirectNonPathPos(const struct FVector& NewDestination, class AActor* ViewFocus, float DestinationOffset, bool bShouldWalk)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MoveToDirectNonPathPos"));

	AController_MoveToDirectNonPathPos_Params params;
	params.NewDestination = NewDestination;
	params.ViewFocus = ViewFocus;
	params.DestinationOffset = DestinationOffset;
	params.bShouldWalk = bShouldWalk;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.MoveTo
// (Final, Latent, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FVector                 NewDestination                 (Parm)
// class AActor*                  ViewFocus                      (OptionalParm, Parm)
// float                          DestinationOffset              (OptionalParm, Parm)
// bool                           bShouldWalk                    (OptionalParm, Parm)

void AController::STATIC_MoveTo(const struct FVector& NewDestination, class AActor* ViewFocus, float DestinationOffset, bool bShouldWalk)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.MoveTo"));

	AController_MoveTo_Params params;
	params.NewDestination = NewDestination;
	params.ViewFocus = ViewFocus;
	params.DestinationOffset = DestinationOffset;
	params.bShouldWalk = bShouldWalk;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.EnemyNotVisible
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated)

void AController::EnemyNotVisible()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.EnemyNotVisible"));

	AController_EnemyNotVisible_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SeeMonster
// (Defined, Net, Simulated)
// Parameters:
// class APawn*                   Seen                           (Parm)

void AController::SeeMonster(class APawn* Seen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SeeMonster"));

	AController_SeeMonster_Params params;
	params.Seen = Seen;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SeePlayer
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class APawn*                   Seen                           (Parm)

void AController::SeePlayer(class APawn* Seen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SeePlayer"));

	AController_SeePlayer_Params params;
	params.Seen = Seen;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.HearNoise
// (Net, Simulated)
// Parameters:
// float                          Loudness                       (Parm)
// class AActor*                  NoiseMaker                     (Parm)
// struct FName                   NoiseType                      (OptionalParm, Parm)

void AController::HearNoise(float Loudness, class AActor* NoiseMaker, const struct FName& NoiseType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.HearNoise"));

	AController_HearNoise_Params params;
	params.Loudness = Loudness;
	params.NoiseMaker = NoiseMaker;
	params.NoiseType = NoiseType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.PickTarget
// (Final, Iterator, HasOptionalParms)
// Parameters:
// class UClass*                  TargetClass                    (Parm)
// float                          bestAim                        (Parm, OutParm)
// float                          bestDist                       (Parm, OutParm)
// struct FVector                 FireDir                        (Parm)
// struct FVector                 projStart                      (Parm)
// float                          MaxRange                       (Parm)
// class APawn*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class APawn* AController::PickTarget(class UClass* TargetClass, const struct FVector& FireDir, const struct FVector& projStart, float MaxRange, float* bestAim, float* bestDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PickTarget"));

	AController_PickTarget_Params params;
	params.TargetClass = TargetClass;
	params.FireDir = FireDir;
	params.projStart = projStart;
	params.MaxRange = MaxRange;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bestAim != nullptr)
		*bestAim = params.bestAim;
	if (bestDist != nullptr)
		*bestDist = params.bestDist;

	return params.ReturnValue;
}


// Function Engine.Controller.CanSeeByPoints
// (Final, Defined, Iterator, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// struct FVector                 ViewLocation                   (Parm)
// struct FVector                 TestLocation                   (Parm)
// struct FRotator                ViewRotation                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::CanSeeByPoints(const struct FVector& ViewLocation, const struct FVector& TestLocation, const struct FRotator& ViewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.CanSeeByPoints"));

	AController_CanSeeByPoints_Params params;
	params.ViewLocation = ViewLocation;
	params.TestLocation = TestLocation;
	params.ViewRotation = ViewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.CanSee
// (Defined, Iterator, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::CanSee(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.CanSee"));

	AController_CanSee_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.LineOfSightTo
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Native, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Parm)
// struct FVector                 chkLocation                    (OptionalParm, Parm)
// bool                           bTryAlternateTargetLoc         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_LineOfSightTo(class AActor* Other, const struct FVector& chkLocation, bool bTryAlternateTargetLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.LineOfSightTo"));

	AController_LineOfSightTo_Params params;
	params.Other = Other;
	params.chkLocation = chkLocation;
	params.bTryAlternateTargetLoc = bTryAlternateTargetLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.NotifyChangedWeapon
// (Final, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AWeapon*                 PrevWeapon                     (Parm)
// class AWeapon*                 NewWeapon                      (Parm)

void AController::STATIC_NotifyChangedWeapon(class AWeapon* PrevWeapon, class AWeapon* NewWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyChangedWeapon"));

	AController_NotifyChangedWeapon_Params params;
	params.PrevWeapon = PrevWeapon;
	params.NewWeapon = NewWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ClientSwitchToBestWeapon
// (Final, Defined, Iterator, Latent, Singular, Static)
// Parameters:
// bool                           bForceNewWeapon                (OptionalParm, Parm)

void AController::STATIC_ClientSwitchToBestWeapon(bool bForceNewWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ClientSwitchToBestWeapon"));

	AController_ClientSwitchToBestWeapon_Params params;
	params.bForceNewWeapon = bForceNewWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SwitchToBestWeapon
// (Final, Defined, Iterator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bForceNewWeapon                (OptionalParm, Parm)

void AController::SwitchToBestWeapon(bool bForceNewWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SwitchToBestWeapon"));

	AController_SwitchToBestWeapon_Params params;
	params.bForceNewWeapon = bForceNewWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReceiveProjectileWarning
// (Latent, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// class AProjectile*             Proj                           (Parm)

void AController::ReceiveProjectileWarning(class AProjectile* Proj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ReceiveProjectileWarning"));

	AController_ReceiveProjectileWarning_Params params;
	params.Proj = Proj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReceiveWarning
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// class APawn*                   shooter                        (Parm)
// float                          projSpeed                      (Parm)
// struct FVector                 FireDir                        (Parm)

void AController::ReceiveWarning(class APawn* shooter, float projSpeed, const struct FVector& FireDir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ReceiveWarning"));

	AController_ReceiveWarning_Params params;
	params.shooter = shooter;
	params.projSpeed = projSpeed;
	params.FireDir = FireDir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.InstantWarnTarget
// (Final, Defined, Exec, Operator, Static)
// Parameters:
// class AActor*                  InTarget                       (Parm)
// class AWeapon*                 FiredWeapon                    (Parm)
// struct FVector                 FireDir                        (Parm)

void AController::STATIC_InstantWarnTarget(class AActor* InTarget, class AWeapon* FiredWeapon, const struct FVector& FireDir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InstantWarnTarget"));

	AController_InstantWarnTarget_Params params;
	params.InTarget = InTarget;
	params.FiredWeapon = FiredWeapon;
	params.FireDir = FireDir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GetAdjustedAimFor
// (Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// struct FVector                 StartFireLoc                   (Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator AController::STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetAdjustedAimFor"));

	AController_GetAdjustedAimFor_Params params;
	params.W = W;
	params.StartFireLoc = StartFireLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.HandlePickup
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AInventory*              Inv                            (Parm)

void AController::STATIC_HandlePickup(class AInventory* Inv)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.HandlePickup"));

	AController_HandlePickup_Params params;
	params.Inv = Inv;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RoundHasEnded
// (Final, Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  EndRoundFocus                  (OptionalParm, Parm)

void AController::RoundHasEnded(class AActor* EndRoundFocus)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RoundHasEnded"));

	AController_RoundHasEnded_Params params;
	params.EndRoundFocus = EndRoundFocus;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.StopFiring
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AController::StopFiring()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.StopFiring"));

	AController_StopFiring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.FireWeaponAt
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Exec, Event, Static)
// Parameters:
// class AActor*                  inActor                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_FireWeaponAt(class AActor* inActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FireWeaponAt"));

	AController_FireWeaponAt_Params params;
	params.inActor = inActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.RatePickup
// (Iterator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  PickupHolder                   (Parm)
// class UClass*                  inPickup                       (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AController::RatePickup(class AActor* PickupHolder, class UClass* inPickup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RatePickup"));

	AController_RatePickup_Params params;
	params.PickupHolder = PickupHolder;
	params.inPickup = inPickup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.WarnProjExplode
// (Latent, Singular, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// class AProjectile*             Proj                           (Parm)

void AController::WarnProjExplode(class AProjectile* Proj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.WarnProjExplode"));

	AController_WarnProjExplode_Params params;
	params.Proj = Proj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyProjLanded
// (Defined, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AProjectile*             Proj                           (Parm)

void AController::STATIC_NotifyProjLanded(class AProjectile* Proj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyProjLanded"));

	AController_NotifyProjLanded_Params params;
	params.Proj = Proj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyKilled
// (Iterator, Latent, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class AController*             Killed                         (Parm)
// class APawn*                   KilledPawn                     (Parm)
// class UClass*                  damageTyp                      (Parm)

void AController::STATIC_NotifyKilled(class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* damageTyp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyKilled"));

	AController_NotifyKilled_Params params;
	params.Killer = Killer;
	params.Killed = Killed;
	params.KilledPawn = KilledPawn;
	params.damageTyp = damageTyp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GameHasEnded
// (Final, Defined, Latent, Singular, Net, NetReliable, Native, Event, Static)
// Parameters:
// class AActor*                  EndGameFocus                   (OptionalParm, Parm)
// bool                           bIsWinner                      (OptionalParm, Parm)

void AController::STATIC_GameHasEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GameHasEnded"));

	AController_GameHasEnded_Params params;
	params.EndGameFocus = EndGameFocus;
	params.bIsWinner = bIsWinner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetCharacter
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 inCharacter                    (Parm, NeedCtorLink)

void AController::SetCharacter(const struct FString& inCharacter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetCharacter"));

	AController_SetCharacter_Params params;
	params.inCharacter = inCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ServerGivePawn
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AController::ServerGivePawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ServerGivePawn"));

	AController_ServerGivePawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ServerRestartPlayer
// (Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void AController::ServerRestartPlayer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ServerRestartPlayer"));

	AController_ServerRestartPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char AController::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetTeamNum"));

	AController_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.CopyPropertiesTo
// (PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AController*             C                              (Parm)

void AController::CopyPropertiesTo(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.CopyPropertiesTo"));

	AController_CopyPropertiesTo_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.InitPlayerReplicationInfo
// (Final, Defined, PreOperator, Singular, Net, Simulated, Operator, Static)

void AController::STATIC_InitPlayerReplicationInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.InitPlayerReplicationInfo"));

	AController_InitPlayerReplicationInfo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyTakeHit
// (Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// int                            Damage                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 Momentum                       (Parm)

void AController::STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyTakeHit"));

	AController_NotifyTakeHit_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.Momentum = Momentum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.EnemyJustTeleported
// (Defined, Latent, Singular, Event, Static)

void AController::STATIC_EnemyJustTeleported()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.EnemyJustTeleported"));

	AController_EnemyJustTeleported_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.BeyondFogDistance
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, Operator)
// Parameters:
// struct FVector                 ViewPoint                      (Parm)
// struct FVector                 OtherPoint                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::BeyondFogDistance(const struct FVector& ViewPoint, const struct FVector& OtherPoint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.BeyondFogDistance"));

	AController_BeyondFogDistance_Params params;
	params.ViewPoint = ViewPoint;
	params.OtherPoint = OtherPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.Restart
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Native, HasOptionalParms)
// Parameters:
// bool                           bVehicleTransition             (Parm)

void AController::Restart(bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.Restart"));

	AController_Restart_Params params;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.CleanupPRI
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Event, Operator)

void AController::CleanupPRI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.CleanupPRI"));

	AController_CleanupPRI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AController::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.Destroyed"));

	AController_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyPostLanded
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::NotifyPostLanded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyPostLanded"));

	AController_NotifyPostLanded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GamePlayEndedState
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_GamePlayEndedState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GamePlayEndedState"));

	AController_GamePlayEndedState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.PawnDied
// (Final, Defined, Latent, Singular, Simulated, Static, HasOptionalParms)
// Parameters:
// class APawn*                   inPawn                         (Parm)

void AController::STATIC_PawnDied(class APawn* inPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PawnDied"));

	AController_PawnDied_Params params;
	params.inPawn = inPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.UnPossess
// (Final, Iterator, Simulated, Exec, Native, HasOptionalParms)

void AController::UnPossess()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.UnPossess"));

	AController_UnPossess_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.Possess
// (Final, Defined, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   inPawn                         (Parm)
// bool                           bVehicleTransition             (Parm)

void AController::Possess(class APawn* inPawn, bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.Possess"));

	AController_Possess_Params params;
	params.inPawn = inPawn;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnPossess
// (Defined, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Possess*         inAction                       (Parm)

void AController::STATIC_OnPossess(class USeqAct_Possess* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.OnPossess"));

	AController_OnPossess_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AController::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ReplicatedEvent"));

	AController_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ClientSetRotation
// (Defined, Iterator, Singular, Static)
// Parameters:
// struct FRotator                NewRotation                    (Parm)
// bool                           bResetCamera                   (OptionalParm, Parm)

void AController::STATIC_ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ClientSetRotation"));

	AController_ClientSetRotation_Params params;
	params.NewRotation = NewRotation;
	params.bResetCamera = bResetCamera;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ClientSetLocation
// (Iterator, Singular, Static)
// Parameters:
// struct FVector                 NewLocation                    (Parm)
// struct FRotator                NewRotation                    (Parm)

void AController::STATIC_ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.ClientSetLocation"));

	AController_ClientSetLocation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.LimitViewRotation
// (Iterator, Latent, PreOperator, Singular, NetReliable, Native, Operator, Static)
// Parameters:
// struct FRotator                ViewRotation                   (Parm)
// float                          ViewPitchMin                   (Parm)
// float                          ViewPitchMax                   (Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator AController::STATIC_LimitViewRotation(const struct FRotator& ViewRotation, float ViewPitchMin, float ViewPitchMax)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.LimitViewRotation"));

	AController_LimitViewRotation_Params params;
	params.ViewRotation = ViewRotation;
	params.ViewPitchMin = ViewPitchMin;
	params.ViewPitchMax = ViewPitchMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AController::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.Reset"));

	AController_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AController::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PostBeginPlay"));

	AController_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetSkelControlScale
// (Defined, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void AController::SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetSkelControlScale"));

	AController_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetMorphWeight
// (Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void AController::SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetMorphWeight"));

	AController_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.StopActorFaceFXAnim
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AController::StopActorFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.StopActorFaceFXAnim"));

	AController_StopActorFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.PlayActorFaceFXAnim
// (Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// struct FString                 SeqName                        (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::PlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.PlayActorFaceFXAnim"));

	AController_PlayActorFaceFXAnim_Params params;
	params.AnimSet = AnimSet;
	params.GroupName = GroupName;
	params.SeqName = SeqName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.FinishAnimControl
// (Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void AController::FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.FinishAnimControl"));

	AController_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetAnimPosition
// (Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void AController::SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetAnimPosition"));

	AController_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.BeginAnimControl
// (Final, Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void AController::BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.BeginAnimControl"));

	AController_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.NotifyPathChanged
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void AController::NotifyPathChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.NotifyPathChanged"));

	AController_NotifyPathChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GetAdjustLocation
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AController::STATIC_GetAdjustLocation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetAdjustLocation"));

	AController_GetAdjustLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.SetAdjustLocation
// (Iterator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewLoc                         (Parm)
// bool                           bAdjust                        (Parm)
// bool                           bOffsetFromBase                (OptionalParm, Parm)

void AController::SetAdjustLocation(const struct FVector& NewLoc, bool bAdjust, bool bOffsetFromBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetAdjustLocation"));

	AController_SetAdjustLocation_Params params;
	params.NewLoc = NewLoc;
	params.bAdjust = bAdjust;
	params.bOffsetFromBase = bOffsetFromBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GetDestinationPosition
// (Final, Iterator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AController::STATIC_GetDestinationPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetDestinationPosition"));

	AController_GetDestinationPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.SetDestinationPosition
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Dest                           (Parm)
// bool                           bOffsetFromBase                (OptionalParm, Parm)

void AController::SetDestinationPosition(const struct FVector& Dest, bool bOffsetFromBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetDestinationPosition"));

	AController_SetDestinationPosition_Params params;
	params.Dest = Dest;
	params.bOffsetFromBase = bOffsetFromBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.GetFocalPoint
// (Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AController::STATIC_GetFocalPoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.GetFocalPoint"));

	AController_GetFocalPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.SetFocalPoint
// (Final, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 FP                             (Parm)
// bool                           bOffsetFromBase                (OptionalParm, Parm)

void AController::SetFocalPoint(const struct FVector& FP, bool bOffsetFromBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.SetFocalPoint"));

	AController_SetFocalPoint_Params params;
	params.FP = FP;
	params.bOffsetFromBase = bOffsetFromBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RouteCache_RemoveIndex
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            InIndex                        (Parm)
// int                            Count                          (OptionalParm, Parm)

void AController::RouteCache_RemoveIndex(int InIndex, int Count)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RouteCache_RemoveIndex"));

	AController_RouteCache_RemoveIndex_Params params;
	params.InIndex = InIndex;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RouteCache_RemoveItem
// (Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        Nav                            (Parm)

void AController::RouteCache_RemoveItem(class ANavigationPoint* Nav)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RouteCache_RemoveItem"));

	AController_RouteCache_RemoveItem_Params params;
	params.Nav = Nav;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RouteCache_InsertItem
// (Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        Nav                            (Parm)
// int                            Idx                            (OptionalParm, Parm)

void AController::RouteCache_InsertItem(class ANavigationPoint* Nav, int Idx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RouteCache_InsertItem"));

	AController_RouteCache_InsertItem_Params params;
	params.Nav = Nav;
	params.Idx = Idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RouteCache_AddItem
// (Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        Nav                            (Parm)

void AController::RouteCache_AddItem(class ANavigationPoint* Nav)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RouteCache_AddItem"));

	AController_RouteCache_AddItem_Params params;
	params.Nav = Nav;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.RouteCache_Empty
// (Final, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)

void AController::RouteCache_Empty()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.RouteCache_Empty"));

	AController_RouteCache_Empty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.IsLocalController
// (Final, Iterator, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_IsLocalController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsLocalController"));

	AController_IsLocalController_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsLocalPlayerController
// (PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AController::STATIC_IsLocalPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Controller.IsLocalPlayerController"));

	AController_IsLocalPlayerController_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ControllerPostTimeLapse
// (Defined, Iterator, Latent, Net, Simulated, Native, HasOptionalParms)

void APlayerController::ControllerPostTimeLapse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ControllerPostTimeLapse"));

	APlayerController_ControllerPostTimeLapse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ControllerPreTimeLapse
// (Final, Defined, Iterator, Latent, Net, Simulated, Native, HasOptionalParms)

void APlayerController::ControllerPreTimeLapse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ControllerPreTimeLapse"));

	APlayerController_ControllerPreTimeLapse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetMatineeConstantCameraAnim
// (Final, Defined, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bOn                            (Parm)
// unsigned char                  Type                           (Parm)
// float                          Rate                           (Parm)

void APlayerController::SetMatineeConstantCameraAnim(bool bOn, unsigned char Type, float Rate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetMatineeConstantCameraAnim"));

	APlayerController_SetMatineeConstantCameraAnim_Params params;
	params.bOn = bOn;
	params.Type = Type;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LostP2PConnection
// (Final, Defined, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            UniqueId                       (Parm)

void APlayerController::LostP2PConnection(const struct FUniqueNetId& UniqueId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LostP2PConnection"));

	APlayerController_LostP2PConnection_Params params;
	params.UniqueId = UniqueId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyDisconnect
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::NotifyDisconnect(const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyDisconnect"));

	APlayerController_NotifyDisconnect_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ReceivedGameClass
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// class UClass*                  GameClass                      (Parm)

void APlayerController::ReceivedGameClass(class UClass* GameClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ReceivedGameClass"));

	APlayerController_ReceivedGameClass_Params params;
	params.GameClass = GameClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LogOutBugItAIGoToLogFile
// (Final, Defined, Latent, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// struct FString                 InScreenShotDesc               (Const, Parm, NeedCtorLink)
// struct FString                 InGoString                     (Const, Parm, NeedCtorLink)
// struct FString                 InLocString                    (Const, Parm, NeedCtorLink)

void APlayerController::STATIC_LogOutBugItAIGoToLogFile(const struct FString& InScreenShotDesc, const struct FString& InGoString, const struct FString& InLocString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LogOutBugItAIGoToLogFile"));

	APlayerController_LogOutBugItAIGoToLogFile_Params params;
	params.InScreenShotDesc = InScreenShotDesc;
	params.InGoString = InGoString;
	params.InLocString = InLocString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LogOutBugItGoToLogFile
// (Iterator, Latent, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// struct FString                 InScreenShotDesc               (Const, Parm, NeedCtorLink)
// struct FString                 InGoString                     (Const, Parm, NeedCtorLink)
// struct FString                 InLocString                    (Const, Parm, NeedCtorLink)

void APlayerController::STATIC_LogOutBugItGoToLogFile(const struct FString& InScreenShotDesc, const struct FString& InGoString, const struct FString& InLocString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LogOutBugItGoToLogFile"));

	APlayerController_LogOutBugItGoToLogFile_Params params;
	params.InScreenShotDesc = InScreenShotDesc;
	params.InGoString = InGoString;
	params.InLocString = InLocString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DisableDebugAI
// (Defined, Iterator, Simulated, Native, Static)

void APlayerController::STATIC_DisableDebugAI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DisableDebugAI"));

	APlayerController_DisableDebugAI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnEngineInitialTick
// (Defined, PreOperator, Exec, Native, HasOptionalParms)

void APlayerController::OnEngineInitialTick()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnEngineInitialTick"));

	APlayerController_OnEngineInitialTick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.BugItStringCreator
// (Final, Defined, Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ViewLocation                   (Const, Parm, OutParm)
// struct FRotator                ViewRotation                   (Const, Parm, OutParm)
// struct FString                 GoString                       (Parm, OutParm, NeedCtorLink)
// struct FString                 LocString                      (Parm, OutParm, NeedCtorLink)

void APlayerController::BugItStringCreator(struct FVector* ViewLocation, struct FRotator* ViewRotation, struct FString* GoString, struct FString* LocString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.BugItStringCreator"));

	APlayerController_BugItStringCreator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ViewLocation != nullptr)
		*ViewLocation = params.ViewLocation;
	if (ViewRotation != nullptr)
		*ViewRotation = params.ViewRotation;
	if (GoString != nullptr)
		*GoString = params.GoString;
	if (LocString != nullptr)
		*LocString = params.LocString;
}


// Function Engine.PlayerController.BugItAI
// (Defined, Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ScreenShotDescription          (OptionalParm, Parm, NeedCtorLink)

void APlayerController::BugItAI(const struct FString& ScreenShotDescription)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.BugItAI"));

	APlayerController_BugItAI_Params params;
	params.ScreenShotDescription = ScreenShotDescription;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LogLoc
// (Latent, NetReliable, Simulated, Native, Operator, Static)

void APlayerController::STATIC_LogLoc()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LogLoc"));

	APlayerController_LogLoc_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.BugIt
// (Final, Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ScreenShotDescription          (OptionalParm, Parm, NeedCtorLink)

void APlayerController::BugIt(const struct FString& ScreenShotDescription)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.BugIt"));

	APlayerController_BugIt_Params params;
	params.ScreenShotDescription = ScreenShotDescription;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.BugItWorker
// (Final, Defined, Iterator, Latent, PreOperator, Net, Native, Event, Operator)
// Parameters:
// struct FVector                 TheLocation                    (Parm)
// struct FRotator                TheRotation                    (Parm)

void APlayerController::BugItWorker(const struct FVector& TheLocation, const struct FRotator& TheRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.BugItWorker"));

	APlayerController_BugItWorker_Params params;
	params.TheLocation = TheLocation;
	params.TheRotation = TheRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.BugItGoString
// (Defined, Iterator, Latent, PreOperator, Net, Native, Event, Operator)
// Parameters:
// struct FString                 TheLocation                    (Parm, NeedCtorLink)
// struct FString                 TheRotation                    (Parm, NeedCtorLink)

void APlayerController::BugItGoString(const struct FString& TheLocation, const struct FString& TheRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.BugItGoString"));

	APlayerController_BugItGoString_Params params;
	params.TheLocation = TheLocation;
	params.TheRotation = TheRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.HasPeerConnection
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Const, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_HasPeerConnection(struct FUniqueNetId* PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HasPeerConnection"));

	APlayerController_HasPeerConnection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PeerNetId != nullptr)
		*PeerNetId = params.PeerNetId;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnSetSoundMode
// (Final, Defined, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetSoundMode*    Action                         (Parm)

void APlayerController::STATIC_OnSetSoundMode(class USeqAct_SetSoundMode* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnSetSoundMode"));

	APlayerController_OnSetSoundMode_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSpawnCameraLensEffect
// (Final, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  LensEffectEmitterClass         (Parm)

void APlayerController::ClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSpawnCameraLensEffect"));

	APlayerController_ClientSpawnCameraLensEffect_Params params;
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DebugCameraAnims
// (Defined, PreOperator, Net, Simulated, Exec, Static)

void APlayerController::STATIC_DebugCameraAnims()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DebugCameraAnims"));

	APlayerController_DebugCameraAnims_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopCameraAnim
// (Defined, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UCameraAnim*             AnimToStop                     (Parm)
// bool                           bImmediate                     (OptionalParm, Parm)

void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop, bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStopCameraAnim"));

	APlayerController_ClientStopCameraAnim_Params params;
	params.AnimToStop = AnimToStop;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayCameraAnim
// (Final, Iterator, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class UCameraAnim*             AnimToPlay                     (Parm)
// float                          Scale                          (OptionalParm, Parm)
// float                          Rate                           (OptionalParm, Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLoop                          (OptionalParm, Parm)
// bool                           bRandomStartTime               (OptionalParm, Parm)
// TEnumAsByte<ECameraAnimPlaySpace> Space                          (OptionalParm, Parm)
// struct FRotator                CustomPlaySpace                (OptionalParm, Parm)

void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, TEnumAsByte<ECameraAnimPlaySpace> Space, const struct FRotator& CustomPlaySpace)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPlayCameraAnim"));

	APlayerController_ClientPlayCameraAnim_Params params;
	params.AnimToPlay = AnimToPlay;
	params.Scale = Scale;
	params.Rate = Rate;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Space = Space;
	params.CustomPlaySpace = CustomPlaySpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnCameraShake
// (Final, Iterator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_CameraShake*     inAction                       (Parm)

void APlayerController::STATIC_OnCameraShake(class USeqAct_CameraShake* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnCameraShake"));

	APlayerController_OnCameraShake_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopCameraShake
// (Final, Iterator, Latent, Singular, Static)
// Parameters:
// class UCameraShake*            Shake                          (Parm)

void APlayerController::STATIC_ClientStopCameraShake(class UCameraShake* Shake)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStopCameraShake"));

	APlayerController_ClientStopCameraShake_Params params;
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayCameraShake
// (Defined, PreOperator, Static)
// Parameters:
// class UCameraShake*            Shake                          (Parm)
// float                          Scale                          (OptionalParm, Parm)
// bool                           bTryForceFeedback              (OptionalParm, Parm)
// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (OptionalParm, Parm)
// struct FRotator                UserPlaySpaceRot               (OptionalParm, Parm)

void APlayerController::STATIC_ClientPlayCameraShake(class UCameraShake* Shake, float Scale, bool bTryForceFeedback, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPlayCameraShake"));

	APlayerController_ClientPlayCameraShake_Params params;
	params.Shake = Shake;
	params.Scale = Scale;
	params.bTryForceFeedback = bTryForceFeedback;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DoForceFeedbackForScreenShake
// (Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class UCameraShake*            ShakeData                      (Parm)
// float                          ShakeScale                     (Parm)

void APlayerController::STATIC_DoForceFeedbackForScreenShake(class UCameraShake* ShakeData, float ShakeScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DoForceFeedbackForScreenShake"));

	APlayerController_DoForceFeedbackForScreenShake_Params params;
	params.ShakeData = ShakeData;
	params.ShakeScale = ShakeScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.InputMatchDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void APlayerController::InputMatchDelegate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.InputMatchDelegate"));

	APlayerController_InputMatchDelegate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Sentinel_PostAcquireTravelTheWorldPoints
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::Sentinel_PostAcquireTravelTheWorldPoints()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Sentinel_PostAcquireTravelTheWorldPoints"));

	APlayerController_Sentinel_PostAcquireTravelTheWorldPoints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Sentinel_PreAcquireTravelTheWorldPoints
// (Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::Sentinel_PreAcquireTravelTheWorldPoints()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Sentinel_PreAcquireTravelTheWorldPoints"));

	APlayerController_Sentinel_PreAcquireTravelTheWorldPoints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Sentinel_SetupForGamebasedTravelTheWorld
// (Final, Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::Sentinel_SetupForGamebasedTravelTheWorld()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Sentinel_SetupForGamebasedTravelTheWorld"));

	APlayerController_Sentinel_SetupForGamebasedTravelTheWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnFlyThroughHasEnded
// (Final, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_FlyThroughHasEnded* inAction                       (Parm)

void APlayerController::STATIC_OnFlyThroughHasEnded(class USeqAct_FlyThroughHasEnded* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnFlyThroughHasEnded"));

	APlayerController_OnFlyThroughHasEnded_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetAchievementProgression
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            AchievementId                  (Parm)
// float                          CurrentValue                   (Parm, OutParm)
// float                          MaxValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::GetAchievementProgression(int AchievementId, float* CurrentValue, float* MaxValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetAchievementProgression"));

	APlayerController_GetAchievementProgression_Params params;
	params.AchievementId = AchievementId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CurrentValue != nullptr)
		*CurrentValue = params.CurrentValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetPartyGameTypeName
// (PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetPartyGameTypeName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPartyGameTypeName"));

	APlayerController_GetPartyGameTypeName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetPartyMapName
// (Final, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetPartyMapName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPartyMapName"));

	APlayerController_GetPartyMapName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsPartyLeader
// (Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsPartyLeader()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsPartyLeader"));

	APlayerController_IsPartyLeader_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientAddTextureStreamingLoc
// (Final, Defined, Latent, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InLoc                          (Parm)
// float                          Duration                       (Parm)
// bool                           bOverrideLocation              (Parm)

void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAddTextureStreamingLoc"));

	APlayerController_ClientAddTextureStreamingLoc_Params params;
	params.InLoc = InLoc;
	params.Duration = Duration;
	params.bOverrideLocation = bOverrideLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPrestreamTextures
// (Final, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  ForcedActor                    (Parm)
// float                          ForceDuration                  (Parm)
// bool                           bEnableStreaming               (Parm)
// TArray<unsigned char>          CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, TArray<unsigned char> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPrestreamTextures"));

	APlayerController_ClientPrestreamTextures_Params params;
	params.ForcedActor = ForcedActor;
	params.ForceDuration = ForceDuration;
	params.bEnableStreaming = bEnableStreaming;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      Material                       (Parm)
// float                          ForceDuration                  (Parm)
// TArray<unsigned char>          CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, TArray<unsigned char> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident"));

	APlayerController_ClientSetForceMipLevelsToBeResident_Params params;
	params.Material = Material;
	params.ForceDuration = ForceDuration;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientControlMovieTexture
// (Static)
// Parameters:
// class UTextureMovie*           MovieTexture                   (Parm)
// TEnumAsByte<EMovieControlType> Mode                           (Parm)

void APlayerController::STATIC_ClientControlMovieTexture(class UTextureMovie* MovieTexture, TEnumAsByte<EMovieControlType> Mode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientControlMovieTexture"));

	APlayerController_ClientControlMovieTexture_Params params;
	params.MovieTexture = MovieTexture;
	params.Mode = Mode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetSplitscreenPlayerCount
// (Final, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int APlayerController::STATIC_GetSplitscreenPlayerCount()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetSplitscreenPlayerCount"));

	APlayerController_GetSplitscreenPlayerCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetSplitscreenPlayerByIndex
// (PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PlayerIndex                    (OptionalParm, Parm)
// class APlayerReplicationInfo*  ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerReplicationInfo* APlayerController::STATIC_GetSplitscreenPlayerByIndex(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetSplitscreenPlayerByIndex"));

	APlayerController_GetSplitscreenPlayerByIndex_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsSplitscreenPlayer
// (Simulated, Exec, Operator, Static)
// Parameters:
// int                            out_SplitscreenPlayerIndex     (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsSplitscreenPlayer(int* out_SplitscreenPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsSplitscreenPlayer"));

	APlayerController_IsSplitscreenPlayer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_SplitscreenPlayerIndex != nullptr)
		*out_SplitscreenPlayerIndex = params.out_SplitscreenPlayerIndex;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsPrimaryPlayer
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsPrimaryPlayer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsPrimaryPlayer"));

	APlayerController_IsPrimaryPlayer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerNotifyPartyHostLeaving
// (Final, Defined, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PartyHostPlayerId              (Parm)

void APlayerController::ServerNotifyPartyHostLeaving(const struct FUniqueNetId& PartyHostPlayerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerNotifyPartyHostLeaving"));

	APlayerController_ServerNotifyPartyHostLeaving_Params params;
	params.PartyHostPlayerId = PartyHostPlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientNotifyPartyHostLeaving
// (Final, Defined, Iterator, Latent, Static)
// Parameters:
// struct FUniqueNetId            PartyHostPlayerId              (Parm)

void APlayerController::STATIC_ClientNotifyPartyHostLeaving(const struct FUniqueNetId& PartyHostPlayerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientNotifyPartyHostLeaving"));

	APlayerController_ClientNotifyPartyHostLeaving_Params params;
	params.PartyHostPlayerId = PartyHostPlayerId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReturnToParty
// (Defined, Iterator, Latent, PreOperator, Static)
// Parameters:
// struct FUniqueNetId            RequestingPlayerId             (Parm)

void APlayerController::STATIC_ClientReturnToParty(const struct FUniqueNetId& RequestingPlayerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientReturnToParty"));

	APlayerController_ClientReturnToParty_Params params;
	params.RequestingPlayerId = RequestingPlayerId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnJoinTravelToSessionComplete
// (Defined, Iterator, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnJoinTravelToSessionComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnJoinTravelToSessionComplete"));

	APlayerController_OnJoinTravelToSessionComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PreJoinUpdateGameSettings
// (Defined, Iterator, Latent, Net, Simulated, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     GameSettings                   (Parm)

void APlayerController::PreJoinUpdateGameSettings(const struct FName& SessionName, class UOnlineGameSettings* GameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PreJoinUpdateGameSettings"));

	APlayerController_PreJoinUpdateGameSettings_Params params;
	params.SessionName = SessionName;
	params.GameSettings = GameSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientTravelToSession
// (Final, PreOperator, Singular, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// class UClass*                  SearchClass                    (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm)

void APlayerController::STATIC_ClientTravelToSession(const struct FName& SessionName, class UClass* SearchClass, unsigned char PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientTravelToSession"));

	APlayerController_ClientTravelToSession_Params params;
	params.SessionName = SessionName;
	params.SearchClass = SearchClass;
	params.PlatformSpecificInfo = PlatformSpecificInfo;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PathClear
// (Defined, Singular, Net, NetReliable, Exec, Native, Event, Operator, Static)

void APlayerController::STATIC_PathClear()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PathClear"));

	APlayerController_PathClear_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PathChild
// (Final, Singular, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// int                            Cnt                            (OptionalParm, Parm)

void APlayerController::STATIC_PathChild(int Cnt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PathChild"));

	APlayerController_PathChild_Params params;
	params.Cnt = Cnt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PathStep
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// int                            Cnt                            (OptionalParm, Parm)

void APlayerController::STATIC_PathStep(int Cnt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PathStep"));

	APlayerController_PathStep_Params params;
	params.Cnt = Cnt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SoakPause
// (Final, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void APlayerController::SoakPause(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SoakPause"));

	APlayerController_SoakPause_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IncrementNumberOfMatchesPlayed
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)

void APlayerController::STATIC_IncrementNumberOfMatchesPlayed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IncrementNumberOfMatchesPlayed"));

	APlayerController_IncrementNumberOfMatchesPlayed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CanViewUserCreatedContent
// (Final, Iterator, Singular, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanViewUserCreatedContent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanViewUserCreatedContent"));

	APlayerController_CanViewUserCreatedContent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientEndOnlineGame
// (Iterator, Static)

void APlayerController::STATIC_ClientEndOnlineGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientEndOnlineGame"));

	APlayerController_ClientEndOnlineGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStartOnlineGame
// (Final, Defined, Latent, Singular, Static)

void APlayerController::STATIC_ClientStartOnlineGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStartOnlineGame"));

	APlayerController_ClientStartOnlineGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerRegisterClientStatGuid
// (Final, Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 StatGuid                       (Parm, NeedCtorLink)

void APlayerController::ServerRegisterClientStatGuid(const struct FString& StatGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerRegisterClientStatGuid"));

	APlayerController_ServerRegisterClientStatGuid_Params params;
	params.StatGuid = StatGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnRegisterHostStatGuidComplete
// (Latent, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnRegisterHostStatGuidComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnRegisterHostStatGuidComplete"));

	APlayerController_OnRegisterHostStatGuidComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRegisterHostStatGuid
// (Iterator, Latent, PreOperator, Static)
// Parameters:
// struct FString                 StatGuid                       (Parm, NeedCtorLink)

void APlayerController::STATIC_ClientRegisterHostStatGuid(const struct FString& StatGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientRegisterHostStatGuid"));

	APlayerController_ClientRegisterHostStatGuid_Params params;
	params.StatGuid = StatGuid;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RemoveAllDebugStrings
// (Defined, Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APlayerController::RemoveAllDebugStrings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RemoveAllDebugStrings"));

	APlayerController_RemoveAllDebugStrings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RemoveDebugText
// (Final, Defined, Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  SrcActor                       (Parm)

void APlayerController::RemoveDebugText(class AActor* SrcActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RemoveDebugText"));

	APlayerController_RemoveDebugText_Params params;
	params.SrcActor = SrcActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddDebugText
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// struct FString                 DebugText                      (Parm, NeedCtorLink)
// class AActor*                  SrcActor                       (OptionalParm, Parm)
// float                          Duration                       (OptionalParm, Parm)
// struct FVector                 Offset                         (OptionalParm, Parm)
// struct FVector                 DesiredOffset                  (OptionalParm, Parm)
// struct FColor                  TextColor                      (OptionalParm, Parm)
// bool                           bSkipOverwriteCheck            (OptionalParm, Parm)
// bool                           bAbsoluteLocation              (OptionalParm, Parm)
// bool                           bKeepAttachedToActor           (OptionalParm, Parm)
// class UFont*                   InFont                         (OptionalParm, Parm)

void APlayerController::AddDebugText(const struct FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AddDebugText"));

	APlayerController_AddDebugText_Params params;
	params.DebugText = DebugText;
	params.SrcActor = SrcActor;
	params.Duration = Duration;
	params.Offset = Offset;
	params.DesiredOffset = DesiredOffset;
	params.TextColor = TextColor;
	params.bSkipOverwriteCheck = bSkipOverwriteCheck;
	params.bAbsoluteLocation = bAbsoluteLocation;
	params.bKeepAttachedToActor = bKeepAttachedToActor;
	params.InFont = InFont;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DrawDebugTextList
// (Final, Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)
// float                          RenderDelta                    (Parm)

void APlayerController::STATIC_DrawDebugTextList(class UCanvas* Canvas, float RenderDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DrawDebugTextList"));

	APlayerController_DrawDebugTextList_Params params;
	params.Canvas = Canvas;
	params.RenderDelta = RenderDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnDestroy
// (Final, Defined, Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Destroy*         Action                         (Parm)

void APlayerController::STATIC_OnDestroy(class USeqAct_Destroy* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnDestroy"));

	APlayerController_OnDestroy_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStartNetworkedVoice
// (Defined, Latent, Singular, Static)

void APlayerController::STATIC_ClientStartNetworkedVoice()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStartNetworkedVoice"));

	APlayerController_ClientStartNetworkedVoice_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopNetworkedVoice
// (Defined, Iterator, Latent, Singular, Static)

void APlayerController::STATIC_ClientStopNetworkedVoice()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStopNetworkedVoice"));

	APlayerController_ClientStopNetworkedVoice_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetHostUniqueId
// (Defined, Singular, Static)
// Parameters:
// struct FUniqueNetId            InHostId                       (Parm)

void APlayerController::STATIC_ClientSetHostUniqueId(const struct FUniqueNetId& InHostId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetHostUniqueId"));

	APlayerController_ClientSetHostUniqueId_Params params;
	params.InHostId = InHostId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientWriteLeaderboardStats
// (Defined, Latent, PreOperator, Singular, Static)
// Parameters:
// class UClass*                  OnlineStatsWriteClass          (Parm)
// bool                           bIsIncomplete                  (OptionalParm, Parm)

void APlayerController::STATIC_ClientWriteLeaderboardStats(class UClass* OnlineStatsWriteClass, bool bIsIncomplete)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientWriteLeaderboardStats"));

	APlayerController_ClientWriteLeaderboardStats_Params params;
	params.OnlineStatsWriteClass = OnlineStatsWriteClass;
	params.bIsIncomplete = bIsIncomplete;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientWriteOnlinePlayerScores
// (Final, Defined, Latent, PreOperator, Singular, Static)
// Parameters:
// int                            LeaderboardId                  (Parm)

void APlayerController::STATIC_ClientWriteOnlinePlayerScores(int LeaderboardId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientWriteOnlinePlayerScores"));

	APlayerController_ClientWriteOnlinePlayerScores_Params params;
	params.LeaderboardId = LeaderboardId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientArbitratedMatchEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)

void APlayerController::ClientArbitratedMatchEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientArbitratedMatchEnded"));

	APlayerController_ClientArbitratedMatchEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyNotEnoughSpaceInInvite
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, Event, Operator, Static)

void APlayerController::STATIC_NotifyNotEnoughSpaceInInvite()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyNotEnoughSpaceInInvite"));

	APlayerController_NotifyNotEnoughSpaceInInvite_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyNotAllPlayersCanJoinInvite
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Event, Operator, Static)

void APlayerController::STATIC_NotifyNotAllPlayersCanJoinInvite()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyNotAllPlayersCanJoinInvite"));

	APlayerController_NotifyNotAllPlayersCanJoinInvite_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyInviteFailed
// (Final, Defined, Latent, Net, Simulated, Exec, Event, Operator, Static)

void APlayerController::STATIC_NotifyInviteFailed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyInviteFailed"));

	APlayerController_NotifyInviteFailed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnInviteJoinComplete
// (Iterator, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnInviteJoinComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnInviteJoinComplete"));

	APlayerController_OnInviteJoinComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ModifyClientURL
// (Final, Defined, Iterator, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_ModifyClientURL(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ModifyClientURL"));

	APlayerController_ModifyClientURL_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnDestroyForInviteComplete
// (PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnDestroyForInviteComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnDestroyForInviteComplete"));

	APlayerController_OnDestroyForInviteComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnEndForInviteComplete
// (Final, Iterator, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnEndForInviteComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnEndForInviteComplete"));

	APlayerController_OnEndForInviteComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClearInviteDelegates
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)

void APlayerController::ClearInviteDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClearInviteDelegates"));

	APlayerController_ClearInviteDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CanAllPlayersPlayOnline
// (Final, Defined, Iterator, Latent, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanAllPlayersPlayOnline()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanAllPlayersPlayOnline"));

	APlayerController_CanAllPlayersPlayOnline_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.InviteHasEnoughSpace
// (Final, Defined, PreOperator, Singular, Net, Exec, Operator, Static)
// Parameters:
// class UOnlineGameSettings*     InviteSettings                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_InviteHasEnoughSpace(class UOnlineGameSettings* InviteSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.InviteHasEnoughSpace"));

	APlayerController_InviteHasEnoughSpace_Params params;
	params.InviteSettings = InviteSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnGameInviteAccepted
// (Final, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FOnlineGameSearchResult InviteResult                   (Const, Parm, OutParm)

void APlayerController::OnGameInviteAccepted(struct FOnlineGameSearchResult* InviteResult)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnGameInviteAccepted"));

	APlayerController_OnGameInviteAccepted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InviteResult != nullptr)
		*InviteResult = params.InviteResult;
}


// Function Engine.PlayerController.ServerRegisteredForArbitration
// (Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void APlayerController::ServerRegisteredForArbitration(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerRegisteredForArbitration"));

	APlayerController_ServerRegisteredForArbitration_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnArbitrationRegisterComplete
// (NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnArbitrationRegisterComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnArbitrationRegisterComplete"));

	APlayerController_OnArbitrationRegisterComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRegisterForArbitration
// (Final, Defined, Latent, PreOperator, Static)

void APlayerController::STATIC_ClientRegisterForArbitration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientRegisterForArbitration"));

	APlayerController_ClientRegisterForArbitration_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientWasKicked
// (Defined, Iterator, Net, Simulated, Native, HasOptionalParms)

void APlayerController::ClientWasKicked()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientWasKicked"));

	APlayerController_ClientWasKicked_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsShowingSubtitles
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsShowingSubtitles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsShowingSubtitles"));

	APlayerController_IsShowingSubtitles_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SetShowSubtitles
// (Final, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bValue                         (Parm)

void APlayerController::SetShowSubtitles(bool bValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetShowSubtitles"));

	APlayerController_SetShowSubtitles_Params params;
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyDirectorControl
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bNowControlling                (Parm)
// class USeqAct_Interp*          CurrentMatinee                 (Parm)
// float                          fFadeTime                      (Parm)

void APlayerController::NotifyDirectorControl(bool bNowControlling, class USeqAct_Interp* CurrentMatinee, float fFadeTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyDirectorControl"));

	APlayerController_NotifyDirectorControl_Params params;
	params.bNowControlling = bNowControlling;
	params.CurrentMatinee = CurrentMatinee;
	params.fFadeTime = fFadeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUnmutePlayer
// (Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::ServerUnmutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUnmutePlayer"));

	APlayerController_ServerUnmutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerMutePlayer
// (Defined, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::ServerMutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerMutePlayer"));

	APlayerController_ServerMutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GameplayUnmutePlayer
// (Defined, Simulated, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::STATIC_GameplayUnmutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GameplayUnmutePlayer"));

	APlayerController_GameplayUnmutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GameplayMutePlayer
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::STATIC_GameplayMutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GameplayMutePlayer"));

	APlayerController_GameplayMutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUnmutePlayer
// (Final, Iterator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::ClientUnmutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientUnmutePlayer"));

	APlayerController_ClientUnmutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientMutePlayer
// (Iterator, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)

void APlayerController::ClientMutePlayer(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientMutePlayer"));

	APlayerController_ClientMutePlayer_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientVoiceHandshakeComplete
// (Defined, Iterator, PreOperator, Singular, Static)

void APlayerController::STATIC_ClientVoiceHandshakeComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientVoiceHandshakeComplete"));

	APlayerController_ClientVoiceHandshakeComplete_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetPlayerControllerFromNetId
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)
// class APlayerController*       ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerController* APlayerController::STATIC_GetPlayerControllerFromNetId(const struct FUniqueNetId& PlayerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPlayerControllerFromNetId"));

	APlayerController_GetPlayerControllerFromNetId_Params params;
	params.PlayerNetId = PlayerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientSetOnlineStatus
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientSetOnlineStatus()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetOnlineStatus"));

	APlayerController_ClientSetOnlineStatus_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SeamlessTravelFrom
// (Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       OldPC                          (Parm)

void APlayerController::SeamlessTravelFrom(class APlayerController* OldPC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SeamlessTravelFrom"));

	APlayerController_SeamlessTravelFrom_Params params;
	params.OldPC = OldPC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SeamlessTravelTo
// (Final, Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       NewPC                          (Parm)

void APlayerController::SeamlessTravelTo(class APlayerController* NewPC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SeamlessTravelTo"));

	APlayerController_SeamlessTravelTo_Params params;
	params.NewPC = NewPC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetSeamlessTravelActorList
// (Defined, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bToEntry                       (Parm)
// TArray<class AActor*>          ActorList                      (Parm, OutParm, NeedCtorLink)

void APlayerController::GetSeamlessTravelActorList(bool bToEntry, TArray<class AActor*>* ActorList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetSeamlessTravelActorList"));

	APlayerController_GetSeamlessTravelActorList_Params params;
	params.bToEntry = bToEntry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActorList != nullptr)
		*ActorList = params.ActorList;
}


// Function Engine.PlayerController.IsPlayerMuted
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            Sender                         (Const, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::IsPlayerMuted(struct FUniqueNetId* Sender)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsPlayerMuted"));

	APlayerController_IsPlayerMuted_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Sender != nullptr)
		*Sender = params.Sender;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetUIController
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UUIInteraction*          ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIInteraction* APlayerController::STATIC_GetUIController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetUIController"));

	APlayerController_GetUIController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SaveActorConfig
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FName                   actorName                      (Parm, CoerceParm)

void APlayerController::SaveActorConfig(const struct FName& actorName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SaveActorConfig"));

	APlayerController_SaveActorConfig_Params params;
	params.actorName = actorName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SaveClassConfig
// (Final, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ClassName                      (Parm, CoerceParm, NeedCtorLink)

void APlayerController::SaveClassConfig(const struct FString& ClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SaveClassConfig"));

	APlayerController_SaveClassConfig_Params params;
	params.ClassName = ClassName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientWaitForLevelsVisible
// (Final, Defined, Iterator, PreOperator, Singular, Static)
// Parameters:
// class USeqAct_WaitForLevelsVisible* inAction                       (Parm)

void APlayerController::STATIC_ClientWaitForLevelsVisible(class USeqAct_WaitForLevelsVisible* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientWaitForLevelsVisible"));

	APlayerController_ClientWaitForLevelsVisible_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientSetBlockOnAsyncLoading()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading"));

	APlayerController_ClientSetBlockOnAsyncLoading_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientFlushLevelStreaming
// (PreOperator, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientFlushLevelStreaming()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientFlushLevelStreaming"));

	APlayerController_ClientFlushLevelStreaming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCancelPendingMapChange
// (Iterator, Latent, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientCancelPendingMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientCancelPendingMapChange"));

	APlayerController_ClientCancelPendingMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCommitMapChange
// (Final, Iterator, Latent, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientCommitMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientCommitMapChange"));

	APlayerController_ClientCommitMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DelayedPrepareMapChange
// (Iterator, Latent, PreOperator, Net, Native, Static)

void APlayerController::STATIC_DelayedPrepareMapChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DelayedPrepareMapChange"));

	APlayerController_DelayedPrepareMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPrepareMapChange
// (Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FName                   LevelName                      (Parm)
// bool                           bFirst                         (Parm)
// bool                           bLast                          (Parm)

void APlayerController::ClientPrepareMapChange(const struct FName& LevelName, bool bFirst, bool bLast)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPrepareMapChange"));

	APlayerController_ClientPrepareMapChange_Params params;
	params.LevelName = LevelName;
	params.bFirst = bFirst;
	params.bLast = bLast;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdateLevelVisibility
// (Final, Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   PackageName                    (Parm)
// bool                           bIsVisible                     (Parm)

void APlayerController::ServerUpdateLevelVisibility(const struct FName& PackageName, bool bIsVisible)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUpdateLevelVisibility"));

	APlayerController_ServerUpdateLevelVisibility_Params params;
	params.PackageName = PackageName;
	params.bIsVisible = bIsVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
// (Iterator, PreOperator, Singular, Static)
// Parameters:
// struct FName                   PackageName                    (Parm)
// bool                           bNewShouldBeLoaded             (Parm)
// bool                           bNewShouldBeVisible            (Parm)
// bool                           bNewShouldBlockOnLoad          (Parm)

void APlayerController::STATIC_ClientUpdateLevelStreamingStatus(const struct FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus"));

	APlayerController_ClientUpdateLevelStreamingStatus_Params params;
	params.PackageName = PackageName;
	params.bNewShouldBeLoaded = bNewShouldBeLoaded;
	params.bNewShouldBeVisible = bNewShouldBeVisible;
	params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LevelStreamingStatusChanged
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class ULevelStreaming*         LevelObject                    (Parm)
// bool                           bNewShouldBeLoaded             (Parm)
// bool                           bNewShouldBeVisible            (Parm)
// bool                           bNewShouldBlockOnLoad          (Parm)

void APlayerController::LevelStreamingStatusChanged(class ULevelStreaming* LevelObject, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LevelStreamingStatusChanged"));

	APlayerController_LevelStreamingStatusChanged_Params params;
	params.LevelObject = LevelObject;
	params.bNewShouldBeLoaded = bNewShouldBeLoaded;
	params.bNewShouldBeVisible = bNewShouldBeVisible;
	params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientForceGarbageCollection
// (Final, PreOperator, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClientForceGarbageCollection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientForceGarbageCollection"));

	APlayerController_ClientForceGarbageCollection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnConsoleCommand
// (Final, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ConsoleCommand*  inAction                       (Parm)

void APlayerController::STATIC_OnConsoleCommand(class USeqAct_ConsoleCommand* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnConsoleCommand"));

	APlayerController_OnConsoleCommand_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ResetPlayerMovementInput
// (Final, Iterator, NetReliable, Native, HasOptionalParms)

void APlayerController::ResetPlayerMovementInput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ResetPlayerMovementInput"));

	APlayerController_ResetPlayerMovementInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IgnoreLookInput
// (Defined, NetReliable, Operator, Static)
// Parameters:
// bool                           bNewLookInput                  (Parm)

void APlayerController::STATIC_IgnoreLookInput(bool bNewLookInput)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IgnoreLookInput"));

	APlayerController_IgnoreLookInput_Params params;
	params.bNewLookInput = bNewLookInput;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IgnoreMoveInput
// (Final, Defined, NetReliable, Operator, Static)
// Parameters:
// bool                           bNewMoveInput                  (Parm)

void APlayerController::STATIC_IgnoreMoveInput(bool bNewMoveInput)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IgnoreMoveInput"));

	APlayerController_IgnoreMoveInput_Params params;
	params.bNewMoveInput = bNewMoveInput;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetCinematicMode
// (Final, Singular, Static)
// Parameters:
// bool                           bInCinematicMode               (Parm)
// bool                           bAffectsMovement               (Parm)
// bool                           bAffectsTurning                (Parm)
// bool                           bAffectsHUD                    (Parm)

void APlayerController::STATIC_ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetCinematicMode"));

	APlayerController_ClientSetCinematicMode_Params params;
	params.bInCinematicMode = bInCinematicMode;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;
	params.bAffectsHUD = bAffectsHUD;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetCinematicMode
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInCinematicMode               (Parm)
// bool                           bHidePlayer                    (Parm)
// bool                           bAffectsHUD                    (Parm)
// bool                           bAffectsMovement               (Parm)
// bool                           bAffectsTurning                (Parm)
// bool                           bAffectsButtons                (Parm)

void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetCinematicMode"));

	APlayerController_SetCinematicMode_Params params;
	params.bInCinematicMode = bInCinematicMode;
	params.bHidePlayer = bHidePlayer;
	params.bAffectsHUD = bAffectsHUD;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;
	params.bAffectsButtons = bAffectsButtons;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnToggleCinematicMode
// (Defined, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleCinematicMode* Action                         (Parm)

void APlayerController::STATIC_OnToggleCinematicMode(class USeqAct_ToggleCinematicMode* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnToggleCinematicMode"));

	APlayerController_OnToggleCinematicMode_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsForceFeedbackAllowed
// (Final, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsForceFeedbackAllowed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsForceFeedbackAllowed"));

	APlayerController_IsForceFeedbackAllowed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.StopForceFeedbackWaveform
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  FFWaveform                     (OptionalParm, Parm)

void APlayerController::StopForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.StopForceFeedbackWaveform"));

	APlayerController_StopForceFeedbackWaveform_Params params;
	params.FFWaveform = FFWaveform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopForceFeedbackWaveform
// (Final, Defined, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  FFWaveform                     (OptionalParm, Parm)

void APlayerController::ClientStopForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientStopForceFeedbackWaveform"));

	APlayerController_ClientStopForceFeedbackWaveform_Params params;
	params.FFWaveform = FFWaveform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PlayForceFeedbackWaveform
// (Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  FFWaveform                     (Parm)
// class AActor*                  FFWaveformInstigator           (OptionalParm, Parm)
// float                          fScale                         (OptionalParm, Parm)
// float                          fScaleDuration                 (OptionalParm, Parm)
// bool                           bForcePlay                     (OptionalParm, Parm)

void APlayerController::PlayForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform, class AActor* FFWaveformInstigator, float fScale, float fScaleDuration, bool bForcePlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PlayForceFeedbackWaveform"));

	APlayerController_PlayForceFeedbackWaveform_Params params;
	params.FFWaveform = FFWaveform;
	params.FFWaveformInstigator = FFWaveformInstigator;
	params.fScale = fScale;
	params.fScaleDuration = fScaleDuration;
	params.bForcePlay = bForcePlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayForceFeedbackWaveform
// (Defined, Iterator, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  FFWaveform                     (Parm)
// class AActor*                  FFWaveformInstigator           (OptionalParm, Parm)
// float                          fScale                         (OptionalParm, Parm)
// float                          fScaleDuration                 (OptionalParm, Parm)
// bool                           bForcePlay                     (OptionalParm, Parm)

void APlayerController::ClientPlayForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform, class AActor* FFWaveformInstigator, float fScale, float fScaleDuration, bool bForcePlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPlayForceFeedbackWaveform"));

	APlayerController_ClientPlayForceFeedbackWaveform_Params params;
	params.FFWaveform = FFWaveform;
	params.FFWaveformInstigator = FFWaveformInstigator;
	params.fScale = fScale;
	params.fScaleDuration = fScaleDuration;
	params.bForcePlay = bForcePlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PlayRumble
// (Defined, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_Rumble*      TheAnimNotify                  (Const, Parm)

void APlayerController::PlayRumble(class UAnimNotify_Rumble* TheAnimNotify)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PlayRumble"));

	APlayerController_PlayRumble_Params params;
	params.TheAnimNotify = TheAnimNotify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnForceFeedback
// (Defined, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ForceFeedback*   Action                         (Parm)

void APlayerController::STATIC_OnForceFeedback(class USeqAct_ForceFeedback* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnForceFeedback"));

	APlayerController_OnForceFeedback_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyTakeHit
// (Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// int                            Damage                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 Momentum                       (Parm)

void APlayerController::STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyTakeHit"));

	APlayerController_NotifyTakeHit_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.Momentum = Momentum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ShowGameState
// (Singular, Simulated, Event, HasOptionalParms)

void APlayerController::ShowGameState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ShowGameState"));

	APlayerController_ShowGameState_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ShowPlayerState
// (Final, PreOperator, Singular, Simulated, Event, HasOptionalParms)

void APlayerController::ShowPlayerState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ShowPlayerState"));

	APlayerController_ShowPlayerState_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerRemoteEvent
// (Final, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   EventName                      (Parm)

void APlayerController::ServerRemoteEvent(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerRemoteEvent"));

	APlayerController_ServerRemoteEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RE
// (Defined, Latent, PreOperator, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   EventName                      (OptionalParm, Parm)

void APlayerController::RE(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RE"));

	APlayerController_RE_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RemoteEvent
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   EventName                      (OptionalParm, Parm)

void APlayerController::RemoteEvent(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RemoteEvent"));

	APlayerController_RemoteEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ListCE
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Native, Operator, Static)

void APlayerController::STATIC_ListCE()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ListCE"));

	APlayerController_ListCE_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ListConsoleEvents
// (Iterator, PreOperator, Singular, Net, NetReliable, Native, Operator, Static)

void APlayerController::STATIC_ListConsoleEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ListConsoleEvents"));

	APlayerController_ListConsoleEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CE
// (Latent, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FName                   EventName                      (OptionalParm, Parm)

void APlayerController::CE(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CE"));

	APlayerController_CE_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CauseEvent
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Operator)
// Parameters:
// struct FName                   EventName                      (OptionalParm, Parm)

void APlayerController::CauseEvent(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CauseEvent"));

	APlayerController_CauseEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerCauseEvent
// (Final, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   EventName                      (Parm)

void APlayerController::ServerCauseEvent(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerCauseEvent"));

	APlayerController_ServerCauseEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnToggleHUD
// (Defined, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleHUD*       inAction                       (Parm)

void APlayerController::STATIC_OnToggleHUD(class USeqAct_ToggleHUD* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnToggleHUD"));

	APlayerController_OnToggleHUD_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnSetCameraTarget
// (Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetCameraTarget* inAction                       (Parm)

void APlayerController::STATIC_OnSetCameraTarget(class USeqAct_SetCameraTarget* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnSetCameraTarget"));

	APlayerController_OnSetCameraTarget_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientClearKismetText
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FVector2D               MessageOffset                  (Parm)

void APlayerController::ClientClearKismetText(const struct FVector2D& MessageOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientClearKismetText"));

	APlayerController_ClientClearKismetText_Params params;
	params.MessageOffset = MessageOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientDrawKismetText
// (Final, Defined, Static)
// Parameters:
// struct FKismetDrawTextInfo     DrawTextInfo                   (Parm, NeedCtorLink)
// float                          DisplayTime                    (Parm)

void APlayerController::STATIC_ClientDrawKismetText(const struct FKismetDrawTextInfo& DrawTextInfo, float DisplayTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientDrawKismetText"));

	APlayerController_ClientDrawKismetText_Params params;
	params.DrawTextInfo = DrawTextInfo;
	params.DisplayTime = DisplayTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnDrawText
// (Iterator, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_DrawText*        inAction                       (Parm)

void APlayerController::STATIC_OnDrawText(class USeqAct_DrawText* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnDrawText"));

	APlayerController_OnDrawText_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void APlayerController::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DisplayDebug"));

	APlayerController_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.PlayerController.ClientIgnoreLookInput
// (Latent, Static)
// Parameters:
// bool                           bIgnore                        (Parm)

void APlayerController::STATIC_ClientIgnoreLookInput(bool bIgnore)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientIgnoreLookInput"));

	APlayerController_ClientIgnoreLookInput_Params params;
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientIgnoreMoveInput
// (Final, Latent, Static)
// Parameters:
// bool                           bIgnore                        (Parm)

void APlayerController::STATIC_ClientIgnoreMoveInput(bool bIgnore)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientIgnoreMoveInput"));

	APlayerController_ClientIgnoreMoveInput_Params params;
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnToggleInput
// (Final, Defined, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleInput*     inAction                       (Parm)

void APlayerController::STATIC_OnToggleInput(class USeqAct_ToggleInput* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnToggleInput"));

	APlayerController_OnToggleInput_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AdjustHUDRenderSize
// (Defined, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            X                              (Parm, OutParm)
// int                            Y                              (Parm, OutParm)
// int                            SizeX                          (Parm, OutParm)
// int                            SizeY                          (Parm, OutParm)
// int                            FullScreenSizeX                (Const, Parm)
// int                            FullScreenSizeY                (Const, Parm)

void APlayerController::AdjustHUDRenderSize(int FullScreenSizeX, int FullScreenSizeY, int* X, int* Y, int* SizeX, int* SizeY)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AdjustHUDRenderSize"));

	APlayerController_AdjustHUDRenderSize_Params params;
	params.FullScreenSizeX = FullScreenSizeX;
	params.FullScreenSizeY = FullScreenSizeY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (SizeX != nullptr)
		*SizeX = params.SizeX;
	if (SizeY != nullptr)
		*SizeY = params.SizeY;
}


// Function Engine.PlayerController.DrawHUD
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// class AHUD*                    H                              (Parm)

void APlayerController::STATIC_DrawHUD(class AHUD* H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DrawHUD"));

	APlayerController_DrawHUD_Params params;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CanRestartPlayer
// (Final, Iterator, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanRestartPlayer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanRestartPlayer"));

	APlayerController_CanRestartPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerViewSelf
// (Latent, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FViewTargetTransitionParams TransitionParams               (OptionalParm, Parm)

void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerViewSelf"));

	APlayerController_ServerViewSelf_Params params;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ViewAPlayer
// (Iterator, Singular, Net, Operator, HasOptionalParms)
// Parameters:
// int                            Dir                            (Parm)

void APlayerController::ViewAPlayer(int Dir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ViewAPlayer"));

	APlayerController_ViewAPlayer_Params params;
	params.Dir = Dir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetNextViewablePlayer
// (Final, Defined, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// int                            Dir                            (Parm)
// class APlayerReplicationInfo*  ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerReplicationInfo* APlayerController::STATIC_GetNextViewablePlayer(int Dir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetNextViewablePlayer"));

	APlayerController_GetNextViewablePlayer_Params params;
	params.Dir = Dir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerViewPrevPlayer
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bFriendlyOnly                  (OptionalParm, Parm)

void APlayerController::ServerViewPrevPlayer(bool bFriendlyOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerViewPrevPlayer"));

	APlayerController_ServerViewPrevPlayer_Params params;
	params.bFriendlyOnly = bFriendlyOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerViewNextPlayer
// (Defined, Iterator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bFriendlyOnly                  (OptionalParm, Parm)

void APlayerController::ServerViewNextPlayer(bool bFriendlyOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerViewNextPlayer"));

	APlayerController_ServerViewNextPlayer_Params params;
	params.bFriendlyOnly = bFriendlyOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSetSpectatorLocation
// (Final, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewLoc                         (Parm)

void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerSetSpectatorLocation"));

	APlayerController_ServerSetSpectatorLocation_Params params;
	params.NewLoc = NewLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.HandleWalking
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)

void APlayerController::STATIC_HandleWalking()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HandleWalking"));

	APlayerController_HandleWalking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CheckJumpOrDuck
// (Final, Defined, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)

void APlayerController::CheckJumpOrDuck()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CheckJumpOrDuck"));

	APlayerController_CheckJumpOrDuck_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ProcessViewRotation
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FRotator                out_ViewRotation               (Parm, OutParm)
// struct FRotator                DeltaRot                       (Parm)

void APlayerController::ProcessViewRotation(float DeltaTime, const struct FRotator& DeltaRot, struct FRotator* out_ViewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ProcessViewRotation"));

	APlayerController_ProcessViewRotation_Params params;
	params.DeltaTime = DeltaTime;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_ViewRotation != nullptr)
		*out_ViewRotation = params.out_ViewRotation;
}


// Function Engine.PlayerController.UpdateRotation
// (Final, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)

void APlayerController::UpdateRotation(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UpdateRotation"));

	APlayerController_UpdateRotation_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ViewShake
// (Final, Iterator, NetReliable, Operator, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)

void APlayerController::ViewShake(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ViewShake"));

	APlayerController_ViewShake_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetPlayerViewPoint
// (Defined, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void APlayerController::STATIC_GetPlayerViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPlayerViewPoint"));

	APlayerController_GetPlayerViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.PlayerController.SpawnPlayerCamera
// (Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::SpawnPlayerCamera()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SpawnPlayerCamera"));

	APlayerController_SpawnPlayerCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerVerifyViewTarget
// (Iterator, Singular, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerVerifyViewTarget()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerVerifyViewTarget"));

	APlayerController_ServerVerifyViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetViewTarget
// (Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* APlayerController::STATIC_GetViewTarget()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetViewTarget"));

	APlayerController_GetViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientSetViewTarget
// (Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  A                              (Parm)
// struct FViewTargetTransitionParams TransitionParams               (OptionalParm, Parm)

void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetViewTarget"));

	APlayerController_ClientSetViewTarget_Params params;
	params.A = A;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetViewTargetWithBlend
// (Defined, Iterator, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm)
// float                          BlendTime                      (OptionalParm, Parm)
// TEnumAsByte<EViewTargetBlendFunction> BlendFunc                      (OptionalParm, Parm)
// float                          BlendExp                       (OptionalParm, Parm)
// bool                           bLockOutgoing                  (OptionalParm, Parm)

void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, TEnumAsByte<EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetViewTargetWithBlend"));

	APlayerController_SetViewTargetWithBlend_Params params;
	params.NewViewTarget = NewViewTarget;
	params.BlendTime = BlendTime;
	params.BlendFunc = BlendFunc;
	params.BlendExp = BlendExp;
	params.bLockOutgoing = bLockOutgoing;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetViewTarget
// (Iterator, PreOperator, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm)
// struct FViewTargetTransitionParams TransitionParams               (OptionalParm, Parm)

void APlayerController::SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetViewTarget"));

	APlayerController_SetViewTarget_Params params;
	params.NewViewTarget = NewViewTarget;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsLocalController
// (Final, Iterator, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsLocalController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsLocalController"));

	APlayerController_IsLocalController_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsLocalPlayerController
// (PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsLocalPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsLocalPlayerController"));

	APlayerController_IsLocalPlayerController_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.NotifyLanded
// (Defined, Iterator, Net, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  FloorActor                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::NotifyLanded(const struct FVector& HitNormal, class AActor* FloorActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyLanded"));

	APlayerController_NotifyLanded_Params params;
	params.HitNormal = HitNormal;
	params.FloorActor = FloorActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.AimHelpDot
// (Iterator, NetReliable, Operator)
// Parameters:
// bool                           bInstantHit                    (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APlayerController::AimHelpDot(bool bInstantHit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AimHelpDot"));

	APlayerController_AimHelpDot_Params params;
	params.bInstantHit = bInstantHit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetAdjustedAimFor
// (Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// struct FVector                 StartFireLoc                   (Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator APlayerController::STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetAdjustedAimFor"));

	APlayerController_GetAdjustedAimFor_Params params;
	params.W = W;
	params.StartFireLoc = StartFireLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CameraLookAtFinished
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_CameraLookAt*    Action                         (Parm)

void APlayerController::CameraLookAtFinished(class USeqAct_CameraLookAt* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CameraLookAtFinished"));

	APlayerController_CameraLookAtFinished_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AimingHelp
// (Final, Iterator, NetReliable, Operator)
// Parameters:
// bool                           bInstantHit                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::AimingHelp(bool bInstantHit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AimingHelp"));

	APlayerController_AimingHelp_Params params;
	params.bInstantHit = bInstantHit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.PlayerMove
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Static)
// Parameters:
// float                          DeltaTime                      (Parm)

void APlayerController::STATIC_PlayerMove(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PlayerMove"));

	APlayerController_PlayerMove_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NotifyChangedWeapon
// (Final, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AWeapon*                 PreviousWeapon                 (Parm)
// class AWeapon*                 NewWeapon                      (Parm)

void APlayerController::STATIC_NotifyChangedWeapon(class AWeapon* PreviousWeapon, class AWeapon* NewWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyChangedWeapon"));

	APlayerController_NotifyChangedWeapon_Params params;
	params.PreviousWeapon = PreviousWeapon;
	params.NewWeapon = NewWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientGameEnded
// (Final, Iterator, Static)
// Parameters:
// class AActor*                  EndGameFocus                   (Parm)
// bool                           bIsWinner                      (Parm)

void APlayerController::STATIC_ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientGameEnded"));

	APlayerController_ClientGameEnded_Params params;
	params.EndGameFocus = EndGameFocus;
	params.bIsWinner = bIsWinner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GameHasEnded
// (Final, Defined, Latent, Singular, Net, NetReliable, Native, Event, Static)
// Parameters:
// class AActor*                  EndGameFocus                   (OptionalParm, Parm)
// bool                           bIsWinner                      (OptionalParm, Parm)

void APlayerController::STATIC_GameHasEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GameHasEnded"));

	APlayerController_GameHasEnded_Params params;
	params.EndGameFocus = EndGameFocus;
	params.bIsWinner = bIsWinner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRestart
// (Defined, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   NewPawn                        (Parm)

void APlayerController::ClientRestart(class APawn* NewPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientRestart"));

	APlayerController_ClientRestart_Params params;
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.EnterStartState
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Event, Static)

void APlayerController::STATIC_EnterStartState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.EnterStartState"));

	APlayerController_EnterStartState_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ForceSingleNetUpdateFor
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// class AActor*                  Target                         (Parm)

void APlayerController::STATIC_ForceSingleNetUpdateFor(class AActor* Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ForceSingleNetUpdateFor"));

	APlayerController_ForceSingleNetUpdateFor_Params params;
	params.Target = Target;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.HasClientLoadedCurrentWorld
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_HasClientLoadedCurrentWorld()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HasClientLoadedCurrentWorld"));

	APlayerController_HasClientLoadedCurrentWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.NotifyLoadedWorld
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FName                   WorldPackageName               (Parm)
// bool                           bFinalDest                     (Parm)

void APlayerController::NotifyLoadedWorld(const struct FName& WorldPackageName, bool bFinalDest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyLoadedWorld"));

	APlayerController_NotifyLoadedWorld_Params params;
	params.WorldPackageName = WorldPackageName;
	params.bFinalDest = bFinalDest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerNotifyLoadedWorld
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   WorldPackageName               (Parm)

void APlayerController::ServerNotifyLoadedWorld(const struct FName& WorldPackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerNotifyLoadedWorld"));

	APlayerController_ServerNotifyLoadedWorld_Params params;
	params.WorldPackageName = WorldPackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Restart
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Native, HasOptionalParms)
// Parameters:
// bool                           bVehicleTransition             (Parm)

void APlayerController::Restart(bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Restart"));

	APlayerController_Restart_Params params;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetProgressMessage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EProgressMessageType> MessageType                    (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)
// struct FString                 Title                          (OptionalParm, Parm, NeedCtorLink)
// bool                           bIgnoreFutureNetworkMessages   (OptionalParm, Parm)

void APlayerController::ClientSetProgressMessage(TEnumAsByte<EProgressMessageType> MessageType, const struct FString& Message, const struct FString& Title, bool bIgnoreFutureNetworkMessages)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetProgressMessage"));

	APlayerController_ClientSetProgressMessage_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.Title = Title;
	params.bIgnoreFutureNetworkMessages = bIgnoreFutureNetworkMessages;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SwitchLevel
// (Defined, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)

void APlayerController::SwitchLevel(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SwitchLevel"));

	APlayerController_SwitchLevel_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerChangeTeam
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            N                              (Parm)

void APlayerController::ServerChangeTeam(int N)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerChangeTeam"));

	APlayerController_ServerChangeTeam_Params params;
	params.N = N;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ChangeTeam
// (Final, Iterator, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 TeamName                       (OptionalParm, Parm, NeedCtorLink)

void APlayerController::ChangeTeam(const struct FString& TeamName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ChangeTeam"));

	APlayerController_ChangeTeam_Params params;
	params.TeamName = TeamName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SwitchTeam
// (Defined, Iterator, Singular, Net, Native, Event, HasOptionalParms)

void APlayerController::SwitchTeam()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SwitchTeam"));

	APlayerController_SwitchTeam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerChangeName
// (Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)

void APlayerController::ServerChangeName(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerChangeName"));

	APlayerController_ServerChangeName_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetName
// (Final, Iterator, Latent, Event, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)

void APlayerController::SetName(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetName"));

	APlayerController_SetName_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSuicide
// (Defined, Latent, PreOperator, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerSuicide()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerSuicide"));

	APlayerController_ServerSuicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Suicide
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::Suicide()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Suicide"));

	APlayerController_Suicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TriggerInteracted
// (Defined, Latent, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::TriggerInteracted()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TriggerInteracted"));

	APlayerController_TriggerInteracted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.FindVehicleToDrive
// (Final, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::FindVehicleToDrive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FindVehicleToDrive"));

	APlayerController_FindVehicleToDrive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.PerformedUseAction
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_PerformedUseAction()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PerformedUseAction"));

	APlayerController_PerformedUseAction_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerUse
// (Defined, Singular, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerUse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUse"));

	APlayerController_ServerUse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Use
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void APlayerController::Use()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Use"));

	APlayerController_Use_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetTriggerUseList
// (Final, Iterator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          interactDistanceToCheck        (Parm)
// float                          crosshairDist                  (Parm)
// float                          minDot                         (Parm)
// bool                           bUsuableOnly                   (Parm)
// TArray<class ATrigger*>        out_useList                    (Parm, OutParm, NeedCtorLink)

void APlayerController::STATIC_GetTriggerUseList(float interactDistanceToCheck, float crosshairDist, float minDot, bool bUsuableOnly, TArray<class ATrigger*>* out_useList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetTriggerUseList"));

	APlayerController_GetTriggerUseList_Params params;
	params.interactDistanceToCheck = interactDistanceToCheck;
	params.crosshairDist = crosshairDist;
	params.minDot = minDot;
	params.bUsuableOnly = bUsuableOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_useList != nullptr)
		*out_useList = params.out_useList;
}


// Function Engine.PlayerController.StopAltFire
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  FireModeNum                    (OptionalParm, Parm)

void APlayerController::StopAltFire(unsigned char FireModeNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.StopAltFire"));

	APlayerController_StopAltFire_Params params;
	params.FireModeNum = FireModeNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.StartAltFire
// (Latent, PreOperator, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  FireModeNum                    (OptionalParm, Parm)

void APlayerController::StartAltFire(unsigned char FireModeNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.StartAltFire"));

	APlayerController_StartAltFire_Params params;
	params.FireModeNum = FireModeNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.StopFire
// (Final, Defined, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)

void APlayerController::StopFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.StopFire"));

	APlayerController_StopFire_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.StartFire
// (Final, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::StartFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.StartFire"));

	APlayerController_StartFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.NextWeapon
// (Final, Net, NetReliable, Exec, Event, Operator, Static)

void APlayerController::STATIC_NextWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NextWeapon"));

	APlayerController_NextWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PrevWeapon
// (Latent, NetReliable, Simulated, HasOptionalParms)

void APlayerController::PrevWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PrevWeapon"));

	APlayerController_PrevWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ThrowWeapon
// (Final, Defined, NetReliable, Simulated, Native, Event, HasOptionalParms)

void APlayerController::ThrowWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ThrowWeapon"));

	APlayerController_ThrowWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UTrace
// (Defined, Iterator, PreOperator, Net, Simulated, Exec)

void APlayerController::UTrace()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UTrace"));

	APlayerController_UTrace_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUTrace
// (Final, Defined, Singular, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerUTrace()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUTrace"));

	APlayerController_ServerUTrace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ConditionalPause
// (Final, Latent, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bDesiredPauseState             (Parm)

void APlayerController::ConditionalPause(bool bDesiredPauseState)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ConditionalPause"));

	APlayerController_ConditionalPause_Params params;
	params.bDesiredPauseState = bDesiredPauseState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerPause
// (Final, Iterator, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerPause"));

	APlayerController_ServerPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Pause
// (Defined, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)

void APlayerController::Pause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Pause"));

	APlayerController_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsPaused
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::IsPaused()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsPaused"));

	APlayerController_IsPaused_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SetPause
// (Final, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bPause                         (Parm)
// struct FScriptDelegate         CanUnpauseDelegate             (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::SetPause(bool bPause, const struct FScriptDelegate& CanUnpauseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetPause"));

	APlayerController_SetPause_Params params;
	params.bPause = bPause;
	params.CanUnpauseDelegate = CanUnpauseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CanUnpause
// (Final, Iterator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanUnpause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanUnpause"));

	APlayerController_CanUnpause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientPauseRumble
// (PreOperator, Static)
// Parameters:
// bool                           bShouldPauseRumble             (Parm)

void APlayerController::STATIC_ClientPauseRumble(bool bShouldPauseRumble)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPauseRumble"));

	APlayerController_ClientPauseRumble_Params params;
	params.bShouldPauseRumble = bShouldPauseRumble;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PauseRumbleForAllPlayers
// (Iterator, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// bool                           bShouldPauseRumble             (OptionalParm, Parm)

void APlayerController::STATIC_PauseRumbleForAllPlayers(bool bShouldPauseRumble)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PauseRumbleForAllPlayers"));

	APlayerController_PauseRumbleForAllPlayers_Params params;
	params.bShouldPauseRumble = bShouldPauseRumble;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LocalTravel
// (Final, Defined, Iterator, Latent, Singular, Simulated, Native, Operator, Static)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)

void APlayerController::STATIC_LocalTravel(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LocalTravel"));

	APlayerController_LocalTravel_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RestartLevel
// (Final, Singular, NetReliable, Native, HasOptionalParms)

void APlayerController::RestartLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RestartLevel"));

	APlayerController_RestartLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSpeech
// (Final, Defined, Iterator, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   Type                           (Parm)
// int                            Index                          (Parm)
// struct FString                 Callsign                       (Parm, NeedCtorLink)

void APlayerController::ServerSpeech(const struct FName& Type, int Index, const struct FString& Callsign)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerSpeech"));

	APlayerController_ServerSpeech_Params params;
	params.Type = Type;
	params.Index = Index;
	params.Callsign = Callsign;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Speech
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   Type                           (Parm)
// int                            Index                          (Parm)
// struct FString                 Callsign                       (Parm, NeedCtorLink)

void APlayerController::Speech(const struct FName& Type, int Index, const struct FString& Callsign)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Speech"));

	APlayerController_Speech_Params params;
	params.Type = Type;
	params.Index = Index;
	params.Callsign = Callsign;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerRestartGame
// (Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::ServerRestartGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerRestartGame"));

	APlayerController_ServerRestartGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdateCamera
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 CamLoc                         (Parm)
// int                            CamPitchAndYaw                 (Parm)

void APlayerController::ServerUpdateCamera(const struct FVector& CamLoc, int CamPitchAndYaw)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUpdateCamera"));

	APlayerController_ServerUpdateCamera_Params params;
	params.CamLoc = CamLoc;
	params.CamPitchAndYaw = CamPitchAndYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CallServerMove
// (Defined, Iterator, Latent, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class USavedMove*              NewMove                        (Parm)
// struct FVector                 ClientLoc                      (Parm)
// unsigned char                  ClientRoll                     (Parm)
// int                            View                           (Parm)
// class USavedMove*              OldMove                        (Parm)

void APlayerController::CallServerMove(class USavedMove* NewMove, const struct FVector& ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CallServerMove"));

	APlayerController_CallServerMove_Params params;
	params.NewMove = NewMove;
	params.ClientLoc = ClientLoc;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.OldMove = OldMove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetNetMoveDelta
// (Final, Net, Exec, Native, Event, Static)
// Parameters:
// float                          DeltaTime                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APlayerController::STATIC_GetNetMoveDelta(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetNetMoveDelta"));

	APlayerController_GetNetMoveDelta_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ReplicateMove
// (PreOperator, Net, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FVector                 newAccel                       (Parm)
// TEnumAsByte<EDoubleClickDir>   DoubleClickMove                (Parm)
// struct FRotator                DeltaRot                       (Parm)

void APlayerController::ReplicateMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ReplicateMove"));

	APlayerController_ReplicateMove_Params params;
	params.DeltaTime = DeltaTime;
	params.newAccel = newAccel;
	params.DoubleClickMove = DoubleClickMove;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CompressAccel
// (Iterator, Latent, Singular, Simulated, Static)
// Parameters:
// int                            C                              (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int APlayerController::STATIC_CompressAccel(int C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CompressAccel"));

	APlayerController_CompressAccel_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClearAckedMoves
// (Final, Defined, Latent, Singular, Simulated, Exec, Native, Event, Operator)

void APlayerController::ClearAckedMoves()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClearAckedMoves"));

	APlayerController_ClearAckedMoves_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdatePing
// (Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            NewPing                        (Parm)

void APlayerController::ServerUpdatePing(int NewPing)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerUpdatePing"));

	APlayerController_ServerUpdatePing_Params params;
	params.NewPing = NewPing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UpdateStateFromAdjustment
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   NewState                       (Parm)

void APlayerController::UpdateStateFromAdjustment(const struct FName& NewState)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UpdateStateFromAdjustment"));

	APlayerController_UpdateStateFromAdjustment_Params params;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SavePositionForSmoothServerCorrection
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)

void APlayerController::SavePositionForSmoothServerCorrection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SavePositionForSmoothServerCorrection"));

	APlayerController_SavePositionForSmoothServerCorrection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UpdateCameraForServerCorrectionSmoothing
// (Defined, Iterator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void APlayerController::UpdateCameraForServerCorrectionSmoothing()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UpdateCameraForServerCorrectionSmoothing"));

	APlayerController_UpdateCameraForServerCorrectionSmoothing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LongClientAdjustPosition
// (Singular, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// float                          NewVelX                        (Parm)
// float                          NewVelY                        (Parm)
// float                          NewVelZ                        (Parm)
// class AActor*                  NewBase                        (Parm)
// float                          NewFloorX                      (Parm)
// float                          NewFloorY                      (Parm)
// float                          NewFloorZ                      (Parm)

void APlayerController::STATIC_LongClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LongClientAdjustPosition"));

	APlayerController_LongClientAdjustPosition_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewVelX = NewVelX;
	params.NewVelY = NewVelY;
	params.NewVelZ = NewVelZ;
	params.NewBase = NewBase;
	params.NewFloorX = NewFloorX;
	params.NewFloorY = NewFloorY;
	params.NewFloorZ = NewFloorZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LongClientAdjustPositionNoInterp
// (Final, Singular, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// float                          NewVelX                        (Parm)
// float                          NewVelY                        (Parm)
// float                          NewVelZ                        (Parm)
// class AActor*                  NewBase                        (Parm)
// float                          NewFloorX                      (Parm)
// float                          NewFloorY                      (Parm)
// float                          NewFloorZ                      (Parm)

void APlayerController::STATIC_LongClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.LongClientAdjustPositionNoInterp"));

	APlayerController_LongClientAdjustPositionNoInterp_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewVelX = NewVelX;
	params.NewVelY = NewVelY;
	params.NewVelZ = NewVelZ;
	params.NewBase = NewBase;
	params.NewFloorX = NewFloorX;
	params.NewFloorY = NewFloorY;
	params.NewFloorZ = NewFloorZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.HandleViewTargetOnAdjustPosition
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)

void APlayerController::STATIC_HandleViewTargetOnAdjustPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HandleViewTargetOnAdjustPosition"));

	APlayerController_HandleViewTargetOnAdjustPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SkipPositionUpdateForRM
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::SkipPositionUpdateForRM()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SkipPositionUpdateForRM"));

	APlayerController_SkipPositionUpdateForRM_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.UpdatePing
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)

void APlayerController::UpdatePing(float TimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UpdatePing"));

	APlayerController_UpdatePing_Params params;
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAdjustPositionNoInterp
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// float                          NewVelX                        (Parm)
// float                          NewVelY                        (Parm)
// float                          NewVelZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::ClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAdjustPositionNoInterp"));

	APlayerController_ClientAdjustPositionNoInterp_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewVelX = NewVelX;
	params.NewVelY = NewVelY;
	params.NewVelZ = NewVelZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAdjustPosition
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// float                          NewVelX                        (Parm)
// float                          NewVelY                        (Parm)
// float                          NewVelZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::ClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAdjustPosition"));

	APlayerController_ClientAdjustPosition_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewVelX = NewVelX;
	params.NewVelY = NewVelY;
	params.NewVelZ = NewVelZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAckGoodMoveNoInterp
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          TimeStamp                      (Parm)

void APlayerController::ClientAckGoodMoveNoInterp(float TimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAckGoodMoveNoInterp"));

	APlayerController_ClientAckGoodMoveNoInterp_Params params;
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAckGoodMove
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          TimeStamp                      (Parm)

void APlayerController::ClientAckGoodMove(float TimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAckGoodMove"));

	APlayerController_ClientAckGoodMove_Params params;
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCapBandwidth
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// int                            Cap                            (Parm)

void APlayerController::ClientCapBandwidth(int Cap)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientCapBandwidth"));

	APlayerController_ClientCapBandwidth_Params params;
	params.Cap = Cap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ShortClientAdjustPositionNoInterp
// (Iterator, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::ShortClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ShortClientAdjustPositionNoInterp"));

	APlayerController_ShortClientAdjustPositionNoInterp_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ShortClientAdjustPosition
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FName                   NewState                       (Parm)
// TEnumAsByte<EPhysics>          newPhysics                     (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::ShortClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ShortClientAdjustPosition"));

	APlayerController_ShortClientAdjustPosition_Params params;
	params.TimeStamp = TimeStamp;
	params.NewState = NewState;
	params.newPhysics = newPhysics;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.VeryShortClientAdjustPositionNoInterp
// (Final, Iterator, PreOperator, Net, Operator, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::VeryShortClientAdjustPositionNoInterp(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.VeryShortClientAdjustPositionNoInterp"));

	APlayerController_VeryShortClientAdjustPositionNoInterp_Params params;
	params.TimeStamp = TimeStamp;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.VeryShortClientAdjustPosition
// (Iterator, PreOperator, Net, Operator, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)
// float                          NewLocX                        (Parm)
// float                          NewLocY                        (Parm)
// float                          NewLocZ                        (Parm)
// class AActor*                  NewBase                        (Parm)

void APlayerController::VeryShortClientAdjustPosition(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.VeryShortClientAdjustPosition"));

	APlayerController_VeryShortClientAdjustPosition_Params params;
	params.TimeStamp = TimeStamp;
	params.NewLocX = NewLocX;
	params.NewLocY = NewLocY;
	params.NewLocZ = NewLocZ;
	params.NewBase = NewBase;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PostServerMoveUpdate
// (Iterator, Latent, PreOperator, Simulated, HasOptionalParms)

void APlayerController::PostServerMoveUpdate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PostServerMoveUpdate"));

	APlayerController_PostServerMoveUpdate_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PostMoveAutonomous
// (Final, Iterator, Simulated, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// unsigned char                  CompressedFlags                (Parm)
// struct FVector                 newAccel                       (Parm)
// struct FRotator                DeltaRot                       (Parm)

void APlayerController::PostMoveAutonomous(float DeltaTime, unsigned char CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PostMoveAutonomous"));

	APlayerController_PostMoveAutonomous_Params params;
	params.DeltaTime = DeltaTime;
	params.CompressedFlags = CompressedFlags;
	params.newAccel = newAccel;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RunAutonomousPhysics
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)

void APlayerController::RunAutonomousPhysics(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RunAutonomousPhysics"));

	APlayerController_RunAutonomousPhysics_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PreMoveAutonomous
// (Final, Defined, Iterator, Latent, Net, Simulated, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// unsigned char                  CompressedFlags                (Parm)
// struct FVector                 newAccel                       (Parm)
// struct FRotator                DeltaRot                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::PreMoveAutonomous(float DeltaTime, unsigned char CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PreMoveAutonomous"));

	APlayerController_PreMoveAutonomous_Params params;
	params.DeltaTime = DeltaTime;
	params.CompressedFlags = CompressedFlags;
	params.newAccel = newAccel;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.MoveAutonomous
// (Defined, Iterator, Latent, Net, NetReliable, Event, Operator, Static)
// Parameters:
// float                          DeltaTime                      (Parm)
// unsigned char                  CompressedFlags                (Parm)
// struct FVector                 newAccel                       (Parm)
// struct FRotator                DeltaRot                       (Parm)

void APlayerController::STATIC_MoveAutonomous(float DeltaTime, unsigned char CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.MoveAutonomous"));

	APlayerController_MoveAutonomous_Params params;
	params.DeltaTime = DeltaTime;
	params.CompressedFlags = CompressedFlags;
	params.newAccel = newAccel;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ProcessMove
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FVector                 newAccel                       (Parm)
// TEnumAsByte<EDoubleClickDir>   DoubleClickMove                (Parm)
// struct FRotator                DeltaRot                       (Parm)

void APlayerController::ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ProcessMove"));

	APlayerController_ProcessMove_Params params;
	params.DeltaTime = DeltaTime;
	params.newAccel = newAccel;
	params.DoubleClickMove = DoubleClickMove;
	params.DeltaRot = DeltaRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsLookInputIgnored
// (Defined, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsLookInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsLookInputIgnored"));

	APlayerController_IsLookInputIgnored_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsMoveInputIgnored
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsMoveInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsMoveInputIgnored"));

	APlayerController_IsMoveInputIgnored_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetFOVAngle
// (Iterator, Latent, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APlayerController::GetFOVAngle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetFOVAngle"));

	APlayerController_GetFOVAngle_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ProcessDrive
// (Final, Defined, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// float                          InForward                      (Parm)
// float                          InStrafe                       (Parm)
// float                          InUp                           (Parm)
// bool                           InJump                         (Parm)

void APlayerController::ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ProcessDrive"));

	APlayerController_ProcessDrive_Params params;
	params.InForward = InForward;
	params.InStrafe = InStrafe;
	params.InUp = InUp;
	params.InJump = InJump;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerDrive
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InForward                      (Parm)
// float                          InStrafe                       (Parm)
// float                          aUp                            (Parm)
// bool                           InJump                         (Parm)
// int                            View                           (Parm)

void APlayerController::ServerDrive(float InForward, float InStrafe, float aUp, bool InJump, int View)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerDrive"));

	APlayerController_ServerDrive_Params params;
	params.InForward = InForward;
	params.InStrafe = InStrafe;
	params.aUp = aUp;
	params.InJump = InJump;
	params.View = View;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ShouldInterpolateMovementCorrections
// (Defined, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::ShouldInterpolateMovementCorrections()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ShouldInterpolateMovementCorrections"));

	APlayerController_ShouldInterpolateMovementCorrections_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SendClientAdjustment
// (Defined, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::SendClientAdjustment()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SendClientAdjustment"));

	APlayerController_SendClientAdjustment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FlushDeferredMoves
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void APlayerController::STATIC_FlushDeferredMoves()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FlushDeferredMoves"));

	APlayerController_FlushDeferredMoves_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerMove
// (Final, Latent, PreOperator, Singular, Net, Exec, Event, Operator)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FVector                 InAccel                        (Parm)
// struct FVector                 ClientLoc                      (Parm)
// unsigned char                  MoveFlags                      (Parm)
// unsigned char                  ClientRoll                     (Parm)
// int                            View                           (Parm)

void APlayerController::ServerMove(float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerMove"));

	APlayerController_ServerMove_Params params;
	params.TimeStamp = TimeStamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.MoveFlags = MoveFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerMoveHandleClientError
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)
// struct FVector                 Accel                          (Parm)
// struct FVector                 ClientLoc                      (Parm)

void APlayerController::ServerMoveHandleClientError(float TimeStamp, const struct FVector& Accel, const struct FVector& ClientLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerMoveHandleClientError"));

	APlayerController_ServerMoveHandleClientError_Params params;
	params.TimeStamp = TimeStamp;
	params.Accel = Accel;
	params.ClientLoc = ClientLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetServerMoveDeltaTime
// (Final, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          TimeStamp                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APlayerController::STATIC_GetServerMoveDeltaTime(float TimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetServerMoveDeltaTime"));

	APlayerController_GetServerMoveDeltaTime_Params params;
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OldServerMove
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Event, Operator)
// Parameters:
// float                          OldTimeStamp                   (Parm)
// unsigned char                  OldAccelX                      (Parm)
// unsigned char                  OldAccelY                      (Parm)
// unsigned char                  OldAccelZ                      (Parm)
// unsigned char                  OldMoveFlags                   (Parm)

void APlayerController::OldServerMove(float OldTimeStamp, unsigned char OldAccelX, unsigned char OldAccelY, unsigned char OldAccelZ, unsigned char OldMoveFlags)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OldServerMove"));

	APlayerController_OldServerMove_Params params;
	params.OldTimeStamp = OldTimeStamp;
	params.OldAccelX = OldAccelX;
	params.OldAccelY = OldAccelY;
	params.OldAccelZ = OldAccelZ;
	params.OldMoveFlags = OldMoveFlags;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DualServerMove
// (Defined, Latent, PreOperator, Singular, Net, Exec, Event, Operator)
// Parameters:
// float                          TimeStamp0                     (Parm)
// struct FVector                 InAccel0                       (Parm)
// unsigned char                  PendingFlags                   (Parm)
// int                            View0                          (Parm)
// float                          TimeStamp                      (Parm)
// struct FVector                 InAccel                        (Parm)
// struct FVector                 ClientLoc                      (Parm)
// unsigned char                  NewFlags                       (Parm)
// unsigned char                  ClientRoll                     (Parm)
// int                            View                           (Parm)

void APlayerController::DualServerMove(float TimeStamp0, const struct FVector& InAccel0, unsigned char PendingFlags, int View0, float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, int View)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DualServerMove"));

	APlayerController_DualServerMove_Params params;
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.TimeStamp = TimeStamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ForceDeathUpdate
// (Iterator, Latent, Singular, NetReliable, Simulated, Exec, Event, Static)

void APlayerController::STATIC_ForceDeathUpdate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ForceDeathUpdate"));

	APlayerController_ForceDeathUpdate_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UsingFirstPersonCamera
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::UsingFirstPersonCamera()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UsingFirstPersonCamera"));

	APlayerController_UsingFirstPersonCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientSetCameraFade
// (Iterator, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableFading                  (Parm)
// struct FColor                  FadeColor                      (OptionalParm, Parm)
// struct FVector2D               FadeAlpha                      (OptionalParm, Parm)
// float                          FadeTime                       (OptionalParm, Parm)
// bool                           bFadeAudio                     (OptionalParm, Parm)

void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetCameraFade"));

	APlayerController_ClientSetCameraFade_Params params;
	params.bEnableFading = bEnableFading;
	params.FadeColor = FadeColor;
	params.FadeAlpha = FadeAlpha;
	params.FadeTime = FadeTime;
	params.bFadeAudio = bFadeAudio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ResetCameraMode
// (NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::ResetCameraMode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ResetCameraMode"));

	APlayerController_ResetCameraMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetCameraMode
// (Latent, PreOperator, Net, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   NewCamMode                     (Parm)

void APlayerController::SetCameraMode(const struct FName& NewCamMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetCameraMode"));

	APlayerController_SetCameraMode_Params params;
	params.NewCamMode = NewCamMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetCameraMode
// (Singular, Static)
// Parameters:
// struct FName                   NewCamMode                     (Parm)

void APlayerController::STATIC_ClientSetCameraMode(const struct FName& NewCamMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetCameraMode"));

	APlayerController_ClientSetCameraMode_Params params;
	params.NewCamMode = NewCamMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerCamera
// (Final, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   NewMode                        (Parm)

void APlayerController::ServerCamera(const struct FName& NewMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerCamera"));

	APlayerController_ServerCamera_Params params;
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Camera
// (Defined, Singular, NetReliable)
// Parameters:
// struct FName                   NewMode                        (Parm)

void APlayerController::Camera(const struct FName& NewMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Camera"));

	APlayerController_Camera_Params params;
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PreClientTravel
// (Iterator, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 PendingURL                     (Parm, NeedCtorLink)
// TEnumAsByte<ETravelType>       TravelType                     (Parm)
// bool                           bIsSeamlessTravel              (Parm)

void APlayerController::PreClientTravel(const struct FString& PendingURL, TEnumAsByte<ETravelType> TravelType, bool bIsSeamlessTravel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PreClientTravel"));

	APlayerController_PreClientTravel_Params params;
	params.PendingURL = PendingURL;
	params.TravelType = TravelType;
	params.bIsSeamlessTravel = bIsSeamlessTravel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerTeamSay
// (Iterator, Latent, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)

void APlayerController::ServerTeamSay(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerTeamSay"));

	APlayerController_ServerTeamSay_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TeamSay
// (Final, Defined, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)

void APlayerController::TeamSay(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TeamSay"));

	APlayerController_TeamSay_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAdminMessage
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)

void APlayerController::ClientAdminMessage(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientAdminMessage"));

	APlayerController_ClientAdminMessage_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSay
// (PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)

void APlayerController::ServerSay(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerSay"));

	APlayerController_ServerSay_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Say
// (Iterator, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)

void APlayerController::Say(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Say"));

	APlayerController_Say_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AllowTextMessage
// (Defined, Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// struct FString                 msg                            (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::AllowTextMessage(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AllowTextMessage"));

	APlayerController_AllowTextMessage_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerMutate
// (Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 MutateString                   (Parm, NeedCtorLink)

void APlayerController::ServerMutate(const struct FString& MutateString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerMutate"));

	APlayerController_ServerMutate_Params params;
	params.MutateString = MutateString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Mutate
// (Final, Iterator, Latent, Singular, Simulated, Event, Operator, Static)
// Parameters:
// struct FString                 MutateString                   (Parm, NeedCtorLink)

void APlayerController::STATIC_Mutate(const struct FString& MutateString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Mutate"));

	APlayerController_Mutate_Params params;
	params.MutateString = MutateString;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FOV
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          F                              (Parm)

void APlayerController::FOV(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FOV"));

	APlayerController_FOV_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ResetFOV
// (Iterator, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void APlayerController::ResetFOV()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ResetFOV"));

	APlayerController_ResetFOV_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetFOV
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewFOV                         (Parm)

void APlayerController::SetFOV(float NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetFOV"));

	APlayerController_SetFOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FixFOV
// (PreOperator, Singular, Net, NetReliable, Exec, Event, Static)

void APlayerController::STATIC_FixFOV()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FixFOV"));

	APlayerController_FixFOV_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Destroyed
// (Iterator, Latent, Singular, Simulated)

void APlayerController::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Destroyed"));

	APlayerController_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CleanupPawn
// (Final, Iterator, Singular, Simulated, Exec, Native, Event, Operator)

void APlayerController::CleanupPawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CleanupPawn"));

	APlayerController_CleanupPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClearOnlineDelegates
// (Final, Latent, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::ClearOnlineDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClearOnlineDelegates"));

	APlayerController_ClearOnlineDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnPartyMembersInfoChanged
// (Final, Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// int                            CustomData1                    (Parm)
// int                            CustomData2                    (Parm)
// int                            CustomData3                    (Parm)
// int                            CustomData4                    (Parm)

void APlayerController::STATIC_OnPartyMembersInfoChanged(const struct FString& PlayerName, const struct FUniqueNetId& PlayerID, int CustomData1, int CustomData2, int CustomData3, int CustomData4)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnPartyMembersInfoChanged"));

	APlayerController_OnPartyMembersInfoChanged_Params params;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;
	params.CustomData1 = CustomData1;
	params.CustomData2 = CustomData2;
	params.CustomData3 = CustomData3;
	params.CustomData4 = CustomData4;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnPartyMemberListChanged
// (Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bJoinedOrLeft                  (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)

void APlayerController::STATIC_OnPartyMemberListChanged(bool bJoinedOrLeft, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnPartyMemberListChanged"));

	APlayerController_OnPartyMemberListChanged_Params params;
	params.bJoinedOrLeft = bJoinedOrLeft;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RegisterOnlineDelegates
// (Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)

void APlayerController::STATIC_RegisterOnlineDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RegisterOnlineDelegates"));

	APlayerController_RegisterOnlineDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PlayBeepSound
// (Latent, Net, HasOptionalParms)

void APlayerController::PlayBeepSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PlayBeepSound"));

	APlayerController_PlayBeepSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TeamMessage
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (Parm)
// float                          MsgLifeTime                    (OptionalParm, Parm)

void APlayerController::TeamMessage(class APlayerReplicationInfo* PRI, const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TeamMessage"));

	APlayerController_TeamMessage_Params params;
	params.PRI = PRI;
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SpeakTTS
// (Final, Singular, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)
// class APlayerReplicationInfo*  PRI                            (OptionalParm, Parm)

void APlayerController::SpeakTTS(const struct FString& S, class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SpeakTTS"));

	APlayerController_SpeakTTS_Params params;
	params.S = S;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TeamTalk
// (Iterator, Singular, Net, NetReliable, Native, Event, HasOptionalParms)

void APlayerController::TeamTalk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TeamTalk"));

	APlayerController_TeamTalk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Talk
// (NetReliable, Native, Event, HasOptionalParms)

void APlayerController::Talk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Talk"));

	APlayerController_Talk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CreateTTSSoundCue
// (Final, Defined, Iterator, PreOperator, Exec, Static)
// Parameters:
// struct FString                 StrToSpeak                     (Parm, NeedCtorLink)
// class APlayerReplicationInfo*  PRI                            (Parm)
// class USoundCue*               ReturnValue                    (Parm, OutParm, ReturnParm)

class USoundCue* APlayerController::STATIC_CreateTTSSoundCue(const struct FString& StrToSpeak, class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CreateTTSSoundCue"));

	APlayerController_CreateTTSSoundCue_Params params;
	params.StrToSpeak = StrToSpeak;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.AllowTTSMessageFrom
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::AllowTTSMessageFrom(class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AllowTTSMessageFrom"));

	APlayerController_AllowTTSMessageFrom_Params params;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CanCommunicate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanCommunicate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanCommunicate"));

	APlayerController_CanCommunicate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ClientMessage
// (Final, Defined, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)
// float                          MsgLifeTime                    (OptionalParm, Parm)

void APlayerController::ClientMessage(const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientMessage"));

	APlayerController_ClientMessage_Params params;
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayActorFaceFXAnim
// (Final, PreOperator, Static)
// Parameters:
// class AActor*                  SourceActor                    (Parm)
// class UFaceFXAnimSet*          AnimSet                        (Parm)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// struct FString                 SeqName                        (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)

void APlayerController::STATIC_ClientPlayActorFaceFXAnim(class AActor* SourceActor, class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPlayActorFaceFXAnim"));

	APlayerController_ClientPlayActorFaceFXAnim_Params params;
	params.SourceActor = SourceActor;
	params.AnimSet = AnimSet;
	params.GroupName = GroupName;
	params.SeqName = SeqName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Kismet_ClientStopSound
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               ASound                         (Parm)
// class AActor*                  SourceActor                    (Parm)
// float                          FadeOutTime                    (Parm)

void APlayerController::Kismet_ClientStopSound(class USoundCue* ASound, class AActor* SourceActor, float FadeOutTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Kismet_ClientStopSound"));

	APlayerController_Kismet_ClientStopSound_Params params;
	params.ASound = ASound;
	params.SourceActor = SourceActor;
	params.FadeOutTime = FadeOutTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Kismet_ClientPlaySound
// (Iterator, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               ASound                         (Parm)
// class AActor*                  SourceActor                    (Parm)
// float                          VolumeMultiplier               (Parm)
// float                          PitchMultiplier                (Parm)
// float                          FadeInTime                     (Parm)
// bool                           bSuppressSubtitles             (Parm)
// bool                           bSuppressSpatialization        (Parm)

void APlayerController::Kismet_ClientPlaySound(class USoundCue* ASound, class AActor* SourceActor, float VolumeMultiplier, float PitchMultiplier, float FadeInTime, bool bSuppressSubtitles, bool bSuppressSpatialization)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Kismet_ClientPlaySound"));

	APlayerController_Kismet_ClientPlaySound_Params params;
	params.ASound = ASound;
	params.SourceActor = SourceActor;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.FadeInTime = FadeInTime;
	params.bSuppressSubtitles = bSuppressSubtitles;
	params.bSuppressSpatialization = bSuppressSpatialization;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsClosestLocalPlayerToActor
// (Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// class AActor*                  TheActor                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsClosestLocalPlayerToActor(class AActor* TheActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsClosestLocalPlayerToActor"));

	APlayerController_IsClosestLocalPlayerToActor_Params params;
	params.TheActor = TheActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.WwiseClientHearSound
// (Iterator, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAkEvent*                ASound                         (Parm)
// class AActor*                  SourceActor                    (Parm)
// struct FVector                 SourceLocation                 (Parm)
// bool                           bStopWhenOwnerDestroyed        (Parm)
// bool                           bIsOccluded                    (OptionalParm, Parm)

void APlayerController::WwiseClientHearSound(class UAkEvent* ASound, class AActor* SourceActor, const struct FVector& SourceLocation, bool bStopWhenOwnerDestroyed, bool bIsOccluded)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.WwiseClientHearSound"));

	APlayerController_WwiseClientHearSound_Params params;
	params.ASound = ASound;
	params.SourceActor = SourceActor;
	params.SourceLocation = SourceLocation;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.bIsOccluded = bIsOccluded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientHearSound
// (Defined, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               ASound                         (Parm)
// class AActor*                  SourceActor                    (Parm)
// struct FVector                 SourceLocation                 (Parm)
// bool                           bStopWhenOwnerDestroyed        (Parm)
// bool                           bIsOccluded                    (OptionalParm, Parm)

void APlayerController::ClientHearSound(class USoundCue* ASound, class AActor* SourceActor, const struct FVector& SourceLocation, bool bStopWhenOwnerDestroyed, bool bIsOccluded)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientHearSound"));

	APlayerController_ClientHearSound_Params params;
	params.ASound = ASound;
	params.SourceActor = SourceActor;
	params.SourceLocation = SourceLocation;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.bIsOccluded = bIsOccluded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetPooledAudioComponent
// (Final, Defined, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class USoundCue*               ASound                         (Parm)
// class AActor*                  SourceActor                    (Parm)
// bool                           bStopWhenOwnerDestroyed        (Parm)
// bool                           bUseLocation                   (OptionalParm, Parm)
// struct FVector                 SourceLocation                 (OptionalParm, Parm)
// class UAudioComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UAudioComponent* APlayerController::STATIC_GetPooledAudioComponent(class USoundCue* ASound, class AActor* SourceActor, bool bStopWhenOwnerDestroyed, bool bUseLocation, const struct FVector& SourceLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPooledAudioComponent"));

	APlayerController_GetPooledAudioComponent_Params params;
	params.ASound = ASound;
	params.SourceActor = SourceActor;
	params.bStopWhenOwnerDestroyed = bStopWhenOwnerDestroyed;
	params.bUseLocation = bUseLocation;
	params.SourceLocation = SourceLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.HearSoundFinished
// (Defined, Latent, PreOperator, Singular, Native)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)

void APlayerController::HearSoundFinished(class UAudioComponent* AC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HearSoundFinished"));

	APlayerController_HearSoundFinished_Params params;
	params.AC = AC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlaySound
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               ASound                         (Parm)

void APlayerController::ClientPlaySound(class USoundCue* ASound)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientPlaySound"));

	APlayerController_ClientPlaySound_Params params;
	params.ASound = ASound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ReceiveLocalizedMessage
// (Final, Defined, Latent, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void APlayerController::ReceiveLocalizedMessage(class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ReceiveLocalizedMessage"));

	APlayerController_ReceiveLocalizedMessage_Params params;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CleanupPRI
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Event, Operator)

void APlayerController::CleanupPRI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CleanupPRI"));

	APlayerController_CleanupPRI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.HandlePickup
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AInventory*              Inv                            (Parm)

void APlayerController::STATIC_HandlePickup(class AInventory* Inv)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.HandlePickup"));

	APlayerController_HandlePickup_Params params;
	params.Inv = Inv;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetSecondaryHUD
// (Final, Defined, Iterator, Singular, Static)
// Parameters:
// class UClass*                  newHUDType                     (Parm)

void APlayerController::STATIC_ClientSetSecondaryHUD(class UClass* newHUDType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetSecondaryHUD"));

	APlayerController_ClientSetSecondaryHUD_Params params;
	params.newHUDType = newHUDType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetHUD
// (Final, Defined, Singular, Static)
// Parameters:
// class UClass*                  newHUDType                     (Parm)

void APlayerController::STATIC_ClientSetHUD(class UClass* newHUDType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientSetHUD"));

	APlayerController_ClientSetHUD_Params params;
	params.newHUDType = newHUDType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PawnDied
// (Final, Defined, Latent, Singular, Simulated, Static, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void APlayerController::STATIC_PawnDied(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PawnDied"));

	APlayerController_PawnDied_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UnPossess
// (Final, Iterator, Simulated, Exec, Native, HasOptionalParms)

void APlayerController::UnPossess()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UnPossess"));

	APlayerController_UnPossess_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerAcknowledgePossession
// (Final, Defined, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void APlayerController::ServerAcknowledgePossession(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerAcknowledgePossession"));

	APlayerController_ServerAcknowledgePossession_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AcknowledgePossession
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void APlayerController::AcknowledgePossession(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AcknowledgePossession"));

	APlayerController_AcknowledgePossession_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Possess
// (Final, Defined, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   aPawn                          (Parm)
// bool                           bVehicleTransition             (Parm)

void APlayerController::Possess(class APawn* aPawn, bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Possess"));

	APlayerController_Possess_Params params;
	params.aPawn = aPawn;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GivePawn
// (Iterator, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   NewPawn                        (Parm)

void APlayerController::GivePawn(class APawn* NewPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GivePawn"));

	APlayerController_GivePawn_Params params;
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AskForPawn
// (Latent, Simulated, Native, HasOptionalParms)

void APlayerController::AskForPawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AskForPawn"));

	APlayerController_AskForPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientGotoState
// (Final, Defined, Iterator, Static)
// Parameters:
// struct FName                   NewState                       (Parm)
// struct FName                   NewLabel                       (OptionalParm, Parm)

void APlayerController::STATIC_ClientGotoState(const struct FName& NewState, const struct FName& NewLabel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientGotoState"));

	APlayerController_ClientGotoState_Params params;
	params.NewState = NewState;
	params.NewLabel = NewLabel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetMaxSmoothedFrameRate
// (Defined, Event, HasOptionalParms)
// Parameters:
// float                          fRate                          (Parm)

void APlayerController::SetMaxSmoothedFrameRate(float fRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetMaxSmoothedFrameRate"));

	APlayerController_SetMaxSmoothedFrameRate_Params params;
	params.fRate = fRate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetTiltActive
// (PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bActive                        (Parm)

void APlayerController::SetTiltActive(bool bActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetTiltActive"));

	APlayerController_SetTiltActive_Params params;
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsMouseAvailable
// (Defined, Iterator, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsMouseAvailable()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsMouseAvailable"));

	APlayerController_IsMouseAvailable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsKeyboardAvailable
// (Defined, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsKeyboardAvailable()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsKeyboardAvailable"));

	APlayerController_IsKeyboardAvailable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SetUseTiltForwardAndBack
// (Final, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bActive                        (Parm)

void APlayerController::SetUseTiltForwardAndBack(bool bActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetUseTiltForwardAndBack"));

	APlayerController_SetUseTiltForwardAndBack_Params params;
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetOnlyUseControllerTiltInput
// (Defined, Iterator, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bActive                        (Parm)

void APlayerController::SetOnlyUseControllerTiltInput(bool bActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetOnlyUseControllerTiltInput"));

	APlayerController_SetOnlyUseControllerTiltInput_Params params;
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetControllerTiltActive
// (Final, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bActive                        (Parm)

void APlayerController::SetControllerTiltActive(bool bActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetControllerTiltActive"));

	APlayerController_SetControllerTiltActive_Params params;
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsControllerTiltActive
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsControllerTiltActive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsControllerTiltActive"));

	APlayerController_IsControllerTiltActive_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SetRumbleScale
// (Iterator, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// float                          ScaleBy                        (Parm)

void APlayerController::SetRumbleScale(float ScaleBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetRumbleScale"));

	APlayerController_SetRumbleScale_Params params;
	params.ScaleBy = ScaleBy;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ReloadProfileSettings
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void APlayerController::ReloadProfileSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ReloadProfileSettings"));

	APlayerController_ReloadProfileSettings_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UnregisterStandardPlayerDataStores
// (Defined, PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void APlayerController::UnregisterStandardPlayerDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UnregisterStandardPlayerDataStores"));

	APlayerController_UnregisterStandardPlayerDataStores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.UnregisterPlayerDataStores
// (Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void APlayerController::UnregisterPlayerDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UnregisterPlayerDataStores"));

	APlayerController_UnregisterPlayerDataStores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RegisterStandardPlayerDataStores
// (Defined, Latent, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void APlayerController::RegisterStandardPlayerDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RegisterStandardPlayerDataStores"));

	APlayerController_RegisterStandardPlayerDataStores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RegisterCustomPlayerDataStores
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void APlayerController::RegisterCustomPlayerDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RegisterCustomPlayerDataStores"));

	APlayerController_RegisterCustomPlayerDataStores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RegisterPlayerDataStores
// (Iterator, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void APlayerController::RegisterPlayerDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RegisterPlayerDataStores"));

	APlayerController_RegisterPlayerDataStores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientInitializeDataStores
// (Final, Defined, Latent, Static)

void APlayerController::STATIC_ClientInitializeDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientInitializeDataStores"));

	APlayerController_ClientInitializeDataStores_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.InitInputSystem
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void APlayerController::InitInputSystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.InitInputSystem"));

	APlayerController_InitInputSystem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetOnlineSubsystem
// (Final, Defined, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UOnlineSubsystem*        ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineSubsystem* APlayerController::STATIC_GetOnlineSubsystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetOnlineSubsystem"));

	APlayerController_GetOnlineSubsystem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.PostControllerIdChange
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)

void APlayerController::PostControllerIdChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PostControllerIdChange"));

	APlayerController_PostControllerIdChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PreControllerIdChange
// (Iterator, Net, Simulated, HasOptionalParms)

void APlayerController::PreControllerIdChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PreControllerIdChange"));

	APlayerController_PreControllerIdChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CleanOutSavedMoves
// (Singular, Simulated, Exec, Native, Event, Operator)

void APlayerController::CleanOutSavedMoves()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CleanOutSavedMoves"));

	APlayerController_CleanOutSavedMoves_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReset
// (Final, Iterator, Latent, PreOperator, Static)

void APlayerController::STATIC_ClientReset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientReset"));

	APlayerController_ClientReset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APlayerController::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.Reset"));

	APlayerController_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SpawnDefaultHUD
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, HasOptionalParms)

void APlayerController::SpawnDefaultHUD()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SpawnDefaultHUD"));

	APlayerController_SpawnDefaultHUD_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.EnableCheats
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void APlayerController::STATIC_EnableCheats()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.EnableCheats"));

	APlayerController_EnableCheats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddCheats
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event)

void APlayerController::AddCheats()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AddCheats"));

	APlayerController_AddCheats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.KickWarning
// (Defined, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)

void APlayerController::KickWarning()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.KickWarning"));

	APlayerController_KickWarning_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerGivePawn
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::ServerGivePawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerGivePawn"));

	APlayerController_ServerGivePawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerShortTimeout
// (Defined, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::ServerShortTimeout()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerShortTimeout"));

	APlayerController_ServerShortTimeout_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ResetTimeMargin
// (Final, NetReliable, Exec, Native, HasOptionalParms)

void APlayerController::ResetTimeMargin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ResetTimeMargin"));

	APlayerController_ResetTimeMargin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PreRender
// (Defined, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void APlayerController::PreRender(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PreRender"));

	APlayerController_PreRender_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnJoinMigratedGame
// (Final, Iterator, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnJoinMigratedGame(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnJoinMigratedGame"));

	APlayerController_OnJoinMigratedGame_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PeerDesignatedAsClient
// (Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)

void APlayerController::STATIC_PeerDesignatedAsClient(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PeerDesignatedAsClient"));

	APlayerController_PeerDesignatedAsClient_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnUnregisterPlayerCompleteForJoinMigrate
// (Final, Iterator, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnUnregisterPlayerCompleteForJoinMigrate(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnUnregisterPlayerCompleteForJoinMigrate"));

	APlayerController_OnUnregisterPlayerCompleteForJoinMigrate_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PeerReceivedMigratedSession
// (Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            FromPeerNetId                  (Parm)
// struct FName                   SessionName                    (Parm)
// class UClass*                  SearchClass                    (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm)

void APlayerController::PeerReceivedMigratedSession(const struct FUniqueNetId& FromPeerNetId, const struct FName& SessionName, class UClass* SearchClass, unsigned char PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PeerReceivedMigratedSession"));

	APlayerController_PeerReceivedMigratedSession_Params params;
	params.FromPeerNetId = FromPeerNetId;
	params.SessionName = SessionName;
	params.SearchClass = SearchClass;
	params.PlatformSpecificInfo = PlatformSpecificInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TellPeerToTravelToSession
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ToPeerNetId                    (Parm)
// struct FName                   SessionName                    (Parm)
// class UClass*                  SearchClass                    (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm)
// int                            PlatformSpecificInfoSize       (Parm)

void APlayerController::TellPeerToTravelToSession(const struct FUniqueNetId& ToPeerNetId, const struct FName& SessionName, class UClass* SearchClass, unsigned char PlatformSpecificInfo, int PlatformSpecificInfoSize)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TellPeerToTravelToSession"));

	APlayerController_TellPeerToTravelToSession_Params params;
	params.ToPeerNetId = ToPeerNetId;
	params.SessionName = SessionName;
	params.SearchClass = SearchClass;
	params.PlatformSpecificInfo = PlatformSpecificInfo;
	params.PlatformSpecificInfoSize = PlatformSpecificInfoSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TellPeerToTravel
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ToPeerNetId                    (Parm)

void APlayerController::TellPeerToTravel(const struct FUniqueNetId& ToPeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.TellPeerToTravel"));

	APlayerController_TellPeerToTravel_Params params;
	params.ToPeerNetId = ToPeerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PeerTravelAsHost
// (Defined, Singular, Net, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// float                          TravelCountdownTimer           (Parm)
// struct FString                 URL                            (Parm, NeedCtorLink)

void APlayerController::STATIC_PeerTravelAsHost(float TravelCountdownTimer, const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PeerTravelAsHost"));

	APlayerController_PeerTravelAsHost_Params params;
	params.TravelCountdownTimer = TravelCountdownTimer;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetNewPeerHostURL
// (Iterator, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetNewPeerHostURL()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetNewPeerHostURL"));

	APlayerController_GetNewPeerHostURL_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.PeerDesignatedAsHost
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)

void APlayerController::STATIC_PeerDesignatedAsHost(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PeerDesignatedAsHost"));

	APlayerController_PeerDesignatedAsHost_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetCurrentSearchClass
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* APlayerController::STATIC_GetCurrentSearchClass()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetCurrentSearchClass"));

	APlayerController_GetCurrentSearchClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnHostMigratedOnlineGame
// (Final, Defined, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnHostMigratedOnlineGame(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnHostMigratedOnlineGame"));

	APlayerController_OnHostMigratedOnlineGame_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnUnregisterPlayerCompleteForHostMigrate
// (Iterator, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::STATIC_OnUnregisterPlayerCompleteForHostMigrate(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnUnregisterPlayerCompleteForHostMigrate"));

	APlayerController_OnUnregisterPlayerCompleteForHostMigrate_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RemoveMissingPeersFromSession
// (Final, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FScriptDelegate         UnregisterDelegate             (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::RemoveMissingPeersFromSession(const struct FName& SessionName, const struct FScriptDelegate& UnregisterDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RemoveMissingPeersFromSession"));

	APlayerController_RemoveMissingPeersFromSession_Params params;
	params.SessionName = SessionName;
	params.UnregisterDelegate = UnregisterDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetPRIFromNetId
// (PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// class APlayerReplicationInfo*  ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerReplicationInfo* APlayerController::STATIC_GetPRIFromNetId(const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPRIFromNetId"));

	APlayerController_GetPRIFromNetId_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnMissingPeersUnregistered
// (Final, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasSuccessful                 (Parm)

void APlayerController::OnMissingPeersUnregistered(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnMissingPeersUnregistered"));

	APlayerController_OnMissingPeersUnregistered_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetRegisteredPlayersInSession
// (Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    OutRegisteredPlayers           (Parm, OutParm, NeedCtorLink)

void APlayerController::STATIC_GetRegisteredPlayersInSession(const struct FName& SessionName, TArray<struct FUniqueNetId>* OutRegisteredPlayers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetRegisteredPlayersInSession"));

	APlayerController_GetRegisteredPlayersInSession_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRegisteredPlayers != nullptr)
		*OutRegisteredPlayers = params.OutRegisteredPlayers;
}


// Function Engine.PlayerController.NotifyHostMigrationStarted
// (Defined, Latent, Net, Simulated, Exec, Event, Operator, Static)

void APlayerController::STATIC_NotifyHostMigrationStarted()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyHostMigrationStarted"));

	APlayerController_NotifyHostMigrationStarted_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.MigrateNewHost
// (Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::MigrateNewHost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.MigrateNewHost"));

	APlayerController_MigrateNewHost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.IsBestHostPeer
// (PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::STATIC_IsBestHostPeer(const struct FUniqueNetId& PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.IsBestHostPeer"));

	APlayerController_IsBestHostPeer_Params params;
	params.PeerNetId = PeerNetId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.NotifyPeerDisconnectHost
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)

void APlayerController::NotifyPeerDisconnectHost(const struct FUniqueNetId& PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.NotifyPeerDisconnectHost"));

	APlayerController_NotifyPeerDisconnectHost_Params params;
	params.PeerNetId = PeerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUpdateBestNextHosts
// (Final, Defined, PreOperator, Singular, Static)
// Parameters:
// struct FUniqueNetId            SortedNextHosts                (Parm)
// unsigned char                  NumEntries                     (Parm)

void APlayerController::STATIC_ClientUpdateBestNextHosts(const struct FUniqueNetId& SortedNextHosts, unsigned char NumEntries)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientUpdateBestNextHosts"));

	APlayerController_ClientUpdateBestNextHosts_Params params;
	params.SortedNextHosts = SortedNextHosts;
	params.NumEntries = NumEntries;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerRemovePeer
// (Defined, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)

void APlayerController::ServerRemovePeer(const struct FUniqueNetId& PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerRemovePeer"));

	APlayerController_ServerRemovePeer_Params params;
	params.PeerNetId = PeerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerAddPeer
// (Final, Defined, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)
// TEnumAsByte<ENATType>          NatType                        (Parm)

void APlayerController::ServerAddPeer(const struct FUniqueNetId& PeerNetId, TEnumAsByte<ENATType> NatType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerAddPeer"));

	APlayerController_ServerAddPeer_Params params;
	params.PeerNetId = PeerNetId;
	params.NatType = NatType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RemovePeer
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)

void APlayerController::RemovePeer(const struct FUniqueNetId& PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.RemovePeer"));

	APlayerController_RemovePeer_Params params;
	params.PeerNetId = PeerNetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddPeer
// (Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)
// TEnumAsByte<ENATType>          NatType                        (Parm)

void APlayerController::AddPeer(const struct FUniqueNetId& PeerNetId, TEnumAsByte<ENATType> NatType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.AddPeer"));

	APlayerController_AddPeer_Params params;
	params.PeerNetId = PeerNetId;
	params.NatType = NatType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FindConnectedPeerIndex
// (Defined, Iterator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FUniqueNetId            PeerNetId                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int APlayerController::STATIC_FindConnectedPeerIndex(const struct FUniqueNetId& PeerNetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FindConnectedPeerIndex"));

	APlayerController_FindConnectedPeerIndex_Params params;
	params.PeerNetId = PeerNetId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ReceivedPlayer
// (Defined, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void APlayerController::ReceivedPlayer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ReceivedPlayer"));

	APlayerController_ReceivedPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PostBeginPlay
// (Final, Latent, Net, Simulated)

void APlayerController::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PostBeginPlay"));

	APlayerController_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SpawnCoverReplicator
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Event, HasOptionalParms)
// Parameters:
// class ACoverReplicator*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ACoverReplicator* APlayerController::SpawnCoverReplicator()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SpawnCoverReplicator"));

	APlayerController_SpawnCoverReplicator_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CanUnpauseControllerConnected
// (Defined, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanUnpauseControllerConnected()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanUnpauseControllerConnected"));

	APlayerController_CanUnpauseControllerConnected_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ControllerChangedUnpause
// (Final, Iterator, Latent, Net, Simulated, Native, HasOptionalParms)

void APlayerController::ControllerChangedUnpause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ControllerChangedUnpause"));

	APlayerController_ControllerChangedUnpause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ControllerChangedPause
// (Iterator, Latent, Net, Simulated, Native, HasOptionalParms)

void APlayerController::ControllerChangedPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ControllerChangedPause"));

	APlayerController_ControllerChangedPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnControllerChanged
// (Final, Defined, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// bool                           bIsConnected                   (Parm)
// bool                           bPauseGame                     (Parm)

void APlayerController::STATIC_OnControllerChanged(int ControllerId, bool bIsConnected, bool bPauseGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnControllerChanged"));

	APlayerController_OnControllerChanged_Params params;
	params.ControllerId = ControllerId;
	params.bIsConnected = bIsConnected;
	params.bPauseGame = bPauseGame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CanUnpauseExternalUI
// (Final, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CanUnpauseExternalUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CanUnpauseExternalUI"));

	APlayerController_CanUnpauseExternalUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.OnExternalUIChanged
// (Defined, Iterator, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bIsOpening                     (Parm)

void APlayerController::STATIC_OnExternalUIChanged(bool bIsOpening)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnExternalUIChanged"));

	APlayerController_OnExternalUIChanged_Params params;
	params.bIsOpening = bIsOpening;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnPrivilegeLevelChecked
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilege> Privilege                      (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevel                 (Parm)
// bool                           bDiffersFromHint               (Parm)

void APlayerController::STATIC_OnPrivilegeLevelChecked(unsigned char LocalUserNum, TEnumAsByte<EFeaturePrivilege> Privilege, TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevel, bool bDiffersFromHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.OnPrivilegeLevelChecked"));

	APlayerController_OnPrivilegeLevelChecked_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Privilege = Privilege;
	params.PrivilegeLevel = PrivilegeLevel;
	params.bDiffersFromHint = bDiffersFromHint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CheckPrivileges
// (Final, Defined, Iterator, Singular, Simulated, Native, HasOptionalParms)

void APlayerController::CheckPrivileges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CheckPrivileges"));

	APlayerController_CheckPrivileges_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ForceClearUnpauseDelegates
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Event, Static)

void APlayerController::STATIC_ForceClearUnpauseDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ForceClearUnpauseDelegates"));

	APlayerController_ForceClearUnpauseDelegates_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DisableActorHeadTracking
// (Final, Simulated, Native, Static)
// Parameters:
// class AActor*                  TargetActor                    (Parm)

void APlayerController::STATIC_DisableActorHeadTracking(class AActor* TargetActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.DisableActorHeadTracking"));

	APlayerController_DisableActorHeadTracking_Params params;
	params.TargetActor = TargetActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.EnableActorHeadTracking
// (Final, Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// class AActor*                  TargetActor                    (Parm)
// struct FName                   TrackControllerName            (Parm)
// class UClass*                  ActorClassesToLookAt           (Parm)
// bool                           bLookAtPawns                   (Parm)
// float                          MinLookAtTime                  (Parm)
// float                          MaxLookAtTime                  (Parm)
// float                          MaxInterestTime                (Parm)
// float                          LookAtActorRadius              (Parm)
// struct FName                   TargetBoneNames                (Parm)

void APlayerController::STATIC_EnableActorHeadTracking(class AActor* TargetActor, const struct FName& TrackControllerName, class UClass* ActorClassesToLookAt, bool bLookAtPawns, float MinLookAtTime, float MaxLookAtTime, float MaxInterestTime, float LookAtActorRadius, const struct FName& TargetBoneNames)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.EnableActorHeadTracking"));

	APlayerController_EnableActorHeadTracking_Params params;
	params.TargetActor = TargetActor;
	params.TrackControllerName = TrackControllerName;
	params.ActorClassesToLookAt = ActorClassesToLookAt;
	params.bLookAtPawns = bLookAtPawns;
	params.MinLookAtTime = MinLookAtTime;
	params.MaxLookAtTime = MaxLookAtTime;
	params.MaxInterestTime = MaxInterestTime;
	params.LookAtActorRadius = LookAtActorRadius;
	params.TargetBoneNames = TargetBoneNames;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void APlayerController::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FellOutOfWorld"));

	APlayerController_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CleanUpAudioComponents
// (Defined, Singular, Simulated, Exec, Native, Event, Operator)

void APlayerController::CleanUpAudioComponents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CleanUpAudioComponents"));

	APlayerController_CleanUpAudioComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.FindStairRotation
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// float                          DeltaTime                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int APlayerController::STATIC_FindStairRotation(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.FindStairRotation"));

	APlayerController_FindStairRotation_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CheckSpeedHack
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// float                          DeltaTime                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerController::CheckSpeedHack(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CheckSpeedHack"));

	APlayerController_CheckSpeedHack_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ServerProcessConvolve
// (Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 C                              (Parm, NeedCtorLink)
// int                            H                              (Parm)

void APlayerController::ServerProcessConvolve(const struct FString& C, int H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ServerProcessConvolve"));

	APlayerController_ServerProcessConvolve_Params params;
	params.C = C;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientConvolve
// (Defined, Iterator, Latent, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 C                              (Parm, NeedCtorLink)
// int                            H                              (Parm)

void APlayerController::ClientConvolve(const struct FString& C, int H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientConvolve"));

	APlayerController_ClientConvolve_Params params;
	params.C = C;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetAudioGroupVolume
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          Volume                         (Parm)

void APlayerController::SetAudioGroupVolume(const struct FName& GroupName, float Volume)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetAudioGroupVolume"));

	APlayerController_SetAudioGroupVolume_Params params;
	params.GroupName = GroupName;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetAllowMatureLanguage
// (Iterator, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bAllowMatureLanguge            (Parm)

void APlayerController::SetAllowMatureLanguage(bool bAllowMatureLanguge)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetAllowMatureLanguage"));

	APlayerController_SetAllowMatureLanguage_Params params;
	params.bAllowMatureLanguge = bAllowMatureLanguge;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PasteFromClipboard
// (Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_PasteFromClipboard()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.PasteFromClipboard"));

	APlayerController_PasteFromClipboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.CopyToClipboard
// (Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, NeedCtorLink)

void APlayerController::CopyToClipboard(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.CopyToClipboard"));

	APlayerController_CopyToClipboard_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.GetDefaultURL
// (Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 Option                         (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetDefaultURL(const struct FString& Option)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetDefaultURL"));

	APlayerController_GetDefaultURL_Params params;
	params.Option = Option;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.UpdateURL
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 NewOption                      (Parm, NeedCtorLink)
// struct FString                 NewValue                       (Parm, NeedCtorLink)
// bool                           bSave1Default                  (Parm)

void APlayerController::UpdateURL(const struct FString& NewOption, const struct FString& NewValue, bool bSave1Default)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.UpdateURL"));

	APlayerController_UpdateURL_Params params;
	params.NewOption = NewOption;
	params.NewValue = NewValue;
	params.bSave1Default = bSave1Default;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientTravel
// (Iterator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// TEnumAsByte<ETravelType>       TravelType                     (Parm)
// bool                           bSeamless                      (OptionalParm, Parm)
// struct FGuid                   MapPackageGuid                 (OptionalParm, Parm, AlwaysInit)

void APlayerController::ClientTravel(const struct FString& URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ClientTravel"));

	APlayerController_ClientTravel_Params params;
	params.URL = URL;
	params.TravelType = TravelType;
	params.bSeamless = bSeamless;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ConsoleCommand
// (Iterator, Latent, Singular, Net, Simulated, Static)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)
// bool                           bWriteToLog                    (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_ConsoleCommand(const struct FString& Command, bool bWriteToLog)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.ConsoleCommand"));

	APlayerController_ConsoleCommand_Params params;
	params.Command = Command;
	params.bWriteToLog = bWriteToLog;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetServerNetworkAddress
// (Defined, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetServerNetworkAddress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetServerNetworkAddress"));

	APlayerController_GetServerNetworkAddress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetPlayerNetworkAddress
// (Final, Defined, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerController::STATIC_GetPlayerNetworkAddress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.GetPlayerNetworkAddress"));

	APlayerController_GetPlayerNetworkAddress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.SetNetSpeed
// (Iterator, PreOperator, Event, HasOptionalParms)
// Parameters:
// int                            NewSpeed                       (Parm)

void APlayerController::SetNetSpeed(int NewSpeed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerController.SetNetSpeed"));

	APlayerController_SetNetSpeed_Params params;
	params.NewSpeed = NewSpeed;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.AnalyticsEndSession
// (Defined, PreOperator, Simulated, Operator)

void UCheatManager::AnalyticsEndSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.AnalyticsEndSession"));

	UCheatManager_AnalyticsEndSession_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.AnalyticsStartSession
// (Final, Iterator, PreOperator, Simulated, Operator)

void UCheatManager::AnalyticsStartSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.AnalyticsStartSession"));

	UCheatManager_AnalyticsStartSession_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.GetAnalyticsUserId
// (Final, PreOperator, Net, Simulated, Native, Event, Static)

void UCheatManager::STATIC_GetAnalyticsUserId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.GetAnalyticsUserId"));

	UCheatManager_GetAnalyticsUserId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetAnalyticsUserId
// (Defined, Iterator, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)

void UCheatManager::SetAnalyticsUserId(const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetAnalyticsUserId"));

	UCheatManager_SetAnalyticsUserId_Params params;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsCachedEvents
// (Final, Defined, Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void UCheatManager::SendAnalyticsCachedEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsCachedEvents"));

	UCheatManager_SendAnalyticsCachedEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsCurrencyGivenEvent
// (Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)

void UCheatManager::SendAnalyticsCurrencyGivenEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsCurrencyGivenEvent"));

	UCheatManager_SendAnalyticsCurrencyGivenEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsCurrencyPurchaseEvent
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)
// struct FString                 RealCurrencyType               (Parm, NeedCtorLink)
// float                          RealMoneyCost                  (Parm)
// struct FString                 PaymentProvider                (Parm, NeedCtorLink)

void UCheatManager::SendAnalyticsCurrencyPurchaseEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount, const struct FString& RealCurrencyType, float RealMoneyCost, const struct FString& PaymentProvider)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsCurrencyPurchaseEvent"));

	UCheatManager_SendAnalyticsCurrencyPurchaseEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;
	params.RealCurrencyType = RealCurrencyType;
	params.RealMoneyCost = RealMoneyCost;
	params.PaymentProvider = PaymentProvider;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsItemPurchaseEvent
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 ItemId                         (Parm, NeedCtorLink)
// struct FString                 Currency                       (Parm, NeedCtorLink)
// int                            PerItemCost                    (Parm)
// int                            ItemQuantity                   (Parm)

void UCheatManager::SendAnalyticsItemPurchaseEvent(const struct FString& ItemId, const struct FString& Currency, int PerItemCost, int ItemQuantity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsItemPurchaseEvent"));

	UCheatManager_SendAnalyticsItemPurchaseEvent_Params params;
	params.ItemId = ItemId;
	params.Currency = Currency;
	params.PerItemCost = PerItemCost;
	params.ItemQuantity = ItemQuantity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsUserAttributeEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 AttributeName                  (Parm, NeedCtorLink)
// struct FString                 AttributeValue                 (Parm, NeedCtorLink)

void UCheatManager::SendAnalyticsUserAttributeEvent(const struct FString& AttributeName, const struct FString& AttributeValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsUserAttributeEvent"));

	UCheatManager_SendAnalyticsUserAttributeEvent_Params params;
	params.AttributeName = AttributeName;
	params.AttributeValue = AttributeValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SendAnalyticsEvent
// (Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// struct FString                 AttributeName                  (OptionalParm, Parm, NeedCtorLink)
// struct FString                 AttributeValue                 (OptionalParm, Parm, NeedCtorLink)

void UCheatManager::SendAnalyticsEvent(const struct FString& EventName, const struct FString& AttributeName, const struct FString& AttributeValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SendAnalyticsEvent"));

	UCheatManager_SendAnalyticsEvent_Params params;
	params.EventName = EventName;
	params.AttributeName = AttributeName;
	params.AttributeValue = AttributeValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnRequestComplete
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class UHttpRequestInterface*   OriginalRequest                (Parm)
// class UHttpResponseInterface*  Response                       (Parm)
// bool                           bDidSucceed                    (Parm)

void UCheatManager::STATIC_OnRequestComplete(class UHttpRequestInterface* OriginalRequest, class UHttpResponseInterface* Response, bool bDidSucceed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnRequestComplete"));

	UCheatManager_OnRequestComplete_Params params;
	params.OriginalRequest = OriginalRequest;
	params.Response = Response;
	params.bDidSucceed = bDidSucceed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.TestHttp
// (Defined, Latent, PreOperator, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 Verb                           (Parm, NeedCtorLink)
// struct FString                 Payload                        (Parm, NeedCtorLink)
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           bSendParallelRequest           (OptionalParm, Parm)

void UCheatManager::TestHttp(const struct FString& Verb, const struct FString& Payload, const struct FString& URL, bool bSendParallelRequest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.TestHttp"));

	UCheatManager_TestHttp_Params params;
	params.Verb = Verb;
	params.Payload = Payload;
	params.URL = URL;
	params.bSendParallelRequest = bSendParallelRequest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnDeleteUserFileComplete
// (Final, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnDeleteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnDeleteUserFileComplete"));

	UCheatManager_OnDeleteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugDeleteUserFile
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_DebugDeleteUserFile(const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugDeleteUserFile"));

	UCheatManager_DebugDeleteUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnReadUserFileComplete
// (Final, Iterator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnReadUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnReadUserFileComplete"));

	UCheatManager_OnReadUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugReadUserFile
// (Latent, Singular, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_DebugReadUserFile(const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugReadUserFile"));

	UCheatManager_DebugReadUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnWriteUserFileComplete
// (Final, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnWriteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnWriteUserFileComplete"));

	UCheatManager_OnWriteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugWriteUserFile
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_DebugWriteUserFile(const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugWriteUserFile"));

	UCheatManager_DebugWriteUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnEnumerateUserFilesComplete
// (Final, Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnEnumerateUserFilesComplete(bool bWasSuccessful, const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnEnumerateUserFilesComplete"));

	UCheatManager_OnEnumerateUserFilesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugQueryUserFiles
// (Final, Defined, Iterator, Singular, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)

void UCheatManager::STATIC_DebugQueryUserFiles(const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugQueryUserFiles"));

	UCheatManager_DebugQueryUserFiles_Params params;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnReceivedLocalNotificationDebug
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FNotificationInfo       Notification                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           bWasAppActive                  (Parm)

void UCheatManager::STATIC_OnReceivedLocalNotificationDebug(bool bWasAppActive, struct FNotificationInfo* Notification)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnReceivedLocalNotificationDebug"));

	UCheatManager_OnReceivedLocalNotificationDebug_Params params;
	params.bWasAppActive = bWasAppActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Notification != nullptr)
		*Notification = params.Notification;
}


// Function Engine.CheatManager.DebugNotification
// (Defined, Singular, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 MessageBody                    (Parm, NeedCtorLink)
// int                            SecondsFromNow                 (Parm)

void UCheatManager::STATIC_DebugNotification(const struct FString& MessageBody, int SecondsFromNow)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugNotification"));

	UCheatManager_DebugNotification_Params params;
	params.MessageBody = MessageBody;
	params.SecondsFromNow = SecondsFromNow;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DrawLocationXYZ
// (Final, Iterator, Net, Exec, Native, Static)
// Parameters:
// float                          X                              (Parm)
// float                          Y                              (Parm)
// float                          Z                              (Parm)

void UCheatManager::STATIC_DrawLocationXYZ(float X, float Y, float Z)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DrawLocationXYZ"));

	UCheatManager_DrawLocationXYZ_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DrawLocation
// (Iterator, Net, Exec, Native, Static)
// Parameters:
// struct FVector                 Loc                            (Parm)

void UCheatManager::STATIC_DrawLocation(const struct FVector& Loc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DrawLocation"));

	UCheatManager_DrawLocation_Params params;
	params.Loc = Loc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DumpCoverStats
// (Latent, PreOperator, NetReliable, Exec, Native, Static)

void UCheatManager::STATIC_DumpCoverStats()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DumpCoverStats"));

	UCheatManager_DumpCoverStats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugEmsDownload
// (Defined, Latent, PreOperator, Net, Simulated, Exec, Static)

void UCheatManager::STATIC_DebugEmsDownload()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugEmsDownload"));

	UCheatManager_DebugEmsDownload_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugDeleteTitleFiles
// (Iterator, PreOperator, Net, Simulated, Exec, Static)

void UCheatManager::STATIC_DebugDeleteTitleFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugDeleteTitleFiles"));

	UCheatManager_DebugDeleteTitleFiles_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnSaveComplete
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnSaveComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnSaveComplete"));

	UCheatManager_OnSaveComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugSaveTitleFile
// (Final, Latent, Singular, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_DebugSaveTitleFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugSaveTitleFile"));

	UCheatManager_DebugSaveTitleFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnLoadComplete
// (Final, Latent, PreOperator, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnLoadComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnLoadComplete"));

	UCheatManager_OnLoadComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnDownloadComplete
// (Final, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UCheatManager::STATIC_OnDownloadComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnDownloadComplete"));

	UCheatManager_OnDownloadComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugDownloadTitleFile
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Exec, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           bFromCache                     (OptionalParm, Parm)

void UCheatManager::STATIC_DebugDownloadTitleFile(const struct FString& Filename, bool bFromCache)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugDownloadTitleFile"));

	UCheatManager_DebugDownloadTitleFile_Params params;
	params.Filename = Filename;
	params.bFromCache = bFromCache;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugIniLocPatcher
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Static)

void UCheatManager::STATIC_DebugIniLocPatcher()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugIniLocPatcher"));

	UCheatManager_DebugIniLocPatcher_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ToggleAILogging
// (Iterator, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void UCheatManager::ToggleAILogging()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ToggleAILogging"));

	UCheatManager_ToggleAILogging_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.UnsuppressAILog
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void UCheatManager::UnsuppressAILog()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.UnsuppressAILog"));

	UCheatManager_UnsuppressAILog_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SuppressAILog
// (Final, Defined, Net, Native, Event, HasOptionalParms)

void UCheatManager::SuppressAILog()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SuppressAILog"));

	UCheatManager_SuppressAILog_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.VerifyNavMeshCoverRefs
// (Final, Defined, Iterator, Latent, Singular, Operator, HasOptionalParms)

void UCheatManager::VerifyNavMeshCoverRefs()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.VerifyNavMeshCoverRefs"));

	UCheatManager_VerifyNavMeshCoverRefs_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.PrintNavMeshObstacles
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, HasOptionalParms)

void UCheatManager::PrintNavMeshObstacles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.PrintNavMeshObstacles"));

	UCheatManager_PrintNavMeshObstacles_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.PrintAllPathObjectEdges
// (Defined, Iterator, PreOperator, NetReliable, Simulated, HasOptionalParms)

void UCheatManager::PrintAllPathObjectEdges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.PrintAllPathObjectEdges"));

	UCheatManager_PrintAllPathObjectEdges_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.NavMeshVerification
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// float                          interval                       (OptionalParm, Parm)

void UCheatManager::STATIC_NavMeshVerification(float interval)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.NavMeshVerification"));

	UCheatManager_NavMeshVerification_Params params;
	params.interval = interval;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DrawUnsupportingEdges
// (Iterator, Latent, Singular, Net, Exec, Native, Static)
// Parameters:
// struct FString                 PawnClassName                  (Parm, CoerceParm, NeedCtorLink)

void UCheatManager::STATIC_DrawUnsupportingEdges(const struct FString& PawnClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DrawUnsupportingEdges"));

	UCheatManager_DrawUnsupportingEdges_Params params;
	params.PawnClassName = PawnClassName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.VerifyNavMeshObjects
// (PreOperator, Singular, Operator, HasOptionalParms)

void UCheatManager::VerifyNavMeshObjects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.VerifyNavMeshObjects"));

	UCheatManager_VerifyNavMeshObjects_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.LogParticleActivateSystemCalls
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// bool                           bShouldLog                     (Parm)

void UCheatManager::STATIC_LogParticleActivateSystemCalls(bool bShouldLog)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.LogParticleActivateSystemCalls"));

	UCheatManager_LogParticleActivateSystemCalls_Params params;
	params.bShouldLog = bShouldLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.LogPlaySoundCalls
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// bool                           bShouldLog                     (Parm)

void UCheatManager::STATIC_LogPlaySoundCalls(bool bShouldLog)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.LogPlaySoundCalls"));

	UCheatManager_LogPlaySoundCalls_Params params;
	params.bShouldLog = bShouldLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.InitCheatManager
// (Final, PreOperator, Net, Simulated, Operator, Static)

void UCheatManager::STATIC_InitCheatManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.InitCheatManager"));

	UCheatManager_InitCheatManager_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.VerbosePathDebug
// (Iterator, Latent, Singular, Operator, HasOptionalParms)

void UCheatManager::VerbosePathDebug()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.VerbosePathDebug"));

	UCheatManager_VerbosePathDebug_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.TestPylonConnectivity
// (Defined, Singular, Simulated, Native, Event, HasOptionalParms)

void UCheatManager::TestPylonConnectivity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.TestPylonConnectivity"));

	UCheatManager_TestPylonConnectivity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.TestNavMeshPath
// (Final, Singular, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bDrawPath                      (OptionalParm, Parm)

void UCheatManager::TestNavMeshPath(bool bDrawPath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.TestNavMeshPath"));

	UCheatManager_TestNavMeshPath_Params params;
	params.bDrawPath = bDrawPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetOnlineDebugLevel
// (Final, Defined, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// int                            DebugLevel                     (Parm)

void UCheatManager::SetOnlineDebugLevel(int DebugLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetOnlineDebugLevel"));

	UCheatManager_SetOnlineDebugLevel_Params params;
	params.DebugLevel = DebugLevel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.TestLevel
// (Iterator, Latent, PreOperator, Simulated, Native, Event, HasOptionalParms)

void UCheatManager::TestLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.TestLevel"));

	UCheatManager_TestLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.StreamLevelOut
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   PackageName                    (Parm)

void UCheatManager::StreamLevelOut(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.StreamLevelOut"));

	UCheatManager_StreamLevelOut_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnlyLoadLevel
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FName                   PackageName                    (Parm)

void UCheatManager::STATIC_OnlyLoadLevel(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.OnlyLoadLevel"));

	UCheatManager_OnlyLoadLevel_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.StreamLevelIn
// (Final, Latent, Singular, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   PackageName                    (Parm)

void UCheatManager::StreamLevelIn(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.StreamLevelIn"));

	UCheatManager_StreamLevelIn_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetLevelStreamingStatus
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   PackageName                    (Parm)
// bool                           bShouldBeLoaded                (Parm)
// bool                           bShouldBeVisible               (Parm)

void UCheatManager::SetLevelStreamingStatus(const struct FName& PackageName, bool bShouldBeLoaded, bool bShouldBeVisible)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetLevelStreamingStatus"));

	UCheatManager_SetLevelStreamingStatus_Params params;
	params.PackageName = PackageName;
	params.bShouldBeLoaded = bShouldBeLoaded;
	params.bShouldBeVisible = bShouldBeVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.AllWeapons
// (Net, NetReliable, Operator)

void UCheatManager::AllWeapons()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.AllWeapons"));

	UCheatManager_AllWeapons_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Loaded
// (Final, Latent, Simulated, Native, Operator, Static)

void UCheatManager::STATIC_Loaded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Loaded"));

	UCheatManager_Loaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewClass
// (Defined, Iterator, Singular, Net, Operator, HasOptionalParms)
// Parameters:
// class UClass*                  aClass                         (Parm)

void UCheatManager::ViewClass(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ViewClass"));

	UCheatManager_ViewClass_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewBot
// (Final, Iterator, Singular, Net, Operator, HasOptionalParms)

void UCheatManager::ViewBot()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ViewBot"));

	UCheatManager_ViewBot_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewActor
// (Final, Defined, Singular, Net, Operator, HasOptionalParms)
// Parameters:
// struct FName                   actorName                      (Parm)

void UCheatManager::ViewActor(const struct FName& actorName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ViewActor"));

	UCheatManager_ViewActor_Params params;
	params.actorName = actorName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewPlayer
// (Defined, Latent, PreOperator, Singular, Net, Operator, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void UCheatManager::ViewPlayer(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ViewPlayer"));

	UCheatManager_ViewPlayer_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewSelf
// (Iterator, NetReliable, Operator, HasOptionalParms)
// Parameters:
// bool                           bQuiet                         (OptionalParm, Parm)

void UCheatManager::ViewSelf(bool bQuiet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ViewSelf"));

	UCheatManager_ViewSelf_Params params;
	params.bQuiet = bQuiet;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.RememberSpot
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void UCheatManager::RememberSpot()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.RememberSpot"));

	UCheatManager_RememberSpot_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FractureAllMeshesToMaximizeMemoryUsage
// (Final, Defined, Latent, Native, Event, Static)

void UCheatManager::STATIC_FractureAllMeshesToMaximizeMemoryUsage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.FractureAllMeshesToMaximizeMemoryUsage"));

	UCheatManager_FractureAllMeshesToMaximizeMemoryUsage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FractureAllMeshes
// (Defined, Latent, Native, Event, Static)

void UCheatManager::STATIC_FractureAllMeshes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.FractureAllMeshes"));

	UCheatManager_FractureAllMeshes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyFractures
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Native, Static)
// Parameters:
// float                          Radius                         (OptionalParm, Parm)

void UCheatManager::STATIC_DestroyFractures(float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DestroyFractures"));

	UCheatManager_DestroyFractures_Params params;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SuspendAI
// (Defined, Iterator, Net, Native, Event, HasOptionalParms)

void UCheatManager::SuspendAI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SuspendAI"));

	UCheatManager_SuspendAI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.PlayersOnly
// (Defined, Iterator, Latent, NetReliable, HasOptionalParms)

void UCheatManager::PlayersOnly()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.PlayersOnly"));

	UCheatManager_PlayersOnly_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.GiveWeapon
// (Defined, Iterator, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 WeaponClassStr                 (Parm, NeedCtorLink)
// class AWeapon*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class AWeapon* UCheatManager::STATIC_GiveWeapon(const struct FString& WeaponClassStr)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.GiveWeapon"));

	UCheatManager_GiveWeapon_Params params;
	params.WeaponClassStr = WeaponClassStr;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CheatManager.Summon
// (Final, Defined, Latent, PreOperator, Singular, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 ClassName                      (Parm, NeedCtorLink)

void UCheatManager::Summon(const struct FString& ClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Summon"));

	UCheatManager_Summon_Params params;
	params.ClassName = ClassName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Avatar
// (Singular, Net, Exec, Operator)
// Parameters:
// struct FName                   ClassName                      (Parm)

void UCheatManager::Avatar(const struct FName& ClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Avatar"));

	UCheatManager_Avatar_Params params;
	params.ClassName = ClassName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.KillPawns
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)

void UCheatManager::STATIC_KillPawns()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.KillPawns"));

	UCheatManager_KillPawns_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.KillAllPawns
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// class UClass*                  aClass                         (Parm)

void UCheatManager::STATIC_KillAllPawns(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.KillAllPawns"));

	UCheatManager_KillAllPawns_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.KillAll
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// class UClass*                  aClass                         (Parm)

void UCheatManager::STATIC_KillAll(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.KillAll"));

	UCheatManager_KillAll_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetSpeed
// (Latent, Net, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// float                          F                              (Parm)

void UCheatManager::SetSpeed(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetSpeed"));

	UCheatManager_SetSpeed_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetGravity
// (Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          F                              (Parm)

void UCheatManager::SetGravity(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetGravity"));

	UCheatManager_SetGravity_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetJumpZ
// (Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          F                              (Parm)

void UCheatManager::SetJumpZ(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.SetJumpZ"));

	UCheatManager_SetJumpZ_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Slomo
// (Defined, Latent, Singular, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// float                          T                              (Parm)

void UCheatManager::Slomo(float T)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Slomo"));

	UCheatManager_Slomo_Params params;
	params.T = T;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.God
// (Final, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)

void UCheatManager::STATIC_God()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.God"));

	UCheatManager_God_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.AllAmmo
// (Final, Defined, Latent, PreOperator, NetReliable, Operator)

void UCheatManager::AllAmmo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.AllAmmo"));

	UCheatManager_AllAmmo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Ghost
// (Defined, Latent, Net, Simulated, Exec, Native, Event, Static)

void UCheatManager::STATIC_Ghost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Ghost"));

	UCheatManager_Ghost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Walk
// (Defined, Latent, PreOperator, Net, NetReliable, Operator, HasOptionalParms)

void UCheatManager::Walk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Walk"));

	UCheatManager_Walk_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Fly
// (Final, Net, Simulated, Exec, Event, Static)

void UCheatManager::STATIC_Fly()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Fly"));

	UCheatManager_Fly_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Amphibious
// (Final, Latent, Simulated, Operator)

void UCheatManager::Amphibious()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Amphibious"));

	UCheatManager_Amphibious_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.EndPath
// (Final, Defined, PreOperator, Event, Static)

void UCheatManager::STATIC_EndPath()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.EndPath"));

	UCheatManager_EndPath_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ChangeSize
// (Iterator, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// float                          F                              (Parm)

void UCheatManager::ChangeSize(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ChangeSize"));

	UCheatManager_ChangeSize_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Teleport
// (Defined, Iterator, Singular, Net, Simulated, Exec, Event, HasOptionalParms)

void UCheatManager::Teleport()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.Teleport"));

	UCheatManager_Teleport_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.KillViewedActor
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)

void UCheatManager::STATIC_KillViewedActor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.KillViewedActor"));

	UCheatManager_KillViewedActor_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.WriteToLog
// (PreOperator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FString                 Param                          (Parm, NeedCtorLink)

void UCheatManager::WriteToLog(const struct FString& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.WriteToLog"));

	UCheatManager_WriteToLog_Params params;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FreezeFrame
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Native, Event, Static)
// Parameters:
// float                          Delay                          (Parm)

void UCheatManager::STATIC_FreezeFrame(float Delay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.FreezeFrame"));

	UCheatManager_FreezeFrame_Params params;
	params.Delay = Delay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ListDynamicActors
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Native, Operator, Static)

void UCheatManager::STATIC_ListDynamicActors()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.ListDynamicActors"));

	UCheatManager_ListDynamicActors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugPause
// (Final, Iterator, Singular, Net, Simulated, Exec, Static)

void UCheatManager::STATIC_DebugPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugPause"));

	UCheatManager_DebugPause_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.EditAIByTrace
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Static)

void UCheatManager::STATIC_EditAIByTrace()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.EditAIByTrace"));

	UCheatManager_EditAIByTrace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugAI
// (Final, PreOperator, Net, Simulated, Exec, Static)
// Parameters:
// struct FName                   Category                       (OptionalParm, Parm, CoerceParm)

void UCheatManager::STATIC_DebugAI(const struct FName& Category)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.DebugAI"));

	UCheatManager_DebugAI_Params params;
	params.Category = Category;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FXStop
// (Final, PreOperator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// class UClass*                  aClass                         (Parm)

void UCheatManager::STATIC_FXStop(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.FXStop"));

	UCheatManager_FXStop_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FXPlay
// (Latent, Singular, NetReliable, Native, Event, Static)
// Parameters:
// class UClass*                  aClass                         (Parm)
// struct FString                 FXAnimPath                     (Parm, NeedCtorLink)

void UCheatManager::STATIC_FXPlay(class UClass* aClass, const struct FString& FXAnimPath)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CheatManager.FXPlay"));

	UCheatManager_FXPlay_Params params;
	params.aClass = aClass;
	params.FXAnimPath = FXAnimPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.GetKeyValue
// (Final, Defined, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// TEnumAsByte<EPlatformInterfaceDataType> Type                           (Parm)
// struct FPlatformInterfaceDelegateResult Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_GetKeyValue(int SaveSlot, const struct FString& KeyName, TEnumAsByte<EPlatformInterfaceDataType> Type, struct FPlatformInterfaceDelegateResult* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.GetKeyValue"));

	UCloudSaveSystem_GetKeyValue_Params params;
	params.SaveSlot = SaveSlot;
	params.KeyName = KeyName;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.GetDataStoreIDAndBlobNameForSaveSlot
// (Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FString                 DataStoreID                    (Parm, OutParm, NeedCtorLink)
// struct FString                 DataBlobName                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_GetDataStoreIDAndBlobNameForSaveSlot(int SaveSlot, struct FString* DataStoreID, struct FString* DataBlobName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.GetDataStoreIDAndBlobNameForSaveSlot"));

	UCloudSaveSystem_GetDataStoreIDAndBlobNameForSaveSlot_Params params;
	params.SaveSlot = SaveSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataStoreID != nullptr)
		*DataStoreID = params.DataStoreID;
	if (DataBlobName != nullptr)
		*DataBlobName = params.DataBlobName;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.SetKeyValue
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// struct FPlatformInterfaceData  Value                          (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::SetKeyValue(int SaveSlot, const struct FString& KeyName, struct FPlatformInterfaceData* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.SetKeyValue"));

	UCloudSaveSystem_SetKeyValue_Params params;
	params.SaveSlot = SaveSlot;
	params.KeyName = KeyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.InternalSetSaveSlotKeyValues
// (Final, Defined, Iterator, PreOperator, Singular, Exec, Operator, Static)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FString                 DataStoreID                    (Parm, NeedCtorLink)
// struct FString                 SaveDataBlobName               (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_InternalSetSaveSlotKeyValues(int SaveSlot, const struct FString& DataStoreID, const struct FString& SaveDataBlobName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.InternalSetSaveSlotKeyValues"));

	UCloudSaveSystem_InternalSetSaveSlotKeyValues_Params params;
	params.SaveSlot = SaveSlot;
	params.DataStoreID = DataStoreID;
	params.SaveDataBlobName = SaveDataBlobName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.SetSaveSlotKeyValues
// (Final, Defined, Iterator, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FString                 DataStoreID                    (Parm, NeedCtorLink)
// struct FString                 SaveDataBlobName               (Parm, NeedCtorLink)
// int                            SaveSlot                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::SetSaveSlotKeyValues(const struct FString& DataStoreID, const struct FString& SaveDataBlobName, int* SaveSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.SetSaveSlotKeyValues"));

	UCloudSaveSystem_SetSaveSlotKeyValues_Params params;
	params.DataStoreID = DataStoreID;
	params.SaveDataBlobName = SaveDataBlobName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SaveSlot != nullptr)
		*SaveSlot = params.SaveSlot;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.OnDeleteSaveDataComplete
// (Final, Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystem::STATIC_OnDeleteSaveDataComplete(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.OnDeleteSaveDataComplete"));

	UCloudSaveSystem_OnDeleteSaveDataComplete_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.DeleteSaveData
// (Final, PreOperator, Singular, Net, Native, Static)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FScriptDelegate         InDeleteSaveDataCallback       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_DeleteSaveData(int SaveSlot, const struct FScriptDelegate& InDeleteSaveDataCallback)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.DeleteSaveData"));

	UCloudSaveSystem_DeleteSaveData_Params params;
	params.SaveSlot = SaveSlot;
	params.InDeleteSaveDataCallback = InDeleteSaveDataCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.OnSetSaveDataComplete
// (Defined, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystem::STATIC_OnSetSaveDataComplete(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.OnSetSaveDataComplete"));

	UCloudSaveSystem_OnSetSaveDataComplete_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.SetSaveData
// (Final, Iterator, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FScriptDelegate         InSetSaveDataCallback          (Parm, NeedCtorLink)
// TArray<unsigned char>          SaveDataBlob                   (Const, Parm, OutParm, NeedCtorLink)

void UCloudSaveSystem::SetSaveData(int SaveSlot, const struct FScriptDelegate& InSetSaveDataCallback, TArray<unsigned char>* SaveDataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.SetSaveData"));

	UCloudSaveSystem_SetSaveData_Params params;
	params.SaveSlot = SaveSlot;
	params.InSetSaveDataCallback = InSetSaveDataCallback;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SaveDataBlob != nullptr)
		*SaveDataBlob = params.SaveDataBlob;
}


// Function Engine.CloudSaveSystem.OnGetSaveDataComplete
// (Final, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// TArray<unsigned char>          DataBlob                       (Parm, OutParm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystem::STATIC_OnGetSaveDataComplete(bool bWasSuccessful, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.OnGetSaveDataComplete"));

	UCloudSaveSystem_OnGetSaveDataComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.CloudSaveSystem.GetSaveData
// (Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            SaveSlot                       (Parm)
// struct FScriptDelegate         OnGetSaveDataCallback          (Parm, NeedCtorLink)

void UCloudSaveSystem::STATIC_GetSaveData(int SaveSlot, const struct FScriptDelegate& OnGetSaveDataCallback)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.GetSaveData"));

	UCloudSaveSystem_GetSaveData_Params params;
	params.SaveSlot = SaveSlot;
	params.OnGetSaveDataCallback = OnGetSaveDataCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// TScriptInterface<class UCloudSaveSystemKVSInterface> InKeyValueStore                (Parm)
// TScriptInterface<class UCloudSaveSystemDataBlobStoreInterface> InDataBlobStore                (Parm)
// int                            VersionNumber                  (Parm)

void UCloudSaveSystem::Init(const TScriptInterface<class UCloudSaveSystemKVSInterface>& InKeyValueStore, const TScriptInterface<class UCloudSaveSystemDataBlobStoreInterface>& InDataBlobStore, int VersionNumber)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.Init"));

	UCloudSaveSystem_Init_Params params;
	params.InKeyValueStore = InKeyValueStore;
	params.InDataBlobStore = InDataBlobStore;
	params.VersionNumber = VersionNumber;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.DeserializeObject
// (Defined, PreOperator, NetReliable, Native, Static)
// Parameters:
// class UClass*                  ObjectClass                    (Parm)
// TArray<unsigned char>          Data                           (Parm, OutParm, NeedCtorLink)
// TEnumAsByte<ESaveDataVersionSupport> VersionSupport                 (Parm)
// int                            DataVersion                    (Parm)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UCloudSaveSystem::STATIC_DeserializeObject(class UClass* ObjectClass, TEnumAsByte<ESaveDataVersionSupport> VersionSupport, int DataVersion, TArray<unsigned char>* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.DeserializeObject"));

	UCloudSaveSystem_DeserializeObject_Params params;
	params.ObjectClass = ObjectClass;
	params.VersionSupport = VersionSupport;
	params.DataVersion = DataVersion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.SerializeObject
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 ObjectToSerialize              (Parm)
// TArray<unsigned char>          Data                           (Parm, OutParm, NeedCtorLink)
// int                            DataVersion                    (Parm)

void UCloudSaveSystem::SerializeObject(class UObject* ObjectToSerialize, int DataVersion, TArray<unsigned char>* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.SerializeObject"));

	UCloudSaveSystem_SerializeObject_Params params;
	params.ObjectToSerialize = ObjectToSerialize;
	params.DataVersion = DataVersion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.CloudSaveSystem.AreAnySlotOperationsActive
// (PreOperator, Net, NetReliable, Simulated, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::AreAnySlotOperationsActive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.AreAnySlotOperationsActive"));

	UCloudSaveSystem_AreAnySlotOperationsActive_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.IsDeleteOperationActive
// (Final, Defined, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_IsDeleteOperationActive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.IsDeleteOperationActive"));

	UCloudSaveSystem_IsDeleteOperationActive_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.IsOperationActiveForSlot
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            SlotIndex                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_IsOperationActiveForSlot(int SlotIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.IsOperationActiveForSlot"));

	UCloudSaveSystem_IsOperationActiveForSlot_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.WriteNumSaveSlots
// (Iterator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// int                            NumSaveSlots                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::WriteNumSaveSlots(int NumSaveSlots)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.WriteNumSaveSlots"));

	UCloudSaveSystem_WriteNumSaveSlots_Params params;
	params.NumSaveSlots = NumSaveSlots;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.DoesSaveSlotKeyValueDataAlreadyExist
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// struct FString                 DataStoreID                    (Parm, NeedCtorLink)
// struct FString                 DataBlobName                   (Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UCloudSaveSystem::STATIC_DoesSaveSlotKeyValueDataAlreadyExist(const struct FString& DataStoreID, const struct FString& DataBlobName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.DoesSaveSlotKeyValueDataAlreadyExist"));

	UCloudSaveSystem_DoesSaveSlotKeyValueDataAlreadyExist_Params params;
	params.DataStoreID = DataStoreID;
	params.DataBlobName = DataBlobName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.GetNumberOfSaveSlots
// (Defined, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            NumSaveSlots                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystem::STATIC_GetNumberOfSaveSlots(int* NumSaveSlots)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.GetNumberOfSaveSlots"));

	UCloudSaveSystem_GetNumberOfSaveSlots_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NumSaveSlots != nullptr)
		*NumSaveSlots = params.NumSaveSlots;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystem.SaveSystemCallback
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// int                            SaveSlot                       (Parm)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystem::SaveSystemCallback(bool bWasSuccessful, int SaveSlot, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.SaveSystemCallback"));

	UCloudSaveSystem_SaveSystemCallback_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.SaveSlot = SaveSlot;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystem.OnGetSaveDataCallback
// (Iterator, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// int                            SaveSlot                       (Parm)
// TArray<unsigned char>          DataBlob                       (Parm, OutParm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystem::OnGetSaveDataCallback(bool bWasSuccessful, int SaveSlot, const struct FString& Error, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystem.OnGetSaveDataCallback"));

	UCloudSaveSystem_OnGetSaveDataCallback_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.SaveSlot = SaveSlot;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.DamageType.VehicleDamageScalingFor
// (Final, Iterator, Latent, Operator, HasOptionalParms)
// Parameters:
// class AVehicle*                V                              (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UDamageType::VehicleDamageScalingFor(class AVehicle* V)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DamageType.VehicleDamageScalingFor"));

	UDamageType_VehicleDamageScalingFor_Params params;
	params.V = V;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FaceFXAsset.UnmountFaceFXAnimSet
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)

void UFaceFXAsset::UnmountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FaceFXAsset.UnmountFaceFXAnimSet"));

	UFaceFXAsset_UnmountFaceFXAnimSet_Params params;
	params.AnimSet = AnimSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FaceFXAsset.MountFaceFXAnimSet
// (Defined, Iterator, Net, NetReliable, Event, Operator, Static)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)

void UFaceFXAsset::STATIC_MountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FaceFXAsset.MountFaceFXAnimSet"));

	UFaceFXAsset_MountFaceFXAnimSet_Params params;
	params.AnimSet = AnimSet;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Font.GetStringHeightAndWidth
// (Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 InString                       (Const, Parm, OutParm, NeedCtorLink)
// int                            Height                         (Parm, OutParm)
// int                            Width                          (Parm, OutParm)

void UFont::STATIC_GetStringHeightAndWidth(struct FString* InString, int* Height, int* Width)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Font.GetStringHeightAndWidth"));

	UFont_GetStringHeightAndWidth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InString != nullptr)
		*InString = params.InString;
	if (Height != nullptr)
		*Height = params.Height;
	if (Width != nullptr)
		*Width = params.Width;
}


// Function Engine.Font.GetMaxCharHeight
// (Defined, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UFont::STATIC_GetMaxCharHeight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Font.GetMaxCharHeight"));

	UFont_GetMaxCharHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Font.GetAuthoredViewportHeight
// (Final, Defined, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ViewportHeight                 (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UFont::STATIC_GetAuthoredViewportHeight(float ViewportHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Font.GetAuthoredViewportHeight"));

	UFont_GetAuthoredViewportHeight_Params params;
	params.ViewportHeight = ViewportHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Font.GetScalingFactor
// (Final, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          HeightTest                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UFont::STATIC_GetScalingFactor(float HeightTest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Font.GetScalingFactor"));

	UFont_GetScalingFactor_Params params;
	params.HeightTest = HeightTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Font.GetResolutionPageIndex
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          HeightTest                     (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UFont::STATIC_GetResolutionPageIndex(float HeightTest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Font.GetResolutionPageIndex"));

	UFont_GetResolutionPageIndex_Params params;
	params.HeightTest = HeightTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MultiFont.GetResolutionTestTableIndex
// (Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          HeightTest                     (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UMultiFont::STATIC_GetResolutionTestTableIndex(float HeightTest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiFont.GetResolutionTestTableIndex"));

	UMultiFont_GetResolutionTestTableIndex_Params params;
	params.HeightTest = HeightTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFeedbackManager.PauseWaveform
// (Defined, Iterator, Simulated, Exec, Native, Event, Operator, Static)
// Parameters:
// bool                           bPause                         (OptionalParm, Parm)

void UForceFeedbackManager::STATIC_PauseWaveform(bool bPause)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFeedbackManager.PauseWaveform"));

	UForceFeedbackManager_PauseWaveform_Params params;
	params.bPause = bPause;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackManager.StopForceFeedbackWaveform
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  WaveForm                       (OptionalParm, Parm)

void UForceFeedbackManager::StopForceFeedbackWaveform(class UForceFeedbackWaveform* WaveForm)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFeedbackManager.StopForceFeedbackWaveform"));

	UForceFeedbackManager_StopForceFeedbackWaveform_Params params;
	params.WaveForm = WaveForm;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackManager.PlayForceFeedbackWaveform
// (Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UForceFeedbackWaveform*  WaveForm                       (Parm)
// class AActor*                  WaveInstigator                 (OptionalParm, Parm)
// float                          fScaleMagnitude                (OptionalParm, Parm)
// float                          fScaleRate                     (OptionalParm, Parm)
// bool                           bForcePlay                     (OptionalParm, Parm)

void UForceFeedbackManager::PlayForceFeedbackWaveform(class UForceFeedbackWaveform* WaveForm, class AActor* WaveInstigator, float fScaleMagnitude, float fScaleRate, bool bForcePlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFeedbackManager.PlayForceFeedbackWaveform"));

	UForceFeedbackManager_PlayForceFeedbackWaveform_Params params;
	params.WaveForm = WaveForm;
	params.WaveInstigator = WaveInstigator;
	params.fScaleMagnitude = fScaleMagnitude;
	params.fScaleRate = fScaleRate;
	params.bForcePlay = bForcePlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.ResetState
// (Final, Latent, NetReliable, Native, HasOptionalParms)

void UGamePadLightbarSubsystem::ResetState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.ResetState"));

	UGamePadLightbarSubsystem_ResetState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPulsingFromDef
// (Iterator, Net, Event, HasOptionalParms)
// Parameters:
// struct FString                 InstructionId                  (Parm, NeedCtorLink)

void UGamePadLightbarSubsystem::SetPulsingFromDef(const struct FString& InstructionId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPulsingFromDef"));

	UGamePadLightbarSubsystem_SetPulsingFromDef_Params params;
	params.InstructionId = InstructionId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPulsing
// (Final, Defined, Net, Event, HasOptionalParms)
// Parameters:
// float                          LerpTime                       (Parm)
// struct FColor                  Target1                        (Parm)
// struct FColor                  Target2                        (OptionalParm, Parm)

void UGamePadLightbarSubsystem::SetPulsing(float LerpTime, const struct FColor& Target1, const struct FColor& Target2)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPulsing"));

	UGamePadLightbarSubsystem_SetPulsing_Params params;
	params.LerpTime = LerpTime;
	params.Target1 = Target1;
	params.Target2 = Target2;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPadColorAndLerpFromDef
// (Defined, Iterator, Singular, Event, HasOptionalParms)
// Parameters:
// struct FString                 InstructionId                  (Parm, NeedCtorLink)

void UGamePadLightbarSubsystem::SetPadColorAndLerpFromDef(const struct FString& InstructionId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPadColorAndLerpFromDef"));

	UGamePadLightbarSubsystem_SetPadColorAndLerpFromDef_Params params;
	params.InstructionId = InstructionId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPadColorAndLerp
// (Final, Iterator, Singular, Event, HasOptionalParms)
// Parameters:
// float                          LerpTime                       (Parm)
// struct FColor                  NewPadColor                    (Parm)
// struct FColor                  NewTargetColor                 (OptionalParm, Parm)

void UGamePadLightbarSubsystem::SetPadColorAndLerp(float LerpTime, const struct FColor& NewPadColor, const struct FColor& NewTargetColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPadColorAndLerp"));

	UGamePadLightbarSubsystem_SetPadColorAndLerp_Params params;
	params.LerpTime = LerpTime;
	params.NewPadColor = NewPadColor;
	params.NewTargetColor = NewTargetColor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.BeginLerpFromDef
// (Final, PreOperator, Simulated, Native, Operator)
// Parameters:
// struct FString                 InstructionId                  (Parm, NeedCtorLink)

void UGamePadLightbarSubsystem::BeginLerpFromDef(const struct FString& InstructionId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.BeginLerpFromDef"));

	UGamePadLightbarSubsystem_BeginLerpFromDef_Params params;
	params.InstructionId = InstructionId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.BeginLerp
// (PreOperator, Simulated, Native, Operator)
// Parameters:
// struct FColor                  NewLerpColor                   (Parm)
// float                          LerpTime                       (Parm)

void UGamePadLightbarSubsystem::BeginLerp(const struct FColor& NewLerpColor, float LerpTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.BeginLerp"));

	UGamePadLightbarSubsystem_BeginLerp_Params params;
	params.NewLerpColor = NewLerpColor;
	params.LerpTime = LerpTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPadColorFromDef
// (Final, Defined, Iterator, Singular, Event, HasOptionalParms)
// Parameters:
// struct FString                 TheColorId                     (Parm, NeedCtorLink)

void UGamePadLightbarSubsystem::SetPadColorFromDef(const struct FString& TheColorId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPadColorFromDef"));

	UGamePadLightbarSubsystem_SetPadColorFromDef_Params params;
	params.TheColorId = TheColorId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GamePadLightbarSubsystem.SetPadColor
// (Iterator, Singular, Event, HasOptionalParms)
// Parameters:
// struct FColor                  NewPadColor                    (Parm)

void UGamePadLightbarSubsystem::SetPadColor(const struct FColor& NewPadColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GamePadLightbarSubsystem.SetPadColor"));

	UGamePadLightbarSubsystem_SetPadColor_Params params;
	params.NewPadColor = NewPadColor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEvents.GetFilename
// (Defined, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UGameplayEvents::GetFilename()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEvents.GetFilename"));

	UGameplayEvents_GetFilename_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEvents.CloseStatsFile
// (Final, Defined, Iterator, Latent, Net, Static)

void UGameplayEvents::STATIC_CloseStatsFile()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEvents.CloseStatsFile"));

	UGameplayEvents_CloseStatsFile_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEvents.OpenStatsFile
// (Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEvents::STATIC_OpenStatsFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEvents.OpenStatsFile"));

	UGameplayEvents_OpenStatsFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetSessionDuration
// (Iterator, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UGameplayEventsReader::STATIC_GetSessionDuration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetSessionDuration"));

	UGameplayEventsReader_GetSessionDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetSessionEnd
// (Final, Iterator, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UGameplayEventsReader::STATIC_GetSessionEnd()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetSessionEnd"));

	UGameplayEventsReader_GetSessionEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetSessionStart
// (Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UGameplayEventsReader::STATIC_GetSessionStart()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetSessionStart"));

	UGameplayEventsReader_GetSessionStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetSessionTimestamp
// (Final, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UGameplayEventsReader::STATIC_GetSessionTimestamp()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetSessionTimestamp"));

	UGameplayEventsReader_GetSessionTimestamp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetPlatform
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsReader::STATIC_GetPlatform()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetPlatform"));

	UGameplayEventsReader_GetPlatform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetTitleID
// (Iterator, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsReader::STATIC_GetTitleID()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetTitleID"));

	UGameplayEventsReader_GetTitleID_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.GetSessionID
// (Defined, Iterator, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UGameplayEventsReader::STATIC_GetSessionID()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.GetSessionID"));

	UGameplayEventsReader_GetSessionID_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.ProcessStreamEnd
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)

void UGameplayEventsReader::ProcessStreamEnd()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.ProcessStreamEnd"));

	UGameplayEventsReader_ProcessStreamEnd_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.ProcessStream
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)

void UGameplayEventsReader::ProcessStream()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.ProcessStream"));

	UGameplayEventsReader_ProcessStream_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.ProcessStreamStart
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)

void UGameplayEventsReader::ProcessStreamStart()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.ProcessStreamStart"));

	UGameplayEventsReader_ProcessStreamStart_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.UnregisterHandler
// (Final, Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UGameplayEventsHandler*  ExistingHandler                (Parm)

void UGameplayEventsReader::UnregisterHandler(class UGameplayEventsHandler* ExistingHandler)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.UnregisterHandler"));

	UGameplayEventsReader_UnregisterHandler_Params params;
	params.ExistingHandler = ExistingHandler;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.RegisterHandler
// (Final, Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UGameplayEventsHandler*  NewHandler                     (Parm)

void UGameplayEventsReader::RegisterHandler(class UGameplayEventsHandler* NewHandler)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.RegisterHandler"));

	UGameplayEventsReader_RegisterHandler_Params params;
	params.NewHandler = NewHandler;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.SerializeHeader
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsReader::SerializeHeader()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.SerializeHeader"));

	UGameplayEventsReader_SerializeHeader_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsReader.CloseStatsFile
// (Final, Defined, Iterator, Latent, Net, Static)

void UGameplayEventsReader::STATIC_CloseStatsFile()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.CloseStatsFile"));

	UGameplayEventsReader_CloseStatsFile_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsReader.OpenStatsFile
// (Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsReader::STATIC_OpenStatsFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsReader.OpenStatsFile"));

	UGameplayEventsReader_OpenStatsFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriterBase.RecordCoverLinkFireLinks
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// class AController*             Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsWriterBase::RecordCoverLinkFireLinks(class ACoverLink* Link, class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.RecordCoverLinkFireLinks"));

	UGameplayEventsWriterBase_RecordCoverLinkFireLinks_Params params;
	params.Link = Link;
	params.Player = Player;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriterBase.RecordAIPathFail
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class AController*             AI                             (Parm)
// struct FString                 Reason                         (Parm, CoerceParm, NeedCtorLink)
// struct FVector                 Dest                           (Parm)

void UGameplayEventsWriterBase::RecordAIPathFail(class AController* AI, const struct FString& Reason, const struct FVector& Dest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.RecordAIPathFail"));

	UGameplayEventsWriterBase_RecordAIPathFail_Params params;
	params.AI = AI;
	params.Reason = Reason;
	params.Dest = Dest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogSystemPollEvents
// (Defined, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)

void UGameplayEventsWriterBase::STATIC_LogSystemPollEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogSystemPollEvents"));

	UGameplayEventsWriterBase_LogSystemPollEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogProjectileIntEvent
// (Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  Proj                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogProjectileIntEvent(int EventID, class AController* Player, class UClass* Proj, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogProjectileIntEvent"));

	UGameplayEventsWriterBase_LogProjectileIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Proj = Proj;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogDamageEvent
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Target                         (Parm)
// int                            Amount                         (Parm)

void UGameplayEventsWriterBase::STATIC_LogDamageEvent(int EventID, class AController* Player, class UClass* dmgType, class AController* Target, int Amount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogDamageEvent"));

	UGameplayEventsWriterBase_LogDamageEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.dmgType = dmgType;
	params.Target = Target;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogWeaponIntEvent
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  WeaponClass                    (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogWeaponIntEvent(int EventID, class AController* Player, class UClass* WeaponClass, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogWeaponIntEvent"));

	UGameplayEventsWriterBase_LogWeaponIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.WeaponClass = WeaponClass;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerPlayerEvent
// (Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class AController*             Target                         (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerPlayerEvent(int EventID, class AController* Player, class AController* Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerPlayerEvent"));

	UGameplayEventsWriterBase_LogPlayerPlayerEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerKillDeath
// (Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            KillType                       (Parm)
// class AController*             Killer                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Dead                           (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerKillDeath(int EventID, int KillType, class AController* Killer, class UClass* dmgType, class AController* Dead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerKillDeath"));

	UGameplayEventsWriterBase_LogPlayerKillDeath_Params params;
	params.EventID = EventID;
	params.KillType = KillType;
	params.Killer = Killer;
	params.dmgType = dmgType;
	params.Dead = Dead;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogAllPlayerPositionsEvent
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)

void UGameplayEventsWriterBase::STATIC_LogAllPlayerPositionsEvent(int EventID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogAllPlayerPositionsEvent"));

	UGameplayEventsWriterBase_LogAllPlayerPositionsEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerLoginChange
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bSplitScreen                   (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerLoginChange(int EventID, class AController* Player, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID, bool bSplitScreen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerLoginChange"));

	UGameplayEventsWriterBase_LogPlayerLoginChange_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;
	params.bSplitScreen = bSplitScreen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerSpawnEvent
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  PawnClass                      (Parm)
// int                            TeamID                         (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerSpawnEvent(int EventID, class AController* Player, class UClass* PawnClass, int TeamID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerSpawnEvent"));

	UGameplayEventsWriterBase_LogPlayerSpawnEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PawnClass = PawnClass;
	params.TeamID = TeamID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerStringEvent
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 EventString                    (Parm, NeedCtorLink)

void UGameplayEventsWriterBase::STATIC_LogPlayerStringEvent(int EventID, class AController* Player, const struct FString& EventString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerStringEvent"));

	UGameplayEventsWriterBase_LogPlayerStringEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.EventString = EventString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerFloatEvent
// (PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerFloatEvent(int EventID, class AController* Player, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerFloatEvent"));

	UGameplayEventsWriterBase_LogPlayerFloatEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogPlayerIntEvent
// (Final, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogPlayerIntEvent(int EventID, class AController* Player, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogPlayerIntEvent"));

	UGameplayEventsWriterBase_LogPlayerIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogTeamStringEvent
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsWriterBase::STATIC_LogTeamStringEvent(int EventID, class ATeamInfo* Team, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogTeamStringEvent"));

	UGameplayEventsWriterBase_LogTeamStringEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogTeamFloatEvent
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogTeamFloatEvent(int EventID, class ATeamInfo* Team, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogTeamFloatEvent"));

	UGameplayEventsWriterBase_LogTeamFloatEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogTeamIntEvent
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogTeamIntEvent(int EventID, class ATeamInfo* Team, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogTeamIntEvent"));

	UGameplayEventsWriterBase_LogTeamIntEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogGamePositionEvent
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FVector                 Position                       (Const, Parm, OutParm)
// float                          Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogGamePositionEvent(int EventID, float Value, struct FVector* Position)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogGamePositionEvent"));

	UGameplayEventsWriterBase_LogGamePositionEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Position != nullptr)
		*Position = params.Position;
}


// Function Engine.GameplayEventsWriterBase.LogGameFloatEvent
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogGameFloatEvent(int EventID, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogGameFloatEvent"));

	UGameplayEventsWriterBase_LogGameFloatEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogGameStringEvent
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsWriterBase::STATIC_LogGameStringEvent(int EventID, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogGameStringEvent"));

	UGameplayEventsWriterBase_LogGameStringEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.LogGameIntEvent
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriterBase::STATIC_LogGameIntEvent(int EventID, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.LogGameIntEvent"));

	UGameplayEventsWriterBase_LogGameIntEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.EndLogging
// (Defined, Iterator, Latent, Event, Static)

void UGameplayEventsWriterBase::STATIC_EndLogging()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.EndLogging"));

	UGameplayEventsWriterBase_EndLogging_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.ResetLogging
// (Defined, NetReliable, Native, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsWriterBase::ResetLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.ResetLogging"));

	UGameplayEventsWriterBase_ResetLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.StartLogging
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsWriterBase::StartLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.StartLogging"));

	UGameplayEventsWriterBase_StartLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.GetPlaylistId
// (Defined, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsWriterBase::GetPlaylistId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.GetPlaylistId"));

	UGameplayEventsWriterBase_GetPlaylistId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriterBase.GetGameTypeId
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsWriterBase::GetGameTypeId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.GetGameTypeId"));

	UGameplayEventsWriterBase_GetGameTypeId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriterBase.Poll
// (Iterator, PreOperator, Net, NetReliable, HasOptionalParms)

void UGameplayEventsWriterBase::Poll()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.Poll"));

	UGameplayEventsWriterBase_Poll_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.StopPolling
// (Final, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void UGameplayEventsWriterBase::StopPolling()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.StopPolling"));

	UGameplayEventsWriterBase_StopPolling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.StartPolling
// (Defined, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          HearbeatDelta                  (Parm)

void UGameplayEventsWriterBase::StartPolling(float HearbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.StartPolling"));

	UGameplayEventsWriterBase_StartPolling_Params params;
	params.HearbeatDelta = HearbeatDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriterBase.IsSessionInProgress
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsWriterBase::STATIC_IsSessionInProgress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriterBase.IsSessionInProgress"));

	UGameplayEventsWriterBase_IsSessionInProgress_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsUploadAnalytics.RecordCoverLinkFireLinks
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// class AController*             Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsUploadAnalytics::RecordCoverLinkFireLinks(class ACoverLink* Link, class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.RecordCoverLinkFireLinks"));

	UGameplayEventsUploadAnalytics_RecordCoverLinkFireLinks_Params params;
	params.Link = Link;
	params.Player = Player;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsUploadAnalytics.RecordAIPathFail
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class AController*             AI                             (Parm)
// struct FString                 Reason                         (Parm, CoerceParm, NeedCtorLink)
// struct FVector                 Dest                           (Parm)

void UGameplayEventsUploadAnalytics::RecordAIPathFail(class AController* AI, const struct FString& Reason, const struct FVector& Dest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.RecordAIPathFail"));

	UGameplayEventsUploadAnalytics_RecordAIPathFail_Params params;
	params.AI = AI;
	params.Reason = Reason;
	params.Dest = Dest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.GetGenericParamListEntry
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UGenericParamListStatEntry* ReturnValue                    (Parm, OutParm, ReturnParm)

class UGenericParamListStatEntry* UGameplayEventsUploadAnalytics::STATIC_GetGenericParamListEntry()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.GetGenericParamListEntry"));

	UGameplayEventsUploadAnalytics_GetGenericParamListEntry_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsUploadAnalytics.LogProjectileIntEvent
// (Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  Proj                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogProjectileIntEvent(int EventID, class AController* Player, class UClass* Proj, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogProjectileIntEvent"));

	UGameplayEventsUploadAnalytics_LogProjectileIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Proj = Proj;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogDamageEvent
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Target                         (Parm)
// int                            Amount                         (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogDamageEvent(int EventID, class AController* Player, class UClass* dmgType, class AController* Target, int Amount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogDamageEvent"));

	UGameplayEventsUploadAnalytics_LogDamageEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.dmgType = dmgType;
	params.Target = Target;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogWeaponIntEvent
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  WeaponClass                    (Parm)
// int                            Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogWeaponIntEvent(int EventID, class AController* Player, class UClass* WeaponClass, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogWeaponIntEvent"));

	UGameplayEventsUploadAnalytics_LogWeaponIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.WeaponClass = WeaponClass;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerPlayerEvent
// (Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class AController*             Target                         (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerPlayerEvent(int EventID, class AController* Player, class AController* Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerPlayerEvent"));

	UGameplayEventsUploadAnalytics_LogPlayerPlayerEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerKillDeath
// (Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            KillType                       (Parm)
// class AController*             Killer                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Dead                           (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerKillDeath(int EventID, int KillType, class AController* Killer, class UClass* dmgType, class AController* Dead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerKillDeath"));

	UGameplayEventsUploadAnalytics_LogPlayerKillDeath_Params params;
	params.EventID = EventID;
	params.KillType = KillType;
	params.Killer = Killer;
	params.dmgType = dmgType;
	params.Dead = Dead;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogAllPlayerPositionsEvent
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogAllPlayerPositionsEvent(int EventID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogAllPlayerPositionsEvent"));

	UGameplayEventsUploadAnalytics_LogAllPlayerPositionsEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerLoginChange
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bSplitScreen                   (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerLoginChange(int EventID, class AController* Player, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID, bool bSplitScreen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerLoginChange"));

	UGameplayEventsUploadAnalytics_LogPlayerLoginChange_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;
	params.bSplitScreen = bSplitScreen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerSpawnEvent
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  PawnClass                      (Parm)
// int                            TeamID                         (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerSpawnEvent(int EventID, class AController* Player, class UClass* PawnClass, int TeamID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerSpawnEvent"));

	UGameplayEventsUploadAnalytics_LogPlayerSpawnEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PawnClass = PawnClass;
	params.TeamID = TeamID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerStringEvent
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 EventString                    (Parm, NeedCtorLink)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerStringEvent(int EventID, class AController* Player, const struct FString& EventString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerStringEvent"));

	UGameplayEventsUploadAnalytics_LogPlayerStringEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.EventString = EventString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerFloatEvent
// (PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// float                          Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerFloatEvent(int EventID, class AController* Player, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerFloatEvent"));

	UGameplayEventsUploadAnalytics_LogPlayerFloatEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogPlayerIntEvent
// (Final, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// int                            Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogPlayerIntEvent(int EventID, class AController* Player, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogPlayerIntEvent"));

	UGameplayEventsUploadAnalytics_LogPlayerIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogTeamStringEvent
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsUploadAnalytics::STATIC_LogTeamStringEvent(int EventID, class ATeamInfo* Team, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogTeamStringEvent"));

	UGameplayEventsUploadAnalytics_LogTeamStringEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogTeamFloatEvent
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// float                          Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogTeamFloatEvent(int EventID, class ATeamInfo* Team, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogTeamFloatEvent"));

	UGameplayEventsUploadAnalytics_LogTeamFloatEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogTeamIntEvent
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogTeamIntEvent(int EventID, class ATeamInfo* Team, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogTeamIntEvent"));

	UGameplayEventsUploadAnalytics_LogTeamIntEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogGamePositionEvent
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FVector                 Position                       (Const, Parm, OutParm)
// float                          Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogGamePositionEvent(int EventID, float Value, struct FVector* Position)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogGamePositionEvent"));

	UGameplayEventsUploadAnalytics_LogGamePositionEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Position != nullptr)
		*Position = params.Position;
}


// Function Engine.GameplayEventsUploadAnalytics.LogGameFloatEvent
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// float                          Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogGameFloatEvent(int EventID, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogGameFloatEvent"));

	UGameplayEventsUploadAnalytics_LogGameFloatEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogGameStringEvent
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsUploadAnalytics::STATIC_LogGameStringEvent(int EventID, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogGameStringEvent"));

	UGameplayEventsUploadAnalytics_LogGameStringEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.LogGameIntEvent
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            Value                          (Parm)

void UGameplayEventsUploadAnalytics::STATIC_LogGameIntEvent(int EventID, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.LogGameIntEvent"));

	UGameplayEventsUploadAnalytics_LogGameIntEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.EndLogging
// (Defined, Iterator, Latent, Event, Static)

void UGameplayEventsUploadAnalytics::STATIC_EndLogging()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.EndLogging"));

	UGameplayEventsUploadAnalytics_EndLogging_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.ResetLogging
// (Defined, NetReliable, Native, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsUploadAnalytics::ResetLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.ResetLogging"));

	UGameplayEventsUploadAnalytics_ResetLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsUploadAnalytics.StartLogging
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsUploadAnalytics::StartLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsUploadAnalytics.StartLogging"));

	UGameplayEventsUploadAnalytics_StartLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.RecordCoverLinkFireLinks
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// class AController*             Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsWriter::RecordCoverLinkFireLinks(class ACoverLink* Link, class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.RecordCoverLinkFireLinks"));

	UGameplayEventsWriter_RecordCoverLinkFireLinks_Params params;
	params.Link = Link;
	params.Player = Player;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriter.RecordAIPathFail
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class AController*             AI                             (Parm)
// struct FString                 Reason                         (Parm, CoerceParm, NeedCtorLink)
// struct FVector                 Dest                           (Parm)

void UGameplayEventsWriter::RecordAIPathFail(class AController* AI, const struct FString& Reason, const struct FVector& Dest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.RecordAIPathFail"));

	UGameplayEventsWriter_RecordAIPathFail_Params params;
	params.AI = AI;
	params.Reason = Reason;
	params.Dest = Dest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.GetGenericParamListEntry
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UGenericParamListStatEntry* ReturnValue                    (Parm, OutParm, ReturnParm)

class UGenericParamListStatEntry* UGameplayEventsWriter::STATIC_GetGenericParamListEntry()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.GetGenericParamListEntry"));

	UGameplayEventsWriter_GetGenericParamListEntry_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriter.LogSystemPollEvents
// (Defined, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)

void UGameplayEventsWriter::STATIC_LogSystemPollEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogSystemPollEvents"));

	UGameplayEventsWriter_LogSystemPollEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogProjectileIntEvent
// (Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  Proj                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogProjectileIntEvent(int EventID, class AController* Player, class UClass* Proj, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogProjectileIntEvent"));

	UGameplayEventsWriter_LogProjectileIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Proj = Proj;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogDamageEvent
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Target                         (Parm)
// int                            Amount                         (Parm)

void UGameplayEventsWriter::STATIC_LogDamageEvent(int EventID, class AController* Player, class UClass* dmgType, class AController* Target, int Amount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogDamageEvent"));

	UGameplayEventsWriter_LogDamageEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.dmgType = dmgType;
	params.Target = Target;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogWeaponIntEvent
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  WeaponClass                    (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogWeaponIntEvent(int EventID, class AController* Player, class UClass* WeaponClass, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogWeaponIntEvent"));

	UGameplayEventsWriter_LogWeaponIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.WeaponClass = WeaponClass;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerPlayerEvent
// (Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class AController*             Target                         (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerPlayerEvent(int EventID, class AController* Player, class AController* Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerPlayerEvent"));

	UGameplayEventsWriter_LogPlayerPlayerEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerKillDeath
// (Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            KillType                       (Parm)
// class AController*             Killer                         (Parm)
// class UClass*                  dmgType                        (Parm)
// class AController*             Dead                           (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerKillDeath(int EventID, int KillType, class AController* Killer, class UClass* dmgType, class AController* Dead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerKillDeath"));

	UGameplayEventsWriter_LogPlayerKillDeath_Params params;
	params.EventID = EventID;
	params.KillType = KillType;
	params.Killer = Killer;
	params.dmgType = dmgType;
	params.Dead = Dead;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogAllPlayerPositionsEvent
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)

void UGameplayEventsWriter::STATIC_LogAllPlayerPositionsEvent(int EventID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogAllPlayerPositionsEvent"));

	UGameplayEventsWriter_LogAllPlayerPositionsEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerLoginChange
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bSplitScreen                   (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerLoginChange(int EventID, class AController* Player, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID, bool bSplitScreen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerLoginChange"));

	UGameplayEventsWriter_LogPlayerLoginChange_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;
	params.bSplitScreen = bSplitScreen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerSpawnEvent
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// class UClass*                  PawnClass                      (Parm)
// int                            TeamID                         (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerSpawnEvent(int EventID, class AController* Player, class UClass* PawnClass, int TeamID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerSpawnEvent"));

	UGameplayEventsWriter_LogPlayerSpawnEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.PawnClass = PawnClass;
	params.TeamID = TeamID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerStringEvent
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// struct FString                 EventString                    (Parm, NeedCtorLink)

void UGameplayEventsWriter::STATIC_LogPlayerStringEvent(int EventID, class AController* Player, const struct FString& EventString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerStringEvent"));

	UGameplayEventsWriter_LogPlayerStringEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.EventString = EventString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerFloatEvent
// (PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerFloatEvent(int EventID, class AController* Player, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerFloatEvent"));

	UGameplayEventsWriter_LogPlayerFloatEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogPlayerIntEvent
// (Final, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class AController*             Player                         (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogPlayerIntEvent(int EventID, class AController* Player, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogPlayerIntEvent"));

	UGameplayEventsWriter_LogPlayerIntEvent_Params params;
	params.EventID = EventID;
	params.Player = Player;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogTeamStringEvent
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsWriter::STATIC_LogTeamStringEvent(int EventID, class ATeamInfo* Team, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogTeamStringEvent"));

	UGameplayEventsWriter_LogTeamStringEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogTeamFloatEvent
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogTeamFloatEvent(int EventID, class ATeamInfo* Team, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogTeamFloatEvent"));

	UGameplayEventsWriter_LogTeamFloatEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogTeamIntEvent
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// class ATeamInfo*               Team                           (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogTeamIntEvent(int EventID, class ATeamInfo* Team, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogTeamIntEvent"));

	UGameplayEventsWriter_LogTeamIntEvent_Params params;
	params.EventID = EventID;
	params.Team = Team;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogGamePositionEvent
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FVector                 Position                       (Const, Parm, OutParm)
// float                          Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogGamePositionEvent(int EventID, float Value, struct FVector* Position)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogGamePositionEvent"));

	UGameplayEventsWriter_LogGamePositionEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Position != nullptr)
		*Position = params.Position;
}


// Function Engine.GameplayEventsWriter.LogGameFloatEvent
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// float                          Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogGameFloatEvent(int EventID, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogGameFloatEvent"));

	UGameplayEventsWriter_LogGameFloatEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogGameStringEvent
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UGameplayEventsWriter::STATIC_LogGameStringEvent(int EventID, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogGameStringEvent"));

	UGameplayEventsWriter_LogGameStringEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.LogGameIntEvent
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Operator, Static)
// Parameters:
// int                            EventID                        (Parm)
// int                            Value                          (Parm)

void UGameplayEventsWriter::STATIC_LogGameIntEvent(int EventID, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.LogGameIntEvent"));

	UGameplayEventsWriter_LogGameIntEvent_Params params;
	params.EventID = EventID;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.EndLogging
// (Defined, Iterator, Latent, Event, Static)

void UGameplayEventsWriter::STATIC_EndLogging()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.EndLogging"));

	UGameplayEventsWriter_EndLogging_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.ResetLogging
// (Defined, NetReliable, Native, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsWriter::ResetLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.ResetLogging"));

	UGameplayEventsWriter_ResetLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.StartLogging
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// float                          HeartbeatDelta                 (OptionalParm, Parm)

void UGameplayEventsWriter::StartLogging(float HeartbeatDelta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.StartLogging"));

	UGameplayEventsWriter_StartLogging_Params params;
	params.HeartbeatDelta = HeartbeatDelta;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.SerializeFooter
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsWriter::SerializeFooter()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.SerializeFooter"));

	UGameplayEventsWriter_SerializeFooter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriter.SerializeHeader
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsWriter::SerializeHeader()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.SerializeHeader"));

	UGameplayEventsWriter_SerializeHeader_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriter.CloseStatsFile
// (Final, Defined, Iterator, Latent, Net, Static)

void UGameplayEventsWriter::STATIC_CloseStatsFile()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.CloseStatsFile"));

	UGameplayEventsWriter_CloseStatsFile_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsWriter.OpenStatsFile
// (Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameplayEventsWriter::STATIC_OpenStatsFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.OpenStatsFile"));

	UGameplayEventsWriter_OpenStatsFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsWriter.ResolvePlayerIndex
// (Final, Defined, Iterator, Latent, NetReliable, Native, HasOptionalParms)
// Parameters:
// class AController*             Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameplayEventsWriter::ResolvePlayerIndex(class AController* Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsWriter.ResolvePlayerIndex"));

	UGameplayEventsWriter_ResolvePlayerIndex_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayEventsHandler.RemoveFilter
// (Final, PreOperator, Native, HasOptionalParms)
// Parameters:
// int                            EventID                        (Parm)

void UGameplayEventsHandler::RemoveFilter(int EventID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.RemoveFilter"));

	UGameplayEventsHandler_RemoveFilter_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsHandler.AddFilter
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// int                            EventID                        (Parm)

void UGameplayEventsHandler::AddFilter(int EventID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.AddFilter"));

	UGameplayEventsHandler_AddFilter_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsHandler.ResolveGroupFilters
// (Final, Iterator, NetReliable, Exec, Native, HasOptionalParms)

void UGameplayEventsHandler::ResolveGroupFilters()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.ResolveGroupFilters"));

	UGameplayEventsHandler_ResolveGroupFilters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsHandler.PostProcessStream
// (Defined, Iterator, Latent, Net, Exec, Native, HasOptionalParms)

void UGameplayEventsHandler::PostProcessStream()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.PostProcessStream"));

	UGameplayEventsHandler_PostProcessStream_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsHandler.PreProcessStream
// (Final, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)

void UGameplayEventsHandler::PreProcessStream()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.PreProcessStream"));

	UGameplayEventsHandler_PreProcessStream_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayEventsHandler.SetReader
// (Final, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// class UGameplayEventsReader*   NewReader                      (Parm)

void UGameplayEventsHandler::SetReader(class UGameplayEventsReader* NewReader)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameplayEventsHandler.SetReader"));

	UGameplayEventsHandler_SetReader_Params params;
	params.NewReader = NewReader;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GenericParamListStatEntry.CommitToDisk
// (Defined, Iterator, Simulated, Static)

void UGenericParamListStatEntry::STATIC_CommitToDisk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.CommitToDisk"));

	UGenericParamListStatEntry_CommitToDisk_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GenericParamListStatEntry.GetString
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParamName                      (Parm)
// struct FString                 out_string                     (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGenericParamListStatEntry::STATIC_GetString(const struct FName& ParamName, struct FString* out_string)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.GetString"));

	UGenericParamListStatEntry_GetString_Params params;
	params.ParamName = ParamName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_string != nullptr)
		*out_string = params.out_string;

	return params.ReturnValue;
}


// Function Engine.GenericParamListStatEntry.GetVector
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParamName                      (Parm)
// struct FVector                 out_vector                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGenericParamListStatEntry::STATIC_GetVector(const struct FName& ParamName, struct FVector* out_vector)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.GetVector"));

	UGenericParamListStatEntry_GetVector_Params params;
	params.ParamName = ParamName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_vector != nullptr)
		*out_vector = params.out_vector;

	return params.ReturnValue;
}


// Function Engine.GenericParamListStatEntry.GetInt
// (Final, Defined, Latent, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParamName                      (Parm)
// int                            out_int                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGenericParamListStatEntry::STATIC_GetInt(const struct FName& ParamName, int* out_int)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.GetInt"));

	UGenericParamListStatEntry_GetInt_Params params;
	params.ParamName = ParamName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_int != nullptr)
		*out_int = params.out_int;

	return params.ReturnValue;
}


// Function Engine.GenericParamListStatEntry.GetFloat
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   ParamName                      (Parm)
// float                          out_Float                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGenericParamListStatEntry::STATIC_GetFloat(const struct FName& ParamName, float* out_Float)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.GetFloat"));

	UGenericParamListStatEntry_GetFloat_Params params;
	params.ParamName = ParamName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Float != nullptr)
		*out_Float = params.out_Float;

	return params.ReturnValue;
}


// Function Engine.GenericParamListStatEntry.AddString
// (PreOperator, Singular, Operator)
// Parameters:
// struct FName                   ParamName                      (Parm)
// struct FString                 Value                          (Parm, CoerceParm, NeedCtorLink)

void UGenericParamListStatEntry::AddString(const struct FName& ParamName, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.AddString"));

	UGenericParamListStatEntry_AddString_Params params;
	params.ParamName = ParamName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GenericParamListStatEntry.AddVector
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FName                   ParamName                      (Parm)
// struct FVector                 Value                          (Parm)

void UGenericParamListStatEntry::AddVector(const struct FName& ParamName, const struct FVector& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.AddVector"));

	UGenericParamListStatEntry_AddVector_Params params;
	params.ParamName = ParamName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GenericParamListStatEntry.AddInt
// (Final, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FName                   ParamName                      (Parm)
// int                            Value                          (Parm)

void UGenericParamListStatEntry::AddInt(const struct FName& ParamName, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.AddInt"));

	UGenericParamListStatEntry_AddInt_Params params;
	params.ParamName = ParamName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GenericParamListStatEntry.AddFloat
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FName                   ParamName                      (Parm)
// float                          Value                          (Parm)

void UGenericParamListStatEntry::AddFloat(const struct FName& ParamName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GenericParamListStatEntry.AddFloat"));

	UGenericParamListStatEntry_AddFloat_Params params;
	params.ParamName = ParamName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HttpBaseInterface.GetContent
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TArray<unsigned char>          Content                        (Parm, OutParm, NeedCtorLink)

void UHttpBaseInterface::STATIC_GetContent(TArray<unsigned char>* Content)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetContent"));

	UHttpBaseInterface_GetContent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Content != nullptr)
		*Content = params.Content;
}


// Function Engine.HttpBaseInterface.GetURL
// (Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpBaseInterface::STATIC_GetURL()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetURL"));

	UHttpBaseInterface_GetURL_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpBaseInterface.GetContentLength
// (Final, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UHttpBaseInterface::STATIC_GetContentLength()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetContentLength"));

	UHttpBaseInterface_GetContentLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpBaseInterface.GetContentType
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpBaseInterface::STATIC_GetContentType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetContentType"));

	UHttpBaseInterface_GetContentType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpBaseInterface.GetURLParameter
// (PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ParameterName                  (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpBaseInterface::STATIC_GetURLParameter(const struct FString& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetURLParameter"));

	UHttpBaseInterface_GetURLParameter_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpBaseInterface.GetHeaders
// (Final, Defined, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<struct FString> UHttpBaseInterface::STATIC_GetHeaders()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetHeaders"));

	UHttpBaseInterface_GetHeaders_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpBaseInterface.GetHeader
// (Defined, Exec, Native, Event, Static)
// Parameters:
// struct FString                 HeaderName                     (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpBaseInterface::STATIC_GetHeader(const struct FString& HeaderName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpBaseInterface.GetHeader"));

	UHttpBaseInterface_GetHeader_Params params;
	params.HeaderName = HeaderName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetProcessRequestCompleteDelegate
// (Final, Defined, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// struct FScriptDelegate         ProcessRequestCompleteDelegate (Parm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetProcessRequestCompleteDelegate(const struct FScriptDelegate& ProcessRequestCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetProcessRequestCompleteDelegate"));

	UHttpRequestInterface_SetProcessRequestCompleteDelegate_Params params;
	params.ProcessRequestCompleteDelegate = ProcessRequestCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.OnProcessRequestComplete
// (Final, Defined, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// class UHttpRequestInterface*   OriginalRequest                (Parm)
// class UHttpResponseInterface*  InHttpResponse                 (Parm)
// bool                           bDidSucceed                    (Parm)

void UHttpRequestInterface::OnProcessRequestComplete(class UHttpRequestInterface* OriginalRequest, class UHttpResponseInterface* InHttpResponse, bool bDidSucceed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.OnProcessRequestComplete"));

	UHttpRequestInterface_OnProcessRequestComplete_Params params;
	params.OriginalRequest = OriginalRequest;
	params.InHttpResponse = InHttpResponse;
	params.bDidSucceed = bDidSucceed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HttpRequestInterface.ProcessRequest
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHttpRequestInterface::ProcessRequest()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.ProcessRequest"));

	UHttpRequestInterface_ProcessRequest_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetHeader
// (Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 HeaderName                     (Parm, NeedCtorLink)
// struct FString                 HeaderValue                    (Parm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetHeader(const struct FString& HeaderName, const struct FString& HeaderValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetHeader"));

	UHttpRequestInterface_SetHeader_Params params;
	params.HeaderName = HeaderName;
	params.HeaderValue = HeaderValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetContentAsString
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 ContentString                  (Parm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetContentAsString(const struct FString& ContentString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetContentAsString"));

	UHttpRequestInterface_SetContentAsString_Params params;
	params.ContentString = ContentString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetContent
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          ContentPayload                 (Const, Parm, OutParm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetContent(TArray<unsigned char>* ContentPayload)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetContent"));

	UHttpRequestInterface_SetContent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ContentPayload != nullptr)
		*ContentPayload = params.ContentPayload;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetURL
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetURL(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetURL"));

	UHttpRequestInterface_SetURL_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.SetVerb
// (Final, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FString                 Verb                           (Parm, NeedCtorLink)
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpRequestInterface::SetVerb(const struct FString& Verb)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.SetVerb"));

	UHttpRequestInterface_SetVerb_Params params;
	params.Verb = Verb;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpRequestInterface.GetVerb
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpRequestInterface::STATIC_GetVerb()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpRequestInterface.GetVerb"));

	UHttpRequestInterface_GetVerb_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpResponseInterface.GetContentAsString
// (Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UHttpResponseInterface::STATIC_GetContentAsString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpResponseInterface.GetContentAsString"));

	UHttpResponseInterface_GetContentAsString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HttpResponseInterface.GetResponseCode
// (Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UHttpResponseInterface::STATIC_GetResponseCode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpResponseInterface.GetResponseCode"));

	UHttpResponseInterface_GetResponseCode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.IniLocPatcher.UpdateLocFileName
// (Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UIniLocPatcher::UpdateLocFileName(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.UpdateLocFileName"));

	UIniLocPatcher_UpdateLocFileName_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.IniLocPatcher.ClearCachedFiles
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void UIniLocPatcher::ClearCachedFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.ClearCachedFiles"));

	UIniLocPatcher_ClearCachedFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.ClearReadFileDelegate
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadTitleFileCompleteDelegate  (Parm, NeedCtorLink)

void UIniLocPatcher::ClearReadFileDelegate(const struct FScriptDelegate& ReadTitleFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.ClearReadFileDelegate"));

	UIniLocPatcher_ClearReadFileDelegate_Params params;
	params.ReadTitleFileCompleteDelegate = ReadTitleFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.AddReadFileDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ReadTitleFileCompleteDelegate  (Parm, NeedCtorLink)

void UIniLocPatcher::AddReadFileDelegate(const struct FScriptDelegate& ReadTitleFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.AddReadFileDelegate"));

	UIniLocPatcher_AddReadFileDelegate_Params params;
	params.ReadTitleFileCompleteDelegate = ReadTitleFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.AddFileToDownload
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::AddFileToDownload(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.AddFileToDownload"));

	UIniLocPatcher_AddFileToDownload_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.ProcessIniLocFile
// (Iterator, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           bIsUnicode                     (Parm)
// TArray<unsigned char>          FileData                       (Const, Parm, OutParm, NeedCtorLink)

void UIniLocPatcher::ProcessIniLocFile(const struct FString& Filename, bool bIsUnicode, TArray<unsigned char>* FileData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.ProcessIniLocFile"));

	UIniLocPatcher_ProcessIniLocFile_Params params;
	params.Filename = Filename;
	params.bIsUnicode = bIsUnicode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileData != nullptr)
		*FileData = params.FileData;
}


// Function Engine.IniLocPatcher.CheckForAllFilesComplete
// (Final, Defined, Latent, Net, NetReliable, Exec, Native, Event, Operator)

void UIniLocPatcher::CheckForAllFilesComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.CheckForAllFilesComplete"));

	UIniLocPatcher_CheckForAllFilesComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.TriggerDownloadCompleteDelegates
// (Iterator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bSuccess                       (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::TriggerDownloadCompleteDelegates(bool bSuccess, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.TriggerDownloadCompleteDelegates"));

	UIniLocPatcher_TriggerDownloadCompleteDelegates_Params params;
	params.bSuccess = bSuccess;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnFileCacheSaveComplete
// (Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::STATIC_OnFileCacheSaveComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnFileCacheSaveComplete"));

	UIniLocPatcher_OnFileCacheSaveComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnFileCacheLoadComplete
// (Final, Defined, Iterator, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::STATIC_OnFileCacheLoadComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnFileCacheLoadComplete"));

	UIniLocPatcher_OnFileCacheLoadComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnDownloadFileComplete
// (Final, Defined, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::STATIC_OnDownloadFileComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnDownloadFileComplete"));

	UIniLocPatcher_OnDownloadFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.StartLoadingFiles
// (Final, Iterator, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)

void UIniLocPatcher::StartLoadingFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.StartLoadingFiles"));

	UIniLocPatcher_StartLoadingFiles_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnRequestTitleFileListComplete
// (Final, Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TArray<struct FString>         FilePaths                      (Parm, NeedCtorLink)

void UIniLocPatcher::OnRequestTitleFileListComplete(bool bWasSuccessful, TArray<struct FString> FilePaths)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnRequestTitleFileListComplete"));

	UIniLocPatcher_OnRequestTitleFileListComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.FilePaths = FilePaths;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.DownloadFiles
// (Final, Iterator, PreOperator, Exec, Native, Static)

void UIniLocPatcher::STATIC_DownloadFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.DownloadFiles"));

	UIniLocPatcher_DownloadFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UIniLocPatcher::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.Init"));

	UIniLocPatcher_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnAllTitleFilesCompleted
// (Final, Defined, Exec, Native, HasOptionalParms)

void UIniLocPatcher::OnAllTitleFilesCompleted()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnAllTitleFilesCompleted"));

	UIniLocPatcher_OnAllTitleFilesCompleted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.IniLocPatcher.OnReadTitleFileComplete
// (Iterator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UIniLocPatcher::STATIC_OnReadTitleFileComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.IniLocPatcher.OnReadTitleFileComplete"));

	UIniLocPatcher_OnReadTitleFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interface_NavigationHandle.NotifyPathChanged
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UInterface_NavigationHandle::NotifyPathChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interface_NavigationHandle.NotifyPathChanged"));

	UInterface_NavigationHandle_NotifyPathChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interface_Speaker.Speak
// (Final, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               Cue                            (Parm)

void UInterface_Speaker::Speak(class USoundCue* Cue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interface_Speaker.Speak"));

	UInterface_Speaker_Speak_Params params;
	params.Cue = Cue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.DecodeJson
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, Static)
// Parameters:
// struct FString                 Str                            (Const, Parm, NeedCtorLink)
// class UJsonObject*             ReturnValue                    (Parm, OutParm, ReturnParm)

class UJsonObject* UJsonObject::STATIC_DecodeJson(const struct FString& Str)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.DecodeJson"));

	UJsonObject_DecodeJson_Params params;
	params.Str = Str;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.EncodeJson
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// class UJsonObject*             Root                           (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UJsonObject::STATIC_EncodeJson(class UJsonObject* Root)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.EncodeJson"));

	UJsonObject_EncodeJson_Params params;
	params.Root = Root;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.SetBoolValue
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// bool                           Value                          (Parm)

void UJsonObject::SetBoolValue(const struct FString& Key, bool Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.SetBoolValue"));

	UJsonObject_SetBoolValue_Params params;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.SetFloatValue
// (Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// float                          Value                          (Parm)

void UJsonObject::SetFloatValue(const struct FString& Key, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.SetFloatValue"));

	UJsonObject_SetFloatValue_Params params;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.SetIntValue
// (Defined, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// int                            Value                          (Parm)

void UJsonObject::SetIntValue(const struct FString& Key, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.SetIntValue"));

	UJsonObject_SetIntValue_Params params;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.SetStringValue
// (Defined, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// struct FString                 Value                          (Const, Parm, NeedCtorLink)

void UJsonObject::SetStringValue(const struct FString& Key, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.SetStringValue"));

	UJsonObject_SetStringValue_Params params;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.SetObject
// (Final, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// class UJsonObject*             Object                         (Parm)

void UJsonObject::SetObject(const struct FString& Key, class UJsonObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.SetObject"));

	UJsonObject_SetObject_Params params;
	params.Key = Key;
	params.Object = Object;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.JsonObject.GetBoolValue
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UJsonObject::STATIC_GetBoolValue(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.GetBoolValue"));

	UJsonObject_GetBoolValue_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.GetFloatValue
// (Final, Iterator, Latent, NetReliable, Native, Event)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UJsonObject::GetFloatValue(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.GetFloatValue"));

	UJsonObject_GetFloatValue_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.GetIntValue
// (PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UJsonObject::STATIC_GetIntValue(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.GetIntValue"));

	UJsonObject_GetIntValue_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.HasKey
// (Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UJsonObject::STATIC_HasKey(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.HasKey"));

	UJsonObject_HasKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.GetStringValue
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UJsonObject::STATIC_GetStringValue(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.GetStringValue"));

	UJsonObject_GetStringValue_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.JsonObject.GetObject
// (Final, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Key                            (Const, Parm, NeedCtorLink)
// class UJsonObject*             ReturnValue                    (Parm, OutParm, ReturnParm)

class UJsonObject* UJsonObject::STATIC_GetObject(const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.JsonObject.GetObject"));

	UJsonObject_GetObject_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.GetServerAddr
// (PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FIpAddr                 OutServerIP                    (Parm, OutParm)
// int                            OutServerPort                  (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_GetServerAddr(struct FIpAddr* OutServerIP, int* OutServerPort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.GetServerAddr"));

	UOnlineAuthInterface_GetServerAddr_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutServerIP != nullptr)
		*OutServerIP = params.OutServerIP;
	if (OutServerPort != nullptr)
		*OutServerPort = params.OutServerPort;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.GetServerUniqueId
// (Final, Defined, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            OutServerUID                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_GetServerUniqueId(struct FUniqueNetId* OutServerUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.GetServerUniqueId"));

	UOnlineAuthInterface_GetServerUniqueId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutServerUID != nullptr)
		*OutServerUID = params.OutServerUID;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.FindLocalServerAuthSession
// (Final, Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// struct FLocalAuthSession       OutSessionInfo                 (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_FindLocalServerAuthSession(class UPlayer* ClientConnection, struct FLocalAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.FindLocalServerAuthSession"));

	UOnlineAuthInterface_FindLocalServerAuthSession_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.FindServerAuthSession
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)
// struct FAuthSession            OutSessionInfo                 (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_FindServerAuthSession(class UPlayer* ServerConnection, struct FAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.FindServerAuthSession"));

	UOnlineAuthInterface_FindServerAuthSession_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.FindLocalClientAuthSession
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)
// struct FLocalAuthSession       OutSessionInfo                 (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_FindLocalClientAuthSession(class UPlayer* ServerConnection, struct FLocalAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.FindLocalClientAuthSession"));

	UOnlineAuthInterface_FindLocalClientAuthSession_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.FindClientAuthSession
// (Defined, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// struct FAuthSession            OutSessionInfo                 (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_FindClientAuthSession(class UPlayer* ClientConnection, struct FAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.FindClientAuthSession"));

	UOnlineAuthInterface_FindClientAuthSession_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.AllLocalServerAuthSessions
// (Final, Iterator, Singular, NetReliable, Operator)
// Parameters:
// struct FLocalAuthSession       OutSessionInfo                 (Parm, OutParm)

void UOnlineAuthInterface::AllLocalServerAuthSessions(struct FLocalAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AllLocalServerAuthSessions"));

	UOnlineAuthInterface_AllLocalServerAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;
}


// Function Engine.OnlineAuthInterface.AllServerAuthSessions
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// struct FAuthSession            OutSessionInfo                 (Parm, OutParm)

void UOnlineAuthInterface::AllServerAuthSessions(struct FAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AllServerAuthSessions"));

	UOnlineAuthInterface_AllServerAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;
}


// Function Engine.OnlineAuthInterface.AllLocalClientAuthSessions
// (Iterator, Singular, NetReliable, Operator)
// Parameters:
// struct FLocalAuthSession       OutSessionInfo                 (Parm, OutParm)

void UOnlineAuthInterface::AllLocalClientAuthSessions(struct FLocalAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AllLocalClientAuthSessions"));

	UOnlineAuthInterface_AllLocalClientAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;
}


// Function Engine.OnlineAuthInterface.AllClientAuthSessions
// (Final, Iterator, Latent, PreOperator, NetReliable, Operator)
// Parameters:
// struct FAuthSession            OutSessionInfo                 (Parm, OutParm)

void UOnlineAuthInterface::AllClientAuthSessions(struct FAuthSession* OutSessionInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AllClientAuthSessions"));

	UOnlineAuthInterface_AllClientAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSessionInfo != nullptr)
		*OutSessionInfo = params.OutSessionInfo;
}


// Function Engine.OnlineAuthInterface.EndAllRemoteServerAuthSessions
// (Defined, Event, Static)

void UOnlineAuthInterface::STATIC_EndAllRemoteServerAuthSessions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndAllRemoteServerAuthSessions"));

	UOnlineAuthInterface_EndAllRemoteServerAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndAllLocalServerAuthSessions
// (Event, Static)

void UOnlineAuthInterface::STATIC_EndAllLocalServerAuthSessions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndAllLocalServerAuthSessions"));

	UOnlineAuthInterface_EndAllLocalServerAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndRemoteServerAuthSession
// (Defined, Iterator, Latent, PreOperator, Event, Static)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)

void UOnlineAuthInterface::STATIC_EndRemoteServerAuthSession(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndRemoteServerAuthSession"));

	UOnlineAuthInterface_EndRemoteServerAuthSession_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndLocalServerAuthSession
// (Final, Iterator, Latent, Event, Static)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)

void UOnlineAuthInterface::STATIC_EndLocalServerAuthSession(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndLocalServerAuthSession"));

	UOnlineAuthInterface_EndLocalServerAuthSession_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.VerifyServerAuthSession
// (Final, PreOperator, Singular, Operator, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            AuthTicketUID                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::VerifyServerAuthSession(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.VerifyServerAuthSession"));

	UOnlineAuthInterface_VerifyServerAuthSession_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.CreateServerAuthSession
// (Defined, Iterator, PreOperator, Exec, Static)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            ClientPort                     (Parm)
// int                            OutAuthTicketUID               (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_CreateServerAuthSession(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int ClientPort, int* OutAuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.CreateServerAuthSession"));

	UOnlineAuthInterface_CreateServerAuthSession_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.ClientPort = ClientPort;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAuthTicketUID != nullptr)
		*OutAuthTicketUID = params.OutAuthTicketUID;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.EndAllRemoteClientAuthSessions
// (Final, Event, Static)

void UOnlineAuthInterface::STATIC_EndAllRemoteClientAuthSessions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndAllRemoteClientAuthSessions"));

	UOnlineAuthInterface_EndAllRemoteClientAuthSessions_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndAllLocalClientAuthSessions
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void UOnlineAuthInterface::STATIC_EndAllLocalClientAuthSessions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndAllLocalClientAuthSessions"));

	UOnlineAuthInterface_EndAllLocalClientAuthSessions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndRemoteClientAuthSession
// (Final, Iterator, Latent, PreOperator, Event, Static)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)

void UOnlineAuthInterface::STATIC_EndRemoteClientAuthSession(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndRemoteClientAuthSession"));

	UOnlineAuthInterface_EndRemoteClientAuthSession_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.EndLocalClientAuthSession
// (Iterator, Latent, Event, Static)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            ServerPort                     (Parm)

void UOnlineAuthInterface::STATIC_EndLocalClientAuthSession(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int ServerPort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.EndLocalClientAuthSession"));

	UOnlineAuthInterface_EndLocalClientAuthSession_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.ServerPort = ServerPort;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.VerifyClientAuthSession
// (Final, Iterator, Latent, Singular, Operator, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            ClientPort                     (Parm)
// int                            AuthTicketUID                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::VerifyClientAuthSession(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int ClientPort, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.VerifyClientAuthSession"));

	UOnlineAuthInterface_VerifyClientAuthSession_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.ClientPort = ClientPort;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.CreateClientAuthSession
// (Final, Defined, Exec, Static)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            ServerPort                     (Parm)
// bool                           bSecure                        (Parm)
// int                            OutAuthTicketUID               (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_CreateClientAuthSession(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int ServerPort, bool bSecure, int* OutAuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.CreateClientAuthSession"));

	UOnlineAuthInterface_CreateClientAuthSession_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.ServerPort = ServerPort;
	params.bSecure = bSecure;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAuthTicketUID != nullptr)
		*OutAuthTicketUID = params.OutAuthTicketUID;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendServerAuthRetryRequest
// (Final, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendServerAuthRetryRequest()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendServerAuthRetryRequest"));

	UOnlineAuthInterface_SendServerAuthRetryRequest_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendClientAuthEndSessionRequest
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendClientAuthEndSessionRequest(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendClientAuthEndSessionRequest"));

	UOnlineAuthInterface_SendClientAuthEndSessionRequest_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendServerAuthResponse
// (Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// int                            AuthTicketUID                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendServerAuthResponse(class UPlayer* ClientConnection, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendServerAuthResponse"));

	UOnlineAuthInterface_SendServerAuthResponse_Params params;
	params.ClientConnection = ClientConnection;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendClientAuthResponse
// (NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            AuthTicketUID                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendClientAuthResponse(int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendClientAuthResponse"));

	UOnlineAuthInterface_SendClientAuthResponse_Params params;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendServerAuthRequest
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendServerAuthRequest(const struct FUniqueNetId& ServerUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendServerAuthRequest"));

	UOnlineAuthInterface_SendServerAuthRequest_Params params;
	params.ServerUID = ServerUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.SendClientAuthRequest
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// struct FUniqueNetId            ClientUID                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::SendClientAuthRequest(class UPlayer* ClientConnection, const struct FUniqueNetId& ClientUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.SendClientAuthRequest"));

	UOnlineAuthInterface_SendClientAuthRequest_Params params;
	params.ClientConnection = ClientConnection;
	params.ClientUID = ClientUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAuthInterface.ClearServerConnectionCloseDelegate
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ServerConnectionCloseDelegate  (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearServerConnectionCloseDelegate(const struct FScriptDelegate& ServerConnectionCloseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearServerConnectionCloseDelegate"));

	UOnlineAuthInterface_ClearServerConnectionCloseDelegate_Params params;
	params.ServerConnectionCloseDelegate = ServerConnectionCloseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddServerConnectionCloseDelegate
// (Defined, Singular, Operator)
// Parameters:
// struct FScriptDelegate         ServerConnectionCloseDelegate  (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddServerConnectionCloseDelegate(const struct FScriptDelegate& ServerConnectionCloseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddServerConnectionCloseDelegate"));

	UOnlineAuthInterface_AddServerConnectionCloseDelegate_Params params;
	params.ServerConnectionCloseDelegate = ServerConnectionCloseDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnServerConnectionClose
// (Final, Defined, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)

void UOnlineAuthInterface::OnServerConnectionClose(class UPlayer* ServerConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnServerConnectionClose"));

	UOnlineAuthInterface_OnServerConnectionClose_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearClientConnectionCloseDelegate
// (Final, Iterator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ClientConnectionCloseDelegate  (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearClientConnectionCloseDelegate(const struct FScriptDelegate& ClientConnectionCloseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearClientConnectionCloseDelegate"));

	UOnlineAuthInterface_ClearClientConnectionCloseDelegate_Params params;
	params.ClientConnectionCloseDelegate = ClientConnectionCloseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddClientConnectionCloseDelegate
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ClientConnectionCloseDelegate  (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddClientConnectionCloseDelegate(const struct FScriptDelegate& ClientConnectionCloseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddClientConnectionCloseDelegate"));

	UOnlineAuthInterface_AddClientConnectionCloseDelegate_Params params;
	params.ClientConnectionCloseDelegate = ClientConnectionCloseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnClientConnectionClose
// (Final, Defined, Iterator, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)

void UOnlineAuthInterface::OnClientConnectionClose(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnClientConnectionClose"));

	UOnlineAuthInterface_OnClientConnectionClose_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearServerAuthRetryRequestDelegate
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthRetryRequestDelegate (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearServerAuthRetryRequestDelegate(const struct FScriptDelegate& ServerAuthRetryRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearServerAuthRetryRequestDelegate"));

	UOnlineAuthInterface_ClearServerAuthRetryRequestDelegate_Params params;
	params.ServerAuthRetryRequestDelegate = ServerAuthRetryRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddServerAuthRetryRequestDelegate
// (Final, Singular, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthRetryRequestDelegate (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddServerAuthRetryRequestDelegate(const struct FScriptDelegate& ServerAuthRetryRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddServerAuthRetryRequestDelegate"));

	UOnlineAuthInterface_AddServerAuthRetryRequestDelegate_Params params;
	params.ServerAuthRetryRequestDelegate = ServerAuthRetryRequestDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnServerAuthRetryRequest
// (Defined, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)

void UOnlineAuthInterface::OnServerAuthRetryRequest(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnServerAuthRetryRequest"));

	UOnlineAuthInterface_OnServerAuthRetryRequest_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearClientAuthEndSessionRequestDelegate
// (Defined, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ClientAuthEndSessionRequestDelegate (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearClientAuthEndSessionRequestDelegate(const struct FScriptDelegate& ClientAuthEndSessionRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearClientAuthEndSessionRequestDelegate"));

	UOnlineAuthInterface_ClearClientAuthEndSessionRequestDelegate_Params params;
	params.ClientAuthEndSessionRequestDelegate = ClientAuthEndSessionRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddClientAuthEndSessionRequestDelegate
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ClientAuthEndSessionRequestDelegate (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddClientAuthEndSessionRequestDelegate(const struct FScriptDelegate& ClientAuthEndSessionRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddClientAuthEndSessionRequestDelegate"));

	UOnlineAuthInterface_AddClientAuthEndSessionRequestDelegate_Params params;
	params.ClientAuthEndSessionRequestDelegate = ClientAuthEndSessionRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnClientAuthEndSessionRequest
// (Iterator, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)

void UOnlineAuthInterface::OnClientAuthEndSessionRequest(class UPlayer* ServerConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnClientAuthEndSessionRequest"));

	UOnlineAuthInterface_OnClientAuthEndSessionRequest_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearServerAuthCompleteDelegate
// (Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthCompleteDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearServerAuthCompleteDelegate(const struct FScriptDelegate& ServerAuthCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearServerAuthCompleteDelegate"));

	UOnlineAuthInterface_ClearServerAuthCompleteDelegate_Params params;
	params.ServerAuthCompleteDelegate = ServerAuthCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddServerAuthCompleteDelegate
// (Defined, Iterator, Latent, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthCompleteDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddServerAuthCompleteDelegate(const struct FScriptDelegate& ServerAuthCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddServerAuthCompleteDelegate"));

	UOnlineAuthInterface_AddServerAuthCompleteDelegate_Params params;
	params.ServerAuthCompleteDelegate = ServerAuthCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnServerAuthComplete
// (Final, Defined, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSuccess                       (Parm)
// struct FUniqueNetId            ServerUID                      (Parm)
// class UPlayer*                 ServerConnection               (Parm)
// struct FString                 ExtraInfo                      (Parm, NeedCtorLink)

void UOnlineAuthInterface::OnServerAuthComplete(bool bSuccess, const struct FUniqueNetId& ServerUID, class UPlayer* ServerConnection, const struct FString& ExtraInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnServerAuthComplete"));

	UOnlineAuthInterface_OnServerAuthComplete_Params params;
	params.bSuccess = bSuccess;
	params.ServerUID = ServerUID;
	params.ServerConnection = ServerConnection;
	params.ExtraInfo = ExtraInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearClientAuthCompleteDelegate
// (Final, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ClientAuthCompleteDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearClientAuthCompleteDelegate(const struct FScriptDelegate& ClientAuthCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearClientAuthCompleteDelegate"));

	UOnlineAuthInterface_ClearClientAuthCompleteDelegate_Params params;
	params.ClientAuthCompleteDelegate = ClientAuthCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddClientAuthCompleteDelegate
// (Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ClientAuthCompleteDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddClientAuthCompleteDelegate(const struct FScriptDelegate& ClientAuthCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddClientAuthCompleteDelegate"));

	UOnlineAuthInterface_AddClientAuthCompleteDelegate_Params params;
	params.ClientAuthCompleteDelegate = ClientAuthCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnClientAuthComplete
// (Final, Defined, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSuccess                       (Parm)
// struct FUniqueNetId            ClientUID                      (Parm)
// class UPlayer*                 ClientConnection               (Parm)
// struct FString                 ExtraInfo                      (Parm, NeedCtorLink)

void UOnlineAuthInterface::OnClientAuthComplete(bool bSuccess, const struct FUniqueNetId& ClientUID, class UPlayer* ClientConnection, const struct FString& ExtraInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnClientAuthComplete"));

	UOnlineAuthInterface_OnClientAuthComplete_Params params;
	params.bSuccess = bSuccess;
	params.ClientUID = ClientUID;
	params.ClientConnection = ClientConnection;
	params.ExtraInfo = ExtraInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearServerAuthResponseDelegate
// (Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthResponseDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearServerAuthResponseDelegate(const struct FScriptDelegate& ServerAuthResponseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearServerAuthResponseDelegate"));

	UOnlineAuthInterface_ClearServerAuthResponseDelegate_Params params;
	params.ServerAuthResponseDelegate = ServerAuthResponseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddServerAuthResponseDelegate
// (Singular, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthResponseDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddServerAuthResponseDelegate(const struct FScriptDelegate& ServerAuthResponseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddServerAuthResponseDelegate"));

	UOnlineAuthInterface_AddServerAuthResponseDelegate_Params params;
	params.ServerAuthResponseDelegate = ServerAuthResponseDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnServerAuthResponse
// (Final, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            AuthTicketUID                  (Parm)

void UOnlineAuthInterface::OnServerAuthResponse(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnServerAuthResponse"));

	UOnlineAuthInterface_OnServerAuthResponse_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearClientAuthResponseDelegate
// (Iterator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ClientAuthResponseDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearClientAuthResponseDelegate(const struct FScriptDelegate& ClientAuthResponseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearClientAuthResponseDelegate"));

	UOnlineAuthInterface_ClearClientAuthResponseDelegate_Params params;
	params.ClientAuthResponseDelegate = ClientAuthResponseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddClientAuthResponseDelegate
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ClientAuthResponseDelegate     (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddClientAuthResponseDelegate(const struct FScriptDelegate& ClientAuthResponseDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddClientAuthResponseDelegate"));

	UOnlineAuthInterface_AddClientAuthResponseDelegate_Params params;
	params.ClientAuthResponseDelegate = ClientAuthResponseDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnClientAuthResponse
// (Defined, Iterator, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            AuthTicketUID                  (Parm)

void UOnlineAuthInterface::OnClientAuthResponse(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnClientAuthResponse"));

	UOnlineAuthInterface_OnClientAuthResponse_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearServerAuthRequestDelegate
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthRequestDelegate      (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearServerAuthRequestDelegate(const struct FScriptDelegate& ServerAuthRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearServerAuthRequestDelegate"));

	UOnlineAuthInterface_ClearServerAuthRequestDelegate_Params params;
	params.ServerAuthRequestDelegate = ServerAuthRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddServerAuthRequestDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         ServerAuthRequestDelegate      (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddServerAuthRequestDelegate(const struct FScriptDelegate& ServerAuthRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddServerAuthRequestDelegate"));

	UOnlineAuthInterface_AddServerAuthRequestDelegate_Params params;
	params.ServerAuthRequestDelegate = ServerAuthRequestDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnServerAuthRequest
// (Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            ClientPort                     (Parm)

void UOnlineAuthInterface::OnServerAuthRequest(class UPlayer* ClientConnection, const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int ClientPort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnServerAuthRequest"));

	UOnlineAuthInterface_OnServerAuthRequest_Params params;
	params.ClientConnection = ClientConnection;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.ClientPort = ClientPort;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearClientAuthRequestDelegate
// (Final, Defined, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ClientAuthRequestDelegate      (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearClientAuthRequestDelegate(const struct FScriptDelegate& ClientAuthRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearClientAuthRequestDelegate"));

	UOnlineAuthInterface_ClearClientAuthRequestDelegate_Params params;
	params.ClientAuthRequestDelegate = ClientAuthRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddClientAuthRequestDelegate
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ClientAuthRequestDelegate      (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddClientAuthRequestDelegate(const struct FScriptDelegate& ClientAuthRequestDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddClientAuthRequestDelegate"));

	UOnlineAuthInterface_AddClientAuthRequestDelegate_Params params;
	params.ClientAuthRequestDelegate = ClientAuthRequestDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnClientAuthRequest
// (Final, Iterator, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            ServerPort                     (Parm)
// bool                           bSecure                        (Parm)

void UOnlineAuthInterface::OnClientAuthRequest(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int ServerPort, bool bSecure)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnClientAuthRequest"));

	UOnlineAuthInterface_OnClientAuthRequest_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.ServerPort = ServerPort;
	params.bSecure = bSecure;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.ClearAuthReadyDelegate
// (Defined, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         AuthReadyDelegate              (Parm, NeedCtorLink)

void UOnlineAuthInterface::ClearAuthReadyDelegate(const struct FScriptDelegate& AuthReadyDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.ClearAuthReadyDelegate"));

	UOnlineAuthInterface_ClearAuthReadyDelegate_Params params;
	params.AuthReadyDelegate = AuthReadyDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.AddAuthReadyDelegate
// (Final, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         AuthReadyDelegate              (Parm, NeedCtorLink)

void UOnlineAuthInterface::AddAuthReadyDelegate(const struct FScriptDelegate& AuthReadyDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.AddAuthReadyDelegate"));

	UOnlineAuthInterface_AddAuthReadyDelegate_Params params;
	params.AuthReadyDelegate = AuthReadyDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.OnAuthReady
// (Latent, Exec, Native, HasOptionalParms)

void UOnlineAuthInterface::OnAuthReady()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.OnAuthReady"));

	UOnlineAuthInterface_OnAuthReady_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAuthInterface.IsReady
// (PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAuthInterface::STATIC_IsReady()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAuthInterface.IsReady"));

	UOnlineAuthInterface_IsReady_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineEventTracker.RaiseEvent
// (Defined, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Const, Parm, NeedCtorLink)
// TArray<struct FString>         EventParams                    (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineEventTracker::RaiseEvent(const struct FString& EventName, TArray<struct FString> EventParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventTracker.RaiseEvent"));

	UOnlineEventTracker_RaiseEvent_Params params;
	params.EventName = EventName;
	params.EventParams = EventParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineEventTracker.ShutDown
// (Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void UOnlineEventTracker::ShutDown()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventTracker.ShutDown"));

	UOnlineEventTracker_ShutDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineEventTracker.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UOnlineEventTracker::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventTracker.Init"));

	UOnlineEventTracker_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMatchmakingStats.StopTimer
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FMMStats_Timer          Timer                          (Parm, OutParm)

void UOnlineMatchmakingStats::StopTimer(struct FMMStats_Timer* Timer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMatchmakingStats.StopTimer"));

	UOnlineMatchmakingStats_StopTimer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Timer != nullptr)
		*Timer = params.Timer;
}


// Function Engine.OnlineMatchmakingStats.StartTimer
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FMMStats_Timer          Timer                          (Parm, OutParm)

void UOnlineMatchmakingStats::StartTimer(struct FMMStats_Timer* Timer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMatchmakingStats.StartTimer"));

	UOnlineMatchmakingStats_StartTimer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Timer != nullptr)
		*Timer = params.Timer;
}


// Function Engine.OnlinePlayerStorage.SetDefaultVersionNumber
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)

void UOnlinePlayerStorage::SetDefaultVersionNumber()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetDefaultVersionNumber"));

	UOnlinePlayerStorage_SetDefaultVersionNumber_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerStorage.GetVersionNumber
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerStorage::STATIC_GetVersionNumber()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetVersionNumber"));

	UOnlinePlayerStorage_GetVersionNumber_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.AppendVersionToSettings
// (Iterator, Singular, NetReliable, Simulated, Operator)

void UOnlinePlayerStorage::AppendVersionToSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.AppendVersionToSettings"));

	UOnlinePlayerStorage_AppendVersionToSettings_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerStorage.SetToDefaults
// (Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)

void UOnlinePlayerStorage::SetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetToDefaults"));

	UOnlinePlayerStorage_SetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerStorage.AddSettingFloat
// (Final, Defined, Iterator, Singular, Operator)
// Parameters:
// int                            SettingId                      (Parm)

void UOnlinePlayerStorage::AddSettingFloat(int SettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.AddSettingFloat"));

	UOnlinePlayerStorage_AddSettingFloat_Params params;
	params.SettingId = SettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerStorage.AddSettingInt
// (Latent, Singular, Operator)
// Parameters:
// int                            SettingId                      (Parm)

void UOnlinePlayerStorage::AddSettingInt(int SettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.AddSettingInt"));

	UOnlinePlayerStorage_AddSettingInt_Params params;
	params.SettingId = SettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerStorage.GetRangedProfileSettingValue
// (Defined, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileId                      (Parm)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetRangedProfileSettingValue(int ProfileId, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetRangedProfileSettingValue"));

	UOnlinePlayerStorage_GetRangedProfileSettingValue_Params params;
	params.ProfileId = ProfileId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetRangedProfileSettingValue
// (Defined, Iterator, Net, Event, HasOptionalParms)
// Parameters:
// int                            ProfileId                      (Parm)
// float                          NewValue                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetRangedProfileSettingValue(int ProfileId, float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetRangedProfileSettingValue"));

	UOnlinePlayerStorage_SetRangedProfileSettingValue_Params params;
	params.ProfileId = ProfileId;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingRange
// (Final, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileId                      (Parm)
// float                          OutMinValue                    (Parm, OutParm)
// float                          OutMaxValue                    (Parm, OutParm)
// float                          RangeIncrement                 (Parm, OutParm)
// unsigned char                  bFormatAsInt                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingRange(int ProfileId, float* OutMinValue, float* OutMaxValue, float* RangeIncrement, unsigned char* bFormatAsInt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingRange"));

	UOnlinePlayerStorage_GetProfileSettingRange_Params params;
	params.ProfileId = ProfileId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMinValue != nullptr)
		*OutMinValue = params.OutMinValue;
	if (OutMaxValue != nullptr)
		*OutMaxValue = params.OutMaxValue;
	if (RangeIncrement != nullptr)
		*RangeIncrement = params.RangeIncrement;
	if (bFormatAsInt != nullptr)
		*bFormatAsInt = params.bFormatAsInt;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingMappingIds
// (Defined, Iterator, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileId                      (Parm)
// TArray<int>                    Ids                            (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingMappingIds(int ProfileId, TArray<int>* Ids)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingMappingIds"));

	UOnlinePlayerStorage_GetProfileSettingMappingIds_Params params;
	params.ProfileId = ProfileId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Ids != nullptr)
		*Ids = params.Ids;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingMappingType
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileId                      (Parm)
// TEnumAsByte<EPropertyValueMappingType> OutType                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingMappingType(int ProfileId, TEnumAsByte<EPropertyValueMappingType>* OutType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingMappingType"));

	UOnlinePlayerStorage_GetProfileSettingMappingType_Params params;
	params.ProfileId = ProfileId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutType != nullptr)
		*OutType = params.OutType;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetProfileSettingValueFloat
// (Defined, Iterator, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// int                            ProfileSettingId               (Parm)
// float                          Value                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetProfileSettingValueFloat(int ProfileSettingId, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetProfileSettingValueFloat"));

	UOnlinePlayerStorage_SetProfileSettingValueFloat_Params params;
	params.ProfileSettingId = ProfileSettingId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetProfileSettingValueInt
// (Net, Event, HasOptionalParms)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            Value                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetProfileSettingValueInt(int ProfileSettingId, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetProfileSettingValueInt"));

	UOnlinePlayerStorage_SetProfileSettingValueInt_Params params;
	params.ProfileSettingId = ProfileSettingId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetProfileSettingValueId
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            Value                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetProfileSettingValueId(int ProfileSettingId, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetProfileSettingValueId"));

	UOnlinePlayerStorage_SetProfileSettingValueId_Params params;
	params.ProfileSettingId = ProfileSettingId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueFloat
// (Final, Iterator, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// float                          Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValueFloat(int ProfileSettingId, float* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueFloat"));

	UOnlinePlayerStorage_GetProfileSettingValueFloat_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueInt
// (Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValueInt(int ProfileSettingId, int* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueInt"));

	UOnlinePlayerStorage_GetProfileSettingValueInt_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueFromListIndex
// (Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            ListIndex                      (Parm)
// int                            Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValueFromListIndex(int ProfileSettingId, int ListIndex, int* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueFromListIndex"));

	UOnlinePlayerStorage_GetProfileSettingValueFromListIndex_Params params;
	params.ProfileSettingId = ProfileSettingId;
	params.ListIndex = ListIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueId
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            ValueId                        (Parm, OutParm)
// int                            ListIndex                      (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValueId(int ProfileSettingId, int* ValueId, int* ListIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueId"));

	UOnlinePlayerStorage_GetProfileSettingValueId_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ValueId != nullptr)
		*ValueId = params.ValueId;
	if (ListIndex != nullptr)
		*ListIndex = params.ListIndex;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetProfileSettingValue
// (Iterator, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// int                            ProfileSettingId               (Parm)
// struct FString                 NewValue                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetProfileSettingValue(int ProfileSettingId, struct FString* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetProfileSettingValue"));

	UOnlinePlayerStorage_SetProfileSettingValue_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewValue != nullptr)
		*NewValue = params.NewValue;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.SetProfileSettingValueByName
// (Final, Iterator, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// struct FName                   ProfileSettingName             (Parm)
// struct FString                 NewValue                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::SetProfileSettingValueByName(const struct FName& ProfileSettingName, struct FString* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.SetProfileSettingValueByName"));

	UOnlinePlayerStorage_SetProfileSettingValueByName_Params params;
	params.ProfileSettingName = ProfileSettingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewValue != nullptr)
		*NewValue = params.NewValue;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueByName
// (Iterator, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ProfileSettingName             (Parm)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValueByName(const struct FName& ProfileSettingName, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueByName"));

	UOnlinePlayerStorage_GetProfileSettingValueByName_Params params;
	params.ProfileSettingName = ProfileSettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValues
// (Defined, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// TArray<struct FName>           Values                         (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValues(int ProfileSettingId, TArray<struct FName>* Values)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValues"));

	UOnlinePlayerStorage_GetProfileSettingValues_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Values != nullptr)
		*Values = params.Values;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValueName
// (Final, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UOnlinePlayerStorage::STATIC_GetProfileSettingValueName(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValueName"));

	UOnlinePlayerStorage_GetProfileSettingValueName_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingValue
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)
// int                            ValueMapID                     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingValue(int ProfileSettingId, int ValueMapID, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingValue"));

	UOnlinePlayerStorage_GetProfileSettingValue_Params params;
	params.ProfileSettingId = ProfileSettingId;
	params.ValueMapID = ValueMapID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.IsProfileSettingIdMapped
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_IsProfileSettingIdMapped(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.IsProfileSettingIdMapped"));

	UOnlinePlayerStorage_IsProfileSettingIdMapped_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.FindDefaultProfileMappingIndexByName
// (Iterator, Latent, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ProfileSettingName             (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerStorage::STATIC_FindDefaultProfileMappingIndexByName(const struct FName& ProfileSettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.FindDefaultProfileMappingIndexByName"));

	UOnlinePlayerStorage_FindDefaultProfileMappingIndexByName_Params params;
	params.ProfileSettingName = ProfileSettingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.FindProfileMappingIndexByName
// (Defined, Iterator, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ProfileSettingName             (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerStorage::STATIC_FindProfileMappingIndexByName(const struct FName& ProfileSettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.FindProfileMappingIndexByName"));

	UOnlinePlayerStorage_FindProfileMappingIndexByName_Params params;
	params.ProfileSettingName = ProfileSettingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.FindProfileMappingIndex
// (Final, Iterator, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerStorage::STATIC_FindProfileMappingIndex(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.FindProfileMappingIndex"));

	UOnlinePlayerStorage_FindProfileMappingIndex_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.FindProfileSettingIndex
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerStorage::STATIC_FindProfileSettingIndex(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.FindProfileSettingIndex"));

	UOnlinePlayerStorage_FindProfileSettingIndex_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingColumnHeader
// (Final, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlinePlayerStorage::STATIC_GetProfileSettingColumnHeader(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingColumnHeader"));

	UOnlinePlayerStorage_GetProfileSettingColumnHeader_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingName
// (Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UOnlinePlayerStorage::STATIC_GetProfileSettingName(int ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingName"));

	UOnlinePlayerStorage_GetProfileSettingName_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerStorage.GetProfileSettingId
// (Final, Iterator, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ProfileSettingName             (Parm)
// int                            ProfileSettingId               (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerStorage::STATIC_GetProfileSettingId(const struct FName& ProfileSettingName, int* ProfileSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerStorage.GetProfileSettingId"));

	UOnlinePlayerStorage_GetProfileSettingId_Params params;
	params.ProfileSettingName = ProfileSettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ProfileSettingId != nullptr)
		*ProfileSettingId = params.ProfileSettingId;

	return params.ReturnValue;
}


// Function Engine.OnlineProfileSettings.ModifyAvailableProfileSettings
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UOnlineProfileSettings::ModifyAvailableProfileSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.ModifyAvailableProfileSettings"));

	UOnlineProfileSettings_ModifyAvailableProfileSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineProfileSettings.AppendVersionToReadIds
// (Final, Defined, Singular, NetReliable, Simulated, Operator)

void UOnlineProfileSettings::AppendVersionToReadIds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.AppendVersionToReadIds"));

	UOnlineProfileSettings_AppendVersionToReadIds_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineProfileSettings.SetToDefaults
// (Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)

void UOnlineProfileSettings::SetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.SetToDefaults"));

	UOnlineProfileSettings_SetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineProfileSettings.GetProfileSettingDefaultFloat
// (Defined, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// float                          DefaultFloat                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineProfileSettings::STATIC_GetProfileSettingDefaultFloat(int ProfileSettingId, float* DefaultFloat)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.GetProfileSettingDefaultFloat"));

	UOnlineProfileSettings_GetProfileSettingDefaultFloat_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DefaultFloat != nullptr)
		*DefaultFloat = params.DefaultFloat;

	return params.ReturnValue;
}


// Function Engine.OnlineProfileSettings.GetProfileSettingDefaultInt
// (Iterator, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            DefaultInt                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineProfileSettings::STATIC_GetProfileSettingDefaultInt(int ProfileSettingId, int* DefaultInt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.GetProfileSettingDefaultInt"));

	UOnlineProfileSettings_GetProfileSettingDefaultInt_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DefaultInt != nullptr)
		*DefaultInt = params.DefaultInt;

	return params.ReturnValue;
}


// Function Engine.OnlineProfileSettings.GetProfileSettingDefaultId
// (Final, Defined, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ProfileSettingId               (Parm)
// int                            DefaultId                      (Parm, OutParm)
// int                            ListIndex                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineProfileSettings::STATIC_GetProfileSettingDefaultId(int ProfileSettingId, int* DefaultId, int* ListIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineProfileSettings.GetProfileSettingDefaultId"));

	UOnlineProfileSettings_GetProfileSettingDefaultId_Params params;
	params.ProfileSettingId = ProfileSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DefaultId != nullptr)
		*DefaultId = params.DefaultId;
	if (ListIndex != nullptr)
		*ListIndex = params.ListIndex;

	return params.ReturnValue;
}


// Function Engine.OnlineStats.GetRankForPlayer
// (Iterator, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineStats::STATIC_GetRankForPlayer(const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStats.GetRankForPlayer"));

	UOnlineStats_GetRankForPlayer_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStats.IsStatZero
// (Final, Defined, Simulated, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStats::STATIC_IsStatZero(const struct FUniqueNetId& PlayerID, const struct FString& StatName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStats.IsStatZero"));

	UOnlineStats_IsStatZero_Params params;
	params.PlayerID = PlayerID;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStats.GetStatValueForPlayerAsString
// (Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// struct FString                 StatValue                      (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStats::STATIC_GetStatValueForPlayerAsString(const struct FUniqueNetId& PlayerID, const struct FString& StatName, struct FString* StatValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStats.GetStatValueForPlayerAsString"));

	UOnlineStats_GetStatValueForPlayerAsString_Params params;
	params.PlayerID = PlayerID;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StatValue != nullptr)
		*StatValue = params.StatValue;

	return params.ReturnValue;
}


// Function Engine.OnlineStats.GetFloatStatValueForPlayer
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// float                          StatValue                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStats::STATIC_GetFloatStatValueForPlayer(const struct FUniqueNetId& PlayerID, const struct FString& StatName, float* StatValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStats.GetFloatStatValueForPlayer"));

	UOnlineStats_GetFloatStatValueForPlayer_Params params;
	params.PlayerID = PlayerID;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StatValue != nullptr)
		*StatValue = params.StatValue;

	return params.ReturnValue;
}


// Function Engine.OnlineStats.GetIntStatValueForPlayer
// (Final, Defined, Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// int                            StatValue                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStats::STATIC_GetIntStatValueForPlayer(const struct FUniqueNetId& PlayerID, const struct FString& StatName, int* StatValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStats.GetIntStatValueForPlayer"));

	UOnlineStats_GetIntStatValueForPlayer_Params params;
	params.PlayerID = PlayerID;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StatValue != nullptr)
		*StatValue = params.StatValue;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsRead.OnReadComplete
// (Final, Iterator, Latent, PreOperator, Exec, Native, HasOptionalParms)

void UOnlineStatsRead::OnReadComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsRead.OnReadComplete"));

	UOnlineStatsRead_OnReadComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsWrite.SetStringStat
// (Final, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// struct FString                 Value                          (Const, Parm, OutParm, NeedCtorLink)

void UOnlineStatsWrite::SetStringStat(const struct FString& StatName, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsWrite.SetStringStat"));

	UOnlineStatsWrite_SetStringStat_Params params;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.OnlineStatsWrite.SetIntStat
// (Final, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// int                            Value                          (Parm)

void UOnlineStatsWrite::SetIntStat(const struct FString& StatName, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsWrite.SetIntStat"));

	UOnlineStatsWrite_SetIntStat_Params params;
	params.StatName = StatName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsWrite.SetFloatStat
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 StatName                       (Const, Parm, NeedCtorLink)
// float                          Value                          (Parm)

void UOnlineStatsWrite::SetFloatStat(const struct FString& StatName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsWrite.SetFloatStat"));

	UOnlineStatsWrite_SetFloatStat_Params params;
	params.StatName = StatName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.ClearLeaveStorefrontDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         LeaveStorefrontDelegate        (Parm, NeedCtorLink)

void UOnlineSubsystem::ClearLeaveStorefrontDelegate(const struct FScriptDelegate& LeaveStorefrontDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.ClearLeaveStorefrontDelegate"));

	UOnlineSubsystem_ClearLeaveStorefrontDelegate_Params params;
	params.LeaveStorefrontDelegate = LeaveStorefrontDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.AddLeaveStorefrontDelegate
// (Defined, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         LeaveStorefrontDelegate        (Parm, NeedCtorLink)

void UOnlineSubsystem::AddLeaveStorefrontDelegate(const struct FScriptDelegate& LeaveStorefrontDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.AddLeaveStorefrontDelegate"));

	UOnlineSubsystem_AddLeaveStorefrontDelegate_Params params;
	params.LeaveStorefrontDelegate = LeaveStorefrontDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.OnLeaveStorefront
// (Final, Defined, Iterator, PreOperator, Exec, Native, HasOptionalParms)

void UOnlineSubsystem::OnLeaveStorefront()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.OnLeaveStorefront"));

	UOnlineSubsystem_OnLeaveStorefront_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.AllowsUserChanging
// (Final, Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::AllowsUserChanging()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.AllowsUserChanging"));

	UOnlineSubsystem_AllowsUserChanging_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetDebugSpewLevel
// (Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            DebugSpewLevel                 (Parm)

void UOnlineSubsystem::SetDebugSpewLevel(int DebugSpewLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetDebugSpewLevel"));

	UOnlineSubsystem_SetDebugSpewLevel_Params params;
	params.DebugSpewLevel = DebugSpewLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.DumpVoiceRegistration
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Native, Static)

void UOnlineSubsystem::STATIC_DumpVoiceRegistration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.DumpVoiceRegistration"));

	UOnlineSubsystem_DumpVoiceRegistration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.DumpSessionState
// (Defined, Latent, PreOperator, NetReliable, Exec, Native, Static)

void UOnlineSubsystem::STATIC_DumpSessionState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.DumpSessionState"));

	UOnlineSubsystem_DumpSessionState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.DumpGameSettings
// (Final, Latent, PreOperator, NetReliable, Exec, Native, Static)
// Parameters:
// class UOnlineGameSettings*     GameSettings                   (Const, Parm)

void UOnlineSubsystem::STATIC_DumpGameSettings(class UOnlineGameSettings* GameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.DumpGameSettings"));

	UOnlineSubsystem_DumpGameSettings_Params params;
	params.GameSettings = GameSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.IsInSession
// (Defined, Iterator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::STATIC_IsInSession(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.IsInSession"));

	UOnlineSubsystem_IsInSession_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetNumSupportedLogins
// (Final, Defined, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineSubsystem::STATIC_GetNumSupportedLogins()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetNumSupportedLogins"));

	UOnlineSubsystem_GetNumSupportedLogins_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetBuildUniqueId
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineSubsystem::STATIC_GetBuildUniqueId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetBuildUniqueId"));

	UOnlineSubsystem_GetBuildUniqueId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.PreLogin
// (Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::PreLogin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.PreLogin"));

	UOnlineSubsystem_PreLogin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetLoginStatus
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// unsigned char                  UserIndex                      (Parm)
// TEnumAsByte<ELoginStatus>      ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ELoginStatus> UOnlineSubsystem::GetLoginStatus(unsigned char UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetLoginStatus"));

	UOnlineSubsystem_GetLoginStatus_Params params;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetAuthPlayerUniqueNetIdFromIndex
// (NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            UserIndex                      (Parm)
// struct FUniqueNetId            ReturnValue                    (Parm, OutParm, ReturnParm)

struct FUniqueNetId UOnlineSubsystem::GetAuthPlayerUniqueNetIdFromIndex(int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetAuthPlayerUniqueNetIdFromIndex"));

	UOnlineSubsystem_GetAuthPlayerUniqueNetIdFromIndex_Params params;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetPlayerUniqueNetIdFromIndex
// (Final, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            UserIndex                      (Parm)
// struct FUniqueNetId            ReturnValue                    (Parm, OutParm, ReturnParm)

struct FUniqueNetId UOnlineSubsystem::GetPlayerUniqueNetIdFromIndex(int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetPlayerUniqueNetIdFromIndex"));

	UOnlineSubsystem_GetPlayerUniqueNetIdFromIndex_Params params;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.StringToUniqueNetId
// (Defined, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 UniqueNetIdString              (Parm, NeedCtorLink)
// struct FUniqueNetId            out_UniqueId                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::StringToUniqueNetId(const struct FString& UniqueNetIdString, struct FUniqueNetId* out_UniqueId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.StringToUniqueNetId"));

	UOnlineSubsystem_StringToUniqueNetId_Params params;
	params.UniqueNetIdString = UniqueNetIdString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_UniqueId != nullptr)
		*out_UniqueId = params.out_UniqueId;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.UniqueNetIdToString
// (Final, Iterator, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            IdToConvert                    (Const, Parm, OutParm)
// bool                           Hex                            (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineSubsystem::UniqueNetIdToString(bool Hex, struct FUniqueNetId* IdToConvert)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.UniqueNetIdToString"));

	UOnlineSubsystem_UniqueNetIdToString_Params params;
	params.Hex = Hex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IdToConvert != nullptr)
		*IdToConvert = params.IdToConvert;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.RaiseEvent
// (Defined, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Const, Parm, NeedCtorLink)
// TArray<struct FString>         EventParams                    (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::RaiseEvent(const struct FString& EventName, TArray<struct FString> EventParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.RaiseEvent"));

	UOnlineSubsystem_RaiseEvent_Params params;
	params.EventName = EventName;
	params.EventParams = EventParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.GetNamedInterface
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FName                   InterfaceName                  (Parm)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UOnlineSubsystem::GetNamedInterface(const struct FName& InterfaceName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.GetNamedInterface"));

	UOnlineSubsystem_GetNamedInterface_Params params;
	params.InterfaceName = InterfaceName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetNamedInterface
// (Final, Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   InterfaceName                  (Parm)
// class UObject*                 NewInterface                   (Parm)

void UOnlineSubsystem::SetNamedInterface(const struct FName& InterfaceName, class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetNamedInterface"));

	UOnlineSubsystem_SetNamedInterface_Params params;
	params.InterfaceName = InterfaceName;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.SetCommunityContentInterface
// (Defined, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InCommunityContentInterface    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetCommunityContentInterface(class UObject* InCommunityContentInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetCommunityContentInterface"));

	UOnlineSubsystem_SetCommunityContentInterface_Params params;
	params.InCommunityContentInterface = InCommunityContentInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetGameDVRInterface
// (Defined, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InGameDVRInterface             (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetGameDVRInterface(class UObject* InGameDVRInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetGameDVRInterface"));

	UOnlineSubsystem_SetGameDVRInterface_Params params;
	params.InGameDVRInterface = InGameDVRInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetSharedCloudInterface
// (Final, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InCloudInterface               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetSharedCloudInterface(class UObject* InCloudInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetSharedCloudInterface"));

	UOnlineSubsystem_SetSharedCloudInterface_Params params;
	params.InCloudInterface = InCloudInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetUserCloudInterface
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InCloudInterface               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetUserCloudInterface(class UObject* InCloudInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetUserCloudInterface"));

	UOnlineSubsystem_SetUserCloudInterface_Params params;
	params.InCloudInterface = InCloudInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetAuthInterface
// (Final, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InAuthInterface                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetAuthInterface(class UObject* InAuthInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetAuthInterface"));

	UOnlineSubsystem_SetAuthInterface_Params params;
	params.InAuthInterface = InAuthInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetSocialInterface
// (Final, Iterator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 InSocialInterface              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetSocialInterface(class UObject* InSocialInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetSocialInterface"));

	UOnlineSubsystem_SetSocialInterface_Params params;
	params.InSocialInterface = InSocialInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetTitleFileCacheInterface
// (Defined, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetTitleFileCacheInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetTitleFileCacheInterface"));

	UOnlineSubsystem_SetTitleFileCacheInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetGameChatInterface
// (Final, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetGameChatInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetGameChatInterface"));

	UOnlineSubsystem_SetGameChatInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetTitleFileInterface
// (Final, Defined, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetTitleFileInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetTitleFileInterface"));

	UOnlineSubsystem_SetTitleFileInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetPartyChatInterface
// (Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetPartyChatInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetPartyChatInterface"));

	UOnlineSubsystem_SetPartyChatInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetNewsInterface
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetNewsInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetNewsInterface"));

	UOnlineSubsystem_SetNewsInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetStatsInterface
// (Defined, Iterator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetStatsInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetStatsInterface"));

	UOnlineSubsystem_SetStatsInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetVoiceInterface
// (PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetVoiceInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetVoiceInterface"));

	UOnlineSubsystem_SetVoiceInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetContentInterface
// (Final, Defined, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetContentInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetContentInterface"));

	UOnlineSubsystem_SetContentInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetGameInterface
// (Final, Defined, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetGameInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetGameInterface"));

	UOnlineSubsystem_SetGameInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetSystemInterface
// (Final, Defined, Iterator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetSystemInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetSystemInterface"));

	UOnlineSubsystem_SetSystemInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetMarketplaceInterface
// (Defined, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetMarketplaceInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetMarketplaceInterface"));

	UOnlineSubsystem_SetMarketplaceInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetPlayerInterfaceEx
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetPlayerInterfaceEx(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetPlayerInterfaceEx"));

	UOnlineSubsystem_SetPlayerInterfaceEx_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetPlayerInterface
// (Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetPlayerInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetPlayerInterface"));

	UOnlineSubsystem_SetPlayerInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.SetAccountInterface
// (Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UObject*                 NewInterface                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::SetAccountInterface(class UObject* NewInterface)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.SetAccountInterface"));

	UOnlineSubsystem_SetAccountInterface_Params params;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.Exit
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UOnlineSubsystem::Exit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.Exit"));

	UOnlineSubsystem_Exit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSubsystem.PostInit
// (Final, Defined, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::PostInit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.PostInit"));

	UOnlineSubsystem_PostInit_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSubsystem.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSubsystem::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSubsystem.Init"));

	UOnlineSubsystem_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.ClearDelegate
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// int                            DelegateType                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UPlatformInterfaceBase::ClearDelegate(int DelegateType, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.ClearDelegate"));

	UPlatformInterfaceBase_ClearDelegate_Params params;
	params.DelegateType = DelegateType;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlatformInterfaceBase.AddDelegate
// (Final, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// int                            DelegateType                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UPlatformInterfaceBase::AddDelegate(int DelegateType, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.AddDelegate"));

	UPlatformInterfaceBase_AddDelegate_Params params;
	params.DelegateType = DelegateType;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlatformInterfaceBase.GetInAppMessageInterface
// (Latent, Exec, Native, Event, Static)
// Parameters:
// class UInAppMessageBase*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UInAppMessageBase* UPlatformInterfaceBase::STATIC_GetInAppMessageInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetInAppMessageInterface"));

	UPlatformInterfaceBase_GetInAppMessageInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetAppNotificationsInterface
// (Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// class UAppNotificationsBase*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UAppNotificationsBase* UPlatformInterfaceBase::STATIC_GetAppNotificationsInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetAppNotificationsInterface"));

	UPlatformInterfaceBase_GetAppNotificationsInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetTwitterIntegration
// (Defined, Iterator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UTwitterIntegrationBase* ReturnValue                    (Parm, OutParm, ReturnParm)

class UTwitterIntegrationBase* UPlatformInterfaceBase::STATIC_GetTwitterIntegration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetTwitterIntegration"));

	UPlatformInterfaceBase_GetTwitterIntegration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetAnalyticEventsInterface
// (PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// class UAnalyticEventsBase*     ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnalyticEventsBase* UPlatformInterfaceBase::STATIC_GetAnalyticEventsInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetAnalyticEventsInterface"));

	UPlatformInterfaceBase_GetAnalyticEventsInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetMicroTransactionInterface
// (Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class UMicroTransactionBase*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UMicroTransactionBase* UPlatformInterfaceBase::STATIC_GetMicroTransactionInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetMicroTransactionInterface"));

	UPlatformInterfaceBase_GetMicroTransactionInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetInGameAdManager
// (Final, Latent, Exec, Native, Event, Static)
// Parameters:
// class UInGameAdManager*        ReturnValue                    (Parm, OutParm, ReturnParm)

class UInGameAdManager* UPlatformInterfaceBase::STATIC_GetInGameAdManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetInGameAdManager"));

	UPlatformInterfaceBase_GetInGameAdManager_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetFacebookIntegration
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UFacebookIntegration*    ReturnValue                    (Parm, OutParm, ReturnParm)

class UFacebookIntegration* UPlatformInterfaceBase::STATIC_GetFacebookIntegration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetFacebookIntegration"));

	UPlatformInterfaceBase_GetFacebookIntegration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetLocalStorageInterface
// (Final, Singular, Exec, Native, Event, Static)
// Parameters:
// class UCloudStorageBase*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UCloudStorageBase* UPlatformInterfaceBase::STATIC_GetLocalStorageInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetLocalStorageInterface"));

	UPlatformInterfaceBase_GetLocalStorageInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.GetCloudStorageInterface
// (Iterator, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UCloudStorageBase*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UCloudStorageBase* UPlatformInterfaceBase::STATIC_GetCloudStorageInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.GetCloudStorageInterface"));

	UPlatformInterfaceBase_GetCloudStorageInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceBase.CallDelegates
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// int                            DelegateType                   (Parm)
// struct FPlatformInterfaceDelegateResult DelegateResult                 (Parm, OutParm, NeedCtorLink)

void UPlatformInterfaceBase::CallDelegates(int DelegateType, struct FPlatformInterfaceDelegateResult* DelegateResult)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.CallDelegates"));

	UPlatformInterfaceBase_CallDelegates_Params params;
	params.DelegateType = DelegateType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DelegateResult != nullptr)
		*DelegateResult = params.DelegateResult;
}


// Function Engine.PlatformInterfaceBase.PlatformInterfaceDelegate
// (Final, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FPlatformInterfaceDelegateResult Result                         (Const, Parm, OutParm, NeedCtorLink)

void UPlatformInterfaceBase::PlatformInterfaceDelegate(struct FPlatformInterfaceDelegateResult* Result)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceBase.PlatformInterfaceDelegate"));

	UPlatformInterfaceBase_PlatformInterfaceDelegate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;
}


// Function Engine.MicroTransactionBase.GetProductIndex
// (Final, Defined, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Identifier                     (Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UMicroTransactionBase::GetProductIndex(const struct FString& Identifier)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MicroTransactionBase.GetProductIndex"));

	UMicroTransactionBase_GetProductIndex_Params params;
	params.Identifier = Identifier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MicroTransactionBase.BeginPurchase
// (PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMicroTransactionBase::BeginPurchase(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MicroTransactionBase.BeginPurchase"));

	UMicroTransactionBase_BeginPurchase_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MicroTransactionBase.IsAllowedToMakePurchases
// (Final, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMicroTransactionBase::IsAllowedToMakePurchases()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MicroTransactionBase.IsAllowedToMakePurchases"));

	UMicroTransactionBase_IsAllowedToMakePurchases_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MicroTransactionBase.QueryForAvailablePurchases
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMicroTransactionBase::QueryForAvailablePurchases()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MicroTransactionBase.QueryForAvailablePurchases"));

	UMicroTransactionBase_QueryForAvailablePurchases_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MicroTransactionBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UMicroTransactionBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MicroTransactionBase.Init"));

	UMicroTransactionBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Player.SwitchController
// (Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void UPlayer::SwitchController(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Player.SwitchController"));

	UPlayer_SwitchController_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.Cleanup
// (Final, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           bExit                          (OptionalParm, Parm)

void ULocalPlayer::Cleanup(bool bExit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.Cleanup"));

	ULocalPlayer_Cleanup_Params params;
	params.bExit = bExit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.Exit
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void ULocalPlayer::Exit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.Exit"));

	ULocalPlayer_Exit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.NotifyServerConnectionClose
// (Exec, Native, HasOptionalParms)

void ULocalPlayer::NotifyServerConnectionClose()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.NotifyServerConnectionClose"));

	ULocalPlayer_NotifyServerConnectionClose_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ViewportClosed
// (PreOperator, Simulated, Exec, Native, HasOptionalParms)

void ULocalPlayer::ViewportClosed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ViewportClosed"));

	ULocalPlayer_ViewportClosed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.StaticOnServerConnectionClose
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)

void ULocalPlayer::StaticOnServerConnectionClose(class UPlayer* ServerConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.StaticOnServerConnectionClose"));

	ULocalPlayer_StaticOnServerConnectionClose_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.OnServerConnectionClose
// (Final, Defined, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)

void ULocalPlayer::OnServerConnectionClose(class UPlayer* ServerConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.OnServerConnectionClose"));

	ULocalPlayer_OnServerConnectionClose_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ServerAuthFailure
// (Defined, Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void ULocalPlayer::ServerAuthFailure()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ServerAuthFailure"));

	ULocalPlayer_ServerAuthFailure_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ServerAuthTimedOut
// (Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void ULocalPlayer::ServerAuthTimedOut()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ServerAuthTimedOut"));

	ULocalPlayer_ServerAuthTimedOut_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.OnServerAuthComplete
// (Final, Defined, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSuccess                       (Parm)
// struct FUniqueNetId            ServerUID                      (Parm)
// class UPlayer*                 ServerConnection               (Parm)
// struct FString                 ExtraInfo                      (Parm, NeedCtorLink)

void ULocalPlayer::OnServerAuthComplete(bool bSuccess, const struct FUniqueNetId& ServerUID, class UPlayer* ServerConnection, const struct FString& ExtraInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.OnServerAuthComplete"));

	ULocalPlayer_OnServerAuthComplete_Params params;
	params.bSuccess = bSuccess;
	params.ServerUID = ServerUID;
	params.ServerConnection = ServerConnection;
	params.ExtraInfo = ExtraInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ProcessServerAuthResponse
// (Final, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            AuthTicketUID                  (Parm)

void ULocalPlayer::ProcessServerAuthResponse(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ProcessServerAuthResponse"));

	ULocalPlayer_ProcessServerAuthResponse_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ProcessClientAuthEndSessionRequest
// (Final, Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class UPlayer*                 ServerConnection               (Parm)

void ULocalPlayer::ProcessClientAuthEndSessionRequest(class UPlayer* ServerConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ProcessClientAuthEndSessionRequest"));

	ULocalPlayer_ProcessClientAuthEndSessionRequest_Params params;
	params.ServerConnection = ServerConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ProcessClientAuthRequest
// (Defined, Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ServerUID                      (Parm)
// struct FIpAddr                 ServerIP                       (Parm)
// int                            ServerPort                     (Parm)
// bool                           bSecure                        (Parm)

void ULocalPlayer::ProcessClientAuthRequest(const struct FUniqueNetId& ServerUID, const struct FIpAddr& ServerIP, int ServerPort, bool bSecure)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ProcessClientAuthRequest"));

	ULocalPlayer_ProcessClientAuthRequest_Params params;
	params.ServerUID = ServerUID;
	params.ServerIP = ServerIP;
	params.ServerPort = ServerPort;
	params.bSecure = bSecure;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.NotifyServerConnectionOpen
// (Final, Exec, Native, HasOptionalParms)

void ULocalPlayer::NotifyServerConnectionOpen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.NotifyServerConnectionOpen"));

	ULocalPlayer_NotifyServerConnectionOpen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.GetNickname
// (Defined, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ULocalPlayer::GetNickname()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.GetNickname"));

	ULocalPlayer_GetNickname_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.GetUniqueNetId
// (Final, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ReturnValue                    (Parm, OutParm, ReturnParm)

struct FUniqueNetId ULocalPlayer::GetUniqueNetId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.GetUniqueNetId"));

	ULocalPlayer_GetUniqueNetId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.FastProject
// (Iterator, PreOperator, Singular, Exec, Event, Static)
// Parameters:
// struct FVector                 WorldLoc                       (Parm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector2D ULocalPlayer::STATIC_FastProject(const struct FVector& WorldLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.FastProject"));

	ULocalPlayer_FastProject_Params params;
	params.WorldLoc = WorldLoc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.FastDeProject
// (Final, Defined, PreOperator, Singular, Exec, Event, Static)
// Parameters:
// struct FVector2D               RelativeScreenPos              (Parm)
// struct FVector                 WorldOrigin                    (Parm, OutParm)
// struct FVector                 WorldDirection                 (Parm, OutParm)

void ULocalPlayer::STATIC_FastDeProject(const struct FVector2D& RelativeScreenPos, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.FastDeProject"));

	ULocalPlayer_FastDeProject_Params params;
	params.RelativeScreenPos = RelativeScreenPos;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldOrigin != nullptr)
		*WorldOrigin = params.WorldOrigin;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;
}


// Function Engine.LocalPlayer.Project
// (Latent, PreOperator, Net, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FVector                 WorldLoc                       (Parm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector2D ULocalPlayer::Project(const struct FVector& WorldLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.Project"));

	ULocalPlayer_Project_Params params;
	params.WorldLoc = WorldLoc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.DeProject
// (Final, Defined, NetReliable, Native, Static)
// Parameters:
// struct FVector2D               RelativeScreenPos              (Parm)
// struct FVector                 WorldOrigin                    (Parm, OutParm)
// struct FVector                 WorldDirection                 (Parm, OutParm)

void ULocalPlayer::STATIC_DeProject(const struct FVector2D& RelativeScreenPos, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.DeProject"));

	ULocalPlayer_DeProject_Params params;
	params.RelativeScreenPos = RelativeScreenPos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldOrigin != nullptr)
		*WorldOrigin = params.WorldOrigin;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;
}


// Function Engine.LocalPlayer.TouchPlayerPostProcessChain
// (Final, Iterator, Singular, Exec, Native, Event, HasOptionalParms)

void ULocalPlayer::TouchPlayerPostProcessChain()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.TouchPlayerPostProcessChain"));

	ULocalPlayer_TouchPlayerPostProcessChain_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.GetPostProcessChain
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            InIndex                        (Parm)
// class UPostProcessChain*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPostProcessChain* ULocalPlayer::STATIC_GetPostProcessChain(int InIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.GetPostProcessChain"));

	ULocalPlayer_GetPostProcessChain_Params params;
	params.InIndex = InIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.RemoveAllPostProcessingChains
// (Defined, Latent, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalPlayer::RemoveAllPostProcessingChains()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.RemoveAllPostProcessingChains"));

	ULocalPlayer_RemoveAllPostProcessingChains_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.RemovePostProcessingChain
// (Final, Iterator, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// int                            InIndex                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalPlayer::RemovePostProcessingChain(int InIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.RemovePostProcessingChain"));

	ULocalPlayer_RemovePostProcessingChain_Params params;
	params.InIndex = InIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.InsertPostProcessingChain
// (Iterator, PreOperator, Net, NetReliable, Simulated, Operator, Static)
// Parameters:
// class UPostProcessChain*       InChain                        (Parm)
// int                            InIndex                        (Parm)
// bool                           bInClone                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalPlayer::STATIC_InsertPostProcessingChain(class UPostProcessChain* InChain, int InIndex, bool bInClone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.InsertPostProcessingChain"));

	ULocalPlayer_InsertPostProcessingChain_Params params;
	params.InChain = InChain;
	params.InIndex = InIndex;
	params.bInClone = bInClone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.InitPostProcessingChain
// (Iterator, PreOperator, Singular, Net, Simulated, Operator, Static)

void ULocalPlayer::STATIC_InitPostProcessingChain()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.InitPostProcessingChain"));

	ULocalPlayer_InitPostProcessingChain_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.GetTranslationContext
// (Defined, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UTranslationContext*     ReturnValue                    (Parm, OutParm, ReturnParm)

class UTranslationContext* ULocalPlayer::STATIC_GetTranslationContext()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.GetTranslationContext"));

	ULocalPlayer_GetTranslationContext_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.SetControllerId
// (Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            NewControllerId                (Parm)

void ULocalPlayer::SetControllerId(int NewControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.SetControllerId"));

	ULocalPlayer_SetControllerId_Params params;
	params.NewControllerId = NewControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.ClearPostProcessSettingsOverride
// (Final, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// float                          BlendOutTime                   (OptionalParm, Parm)

void ULocalPlayer::ClearPostProcessSettingsOverride(float BlendOutTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.ClearPostProcessSettingsOverride"));

	ULocalPlayer_ClearPostProcessSettingsOverride_Params params;
	params.BlendOutTime = BlendOutTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.OverridePostProcessSettingsCurve
// (Final, Defined, Iterator, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FPostProcessSettings    OverrideSettings               (Parm, NeedCtorLink)
// struct FInterpCurveFloat       Curve                          (Const, Parm, OutParm, NeedCtorLink)

void ULocalPlayer::STATIC_OverridePostProcessSettingsCurve(const struct FPostProcessSettings& OverrideSettings, struct FInterpCurveFloat* Curve)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.OverridePostProcessSettingsCurve"));

	ULocalPlayer_OverridePostProcessSettingsCurve_Params params;
	params.OverrideSettings = OverrideSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Curve != nullptr)
		*Curve = params.Curve;
}


// Function Engine.LocalPlayer.OverridePostProcessSettings
// (Defined, Iterator, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FPostProcessSettings    OverrideSettings               (Parm, NeedCtorLink)
// float                          BlendInTime                    (OptionalParm, Parm)

void ULocalPlayer::STATIC_OverridePostProcessSettings(const struct FPostProcessSettings& OverrideSettings, float BlendInTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.OverridePostProcessSettings"));

	ULocalPlayer_OverridePostProcessSettings_Params params;
	params.OverrideSettings = OverrideSettings;
	params.BlendInTime = BlendInTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.GetActorVisibility
// (Final, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  TestActor                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalPlayer::STATIC_GetActorVisibility(class AActor* TestActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.GetActorVisibility"));

	ULocalPlayer_GetActorVisibility_Params params;
	params.TestActor = TestActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalPlayer.SendSplitJoin
// (Defined, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void ULocalPlayer::SendSplitJoin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.SendSplitJoin"));

	ULocalPlayer_SendSplitJoin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalPlayer.SpawnPlayActor
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// struct FString                 OutError                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalPlayer::SpawnPlayActor(const struct FString& URL, struct FString* OutError)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalPlayer.SpawnPlayActor"));

	ULocalPlayer_SpawnPlayActor_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutError != nullptr)
		*OutError = params.OutError;

	return params.ReturnValue;
}


// Function Engine.PostProcessChain.FindPostProcessEffect
// (Iterator, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   EffectName                     (Parm)
// class UPostProcessEffect*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UPostProcessEffect* UPostProcessChain::STATIC_FindPostProcessEffect(const struct FName& EffectName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PostProcessChain.FindPostProcessEffect"));

	UPostProcessChain_FindPostProcessEffect_Params params;
	params.EffectName = EffectName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ReachSpec.IsBlockedFor
// (Defined, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UReachSpec::STATIC_IsBlockedFor(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReachSpec.IsBlockedFor"));

	UReachSpec_IsBlockedFor_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ReachSpec.GetDirection
// (Defined, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UReachSpec::STATIC_GetDirection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReachSpec.GetDirection"));

	UReachSpec_GetDirection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ReachSpec.GetEnd
// (PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* UReachSpec::STATIC_GetEnd()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReachSpec.GetEnd"));

	UReachSpec_GetEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ReachSpec.CostFor
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UReachSpec::STATIC_CostFor(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReachSpec.CostFor"));

	UReachSpec_CostFor_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SavedMove.GetDebugString
// (Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString USavedMove::GetDebugString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SavedMove.GetDebugString"));

	USavedMove_GetDebugString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SavedMove.CompressedFlags
// (Final, Defined, Iterator, Latent, Singular, Simulated, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char USavedMove::STATIC_CompressedFlags()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SavedMove.CompressedFlags"));

	USavedMove_CompressedFlags_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SavedMove.SetInitialPosition
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)

void USavedMove::SetInitialPosition(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SavedMove.SetInitialPosition"));

	USavedMove_SetInitialPosition_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SavedMove.Clear
// (Final, Defined, Iterator, Latent, NetReliable, Native, Event, HasOptionalParms)

void USavedMove::Clear()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SavedMove.Clear"));

	USavedMove_Clear_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SetHardwareMouseCursorVisibility
// (Defined, Iterator, Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bIsVisible                     (Parm)

void UGameViewportClient::SetHardwareMouseCursorVisibility(bool bIsVisible)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetHardwareMouseCursorVisibility"));

	UGameViewportClient_SetHardwareMouseCursorVisibility_Params params;
	params.bIsVisible = bIsVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.DebugSetUISystemEnabled
// (Defined, Latent, Singular, Net, Simulated, Exec, Static)
// Parameters:
// bool                           bOldUISystemActive             (Parm)
// bool                           bGFxUISystemActive             (Parm)

void UGameViewportClient::STATIC_DebugSetUISystemEnabled(bool bOldUISystemActive, bool bGFxUISystemActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DebugSetUISystemEnabled"));

	UGameViewportClient_DebugSetUISystemEnabled_Params params;
	params.bOldUISystemActive = bOldUISystemActive;
	params.bGFxUISystemActive = bGFxUISystemActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.IsScaleformEnabled
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_IsScaleformEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.IsScaleformEnabled"));

	UGameViewportClient_IsScaleformEnabled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.DisableScaleform
// (Defined, Iterator, Latent, Simulated, Native, Static)

void UGameViewportClient::STATIC_DisableScaleform()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DisableScaleform"));

	UGameViewportClient_DisableScaleform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.EnableScaleform
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void UGameViewportClient::STATIC_EnableScaleform()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.EnableScaleform"));

	UGameViewportClient_EnableScaleform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.BecomePrimaryPlayer
// (Simulated, Native, Operator)
// Parameters:
// int                            PlayerIndex                    (Parm)

void UGameViewportClient::BecomePrimaryPlayer(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.BecomePrimaryPlayer"));

	UGameViewportClient_BecomePrimaryPlayer_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.OnPrimaryPlayerSwitch
// (Final, Iterator, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class ULocalPlayer*            OldPrimaryPlayer               (Parm)
// class ULocalPlayer*            NewPrimaryPlayer               (Parm)

void UGameViewportClient::STATIC_OnPrimaryPlayerSwitch(class ULocalPlayer* OldPrimaryPlayer, class ULocalPlayer* NewPrimaryPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.OnPrimaryPlayerSwitch"));

	UGameViewportClient_OnPrimaryPlayerSwitch_Params params;
	params.OldPrimaryPlayer = OldPrimaryPlayer;
	params.NewPrimaryPlayer = NewPrimaryPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.FixupOwnerReferences
// (Defined, PreOperator, Singular, Net, NetReliable, Exec, Event, Static)
// Parameters:
// TArray<int>                    IDMappings                     (Parm, NeedCtorLink)

void UGameViewportClient::STATIC_FixupOwnerReferences(TArray<int> IDMappings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.FixupOwnerReferences"));

	UGameViewportClient_FixupOwnerReferences_Params params;
	params.IDMappings = IDMappings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.GetPlayerOwner
// (Defined, Iterator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ULocalPlayer* UGameViewportClient::STATIC_GetPlayerOwner(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetPlayerOwner"));

	UGameViewportClient_GetPlayerOwner_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.ClearProgressMessages
// (Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)

void UGameViewportClient::ClearProgressMessages()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.ClearProgressMessages"));

	UGameViewportClient_ClearProgressMessages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SetProgressTime
// (Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          T                              (Parm)

void UGameViewportClient::SetProgressTime(float T)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetProgressTime"));

	UGameViewportClient_SetProgressTime_Params params;
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.NotifyConnectionError
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// TEnumAsByte<EProgressMessageType> MessageType                    (Parm)
// struct FString                 Message                        (OptionalParm, Parm, NeedCtorLink)
// struct FString                 Title                          (OptionalParm, Parm, NeedCtorLink)

void UGameViewportClient::STATIC_NotifyConnectionError(TEnumAsByte<EProgressMessageType> MessageType, const struct FString& Message, const struct FString& Title)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.NotifyConnectionError"));

	UGameViewportClient_NotifyConnectionError_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.Title = Title;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SetProgressMessage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EProgressMessageType> MessageType                    (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)
// struct FString                 Title                          (OptionalParm, Parm, NeedCtorLink)
// bool                           bIgnoreFutureNetworkMessages   (OptionalParm, Parm)

void UGameViewportClient::SetProgressMessage(TEnumAsByte<EProgressMessageType> MessageType, const struct FString& Message, const struct FString& Title, bool bIgnoreFutureNetworkMessages)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetProgressMessage"));

	UGameViewportClient_SetProgressMessage_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.Title = Title;
	params.bIgnoreFutureNetworkMessages = bIgnoreFutureNetworkMessages;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.RemoveLocalPlayer
// (Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            ExistingPlayer                 (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameViewportClient::RemoveLocalPlayer(class ULocalPlayer* ExistingPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.RemoveLocalPlayer"));

	UGameViewportClient_RemoveLocalPlayer_Params params;
	params.ExistingPlayer = ExistingPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.AddLocalPlayer
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class ULocalPlayer*            NewPlayer                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameViewportClient::AddLocalPlayer(class ULocalPlayer* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.AddLocalPlayer"));

	UGameViewportClient_AddLocalPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.NotifyPlayerRemoved
// (Final, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            RemovedPlayer                  (Parm)

void UGameViewportClient::STATIC_NotifyPlayerRemoved(int PlayerIndex, class ULocalPlayer* RemovedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.NotifyPlayerRemoved"));

	UGameViewportClient_NotifyPlayerRemoved_Params params;
	params.PlayerIndex = PlayerIndex;
	params.RemovedPlayer = RemovedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.NotifyPlayerAdded
// (Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            AddedPlayer                    (Parm)

void UGameViewportClient::STATIC_NotifyPlayerAdded(int PlayerIndex, class ULocalPlayer* AddedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.NotifyPlayerAdded"));

	UGameViewportClient_NotifyPlayerAdded_Params params;
	params.PlayerIndex = PlayerIndex;
	params.AddedPlayer = AddedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.DrawTransitionMessage
// (Final, Latent, Singular, Net, Exec, Native, Static)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UGameViewportClient::STATIC_DrawTransitionMessage(class UCanvas* Canvas, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DrawTransitionMessage"));

	UGameViewportClient_DrawTransitionMessage_Params params;
	params.Canvas = Canvas;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.DrawTransition
// (Latent, Singular, Net, Exec, Native, Static)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UGameViewportClient::STATIC_DrawTransition(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DrawTransition"));

	UGameViewportClient_DrawTransition_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.DisplayProgressMessage
// (Defined, Iterator, Singular, Simulated, Native, Static)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UGameViewportClient::STATIC_DisplayProgressMessage(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DisplayProgressMessage"));

	UGameViewportClient_DisplayProgressMessage_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.PostRender
// (Final, Defined, Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UGameViewportClient::PostRender(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.PostRender"));

	UGameViewportClient_PostRender_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.DrawTitleSafeArea
// (Final, Defined, Iterator, Singular, Net, Exec, Native, Static)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UGameViewportClient::STATIC_DrawTitleSafeArea(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.DrawTitleSafeArea"));

	UGameViewportClient_DrawTitleSafeArea_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void UGameViewportClient::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.Tick"));

	UGameViewportClient_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.CalculateDeadZoneForAllSides
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// class ULocalPlayer*            LPlayer                        (Parm)
// class UCanvas*                 Canvas                         (Parm)
// float                          fTopSafeZone                   (Parm, OutParm)
// float                          fBottomSafeZone                (Parm, OutParm)
// float                          fLeftSafeZone                  (Parm, OutParm)
// float                          fRightSafeZone                 (Parm, OutParm)
// bool                           bUseMaxPercent                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::CalculateDeadZoneForAllSides(class ULocalPlayer* LPlayer, class UCanvas* Canvas, bool bUseMaxPercent, float* fTopSafeZone, float* fBottomSafeZone, float* fLeftSafeZone, float* fRightSafeZone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.CalculateDeadZoneForAllSides"));

	UGameViewportClient_CalculateDeadZoneForAllSides_Params params;
	params.LPlayer = LPlayer;
	params.Canvas = Canvas;
	params.bUseMaxPercent = bUseMaxPercent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (fTopSafeZone != nullptr)
		*fTopSafeZone = params.fTopSafeZone;
	if (fBottomSafeZone != nullptr)
		*fBottomSafeZone = params.fBottomSafeZone;
	if (fLeftSafeZone != nullptr)
		*fLeftSafeZone = params.fLeftSafeZone;
	if (fRightSafeZone != nullptr)
		*fRightSafeZone = params.fRightSafeZone;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.CalculateSafeZoneValues
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// float                          out_Horizontal                 (Parm, OutParm)
// float                          out_Vertical                   (Parm, OutParm)
// class UCanvas*                 Canvas                         (Parm)
// int                            LocalPlayerIndex               (Parm)
// bool                           bUseMaxPercent                 (Parm)

void UGameViewportClient::CalculateSafeZoneValues(class UCanvas* Canvas, int LocalPlayerIndex, bool bUseMaxPercent, float* out_Horizontal, float* out_Vertical)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.CalculateSafeZoneValues"));

	UGameViewportClient_CalculateSafeZoneValues_Params params;
	params.Canvas = Canvas;
	params.LocalPlayerIndex = LocalPlayerIndex;
	params.bUseMaxPercent = bUseMaxPercent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Horizontal != nullptr)
		*out_Horizontal = params.out_Horizontal;
	if (out_Vertical != nullptr)
		*out_Vertical = params.out_Vertical;
}


// Function Engine.GameViewportClient.GetPixelSizeOfScreen
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// float                          out_Width                      (Parm, OutParm)
// float                          out_Height                     (Parm, OutParm)
// class UCanvas*                 Canvas                         (Parm)
// int                            LocalPlayerIndex               (Parm)

void UGameViewportClient::STATIC_GetPixelSizeOfScreen(class UCanvas* Canvas, int LocalPlayerIndex, float* out_Width, float* out_Height)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetPixelSizeOfScreen"));

	UGameViewportClient_GetPixelSizeOfScreen_Params params;
	params.Canvas = Canvas;
	params.LocalPlayerIndex = LocalPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Width != nullptr)
		*out_Width = params.out_Width;
	if (out_Height != nullptr)
		*out_Height = params.out_Height;
}


// Function Engine.GameViewportClient.HasRightSafeZone
// (Final, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            LocalPlayerIndex               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_HasRightSafeZone(int LocalPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HasRightSafeZone"));

	UGameViewportClient_HasRightSafeZone_Params params;
	params.LocalPlayerIndex = LocalPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HasLeftSafeZone
// (Final, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            LocalPlayerIndex               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_HasLeftSafeZone(int LocalPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HasLeftSafeZone"));

	UGameViewportClient_HasLeftSafeZone_Params params;
	params.LocalPlayerIndex = LocalPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HasBottomSafeZone
// (Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            LocalPlayerIndex               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_HasBottomSafeZone(int LocalPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HasBottomSafeZone"));

	UGameViewportClient_HasBottomSafeZone_Params params;
	params.LocalPlayerIndex = LocalPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HasTopSafeZone
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            LocalPlayerIndex               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_HasTopSafeZone(int LocalPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HasTopSafeZone"));

	UGameViewportClient_HasTopSafeZone_Params params;
	params.LocalPlayerIndex = LocalPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.ConvertLocalPlayerToGamePlayerIndex
// (Defined, Iterator, Net, NetReliable, Simulated, Static)
// Parameters:
// class ULocalPlayer*            LPlayer                        (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameViewportClient::STATIC_ConvertLocalPlayerToGamePlayerIndex(class ULocalPlayer* LPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.ConvertLocalPlayerToGamePlayerIndex"));

	UGameViewportClient_ConvertLocalPlayerToGamePlayerIndex_Params params;
	params.LPlayer = LPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.GetSubtitleRegion
// (Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector2D               MinPos                         (Parm, OutParm)
// struct FVector2D               MaxPos                         (Parm, OutParm)

void UGameViewportClient::GetSubtitleRegion(struct FVector2D* MinPos, struct FVector2D* MaxPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetSubtitleRegion"));

	UGameViewportClient_GetSubtitleRegion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MinPos != nullptr)
		*MinPos = params.MinPos;
	if (MaxPos != nullptr)
		*MaxPos = params.MaxPos;
}


// Function Engine.GameViewportClient.LayoutPlayers
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UGameViewportClient::LayoutPlayers()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.LayoutPlayers"));

	UGameViewportClient_LayoutPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.UpdateActiveSplitscreenType
// (Net, Simulated, Exec, Native, Event, HasOptionalParms)

void UGameViewportClient::UpdateActiveSplitscreenType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.UpdateActiveSplitscreenType"));

	UGameViewportClient_UpdateActiveSplitscreenType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.GetSplitscreenConfiguration
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<ESplitScreenType>  ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ESplitScreenType> UGameViewportClient::STATIC_GetSplitscreenConfiguration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetSplitscreenConfiguration"));

	UGameViewportClient_GetSplitscreenConfiguration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.SetSplitscreenConfiguration
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ESplitScreenType>  SplitType                      (Parm)

void UGameViewportClient::SetSplitscreenConfiguration(TEnumAsByte<ESplitScreenType> SplitType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetSplitscreenConfiguration"));

	UGameViewportClient_SetSplitscreenConfiguration_Params params;
	params.SplitType = SplitType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.GameSessionEnded
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)

void UGameViewportClient::GameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GameSessionEnded"));

	UGameViewportClient_GameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.InsertInteraction
// (Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInteraction*            NewInteraction                 (Parm)
// int                            InIndex                        (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameViewportClient::InsertInteraction(class UInteraction* NewInteraction, int InIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.InsertInteraction"));

	UGameViewportClient_InsertInteraction_Params params;
	params.NewInteraction = NewInteraction;
	params.InIndex = InIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.CreateInitialPlayer
// (Final, Defined, Iterator, Exec, Static)
// Parameters:
// struct FString                 OutError                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_CreateInitialPlayer(struct FString* OutError)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.CreateInitialPlayer"));

	UGameViewportClient_CreateInitialPlayer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutError != nullptr)
		*OutError = params.OutError;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// struct FString                 OutError                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::Init(struct FString* OutError)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.Init"));

	UGameViewportClient_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutError != nullptr)
		*OutError = params.OutError;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.IsConsoleEnabled
// (Iterator, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_IsConsoleEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.IsConsoleEnabled"));

	UGameViewportClient_IsConsoleEnabled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.FindPlayerByControllerId
// (PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// class ULocalPlayer*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ULocalPlayer* UGameViewportClient::FindPlayerByControllerId(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.FindPlayerByControllerId"));

	UGameViewportClient_FindPlayerByControllerId_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.RemovePlayer
// (Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            ExPlayer                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::RemovePlayer(class ULocalPlayer* ExPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.RemovePlayer"));

	UGameViewportClient_RemovePlayer_Params params;
	params.ExPlayer = ExPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.CreatePlayer
// (Final, Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FString                 OutError                       (Parm, OutParm, NeedCtorLink)
// bool                           bSpawnActor                    (Parm)
// class ULocalPlayer*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ULocalPlayer* UGameViewportClient::CreatePlayer(int ControllerId, bool bSpawnActor, struct FString* OutError)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.CreatePlayer"));

	UGameViewportClient_CreatePlayer_Params params;
	params.ControllerId = ControllerId;
	params.bSpawnActor = bSpawnActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutError != nullptr)
		*OutError = params.OutError;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.SetMouse
// (Final, Latent, Event, HasOptionalParms)
// Parameters:
// int                            X                              (Parm)
// int                            Y                              (Parm)

void UGameViewportClient::SetMouse(int X, int Y)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetMouse"));

	UGameViewportClient_SetMouse_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.ForceUpdateMouseCursor
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// bool                           bSetCursor                     (Parm)

void UGameViewportClient::STATIC_ForceUpdateMouseCursor(bool bSetCursor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.ForceUpdateMouseCursor"));

	UGameViewportClient_ForceUpdateMouseCursor_Params params;
	params.bSetCursor = bSetCursor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.NotifySplitscreenLayoutChanged
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)

void UGameViewportClient::STATIC_NotifySplitscreenLayoutChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.NotifySplitscreenLayoutChanged"));

	UGameViewportClient_NotifySplitscreenLayoutChanged_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SetCustomInteractionObject
// (Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UInteraction*            InInteraction                  (Parm)

void UGameViewportClient::SetCustomInteractionObject(class UInteraction* InInteraction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.SetCustomInteractionObject"));

	UGameViewportClient_SetCustomInteractionObject_Params params;
	params.InInteraction = InInteraction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.GetCustomInteractionClass
// (Final, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            InIndex                        (Parm)
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* UGameViewportClient::STATIC_GetCustomInteractionClass(int InIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetCustomInteractionClass"));

	UGameViewportClient_GetCustomInteractionClass_Params params;
	params.InIndex = InIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.GetNumCustomInteractions
// (Final, Defined, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameViewportClient::STATIC_GetNumCustomInteractions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetNumCustomInteractions"));

	UGameViewportClient_GetNumCustomInteractions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.ShouldForceFullscreenViewport
// (Final, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::ShouldForceFullscreenViewport()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.ShouldForceFullscreenViewport"));

	UGameViewportClient_ShouldForceFullscreenViewport_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.GetMousePosition
// (Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector2D UGameViewportClient::STATIC_GetMousePosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetMousePosition"));

	UGameViewportClient_GetMousePosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.IsFullScreenViewport
// (Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::STATIC_IsFullScreenViewport()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.IsFullScreenViewport"));

	UGameViewportClient_IsFullScreenViewport_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.GetViewportSize
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector2D               out_ViewportSize               (Parm, OutParm)

void UGameViewportClient::STATIC_GetViewportSize(struct FVector2D* out_ViewportSize)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.GetViewportSize"));

	UGameViewportClient_GetViewportSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_ViewportSize != nullptr)
		*out_ViewportSize = params.out_ViewportSize;
}


// Function Engine.GameViewportClient.ConsoleCommand
// (Iterator, Latent, Singular, Net, Simulated, Static)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UGameViewportClient::STATIC_ConsoleCommand(const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.ConsoleCommand"));

	UGameViewportClient_ConsoleCommand_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HandleInputChar
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FString                 Unicode                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::HandleInputChar(int ControllerId, const struct FString& Unicode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HandleInputChar"));

	UGameViewportClient_HandleInputChar_Params params;
	params.ControllerId = ControllerId;
	params.Unicode = Unicode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HandleInputAxis
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FName                   Key                            (Parm)
// float                          Delta                          (Parm)
// float                          DeltaTime                      (Parm)
// bool                           bGamepad                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::HandleInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime, bool bGamepad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HandleInputAxis"));

	UGameViewportClient_HandleInputAxis_Params params;
	params.ControllerId = ControllerId;
	params.Key = Key;
	params.Delta = Delta;
	params.DeltaTime = DeltaTime;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameViewportClient.HandleInputKey
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FName                   Key                            (Parm)
// TEnumAsByte<EInputEvent>       EventType                      (Parm)
// float                          AmountDepressed                (Parm)
// bool                           bGamepad                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameViewportClient::HandleInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> EventType, float AmountDepressed, bool bGamepad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameViewportClient.HandleInputKey"));

	UGameViewportClient_HandleInputKey_Params params;
	params.ControllerId = ControllerId;
	params.Key = Key;
	params.EventType = EventType;
	params.AmountDepressed = AmountDepressed;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.UpdateFromURL
// (Iterator, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Const, Parm, OutParm, NeedCtorLink)
// class AGameInfo*               Game                           (Parm)

void USettings::UpdateFromURL(class AGameInfo* Game, struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.UpdateFromURL"));

	USettings_UpdateFromURL_Params params;
	params.Game = Game;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;
}


// Function Engine.Settings.BuildURL
// (Defined, PreOperator, Singular, Net, Native, Event, Operator)
// Parameters:
// struct FString                 URL                            (Parm, OutParm, NeedCtorLink)

void USettings::BuildURL(struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.BuildURL"));

	USettings_BuildURL_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;
}


// Function Engine.Settings.AppendContextsToURL
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Operator)
// Parameters:
// struct FString                 URL                            (Parm, OutParm, NeedCtorLink)

void USettings::AppendContextsToURL(struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.AppendContextsToURL"));

	USettings_AppendContextsToURL_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;
}


// Function Engine.Settings.AppendPropertiesToURL
// (Defined, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct FString                 URL                            (Parm, OutParm, NeedCtorLink)

void USettings::AppendPropertiesToURL(struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.AppendPropertiesToURL"));

	USettings_AppendPropertiesToURL_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;
}


// Function Engine.Settings.AppendDataBindingsToURL
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Operator)
// Parameters:
// struct FString                 URL                            (Parm, OutParm, NeedCtorLink)

void USettings::AppendDataBindingsToURL(struct FString* URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.AppendDataBindingsToURL"));

	USettings_AppendDataBindingsToURL_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (URL != nullptr)
		*URL = params.URL;
}


// Function Engine.Settings.GetQoSAdvertisedStringSettings
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FLocalizedStringSetting> QoSSettings                    (Parm, OutParm, NeedCtorLink)

void USettings::STATIC_GetQoSAdvertisedStringSettings(TArray<struct FLocalizedStringSetting>* QoSSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetQoSAdvertisedStringSettings"));

	USettings_GetQoSAdvertisedStringSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (QoSSettings != nullptr)
		*QoSSettings = params.QoSSettings;
}


// Function Engine.Settings.GetQoSAdvertisedProperties
// (Defined, Iterator, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FSettingsProperty> QoSProps                       (Parm, OutParm, NeedCtorLink)

void USettings::STATIC_GetQoSAdvertisedProperties(TArray<struct FSettingsProperty>* QoSProps)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetQoSAdvertisedProperties"));

	USettings_GetQoSAdvertisedProperties_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (QoSProps != nullptr)
		*QoSProps = params.QoSProps;
}


// Function Engine.Settings.GetRangedPropertyValue
// (Final, Defined, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetRangedPropertyValue(int PropertyId, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetRangedPropertyValue"));

	USettings_GetRangedPropertyValue_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.Settings.SetRangedPropertyValue
// (Final, Defined, Iterator, Net, Event, HasOptionalParms)
// Parameters:
// int                            PropertyId                     (Parm)
// float                          NewValue                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::SetRangedPropertyValue(int PropertyId, float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetRangedPropertyValue"));

	USettings_SetRangedPropertyValue_Params params;
	params.PropertyId = PropertyId;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyRange
// (Final, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// float                          OutMinValue                    (Parm, OutParm)
// float                          OutMaxValue                    (Parm, OutParm)
// float                          RangeIncrement                 (Parm, OutParm)
// unsigned char                  bFormatAsInt                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetPropertyRange(int PropertyId, float* OutMinValue, float* OutMaxValue, float* RangeIncrement, unsigned char* bFormatAsInt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyRange"));

	USettings_GetPropertyRange_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMinValue != nullptr)
		*OutMinValue = params.OutMinValue;
	if (OutMaxValue != nullptr)
		*OutMaxValue = params.OutMaxValue;
	if (RangeIncrement != nullptr)
		*RangeIncrement = params.RangeIncrement;
	if (bFormatAsInt != nullptr)
		*bFormatAsInt = params.bFormatAsInt;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyMappingType
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// TEnumAsByte<EPropertyValueMappingType> OutType                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetPropertyMappingType(int PropertyId, TEnumAsByte<EPropertyValueMappingType>* OutType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyMappingType"));

	USettings_GetPropertyMappingType_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutType != nullptr)
		*OutType = params.OutType;

	return params.ReturnValue;
}


// Function Engine.Settings.HasStringSetting
// (Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            SettingId                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_HasStringSetting(int SettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.HasStringSetting"));

	USettings_HasStringSetting_Params params;
	params.SettingId = SettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.HasProperty
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_HasProperty(int PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.HasProperty"));

	USettings_HasProperty_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.UpdateProperties
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// TArray<struct FSettingsProperty> Props                          (Const, Parm, OutParm, NeedCtorLink)
// bool                           bShouldAddIfMissing            (OptionalParm, Parm)

void USettings::UpdateProperties(bool bShouldAddIfMissing, TArray<struct FSettingsProperty>* Props)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.UpdateProperties"));

	USettings_UpdateProperties_Params params;
	params.bShouldAddIfMissing = bShouldAddIfMissing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Props != nullptr)
		*Props = params.Props;
}


// Function Engine.Settings.UpdateStringSettings
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// TArray<struct FLocalizedStringSetting> Settings                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           bShouldAddIfMissing            (OptionalParm, Parm)

void USettings::UpdateStringSettings(bool bShouldAddIfMissing, TArray<struct FLocalizedStringSetting>* Settings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.UpdateStringSettings"));

	USettings_UpdateStringSettings_Params params;
	params.bShouldAddIfMissing = bShouldAddIfMissing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Settings != nullptr)
		*Settings = params.Settings;
}


// Function Engine.Settings.GetPropertyType
// (Defined, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// TEnumAsByte<ESettingsDataType> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ESettingsDataType> USettings::STATIC_GetPropertyType(int PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyType"));

	USettings_GetPropertyType_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyValueId
// (Final, Defined, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// int                            ValueId                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetPropertyValueId(int PropertyId, int* ValueId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyValueId"));

	USettings_GetPropertyValueId_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ValueId != nullptr)
		*ValueId = params.ValueId;

	return params.ReturnValue;
}


// Function Engine.Settings.SetPropertyValueId
// (Defined, Net, Event, HasOptionalParms)
// Parameters:
// int                            PropertyId                     (Parm)
// int                            ValueId                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::SetPropertyValueId(int PropertyId, int ValueId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetPropertyValueId"));

	USettings_SetPropertyValueId_Params params;
	params.PropertyId = PropertyId;
	params.ValueId = ValueId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringProperty
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetStringProperty(int PropertyId, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringProperty"));

	USettings_GetStringProperty_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.Settings.SetStringProperty
// (Final, Iterator, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            PropertyId                     (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)

void USettings::SetStringProperty(int PropertyId, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetStringProperty"));

	USettings_SetStringProperty_Params params;
	params.PropertyId = PropertyId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Settings.GetIntProperty
// (Defined, Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// int                            Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetIntProperty(int PropertyId, int* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetIntProperty"));

	USettings_GetIntProperty_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.Settings.SetIntProperty
// (Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            PropertyId                     (Parm)
// int                            Value                          (Parm)

void USettings::SetIntProperty(int PropertyId, int Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetIntProperty"));

	USettings_SetIntProperty_Params params;
	params.PropertyId = PropertyId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Settings.GetFloatProperty
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// float                          Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetFloatProperty(int PropertyId, float* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetFloatProperty"));

	USettings_GetFloatProperty_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.Settings.SetFloatProperty
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            PropertyId                     (Parm)
// float                          Value                          (Parm)

void USettings::SetFloatProperty(int PropertyId, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetFloatProperty"));

	USettings_SetFloatProperty_Params params;
	params.PropertyId = PropertyId;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Settings.SetPropertyFromStringByName
// (Final, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   PropertyName                   (Parm)
// struct FString                 NewValue                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::SetPropertyFromStringByName(const struct FName& PropertyName, struct FString* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetPropertyFromStringByName"));

	USettings_SetPropertyFromStringByName_Params params;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewValue != nullptr)
		*NewValue = params.NewValue;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyAsStringByName
// (Iterator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   PropertyName                   (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString USettings::STATIC_GetPropertyAsStringByName(const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyAsStringByName"));

	USettings_GetPropertyAsStringByName_Params params;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyAsString
// (Final, Defined, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString USettings::STATIC_GetPropertyAsString(int PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyAsString"));

	USettings_GetPropertyAsString_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyColumnHeader
// (Final, Iterator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString USettings::STATIC_GetPropertyColumnHeader(int PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyColumnHeader"));

	USettings_GetPropertyColumnHeader_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyName
// (Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            PropertyId                     (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USettings::STATIC_GetPropertyName(int PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyName"));

	USettings_GetPropertyName_Params params;
	params.PropertyId = PropertyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetPropertyId
// (Defined, Iterator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   PropertyName                   (Parm)
// int                            PropertyId                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetPropertyId(const struct FName& PropertyName, int* PropertyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetPropertyId"));

	USettings_GetPropertyId_Params params;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PropertyId != nullptr)
		*PropertyId = params.PropertyId;

	return params.ReturnValue;
}


// Function Engine.Settings.SetStringSettingValueFromStringByName
// (Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   StringSettingName              (Parm)
// struct FString                 NewValue                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::SetStringSettingValueFromStringByName(const struct FName& StringSettingName, struct FString* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetStringSettingValueFromStringByName"));

	USettings_SetStringSettingValueFromStringByName_Params params;
	params.StringSettingName = StringSettingName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewValue != nullptr)
		*NewValue = params.NewValue;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingValueNameByName
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   StringSettingName              (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USettings::STATIC_GetStringSettingValueNameByName(const struct FName& StringSettingName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingValueNameByName"));

	USettings_GetStringSettingValueNameByName_Params params;
	params.StringSettingName = StringSettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingValueName
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// int                            ValueIndex                     (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USettings::STATIC_GetStringSettingValueName(int StringSettingId, int ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingValueName"));

	USettings_GetStringSettingValueName_Params params;
	params.StringSettingId = StringSettingId;
	params.ValueIndex = ValueIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.IsWildcardStringSetting
// (Final, Iterator, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_IsWildcardStringSetting(int StringSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.IsWildcardStringSetting"));

	USettings_IsWildcardStringSetting_Params params;
	params.StringSettingId = StringSettingId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingColumnHeader
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString USettings::STATIC_GetStringSettingColumnHeader(int StringSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingColumnHeader"));

	USettings_GetStringSettingColumnHeader_Params params;
	params.StringSettingId = StringSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingName
// (Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USettings::STATIC_GetStringSettingName(int StringSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingName"));

	USettings_GetStringSettingName_Params params;
	params.StringSettingId = StringSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingId
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   StringSettingName              (Parm)
// int                            StringSettingId                (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetStringSettingId(const struct FName& StringSettingName, int* StringSettingId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingId"));

	USettings_GetStringSettingId_Params params;
	params.StringSettingName = StringSettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StringSettingId != nullptr)
		*StringSettingId = params.StringSettingId;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingValueByName
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   StringSettingName              (Parm)
// int                            ValueIndex                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetStringSettingValueByName(const struct FName& StringSettingName, int* ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingValueByName"));

	USettings_GetStringSettingValueByName_Params params;
	params.StringSettingName = StringSettingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ValueIndex != nullptr)
		*ValueIndex = params.ValueIndex;

	return params.ReturnValue;
}


// Function Engine.Settings.SetStringSettingValueByName
// (Final, Defined, Iterator, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   StringSettingName              (Parm)
// int                            ValueIndex                     (Parm)
// bool                           bShouldAutoAdd                 (Parm)

void USettings::SetStringSettingValueByName(const struct FName& StringSettingName, int ValueIndex, bool bShouldAutoAdd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetStringSettingValueByName"));

	USettings_SetStringSettingValueByName_Params params;
	params.StringSettingName = StringSettingName;
	params.ValueIndex = ValueIndex;
	params.bShouldAutoAdd = bShouldAutoAdd;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Settings.GetStringSettingValueNames
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// TArray<struct FIdToStringMapping> Values                         (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetStringSettingValueNames(int StringSettingId, TArray<struct FIdToStringMapping>* Values)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingValueNames"));

	USettings_GetStringSettingValueNames_Params params;
	params.StringSettingId = StringSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Values != nullptr)
		*Values = params.Values;

	return params.ReturnValue;
}


// Function Engine.Settings.IncrementStringSettingValue
// (Simulated, Operator, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// int                            Direction                      (Parm)
// bool                           bShouldWrap                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_IncrementStringSettingValue(int StringSettingId, int Direction, bool bShouldWrap)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.IncrementStringSettingValue"));

	USettings_IncrementStringSettingValue_Params params;
	params.StringSettingId = StringSettingId;
	params.Direction = Direction;
	params.bShouldWrap = bShouldWrap;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Settings.GetStringSettingValue
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            StringSettingId                (Parm)
// int                            ValueIndex                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USettings::STATIC_GetStringSettingValue(int StringSettingId, int* ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetStringSettingValue"));

	USettings_GetStringSettingValue_Params params;
	params.StringSettingId = StringSettingId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ValueIndex != nullptr)
		*ValueIndex = params.ValueIndex;

	return params.ReturnValue;
}


// Function Engine.Settings.SetStringSettingValue
// (Defined, Iterator, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            StringSettingId                (Parm)
// int                            ValueIndex                     (Parm)
// bool                           bShouldAutoAdd                 (OptionalParm, Parm)

void USettings::SetStringSettingValue(int StringSettingId, int ValueIndex, bool bShouldAutoAdd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetStringSettingValue"));

	USettings_SetStringSettingValue_Params params;
	params.StringSettingId = StringSettingId;
	params.ValueIndex = ValueIndex;
	params.bShouldAutoAdd = bShouldAutoAdd;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Settings.GetSettingsDataDateTime
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// int                            OutInt1                        (Parm, OutParm)
// int                            OutInt2                        (Parm, OutParm)

void USettings::STATIC_GetSettingsDataDateTime(struct FSettingsData* Data, int* OutInt1, int* OutInt2)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetSettingsDataDateTime"));

	USettings_GetSettingsDataDateTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
	if (OutInt1 != nullptr)
		*OutInt1 = params.OutInt1;
	if (OutInt2 != nullptr)
		*OutInt2 = params.OutInt2;
}


// Function Engine.Settings.GetSettingsDataBlob
// (Defined, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// TArray<unsigned char>          OutBlob                        (Parm, OutParm, NeedCtorLink)

void USettings::STATIC_GetSettingsDataBlob(struct FSettingsData* Data, TArray<unsigned char>* OutBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetSettingsDataBlob"));

	USettings_GetSettingsDataBlob_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
	if (OutBlob != nullptr)
		*OutBlob = params.OutBlob;
}


// Function Engine.Settings.GetSettingsDataInt
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USettings::STATIC_GetSettingsDataInt(struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetSettingsDataInt"));

	USettings_GetSettingsDataInt_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

	return params.ReturnValue;
}


// Function Engine.Settings.GetSettingsDataFloat
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USettings::STATIC_GetSettingsDataFloat(struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.GetSettingsDataFloat"));

	USettings_GetSettingsDataFloat_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

	return params.ReturnValue;
}


// Function Engine.Settings.EmptySettingsData
// (Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)

void USettings::STATIC_EmptySettingsData(struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.EmptySettingsData"));

	USettings_EmptySettingsData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.Settings.SetSettingsData
// (Final, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// struct FSettingsData           Data2Copy                      (Parm, OutParm)

void USettings::SetSettingsData(struct FSettingsData* Data, struct FSettingsData* Data2Copy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetSettingsData"));

	USettings_SetSettingsData_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
	if (Data2Copy != nullptr)
		*Data2Copy = params.Data2Copy;
}


// Function Engine.Settings.SetSettingsDataBlob
// (Defined, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// TArray<unsigned char>          InBlob                         (Parm, OutParm, NeedCtorLink)

void USettings::SetSettingsDataBlob(struct FSettingsData* Data, TArray<unsigned char>* InBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetSettingsDataBlob"));

	USettings_SetSettingsDataBlob_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
	if (InBlob != nullptr)
		*InBlob = params.InBlob;
}


// Function Engine.Settings.SetSettingsDataDateTime
// (Final, Defined, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// int                            InInt1                         (Parm)
// int                            InInt2                         (Parm)

void USettings::SetSettingsDataDateTime(int InInt1, int InInt2, struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetSettingsDataDateTime"));

	USettings_SetSettingsDataDateTime_Params params;
	params.InInt1 = InInt1;
	params.InInt2 = InInt2;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.Settings.SetSettingsDataInt
// (Final, Iterator, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// int                            InInt                          (Parm)

void USettings::SetSettingsDataInt(int InInt, struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetSettingsDataInt"));

	USettings_SetSettingsDataInt_Params params;
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.Settings.SetSettingsDataFloat
// (Iterator, Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FSettingsData           Data                           (Parm, OutParm)
// float                          InFloat                        (Parm)

void USettings::SetSettingsDataFloat(float InFloat, struct FSettingsData* Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Settings.SetSettingsDataFloat"));

	USettings_SetSettingsDataFloat_Params params;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.OnlineGameSearch.GetNamedProperty
// (Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FName                   PropertyName                   (Parm)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameSearch::GetNamedProperty(const struct FName& PropertyName, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameSearch.GetNamedProperty"));

	UOnlineGameSearch_GetNamedProperty_Params params;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.OnlineGameSearch.SetNamedProperty
// (Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   PropertyName                   (Parm)
// struct FString                 Value                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameSearch::SetNamedProperty(const struct FName& PropertyName, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameSearch.SetNamedProperty"));

	UOnlineGameSearch_SetNamedProperty_Params params;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameSearch.SortSearchResults
// (Defined, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void UOnlineGameSearch::SortSearchResults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameSearch.SortSearchResults"));

	UOnlineGameSearch_SortSearchResults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameSearch.SetSkillOverride
// (Defined, Iterator, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// int                            LeaderboardId                  (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)

void UOnlineGameSearch::SetSkillOverride(int LeaderboardId, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameSearch.SetSkillOverride"));

	UOnlineGameSearch_SetSkillOverride_Params params;
	params.LeaderboardId = LeaderboardId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;
}


// Function Engine.Surface.GetSurfaceHeight
// (Defined, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USurface::STATIC_GetSurfaceHeight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Surface.GetSurfaceHeight"));

	USurface_GetSurfaceHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Surface.GetSurfaceWidth
// (Final, Defined, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USurface::STATIC_GetSurfaceWidth()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Surface.GetSurfaceWidth"));

	USurface_GetSurfaceWidth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.SetForceMipLevelsToBeResident
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           OverrideForceMiplevelsToBeResident (Parm)
// bool                           bForceMiplevelsToBeResidentValue (Parm)
// float                          ForceDuration                  (Parm)
// TArray<unsigned char>          CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void UMaterialInterface::SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, TArray<unsigned char> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.SetForceMipLevelsToBeResident"));

	UMaterialInterface_SetForceMipLevelsToBeResident_Params params;
	params.OverrideForceMiplevelsToBeResident = OverrideForceMiplevelsToBeResident;
	params.bForceMiplevelsToBeResidentValue = bForceMiplevelsToBeResidentValue;
	params.ForceDuration = ForceDuration;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInterface.GetMobileVectorParameterValue
// (Final, Defined, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetMobileVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetMobileVectorParameterValue"));

	UMaterialInterface_GetMobileVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetMobileTextureParameterValue
// (Defined, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetMobileTextureParameterValue(const struct FName& ParameterName, class UTexture** OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetMobileTextureParameterValue"));

	UMaterialInterface_GetMobileTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetMobileScalarParameterValue
// (Final, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetMobileScalarParameterValue(const struct FName& ParameterName, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetMobileScalarParameterValue"));

	UMaterialInterface_GetMobileScalarParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetGroupName
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FName                   GroupName                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetGroupName(const struct FName& ParameterName, struct FName* GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetGroupName"));

	UMaterialInterface_GetGroupName_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (GroupName != nullptr)
		*GroupName = params.GroupName;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetLinearColorCurveParameterValue
// (Final, Defined, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveLinearColor OutValue                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetLinearColorCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveLinearColor* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetLinearColorCurveParameterValue"));

	UMaterialInterface_GetLinearColorCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetLinearColorParameterValue
// (Iterator, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetLinearColorParameterValue(const struct FName& ParameterName, struct FLinearColor* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetLinearColorParameterValue"));

	UMaterialInterface_GetLinearColorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetVectorCurveParameterValue
// (Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveVector      OutValue                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetVectorCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveVector* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetVectorCurveParameterValue"));

	UMaterialInterface_GetVectorCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetVectorParameterValue
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetVectorParameterValue"));

	UMaterialInterface_GetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetTextureParameterValue
// (Final, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetTextureParameterValue(const struct FName& ParameterName, class UTexture** OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetTextureParameterValue"));

	UMaterialInterface_GetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetScalarCurveParameterValue
// (Final, Defined, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveFloat       OutValue                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetScalarCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveFloat* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetScalarCurveParameterValue"));

	UMaterialInterface_GetScalarCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetScalarParameterValue
// (Iterator, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetScalarParameterValue(const struct FName& ParameterName, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetScalarParameterValue"));

	UMaterialInterface_GetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetFontParameterValue
// (Final, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UFont*                   OutFontValue                   (Parm, OutParm)
// int                            OutFontPage                    (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetFontParameterValue(const struct FName& ParameterName, class UFont** OutFontValue, int* OutFontPage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetFontParameterValue"));

	UMaterialInterface_GetFontParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFontValue != nullptr)
		*OutFontValue = params.OutFontValue;
	if (OutFontPage != nullptr)
		*OutFontPage = params.OutFontPage;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetParameterDesc
// (Final, Defined, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FString                 OutDesc                        (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInterface::STATIC_GetParameterDesc(const struct FName& ParameterName, struct FString* OutDesc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetParameterDesc"));

	UMaterialInterface_GetParameterDesc_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutDesc != nullptr)
		*OutDesc = params.OutDesc;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetPhysicalMaterial
// (Final, Defined, Iterator, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UPhysicalMaterial*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicalMaterial* UMaterialInterface::STATIC_GetPhysicalMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetPhysicalMaterial"));

	UMaterialInterface_GetPhysicalMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetMaterial
// (PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// class UMaterial*               ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterial* UMaterialInterface::STATIC_GetMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInterface.GetMaterial"));

	UMaterialInterface_GetMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.HasLocalEmitter
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystem::STATIC_HasLocalEmitter()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.HasLocalEmitter"));

	UParticleSystem_HasLocalEmitter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.GetMaxLifespan
// (Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          InComponentDelay               (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UParticleSystem::STATIC_GetMaxLifespan(float InComponentDelay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.GetMaxLifespan"));

	UParticleSystem_GetMaxLifespan_Params params;
	params.InComponentDelay = InComponentDelay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.SetLODDistance
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            LODLevelIndex                  (Parm)
// float                          InDistance                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystem::SetLODDistance(int LODLevelIndex, float InDistance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.SetLODDistance"));

	UParticleSystem_SetLODDistance_Params params;
	params.LODLevelIndex = LODLevelIndex;
	params.InDistance = InDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.SetCurrentLODMethod
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EParticleSystemLODMethod> InMethod                       (Parm)

void UParticleSystem::SetCurrentLODMethod(TEnumAsByte<EParticleSystemLODMethod> InMethod)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.SetCurrentLODMethod"));

	UParticleSystem_SetCurrentLODMethod_Params params;
	params.InMethod = InMethod;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystem.GetLODDistance
// (Final, Defined, Iterator, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            LODLevelIndex                  (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UParticleSystem::STATIC_GetLODDistance(int LODLevelIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.GetLODDistance"));

	UParticleSystem_GetLODDistance_Params params;
	params.LODLevelIndex = LODLevelIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.GetLODLevelCount
// (Final, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UParticleSystem::STATIC_GetLODLevelCount()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.GetLODLevelCount"));

	UParticleSystem_GetLODLevelCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystem.GetCurrentLODMethod
// (Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EParticleSystemLODMethod> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EParticleSystemLODMethod> UParticleSystem::STATIC_GetCurrentLODMethod()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystem.GetCurrentLODMethod"));

	UParticleSystem_GetCurrentLODMethod_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2D.Create
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// int                            InSizeX                        (Parm)
// int                            InSizeY                        (Parm)
// TEnumAsByte<EPixelFormat>      InFormat                       (OptionalParm, Parm)
// class UTexture2D*              ReturnValue                    (Parm, OutParm, ReturnParm)

class UTexture2D* UTexture2D::Create(int InSizeX, int InSizeY, TEnumAsByte<EPixelFormat> InFormat)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2D.Create"));

	UTexture2D_Create_Params params;
	params.InSizeX = InSizeX;
	params.InSizeY = InSizeY;
	params.InFormat = InFormat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2D.SetForceMipLevelsToBeResident
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          Seconds                        (Parm)
// TArray<TEnumAsByte<ETextureGroup>> CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void UTexture2D::SetForceMipLevelsToBeResident(float Seconds, TArray<TEnumAsByte<ETextureGroup>> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2D.SetForceMipLevelsToBeResident"));

	UTexture2D_SetForceMipLevelsToBeResident_Params params;
	params.Seconds = Seconds;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TranslationContext.RegisterTranslatorTag
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class UTranslatorTag*          InTagHandler                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTranslationContext::RegisterTranslatorTag(class UTranslatorTag* InTagHandler)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TranslationContext.RegisterTranslatorTag"));

	UTranslationContext_RegisterTranslatorTag_Params params;
	params.InTagHandler = InTagHandler;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TranslatorTag.Translate
// (Final, Iterator, Singular, Net, NetReliable, Exec, Native, Operator, HasOptionalParms)
// Parameters:
// struct FString                 InArgument                     (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UTranslatorTag::Translate(const struct FString& InArgument)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TranslatorTag.Translate"));

	UTranslatorTag_Translate_Params params;
	params.InArgument = InArgument;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StringsTag.Translate
// (Final, Iterator, Singular, Net, NetReliable, Exec, Native, Operator, HasOptionalParms)
// Parameters:
// struct FString                 InArgument                     (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UStringsTag::Translate(const struct FString& InArgument)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StringsTag.Translate"));

	UStringsTag_Translate_Params params;
	params.InArgument = InArgument;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.SafeCaps
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 StringToCap                    (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UUIRoot::SafeCaps(const struct FString& StringToCap)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.SafeCaps"));

	UUIRoot_SafeCaps_Params params;
	params.StringToCap = StringToCap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetOnlinePlayerInterfaceEx
// (Defined, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterfaceEx> ReturnValue                    (Parm, OutParm, ReturnParm)

TScriptInterface<class UOnlinePlayerInterfaceEx> UUIRoot::STATIC_GetOnlinePlayerInterfaceEx()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetOnlinePlayerInterfaceEx"));

	UUIRoot_GetOnlinePlayerInterfaceEx_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetOnlinePlayerInterface
// (Final, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> ReturnValue                    (Parm, OutParm, ReturnParm)

TScriptInterface<class UOnlinePlayerInterface> UUIRoot::STATIC_GetOnlinePlayerInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetOnlinePlayerInterface"));

	UUIRoot_GetOnlinePlayerInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetOnlineGameInterface
// (Singular, Net, Exec, Native, Event, Static)
// Parameters:
// TScriptInterface<class UOnlineGameInterface> ReturnValue                    (Parm, OutParm, ReturnParm)

TScriptInterface<class UOnlineGameInterface> UUIRoot::STATIC_GetOnlineGameInterface()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetOnlineGameInterface"));

	UUIRoot_GetOnlineGameInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.StaticResolveDataStore
// (Defined, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   DataStoreTag                   (Parm)
// class ULocalPlayer*            InPlayerOwner                  (OptionalParm, Parm)
// class UUIDataStore*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIDataStore* UUIRoot::StaticResolveDataStore(const struct FName& DataStoreTag, class ULocalPlayer* InPlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.StaticResolveDataStore"));

	UUIRoot_StaticResolveDataStore_Params params;
	params.DataStoreTag = DataStoreTag;
	params.InPlayerOwner = InPlayerOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetSceneClient
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class UGameUISceneClient*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UGameUISceneClient* UUIRoot::STATIC_GetSceneClient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetSceneClient"));

	UUIRoot_GetSceneClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetCurrentUIController
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UUIInteraction*          ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIInteraction* UUIRoot::STATIC_GetCurrentUIController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetCurrentUIController"));

	UUIRoot_GetCurrentUIController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIRoot.GetInputPlatformType
// (Defined, Latent, Exec, Native, Event, Static)
// Parameters:
// class ULocalPlayer*            OwningPlayer                   (OptionalParm, Parm)
// TEnumAsByte<EInputPlatformType> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EInputPlatformType> UUIRoot::STATIC_GetInputPlatformType(class ULocalPlayer* OwningPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIRoot.GetInputPlatformType"));

	UUIRoot_GetInputPlatformType_Params params;
	params.OwningPlayer = OwningPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Interaction.NotifyPlayerRemoved
// (Final, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            RemovedPlayer                  (Parm)

void UInteraction::STATIC_NotifyPlayerRemoved(int PlayerIndex, class ULocalPlayer* RemovedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.NotifyPlayerRemoved"));

	UInteraction_NotifyPlayerRemoved_Params params;
	params.PlayerIndex = PlayerIndex;
	params.RemovedPlayer = RemovedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.NotifyPlayerAdded
// (Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            AddedPlayer                    (Parm)

void UInteraction::STATIC_NotifyPlayerAdded(int PlayerIndex, class ULocalPlayer* AddedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.NotifyPlayerAdded"));

	UInteraction_NotifyPlayerAdded_Params params;
	params.PlayerIndex = PlayerIndex;
	params.AddedPlayer = AddedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UInteraction::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.NotifyGameSessionEnded"));

	UInteraction_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.Initialized
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Event, Operator)

void UInteraction::Initialized()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.Initialized"));

	UInteraction_Initialized_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.OnInitialize
// (Defined, Iterator, PreOperator, Exec, Native, HasOptionalParms)

void UInteraction::OnInitialize()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.OnInitialize"));

	UInteraction_OnInitialize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UInteraction::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.Init"));

	UInteraction_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.PostRender
// (Final, Defined, Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UInteraction::PostRender(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.PostRender"));

	UInteraction_PostRender_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void UInteraction::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.Tick"));

	UInteraction_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Interaction.OnReceivedNativeInputChar
// (Singular, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FString                 Unicode                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInteraction::OnReceivedNativeInputChar(int ControllerId, const struct FString& Unicode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.OnReceivedNativeInputChar"));

	UInteraction_OnReceivedNativeInputChar_Params params;
	params.ControllerId = ControllerId;
	params.Unicode = Unicode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Interaction.OnReceivedNativeInputAxis
// (Final, Defined, Iterator, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FName                   Key                            (Parm)
// float                          Delta                          (Parm)
// float                          DeltaTime                      (Parm)
// bool                           bGamepad                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInteraction::OnReceivedNativeInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime, bool bGamepad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.OnReceivedNativeInputAxis"));

	UInteraction_OnReceivedNativeInputAxis_Params params;
	params.ControllerId = ControllerId;
	params.Key = Key;
	params.Delta = Delta;
	params.DeltaTime = DeltaTime;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Interaction.OnReceivedNativeInputKey
// (Final, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FName                   Key                            (Parm)
// TEnumAsByte<EInputEvent>       EventType                      (Parm)
// float                          AmountDepressed                (OptionalParm, Parm)
// bool                           bGamepad                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInteraction::OnReceivedNativeInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> EventType, float AmountDepressed, bool bGamepad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interaction.OnReceivedNativeInputKey"));

	UInteraction_OnReceivedNativeInputKey_Params params;
	params.ControllerId = ControllerId;
	params.Key = Key;
	params.EventType = EventType;
	params.AmountDepressed = AmountDepressed;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UUIInteraction::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.NotifyGameSessionEnded"));

	UUIInteraction_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIInteraction.GetNATType
// (Final, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<ENATType>          ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENATType> UUIInteraction::GetNATType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetNATType"));

	UUIInteraction_GetNATType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetConnectedGamepadCount
// (Iterator, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TArray<unsigned long>          ControllerConnectionStatusOverrides (OptionalParm, Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::STATIC_GetConnectedGamepadCount(TArray<unsigned long> ControllerConnectionStatusOverrides)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetConnectedGamepadCount"));

	UUIInteraction_GetConnectedGamepadCount_Params params;
	params.ControllerConnectionStatusOverrides = ControllerConnectionStatusOverrides;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.IsGamepadConnected
// (Final, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIInteraction::STATIC_IsGamepadConnected(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.IsGamepadConnected"));

	UUIInteraction_IsGamepadConnected_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetNumGuestsLoggedIn
// (Final, Defined, Iterator, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::STATIC_GetNumGuestsLoggedIn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetNumGuestsLoggedIn"));

	UUIInteraction_GetNumGuestsLoggedIn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetLoggedInPlayerCount
// (Defined, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// bool                           bRequireOnlineLogin            (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::STATIC_GetLoggedInPlayerCount(bool bRequireOnlineLogin)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetLoggedInPlayerCount"));

	UUIInteraction_GetLoggedInPlayerCount_Params params;
	params.bRequireOnlineLogin = bRequireOnlineLogin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.IsLoggedIn
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// bool                           bRequireOnlineLogin            (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIInteraction::IsLoggedIn(int ControllerId, bool bRequireOnlineLogin)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.IsLoggedIn"));

	UUIInteraction_IsLoggedIn_Params params;
	params.ControllerId = ControllerId;
	params.bRequireOnlineLogin = bRequireOnlineLogin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.HasLinkConnection
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIInteraction::HasLinkConnection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.HasLinkConnection"));

	UUIInteraction_HasLinkConnection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetLowestLoginStatusOfControllers
// (Final, Defined, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<ELoginStatus>      ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ELoginStatus> UUIInteraction::STATIC_GetLowestLoginStatusOfControllers()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetLowestLoginStatusOfControllers"));

	UUIInteraction_GetLowestLoginStatusOfControllers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetLoginStatus
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// TEnumAsByte<ELoginStatus>      ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ELoginStatus> UUIInteraction::GetLoginStatus(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetLoginStatus"));

	UUIInteraction_GetLoginStatus_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.NotifyPlayerRemoved
// (Final, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            RemovedPlayer                  (Parm)

void UUIInteraction::STATIC_NotifyPlayerRemoved(int PlayerIndex, class ULocalPlayer* RemovedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.NotifyPlayerRemoved"));

	UUIInteraction_NotifyPlayerRemoved_Params params;
	params.PlayerIndex = PlayerIndex;
	params.RemovedPlayer = RemovedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIInteraction.NotifyPlayerAdded
// (Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            AddedPlayer                    (Parm)

void UUIInteraction::STATIC_NotifyPlayerAdded(int PlayerIndex, class ULocalPlayer* AddedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.NotifyPlayerAdded"));

	UUIInteraction_NotifyPlayerAdded_Params params;
	params.PlayerIndex = PlayerIndex;
	params.AddedPlayer = AddedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIInteraction.GetLocalPlayer
// (Singular, Exec, Native, Event, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ULocalPlayer* UUIInteraction::STATIC_GetLocalPlayer(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetLocalPlayer"));

	UUIInteraction_GetLocalPlayer_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetDataStoreClient
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UDataStoreClient*        ReturnValue                    (Parm, OutParm, ReturnParm)

class UDataStoreClient* UUIInteraction::STATIC_GetDataStoreClient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetDataStoreClient"));

	UUIInteraction_GetDataStoreClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetPlayerControllerId
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::STATIC_GetPlayerControllerId(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetPlayerControllerId"));

	UUIInteraction_GetPlayerControllerId_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetPlayerIndex
// (Defined, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::STATIC_GetPlayerIndex(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetPlayerIndex"));

	UUIInteraction_GetPlayerIndex_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIInteraction.GetPlayerCount
// (Defined, Latent, Net, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIInteraction::GetPlayerCount()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIInteraction.GetPlayerCount"));

	UUIInteraction_GetPlayerCount_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIManager.FindLocalPlayerIndex
// (Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 P                              (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIManager::STATIC_FindLocalPlayerIndex(class UPlayer* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.FindLocalPlayerIndex"));

	UUIManager_FindLocalPlayerIndex_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIManager.NotifyPlayerRemoved
// (Final, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            RemovedPlayer                  (Parm)

void UUIManager::STATIC_NotifyPlayerRemoved(int PlayerIndex, class ULocalPlayer* RemovedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.NotifyPlayerRemoved"));

	UUIManager_NotifyPlayerRemoved_Params params;
	params.PlayerIndex = PlayerIndex;
	params.RemovedPlayer = RemovedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIManager.NotifyPlayerAdded
// (Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            AddedPlayer                    (Parm)

void UUIManager::STATIC_NotifyPlayerAdded(int PlayerIndex, class ULocalPlayer* AddedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.NotifyPlayerAdded"));

	UUIManager_NotifyPlayerAdded_Params params;
	params.PlayerIndex = PlayerIndex;
	params.AddedPlayer = AddedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIManager.PauseGame
// (Final, Defined, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bDesiredPauseState             (Parm)
// int                            PlayerIndex                    (OptionalParm, Parm)

void UUIManager::PauseGame(bool bDesiredPauseState, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.PauseGame"));

	UUIManager_PauseGame_Params params;
	params.bDesiredPauseState = bDesiredPauseState;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIManager.CanUnpauseInternalUI
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIManager::CanUnpauseInternalUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.CanUnpauseInternalUI"));

	UUIManager_CanUnpauseInternalUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIManager.GetUIManager
// (Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UUIManager*              ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIManager* UUIManager::STATIC_GetUIManager()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIManager.GetUIManager"));

	UUIManager_GetUIManager_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.EnvironmentVolume.SetSplitNavMesh
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bNewValue                      (Parm)

void AEnvironmentVolume::SetSplitNavMesh(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EnvironmentVolume.SetSplitNavMesh"));

	AEnvironmentVolume_SetSplitNavMesh_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AIController.CanFireWeapon
// (Iterator, Net, Exec, Native, Event, Operator)
// Parameters:
// class AWeapon*                 Wpn                            (Parm)
// unsigned char                  FireModeNum                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAIController::CanFireWeapon(class AWeapon* Wpn, unsigned char FireModeNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.CanFireWeapon"));

	AAIController_CanFireWeapon_Params params;
	params.Wpn = Wpn;
	params.FireModeNum = FireModeNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AIController.NotifyWeaponFinishedFiring
// (Latent, Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// unsigned char                  FireMode                       (Parm)

void AAIController::STATIC_NotifyWeaponFinishedFiring(class AWeapon* W, unsigned char FireMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.NotifyWeaponFinishedFiring"));

	AAIController_NotifyWeaponFinishedFiring_Params params;
	params.W = W;
	params.FireMode = FireMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AIController.NotifyWeaponFired
// (Final, Latent, Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// unsigned char                  FireMode                       (Parm)

void AAIController::STATIC_NotifyWeaponFired(class AWeapon* W, unsigned char FireMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.NotifyWeaponFired"));

	AAIController_NotifyWeaponFired_Params params;
	params.W = W;
	params.FireMode = FireMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AIController.GetPlayerViewPoint
// (Defined, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void AAIController::STATIC_GetPlayerViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.GetPlayerViewPoint"));

	AAIController_GetPlayerViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.AIController.SetTeam
// (Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            inTeamIdx                      (Parm)

void AAIController::SetTeam(int inTeamIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.SetTeam"));

	AAIController_SetTeam_Params params;
	params.inTeamIdx = inTeamIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AIController.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AAIController::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.DisplayDebug"));

	AAIController_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.AIController.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AAIController::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.Reset"));

	AAIController_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AIController.PreBeginPlay
// (Latent, Net, Simulated)

void AAIController::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AIController.PreBeginPlay"));

	AAIController_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CrowdAgentBase.NotifyPathChanged
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void ACrowdAgentBase::NotifyPathChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CrowdAgentBase.NotifyPathChanged"));

	ACrowdAgentBase_NotifyPathChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PathTargetPoint.ShouldBeHiddenBySHOW_NavigationNodes
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APathTargetPoint::ShouldBeHiddenBySHOW_NavigationNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathTargetPoint.ShouldBeHiddenBySHOW_NavigationNodes"));

	APathTargetPoint_ShouldBeHiddenBySHOW_NavigationNodes_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshObstacle.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ANavMeshObstacle_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ANavMeshObstacle::ApplyCheckpointRecord(struct ANavMeshObstacle_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.ApplyCheckpointRecord"));

	ANavMeshObstacle_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.NavMeshObstacle.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ANavMeshObstacle_FCheckpointRecord Record                         (Parm, OutParm)

void ANavMeshObstacle::STATIC_CreateCheckpointRecord(struct ANavMeshObstacle_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.CreateCheckpointRecord"));

	ANavMeshObstacle_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.NavMeshObstacle.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnabled                     (Parm)

void ANavMeshObstacle::SetEnabled(bool bInEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.SetEnabled"));

	ANavMeshObstacle_SetEnabled_Params params;
	params.bInEnabled = bInEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshObstacle.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ANavMeshObstacle::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.OnToggle"));

	ANavMeshObstacle_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshObstacle.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ANavMeshObstacle::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.PostBeginPlay"));

	ANavMeshObstacle_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshObstacle.UnRegisterObstacle
// (Final, Defined, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void ANavMeshObstacle::UnRegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.UnRegisterObstacle"));

	ANavMeshObstacle_UnRegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshObstacle.RegisterObstacle
// (Final, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void ANavMeshObstacle::RegisterObstacle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.RegisterObstacle"));

	ANavMeshObstacle_RegisterObstacle_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshObstacle.GetObstacleBoudingShape
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<struct FVector>         Shape                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANavMeshObstacle::GetObstacleBoudingShape(TArray<struct FVector>* Shape)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshObstacle.GetObstacleBoudingShape"));

	ANavMeshObstacle_GetObstacleBoudingShape_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Shape != nullptr)
		*Shape = params.Shape;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.RecalculateFx
// (PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)

void UMeshComponent::RecalculateFx()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.RecalculateFx"));

	UMeshComponent_RecalculateFx_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.ApplyDye
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// class UMaterialInterface*      PrimaryDyeMI                   (Parm)
// class UMaterialInterface*      SecondaryDyeMI                 (Parm)
// class UMaterialInterface*      EmissiveDyeMI                  (Parm)

void UMeshComponent::ApplyDye(class UMaterialInterface* PrimaryDyeMI, class UMaterialInterface* SecondaryDyeMI, class UMaterialInterface* EmissiveDyeMI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.ApplyDye"));

	UMeshComponent_ApplyDye_Params params;
	params.PrimaryDyeMI = PrimaryDyeMI;
	params.SecondaryDyeMI = SecondaryDyeMI;
	params.EmissiveDyeMI = EmissiveDyeMI;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.SwapMaterial
// (Defined, PreOperator, Net, Native, Event, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      MI                             (Parm)
// bool                           bNoParamReaping                (OptionalParm, Parm)

void UMeshComponent::SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.SwapMaterial"));

	UMeshComponent_SwapMaterial_Params params;
	params.MI = MI;
	params.bNoParamReaping = bNoParamReaping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.OnMeshSetHidden
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bHidden                        (Parm)

void UMeshComponent::STATIC_OnMeshSetHidden(bool bHidden)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.OnMeshSetHidden"));

	UMeshComponent_OnMeshSetHidden_Params params;
	params.bHidden = bHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.GetDefaultMaterial
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            nIndex                         (Parm)
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInterface* UMeshComponent::STATIC_GetDefaultMaterial(int nIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.GetDefaultMaterial"));

	UMeshComponent_GetDefaultMaterial_Params params;
	params.nIndex = nIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.SetDefaultSkin
// (Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            nIndex                         (Parm)

void UMeshComponent::SetDefaultSkin(int nIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.SetDefaultSkin"));

	UMeshComponent_SetDefaultSkin_Params params;
	params.nIndex = nIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxActivateIndependant
// (Iterator, Latent, PreOperator, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)
// bool                           bUseSocketOverride             (OptionalParm, Parm)
// TArray<struct FParticleSysParam> Params                         (OptionalParm, Parm, NeedCtorLink)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UMeshComponent::STATIC_FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, TArray<struct FParticleSysParam> Params)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxActivateIndependant"));

	UMeshComponent_FxActivateIndependant_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;
	params.bUseSocketOverride = bUseSocketOverride;
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.FxSpawnSound
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// struct FVector                 SoundLocation                  (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)

void UMeshComponent::STATIC_FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxSpawnSound"));

	UMeshComponent_FxSpawnSound_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.SoundLocation = SoundLocation;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxSpawnEmitter
// (Defined, Iterator, Latent, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)

void UMeshComponent::STATIC_FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxSpawnEmitter"));

	UMeshComponent_FxSpawnEmitter_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxSpawnTracer
// (PreOperator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// struct FVector                 HitLocation                    (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)

void UMeshComponent::STATIC_FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxSpawnTracer"));

	UMeshComponent_FxSpawnTracer_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.HitLocation = HitLocation;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxDeactivateAll
// (Iterator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// int                            nEquipSlot                     (OptionalParm, Parm)

void UMeshComponent::STATIC_FxDeactivateAll(int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxDeactivateAll"));

	UMeshComponent_FxDeactivateAll_Params params;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxDeactivateGroup
// (Final, Iterator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)

void UMeshComponent::STATIC_FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxDeactivateGroup"));

	UMeshComponent_FxDeactivateGroup_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxActivateGroup
// (Final, Defined, Latent, PreOperator, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)
// bool                           bIgnoreRelevancy               (OptionalParm, Parm)
// bool                           bFromEffectForm                (OptionalParm, Parm)
// bool                           bSkipWeapon                    (OptionalParm, Parm)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UMeshComponent::STATIC_FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxActivateGroup"));

	UMeshComponent_FxActivateGroup_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;
	params.bIgnoreRelevancy = bIgnoreRelevancy;
	params.bFromEffectForm = bFromEffectForm;
	params.bSkipWeapon = bSkipWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.FxGetAll
// (Final, Defined, Iterator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// int                            nIndex                         (OptionalParm, Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)
// TArray<class UObject*>         ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<class UObject*> UMeshComponent::STATIC_FxGetAll(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxGetAll"));

	UMeshComponent_FxGetAll_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.nIndex = nIndex;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.FxGet
// (Defined, Iterator, Singular, NetReliable, Native, Event, Static)
// Parameters:
// struct FName                   nmGroup                        (Parm)
// int                            nMode                          (Parm)
// int                            nIndex                         (OptionalParm, Parm)
// int                            nSocketIndex                   (OptionalParm, Parm)
// int                            nEquipSlot                     (OptionalParm, Parm)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UMeshComponent::STATIC_FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxGet"));

	UMeshComponent_FxGet_Params params;
	params.nmGroup = nmGroup;
	params.nMode = nMode;
	params.nIndex = nIndex;
	params.nSocketIndex = nSocketIndex;
	params.nEquipSlot = nEquipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.FxRemove
// (Final, Latent, Singular, NetReliable, Native, Event, Static)
// Parameters:
// class UObject*                 Fx                             (Parm)

void UMeshComponent::STATIC_FxRemove(class UObject* Fx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxRemove"));

	UMeshComponent_FxRemove_Params params;
	params.Fx = Fx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.FxAdd
// (Final, Iterator, Latent, PreOperator, NetReliable, Native, Event, Static)
// Parameters:
// class UObject*                 Fx                             (Parm)

void UMeshComponent::STATIC_FxAdd(class UObject* Fx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.FxAdd"));

	UMeshComponent_FxAdd_Params params;
	params.Fx = Fx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.CreateAndSetMaterialInstanceTimeVarying
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Static)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInstanceTimeVarying* ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInstanceTimeVarying* UMeshComponent::STATIC_CreateAndSetMaterialInstanceTimeVarying(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.CreateAndSetMaterialInstanceTimeVarying"));

	UMeshComponent_CreateAndSetMaterialInstanceTimeVarying_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.CreateAndSetMaterialInstanceConstant
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Static)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInstanceConstant* ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInstanceConstant* UMeshComponent::STATIC_CreateAndSetMaterialInstanceConstant(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.CreateAndSetMaterialInstanceConstant"));

	UMeshComponent_CreateAndSetMaterialInstanceConstant_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.PrestreamTextures
// (Final, Defined, Latent, PreOperator, Net, Simulated, HasOptionalParms)
// Parameters:
// float                          Seconds                        (Parm)
// bool                           bPrioritizeCharacterTextures   (Parm)
// TArray<unsigned char>          CinematicTextureGroups         (OptionalParm, Parm, NeedCtorLink)

void UMeshComponent::PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, TArray<unsigned char> CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.PrestreamTextures"));

	UMeshComponent_PrestreamTextures_Params params;
	params.Seconds = Seconds;
	params.bPrioritizeCharacterTextures = bPrioritizeCharacterTextures;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.GetNumElements
// (Iterator, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UMeshComponent::STATIC_GetNumElements()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.GetNumElements"));

	UMeshComponent_GetNumElements_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.SetMaterial
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInterface*      Material                       (Parm)

void UMeshComponent::SetMaterial(int ElementIndex, class UMaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.SetMaterial"));

	UMeshComponent_SetMaterial_Params params;
	params.ElementIndex = ElementIndex;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.GetMaterial
// (PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInterface* UMeshComponent::STATIC_GetMaterial(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MeshComponent.GetMaterial"));

	UMeshComponent_GetMaterial_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMeshComponent.CanBecomeDynamic
// (Final, Defined, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UStaticMeshComponent::CanBecomeDynamic()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshComponent.CanBecomeDynamic"));

	UStaticMeshComponent_CanBecomeDynamic_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMeshComponent.SetForceStaticDecals
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInForceStaticDecals           (Parm)

void UStaticMeshComponent::SetForceStaticDecals(bool bInForceStaticDecals)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshComponent.SetForceStaticDecals"));

	UStaticMeshComponent_SetForceStaticDecals_Params params;
	params.bInForceStaticDecals = bInForceStaticDecals;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.DisableRBCollisionWithSMC
// (Iterator, Latent, Simulated, Native, Static)
// Parameters:
// class UPrimitiveComponent*     OtherSMC                       (Parm, EditInline)
// bool                           bDisabled                      (Parm)

void UStaticMeshComponent::STATIC_DisableRBCollisionWithSMC(class UPrimitiveComponent* OtherSMC, bool bDisabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshComponent.DisableRBCollisionWithSMC"));

	UStaticMeshComponent_DisableRBCollisionWithSMC_Params params;
	params.OtherSMC = OtherSMC;
	params.bDisabled = bDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.SetStaticMesh
// (Defined, NetReliable, Event, HasOptionalParms)
// Parameters:
// class UStaticMesh*             NewMesh                        (Parm)
// bool                           bForce                         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh, bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.StaticMeshComponent.SetStaticMesh"));

	UStaticMeshComponent_SetStaticMesh_Params params;
	params.NewMesh = NewMesh;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AICommandBase.GetUtility
// (Defined, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AAIController*           InAI                           (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UAICommandBase::GetUtility(class AAIController* InAI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AICommandBase.GetUtility"));

	UAICommandBase_GetUtility_Params params;
	params.InAI = InAI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Interface_ActorPathConstraints.SolveConstraints
// (Defined, Iterator, PreOperator, Exec, Event, HasOptionalParms)
// Parameters:
// struct FVector                 InitialPosition                (Const, Parm)
// float                          MaxDistance                    (Const, Parm)
// struct FVector                 OutDesiredPosition             (Parm, OutParm)

void UInterface_ActorPathConstraints::SolveConstraints(const struct FVector& InitialPosition, float MaxDistance, struct FVector* OutDesiredPosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interface_ActorPathConstraints.SolveConstraints"));

	UInterface_ActorPathConstraints_SolveConstraints_Params params;
	params.InitialPosition = InitialPosition;
	params.MaxDistance = MaxDistance;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutDesiredPosition != nullptr)
		*OutDesiredPosition = params.OutDesiredPosition;
}


// Function Engine.Interface_NavMeshPathSwitch.AIActivateSwitch
// (Final, Defined, Simulated, Native, HasOptionalParms)
// Parameters:
// class AAIController*           AI                             (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInterface_NavMeshPathSwitch::AIActivateSwitch(class AAIController* AI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Interface_NavMeshPathSwitch.AIActivateSwitch"));

	UInterface_NavMeshPathSwitch_AIActivateSwitch_Params params;
	params.AI = AI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.DrawBreadCrumbs
// (Defined, Iterator, Singular, Exec, Native, Static)
// Parameters:
// bool                           bPersistent                    (OptionalParm, Parm)

void UNavigationHandle::STATIC_DrawBreadCrumbs(bool bPersistent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.DrawBreadCrumbs"));

	UNavigationHandle_DrawBreadCrumbs_Params params;
	params.bPersistent = bPersistent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.StaticGetValidatedAnchorPosition
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FVector                 out_NewAnchorLoc               (Parm, OutParm)
// struct FVector                 StartCheckBaseLocation         (Parm)
// struct FVector                 Extent                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::StaticGetValidatedAnchorPosition(const struct FVector& StartCheckBaseLocation, const struct FVector& Extent, struct FVector* out_NewAnchorLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.StaticGetValidatedAnchorPosition"));

	UNavigationHandle_StaticGetValidatedAnchorPosition_Params params;
	params.StartCheckBaseLocation = StartCheckBaseLocation;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_NewAnchorLoc != nullptr)
		*out_NewAnchorLoc = params.out_NewAnchorLoc;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetPackedKeyForPosition
// (Defined, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 pos                            (Parm, OutParm)
// struct FVector                 PrevPos                        (Const, Parm, OutParm)
// int                            PreviousKey                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UNavigationHandle::STATIC_GetPackedKeyForPosition(int PreviousKey, struct FVector* pos, struct FVector* PrevPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetPackedKeyForPosition"));

	UNavigationHandle_GetPackedKeyForPosition_Params params;
	params.PreviousKey = PreviousKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (pos != nullptr)
		*pos = params.pos;
	if (PrevPos != nullptr)
		*PrevPos = params.PrevPos;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetValidatedAnchorPosition
// (Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_NewAnchorLoc               (Parm, OutParm)
// struct FVector                 OverrideStartLoc               (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_GetValidatedAnchorPosition(const struct FVector& OverrideStartLoc, struct FVector* out_NewAnchorLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetValidatedAnchorPosition"));

	UNavigationHandle_GetValidatedAnchorPosition_Params params;
	params.OverrideStartLoc = OverrideStartLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_NewAnchorLoc != nullptr)
		*out_NewAnchorLoc = params.out_NewAnchorLoc;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetAllCoverSlotsInRadius
// (Defined, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 FromLoc                        (Parm)
// float                          Radius                         (Parm)
// TArray<struct FCoverInfo>      out_CoverList                  (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_GetAllCoverSlotsInRadius(const struct FVector& FromLoc, float Radius, TArray<struct FCoverInfo>* out_CoverList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetAllCoverSlotsInRadius"));

	UNavigationHandle_GetAllCoverSlotsInRadius_Params params;
	params.FromLoc = FromLoc;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_CoverList != nullptr)
		*out_CoverList = params.out_CoverList;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PopulatePathfindingParamCache
// (Defined, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::PopulatePathfindingParamCache()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PopulatePathfindingParamCache"));

	UNavigationHandle_PopulatePathfindingParamCache_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.MoveToDesiredHeightAboveMesh
// (Defined, Latent, Singular, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FVector                 Point                          (Parm)
// float                          Height                         (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UNavigationHandle::STATIC_MoveToDesiredHeightAboveMesh(const struct FVector& Point, float Height)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.MoveToDesiredHeightAboveMesh"));

	UNavigationHandle_MoveToDesiredHeightAboveMesh_Params params;
	params.Point = Point;
	params.Height = Height;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.CopyMovePointsFromPathCache
// (Final, PreOperator, Net, NetReliable, Simulated, Static)
// Parameters:
// struct FVector                 FinalDest                      (Parm)
// TArray<struct FVector>         out_MovePoints                 (Parm, OutParm, NeedCtorLink)

void UNavigationHandle::STATIC_CopyMovePointsFromPathCache(const struct FVector& FinalDest, TArray<struct FVector>* out_MovePoints)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.CopyMovePointsFromPathCache"));

	UNavigationHandle_CopyMovePointsFromPathCache_Params params;
	params.FinalDest = FinalDest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_MovePoints != nullptr)
		*out_MovePoints = params.out_MovePoints;
}


// Function Engine.NavigationHandle.CalculatePathDistance
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// struct FVector                 FinalDest                      (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UNavigationHandle::CalculatePathDistance(const struct FVector& FinalDest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.CalculatePathDistance"));

	UNavigationHandle_CalculatePathDistance_Params params;
	params.FinalDest = FinalDest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetFirstMoveLocation
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UNavigationHandle::STATIC_GetFirstMoveLocation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetFirstMoveLocation"));

	UNavigationHandle_GetFirstMoveLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.IsAnchorInescapable
// (Final, Iterator, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_IsAnchorInescapable()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.IsAnchorInescapable"));

	UNavigationHandle_IsAnchorInescapable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.LimitPathCacheDistance
// (Defined, Latent, PreOperator, Singular, NetReliable, Native, Operator, Static)
// Parameters:
// float                          MaxDist                        (Parm)

void UNavigationHandle::STATIC_LimitPathCacheDistance(float MaxDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.LimitPathCacheDistance"));

	UNavigationHandle_LimitPathCacheDistance_Params params;
	params.MaxDist = MaxDist;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.GetValidPositionsForBox
// (Final, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 pos                            (Parm)
// float                          Radius                         (Parm)
// struct FVector                 Extent                         (Parm)
// bool                           bMustBeReachableFromStartPos   (Parm)
// TArray<struct FVector>         out_ValidPositions             (Parm, OutParm, NeedCtorLink)
// int                            MaxPositions                   (OptionalParm, Parm)
// float                          MinRadius                      (OptionalParm, Parm)
// struct FVector                 ValidBoxAroundStartPos         (OptionalParm, Parm)

void UNavigationHandle::STATIC_GetValidPositionsForBox(const struct FVector& pos, float Radius, const struct FVector& Extent, bool bMustBeReachableFromStartPos, int MaxPositions, float MinRadius, const struct FVector& ValidBoxAroundStartPos, TArray<struct FVector>* out_ValidPositions)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetValidPositionsForBox"));

	UNavigationHandle_GetValidPositionsForBox_Params params;
	params.pos = pos;
	params.Radius = Radius;
	params.Extent = Extent;
	params.bMustBeReachableFromStartPos = bMustBeReachableFromStartPos;
	params.MaxPositions = MaxPositions;
	params.MinRadius = MinRadius;
	params.ValidBoxAroundStartPos = ValidBoxAroundStartPos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_ValidPositions != nullptr)
		*out_ValidPositions = params.out_ValidPositions;
}


// Function Engine.NavigationHandle.GetAllPolyCentersWithinBounds
// (Final, Iterator, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 pos                            (Parm)
// struct FVector                 Extent                         (Parm)
// TArray<struct FVector>         out_PolyCtrs                   (Parm, OutParm, NeedCtorLink)

void UNavigationHandle::STATIC_GetAllPolyCentersWithinBounds(const struct FVector& pos, const struct FVector& Extent, TArray<struct FVector>* out_PolyCtrs)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetAllPolyCentersWithinBounds"));

	UNavigationHandle_GetAllPolyCentersWithinBounds_Params params;
	params.pos = pos;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_PolyCtrs != nullptr)
		*out_PolyCtrs = params.out_PolyCtrs;
}


// Function Engine.NavigationHandle.GetCurrentEdgeType
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<ENavMeshEdgeType>  ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENavMeshEdgeType> UNavigationHandle::STATIC_GetCurrentEdgeType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetCurrentEdgeType"));

	UNavigationHandle_GetCurrentEdgeType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.ClearCurrentEdge
// (Final, Defined, PreOperator, Net, Simulated, Exec, Native, Event, Operator)

void UNavigationHandle::ClearCurrentEdge()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ClearCurrentEdge"));

	UNavigationHandle_ClearCurrentEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.GetCurrentEdgeDebugText
// (Defined, Iterator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UNavigationHandle::STATIC_GetCurrentEdgeDebugText()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetCurrentEdgeDebugText"));

	UNavigationHandle_GetCurrentEdgeDebugText_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PrintPathCacheDebugText
// (Final, Latent, PreOperator, NetReliable, Simulated, HasOptionalParms)

void UNavigationHandle::PrintPathCacheDebugText()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PrintPathCacheDebugText"));

	UNavigationHandle_PrintPathCacheDebugText_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.DrawPathCache
// (Final, Defined, Iterator, Latent, Net, Exec, Native, Static)
// Parameters:
// struct FVector                 DrawOffset                     (OptionalParm, Parm)
// bool                           bPersistent                    (OptionalParm, Parm)
// struct FColor                  DrawColor                      (OptionalParm, Parm)

void UNavigationHandle::STATIC_DrawPathCache(const struct FVector& DrawOffset, bool bPersistent, const struct FColor& DrawColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.DrawPathCache"));

	UNavigationHandle_DrawPathCache_Params params;
	params.DrawOffset = DrawOffset;
	params.bPersistent = bPersistent;
	params.DrawColor = DrawColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.ActorReachable
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, Event)
// Parameters:
// class AActor*                  A                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::ActorReachable(class AActor* A)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ActorReachable"));

	UNavigationHandle_ActorReachable_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PointReachable
// (Final, PreOperator, Net, NetReliable, HasOptionalParms)
// Parameters:
// struct FVector                 Point                          (Parm)
// struct FVector                 OverrideStartPoint             (OptionalParm, Parm)
// bool                           bAllowHitsInEndCollisionBox    (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::PointReachable(const struct FVector& Point, const struct FVector& OverrideStartPoint, bool bAllowHitsInEndCollisionBox)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PointReachable"));

	UNavigationHandle_PointReachable_Params params;
	params.Point = Point;
	params.OverrideStartPoint = OverrideStartPoint;
	params.bAllowHitsInEndCollisionBox = bAllowHitsInEndCollisionBox;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PointCheck
// (Final, Defined, Iterator, Net, NetReliable, HasOptionalParms)
// Parameters:
// struct FVector                 Pt                             (Parm)
// struct FVector                 Extent                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::PointCheck(const struct FVector& Pt, const struct FVector& Extent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PointCheck"));

	UNavigationHandle_PointCheck_Params params;
	params.Pt = Pt;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.LineCheck
// (Defined, Iterator, PreOperator, Net, NetReliable, Native, Operator, Static)
// Parameters:
// struct FVector                 Start                          (Parm)
// struct FVector                 End                            (Parm)
// struct FVector                 Extent                         (Parm)
// struct FVector                 out_HitLocation                (OptionalParm, Parm, OutParm)
// struct FVector                 out_HitNormal                  (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_LineCheck(const struct FVector& Start, const struct FVector& End, const struct FVector& Extent, struct FVector* out_HitLocation, struct FVector* out_HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.LineCheck"));

	UNavigationHandle_LineCheck_Params params;
	params.Start = Start;
	params.End = End;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_HitLocation != nullptr)
		*out_HitLocation = params.out_HitLocation;
	if (out_HitNormal != nullptr)
		*out_HitNormal = params.out_HitNormal;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.ObstaclePointCheck
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Event, Operator, Static)
// Parameters:
// struct FVector                 Pt                             (Parm)
// struct FVector                 Extent                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_ObstaclePointCheck(const struct FVector& Pt, const struct FVector& Extent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ObstaclePointCheck"));

	UNavigationHandle_ObstaclePointCheck_Params params;
	params.Pt = Pt;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.ObstacleLineCheck
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Event, Operator, Static)
// Parameters:
// struct FVector                 Start                          (Parm)
// struct FVector                 End                            (Parm)
// struct FVector                 Extent                         (Parm)
// struct FVector                 out_HitLoc                     (OptionalParm, Parm, OutParm)
// struct FVector                 out_HitNorm                    (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_ObstacleLineCheck(const struct FVector& Start, const struct FVector& End, const struct FVector& Extent, struct FVector* out_HitLoc, struct FVector* out_HitNorm)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ObstacleLineCheck"));

	UNavigationHandle_ObstacleLineCheck_Params params;
	params.Start = Start;
	params.End = End;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_HitLoc != nullptr)
		*out_HitLoc = params.out_HitLoc;
	if (out_HitNorm != nullptr)
		*out_HitNorm = params.out_HitNorm;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 MovePt                         (Parm, OutParm)
// class AController*             C                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::SuggestMovePreparation(class AController* C, struct FVector* MovePt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.SuggestMovePreparation"));

	UNavigationHandle_SuggestMovePreparation_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MovePt != nullptr)
		*MovePt = params.MovePt;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.FindPath
// (Iterator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class AActor*                  out_DestActor                  (OptionalParm, Parm, OutParm)
// int                            out_DestItem                   (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_FindPath(class AActor** out_DestActor, int* out_DestItem)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.FindPath"));

	UNavigationHandle_FindPath_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_DestActor != nullptr)
		*out_DestActor = params.out_DestActor;
	if (out_DestItem != nullptr)
		*out_DestItem = params.out_DestItem;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.ComputeValidFinalDestination
// (Final, Net, Simulated, Static)
// Parameters:
// struct FVector                 out_ComputedPosition           (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_ComputeValidFinalDestination(struct FVector* out_ComputedPosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ComputeValidFinalDestination"));

	UNavigationHandle_ComputeValidFinalDestination_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_ComputedPosition != nullptr)
		*out_ComputedPosition = params.out_ComputedPosition;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.SetFinalDestination
// (Final, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 FinalDest                      (Parm)
// class AActor*                  FinalActor                     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::SetFinalDestination(const struct FVector& FinalDest, class AActor* FinalActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.SetFinalDestination"));

	UNavigationHandle_SetFinalDestination_Params params;
	params.FinalDest = FinalDest;
	params.FinalActor = FinalActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetNextMoveLocation
// (Final, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_MoveDest                   (Parm, OutParm)
// float                          ArrivalDistance                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_GetNextMoveLocation(float ArrivalDistance, struct FVector* out_MoveDest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetNextMoveLocation"));

	UNavigationHandle_GetNextMoveLocation_Params params;
	params.ArrivalDistance = ArrivalDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_MoveDest != nullptr)
		*out_MoveDest = params.out_MoveDest;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetPylonFromPos
// (Final, Iterator, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 Position                       (Parm)
// class APylon*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class APylon* UNavigationHandle::STATIC_GetPylonFromPos(const struct FVector& Position)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetPylonFromPos"));

	UNavigationHandle_GetPylonFromPos_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.FindPylon
// (Final, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_FindPylon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.FindPylon"));

	UNavigationHandle_FindPylon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetBestUnfinishedPathPoint
// (Iterator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UNavigationHandle::STATIC_GetBestUnfinishedPathPoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetBestUnfinishedPathPoint"));

	UNavigationHandle_GetBestUnfinishedPathPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PathCache_RemoveIndex
// (Singular, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// int                            InIdx                          (Parm)
// int                            Count                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_PathCache_RemoveIndex(int InIdx, int Count)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PathCache_RemoveIndex"));

	UNavigationHandle_PathCache_RemoveIndex_Params params;
	params.InIdx = InIdx;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PathCache_GetGoalPoint
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UNavigationHandle::STATIC_PathCache_GetGoalPoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PathCache_GetGoalPoint"));

	UNavigationHandle_PathCache_GetGoalPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.PathCache_Empty
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_PathCache_Empty()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.PathCache_Empty"));

	UNavigationHandle_PathCache_Empty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.GetPathCacheLength
// (Iterator, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UNavigationHandle::STATIC_GetPathCacheLength()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetPathCacheLength"));

	UNavigationHandle_GetPathCacheLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.CreatePathGoalEvaluator
// (Defined, PreOperator, Exec, Static)
// Parameters:
// class UClass*                  GoalEvalClass                  (Parm)
// class UNavMeshPathGoalEvaluator* ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshPathGoalEvaluator* UNavigationHandle::STATIC_CreatePathGoalEvaluator(class UClass* GoalEvalClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.CreatePathGoalEvaluator"));

	UNavigationHandle_CreatePathGoalEvaluator_Params params;
	params.GoalEvalClass = GoalEvalClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.CreatePathConstraint
// (Final, PreOperator, Exec, Static)
// Parameters:
// class UClass*                  ConstraintClass                (Parm)
// class UNavMeshPathConstraint*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshPathConstraint* UNavigationHandle::STATIC_CreatePathConstraint(class UClass* ConstraintClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.CreatePathConstraint"));

	UNavigationHandle_CreatePathConstraint_Params params;
	params.ConstraintClass = ConstraintClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.DoesPylonAHaveAPathToPylonB
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class APylon*                  A                              (Parm)
// class APylon*                  B                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_DoesPylonAHaveAPathToPylonB(class APylon* A, class APylon* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.DoesPylonAHaveAPathToPylonB"));

	UNavigationHandle_DoesPylonAHaveAPathToPylonB_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.BuildFromPylonAToPylonB
// (Iterator, Singular, Net, Native, Event, Operator)
// Parameters:
// class APylon*                  A                              (Parm)
// class APylon*                  B                              (Parm)
// class APylon*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class APylon* UNavigationHandle::BuildFromPylonAToPylonB(class APylon* A, class APylon* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.BuildFromPylonAToPylonB"));

	UNavigationHandle_BuildFromPylonAToPylonB_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.AddGoalEvaluator
// (Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UNavMeshPathGoalEvaluator* Evaluator                      (Parm)

void UNavigationHandle::AddGoalEvaluator(class UNavMeshPathGoalEvaluator* Evaluator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.AddGoalEvaluator"));

	UNavigationHandle_AddGoalEvaluator_Params params;
	params.Evaluator = Evaluator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.AddPathConstraint
// (Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UNavMeshPathConstraint*  Constraint                     (Parm)

void UNavigationHandle::AddPathConstraint(class UNavMeshPathConstraint* Constraint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.AddPathConstraint"));

	UNavigationHandle_AddPathConstraint_Params params;
	params.Constraint = Constraint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.ClearConstraints
// (Latent, Net, Simulated, Exec, Native, Event, Operator)

void UNavigationHandle::ClearConstraints()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.ClearConstraints"));

	UNavigationHandle_ClearConstraints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.GetNextBreadCrumb
// (Final, Defined, Iterator, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_BreadCrumbLoc              (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavigationHandle::STATIC_GetNextBreadCrumb(struct FVector* out_BreadCrumbLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.GetNextBreadCrumb"));

	UNavigationHandle_GetNextBreadCrumb_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_BreadCrumbLoc != nullptr)
		*out_BreadCrumbLoc = params.out_BreadCrumbLoc;

	return params.ReturnValue;
}


// Function Engine.NavigationHandle.UpdateBreadCrumbs
// (Final, Iterator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 InLocation                     (Parm)

void UNavigationHandle::UpdateBreadCrumbs(const struct FVector& InLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.UpdateBreadCrumbs"));

	UNavigationHandle_UpdateBreadCrumbs_Params params;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavigationHandle.CopyPathStoreToPathCache
// (Defined, PreOperator, Net, NetReliable, Simulated, Static)
// Parameters:
// struct FPathStore              InStore                        (Const, Parm, OutParm)

void UNavigationHandle::STATIC_CopyPathStoreToPathCache(struct FPathStore* InStore)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavigationHandle.CopyPathStoreToPathCache"));

	UNavigationHandle_CopyPathStoreToPathCache_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InStore != nullptr)
		*InStore = params.InStore;
}


// Function Engine.NavMeshGoal_Filter.GetDumpString
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UNavMeshGoal_Filter::GetDumpString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Filter.GetDumpString"));

	UNavMeshGoal_Filter_GetDumpString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoalFilter_MinPathDistance.MustBeLongerPathThan
// (Defined, Latent, Singular, Simulated, Event, Operator, Static)
// Parameters:
// class UNavMeshGoal_GenericFilterContainer* FilterContainer                (Parm)
// int                            InMinDistancePathShouldBe      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoalFilter_MinPathDistance::STATIC_MustBeLongerPathThan(class UNavMeshGoal_GenericFilterContainer* FilterContainer, int InMinDistancePathShouldBe)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoalFilter_MinPathDistance.MustBeLongerPathThan"));

	UNavMeshGoalFilter_MinPathDistance_MustBeLongerPathThan_Params params;
	params.FilterContainer = FilterContainer;
	params.InMinDistancePathShouldBe = InMinDistancePathShouldBe;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoalFilter_NotNearOtherAI.NotNearOtherAI
// (Iterator, Latent, Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class UNavMeshGoal_GenericFilterContainer* FilterContainer                (Parm)
// float                          InDistanceToCheck              (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoalFilter_NotNearOtherAI::STATIC_NotNearOtherAI(class UNavMeshGoal_GenericFilterContainer* FilterContainer, float InDistanceToCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoalFilter_NotNearOtherAI.NotNearOtherAI"));

	UNavMeshGoalFilter_NotNearOtherAI_NotNearOtherAI_Params params;
	params.FilterContainer = FilterContainer;
	params.InDistanceToCheck = InDistanceToCheck;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoalFilter_OutOfViewFrom.MustBeHiddenFromThisPoint
// (Final, Latent, Singular, Simulated, Event, Operator, Static)
// Parameters:
// class UNavMeshGoal_GenericFilterContainer* FilterContainer                (Parm)
// struct FVector                 InOutOfViewLocation            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoalFilter_OutOfViewFrom::STATIC_MustBeHiddenFromThisPoint(class UNavMeshGoal_GenericFilterContainer* FilterContainer, const struct FVector& InOutOfViewLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoalFilter_OutOfViewFrom.MustBeHiddenFromThisPoint"));

	UNavMeshGoalFilter_OutOfViewFrom_MustBeHiddenFromThisPoint_Params params;
	params.FilterContainer = FilterContainer;
	params.InOutOfViewLocation = InOutOfViewLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoalFilter_OutSideOfDotProductWedge.OutsideOfDotProductWedge
// (Iterator, Exec, Native, Event, Operator, Static)
// Parameters:
// class UNavMeshGoal_GenericFilterContainer* FilterContainer                (Parm)
// struct FVector                 InLocation                     (Parm)
// struct FRotator                InRotation                     (Parm)
// float                          InEpsilon                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoalFilter_OutSideOfDotProductWedge::STATIC_OutsideOfDotProductWedge(class UNavMeshGoal_GenericFilterContainer* FilterContainer, const struct FVector& InLocation, const struct FRotator& InRotation, float InEpsilon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoalFilter_OutSideOfDotProductWedge.OutsideOfDotProductWedge"));

	UNavMeshGoalFilter_OutSideOfDotProductWedge_OutsideOfDotProductWedge_Params params;
	params.FilterContainer = FilterContainer;
	params.InLocation = InLocation;
	params.InRotation = InRotation;
	params.InEpsilon = InEpsilon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoalFilter_PolyEncompassesAI.MakeSureAIFits
// (Iterator, PreOperator, Net, Exec, Native, Operator, Static)
// Parameters:
// class UNavMeshGoal_GenericFilterContainer* FilterContainer                (Parm)
// struct FVector                 InOverrideExtentToCheck        (Const, OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoalFilter_PolyEncompassesAI::STATIC_MakeSureAIFits(class UNavMeshGoal_GenericFilterContainer* FilterContainer, const struct FVector& InOverrideExtentToCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoalFilter_PolyEncompassesAI.MakeSureAIFits"));

	UNavMeshGoalFilter_PolyEncompassesAI_MakeSureAIFits_Params params;
	params.FilterContainer = FilterContainer;
	params.InOverrideExtentToCheck = InOverrideExtentToCheck;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPathConstraint.GetDumpString
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UNavMeshPathConstraint::GetDumpString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPathConstraint.GetDumpString"));

	UNavMeshPathConstraint_GetDumpString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPathConstraint.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPathConstraint::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPathConstraint.Recycle"));

	UNavMeshPathConstraint_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_AlongLine.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_AlongLine::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_AlongLine.Recycle"));

	UNavMeshPath_AlongLine_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_AlongLine.AlongLine
// (Final, Net, NetReliable, Operator)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 Dir                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_AlongLine::AlongLine(class UNavigationHandle* NavHandle, const struct FVector& Dir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_AlongLine.AlongLine"));

	UNavMeshPath_AlongLine_AlongLine_Params params;
	params.NavHandle = NavHandle;
	params.Dir = Dir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_EnforceTwoWayEdges.EnforceTwoWayEdges
// (Final, Defined, Iterator, Latent, Singular, Event, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_EnforceTwoWayEdges::STATIC_EnforceTwoWayEdges(class UNavigationHandle* NavHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_EnforceTwoWayEdges.EnforceTwoWayEdges"));

	UNavMeshPath_EnforceTwoWayEdges_EnforceTwoWayEdges_Params params;
	params.NavHandle = NavHandle;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_MinDistBetweenSpecsOfType.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_MinDistBetweenSpecsOfType::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_MinDistBetweenSpecsOfType.Recycle"));

	UNavMeshPath_MinDistBetweenSpecsOfType_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_MinDistBetweenSpecsOfType.EnforceMinDist
// (Defined, Iterator, Latent, Singular, Event, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// float                          InMinDist                      (Parm)
// TEnumAsByte<ENavMeshEdgeType>  InEdgeType                     (Parm)
// struct FVector                 LastLocation                   (OptionalParm, Parm)
// float                          InPenalty                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_MinDistBetweenSpecsOfType::STATIC_EnforceMinDist(class UNavigationHandle* NavHandle, float InMinDist, TEnumAsByte<ENavMeshEdgeType> InEdgeType, const struct FVector& LastLocation, float InPenalty)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_MinDistBetweenSpecsOfType.EnforceMinDist"));

	UNavMeshPath_MinDistBetweenSpecsOfType_EnforceMinDist_Params params;
	params.NavHandle = NavHandle;
	params.InMinDist = InMinDist;
	params.InEdgeType = InEdgeType;
	params.LastLocation = LastLocation;
	params.InPenalty = InPenalty;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_SameCoverLink.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_SameCoverLink::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_SameCoverLink.Recycle"));

	UNavMeshPath_SameCoverLink_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_SameCoverLink.SameCoverLink
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// class ACoverLink*              InLink                         (Parm)

void UNavMeshPath_SameCoverLink::SameCoverLink(class UNavigationHandle* NavHandle, class ACoverLink* InLink)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_SameCoverLink.SameCoverLink"));

	UNavMeshPath_SameCoverLink_SameCoverLink_Params params;
	params.NavHandle = NavHandle;
	params.InLink = InLink;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_Toward.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_Toward::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_Toward.Recycle"));

	UNavMeshPath_Toward_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_Toward.TowardPoint
// (Final, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 Point                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_Toward::TowardPoint(class UNavigationHandle* NavHandle, const struct FVector& Point)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_Toward.TowardPoint"));

	UNavMeshPath_Toward_TowardPoint_Params params;
	params.NavHandle = NavHandle;
	params.Point = Point;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_Toward.TowardGoal
// (Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// class AActor*                  Goal                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_Toward::TowardGoal(class UNavigationHandle* NavHandle, class AActor* Goal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_Toward.TowardGoal"));

	UNavMeshPath_Toward_TowardGoal_Params params;
	params.NavHandle = NavHandle;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_WithinDistanceEnvelope.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_WithinDistanceEnvelope::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_WithinDistanceEnvelope.Recycle"));

	UNavMeshPath_WithinDistanceEnvelope_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_WithinDistanceEnvelope.StayWithinEnvelopeToLoc
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 InEnvelopeTestPoint            (Parm)
// float                          InMaxDistance                  (Parm)
// float                          InMinDistance                  (Parm)
// bool                           bInSoft                        (OptionalParm, Parm)
// float                          InSoftStartPenalty             (OptionalParm, Parm)
// bool                           bOnlyTossOutSpecsThatLeave     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_WithinDistanceEnvelope::StayWithinEnvelopeToLoc(class UNavigationHandle* NavHandle, const struct FVector& InEnvelopeTestPoint, float InMaxDistance, float InMinDistance, bool bInSoft, float InSoftStartPenalty, bool bOnlyTossOutSpecsThatLeave)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_WithinDistanceEnvelope.StayWithinEnvelopeToLoc"));

	UNavMeshPath_WithinDistanceEnvelope_StayWithinEnvelopeToLoc_Params params;
	params.NavHandle = NavHandle;
	params.InEnvelopeTestPoint = InEnvelopeTestPoint;
	params.InMaxDistance = InMaxDistance;
	params.InMinDistance = InMinDistance;
	params.bInSoft = bInSoft;
	params.InSoftStartPenalty = InSoftStartPenalty;
	params.bOnlyTossOutSpecsThatLeave = bOnlyTossOutSpecsThatLeave;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPath_WithinTraversalDist.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPath_WithinTraversalDist::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_WithinTraversalDist.Recycle"));

	UNavMeshPath_WithinTraversalDist_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshPath_WithinTraversalDist.DontExceedMaxDist
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// float                          InMaxTraversalDist             (Parm)
// bool                           bInSoft                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshPath_WithinTraversalDist::STATIC_DontExceedMaxDist(class UNavigationHandle* NavHandle, float InMaxTraversalDist, bool bInSoft)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPath_WithinTraversalDist.DontExceedMaxDist"));

	UNavMeshPath_WithinTraversalDist_DontExceedMaxDist_Params params;
	params.NavHandle = NavHandle;
	params.InMaxTraversalDist = InMaxTraversalDist;
	params.bInSoft = bInSoft;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPathGoalEvaluator.GetDumpString
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UNavMeshPathGoalEvaluator::GetDumpString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPathGoalEvaluator.GetDumpString"));

	UNavMeshPathGoalEvaluator_GetDumpString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshPathGoalEvaluator.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshPathGoalEvaluator::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshPathGoalEvaluator.Recycle"));

	UNavMeshPathGoalEvaluator_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_At.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_At::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_At.Recycle"));

	UNavMeshGoal_At_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_At.AtLocation
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 GoalLocation                   (Parm)
// float                          Dist                           (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// bool                           bInWeightPartialByDist         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_At::AtLocation(class UNavigationHandle* NavHandle, const struct FVector& GoalLocation, float Dist, bool bReturnPartial, bool bInWeightPartialByDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_At.AtLocation"));

	UNavMeshGoal_At_AtLocation_Params params;
	params.NavHandle = NavHandle;
	params.GoalLocation = GoalLocation;
	params.Dist = Dist;
	params.bReturnPartial = bReturnPartial;
	params.bInWeightPartialByDist = bInWeightPartialByDist;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_At.AtActor
// (PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// class AActor*                  GoalActor                      (Parm)
// float                          Dist                           (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// bool                           bInWeightPartialByDist         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_At::AtActor(class UNavigationHandle* NavHandle, class AActor* GoalActor, float Dist, bool bReturnPartial, bool bInWeightPartialByDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_At.AtActor"));

	UNavMeshGoal_At_AtActor_Params params;
	params.NavHandle = NavHandle;
	params.GoalActor = GoalActor;
	params.Dist = Dist;
	params.bReturnPartial = bReturnPartial;
	params.bInWeightPartialByDist = bInWeightPartialByDist;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_At.RecycleNative
// (Iterator, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)

void UNavMeshGoal_At::RecycleNative()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_At.RecycleNative"));

	UNavMeshGoal_At_RecycleNative_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_ClosestActorInList.RecycleInternal
// (Final, Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_ClosestActorInList::RecycleInternal()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_ClosestActorInList.RecycleInternal"));

	UNavMeshGoal_ClosestActorInList_RecycleInternal_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_ClosestActorInList.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_ClosestActorInList::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_ClosestActorInList.Recycle"));

	UNavMeshGoal_ClosestActorInList_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_ClosestActorInList.ClosestActorInList
// (Defined, Iterator, Latent, Net, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// TArray<struct FBiasedGoalActor> InGoalList                     (Const, Parm, OutParm, NeedCtorLink)
// class UNavMeshGoal_ClosestActorInList* ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshGoal_ClosestActorInList* UNavMeshGoal_ClosestActorInList::STATIC_ClosestActorInList(class UNavigationHandle* NavHandle, TArray<struct FBiasedGoalActor>* InGoalList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_ClosestActorInList.ClosestActorInList"));

	UNavMeshGoal_ClosestActorInList_ClosestActorInList_Params params;
	params.NavHandle = NavHandle;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InGoalList != nullptr)
		*InGoalList = params.InGoalList;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_GenericFilterContainer.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_GenericFilterContainer::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_GenericFilterContainer.Recycle"));

	UNavMeshGoal_GenericFilterContainer_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_GenericFilterContainer.GetGoalPoint
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UNavMeshGoal_GenericFilterContainer::STATIC_GetGoalPoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_GenericFilterContainer.GetGoalPoint"));

	UNavMeshGoal_GenericFilterContainer_GetGoalPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_GenericFilterContainer.GetFilterOfType
// (Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UClass*                  Filter_Class                   (Parm)
// class UNavMeshGoal_Filter*     ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshGoal_Filter* UNavMeshGoal_GenericFilterContainer::STATIC_GetFilterOfType(class UClass* Filter_Class)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_GenericFilterContainer.GetFilterOfType"));

	UNavMeshGoal_GenericFilterContainer_GetFilterOfType_Params params;
	params.Filter_Class = Filter_Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_GenericFilterContainer.CreateAndAddFilterToNavHandleFromSeedList
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// TArray<struct FVector>         InSearchSeeds                  (Parm, OutParm, NeedCtorLink)
// int                            InMaxPathVisits                (OptionalParm, Parm)
// class UNavMeshGoal_GenericFilterContainer* ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshGoal_GenericFilterContainer* UNavMeshGoal_GenericFilterContainer::STATIC_CreateAndAddFilterToNavHandleFromSeedList(class UNavigationHandle* NavHandle, int InMaxPathVisits, TArray<struct FVector>* InSearchSeeds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_GenericFilterContainer.CreateAndAddFilterToNavHandleFromSeedList"));

	UNavMeshGoal_GenericFilterContainer_CreateAndAddFilterToNavHandleFromSeedList_Params params;
	params.NavHandle = NavHandle;
	params.InMaxPathVisits = InMaxPathVisits;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InSearchSeeds != nullptr)
		*InSearchSeeds = params.InSearchSeeds;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_GenericFilterContainer.CreateAndAddFilterToNavHandle
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// int                            InMaxPathVisits                (OptionalParm, Parm)
// class UNavMeshGoal_GenericFilterContainer* ReturnValue                    (Parm, OutParm, ReturnParm)

class UNavMeshGoal_GenericFilterContainer* UNavMeshGoal_GenericFilterContainer::STATIC_CreateAndAddFilterToNavHandle(class UNavigationHandle* NavHandle, int InMaxPathVisits)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_GenericFilterContainer.CreateAndAddFilterToNavHandle"));

	UNavMeshGoal_GenericFilterContainer_CreateAndAddFilterToNavHandle_Params params;
	params.NavHandle = NavHandle;
	params.InMaxPathVisits = InMaxPathVisits;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_Null.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_Null::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Null.Recycle"));

	UNavMeshGoal_Null_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_Null.RecycleNative
// (Iterator, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)

void UNavMeshGoal_Null::RecycleNative()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Null.RecycleNative"));

	UNavMeshGoal_Null_RecycleNative_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_Null.GoUntilBust
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// int                            InMaxPathVisits                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_Null::STATIC_GoUntilBust(class UNavigationHandle* NavHandle, int InMaxPathVisits)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Null.GoUntilBust"));

	UNavMeshGoal_Null_GoUntilBust_Params params;
	params.NavHandle = NavHandle;
	params.InMaxPathVisits = InMaxPathVisits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_PolyEncompassesAI.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_PolyEncompassesAI::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_PolyEncompassesAI.Recycle"));

	UNavMeshGoal_PolyEncompassesAI_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_PolyEncompassesAI.MakeSureAIFits
// (Iterator, PreOperator, Net, Exec, Native, Operator, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 InOverrideExtentToCheck        (Const, OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_PolyEncompassesAI::STATIC_MakeSureAIFits(class UNavigationHandle* NavHandle, const struct FVector& InOverrideExtentToCheck)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_PolyEncompassesAI.MakeSureAIFits"));

	UNavMeshGoal_PolyEncompassesAI_MakeSureAIFits_Params params;
	params.NavHandle = NavHandle;
	params.InOverrideExtentToCheck = InOverrideExtentToCheck;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_Random.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_Random::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Random.Recycle"));

	UNavMeshGoal_Random_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_Random.RecycleNative
// (Iterator, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)

void UNavMeshGoal_Random::RecycleNative()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Random.RecycleNative"));

	UNavMeshGoal_Random_RecycleNative_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_Random.FindRandom
// (Defined, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// int                            InMinDist                      (OptionalParm, Parm)
// int                            InMaxPathVisits                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_Random::STATIC_FindRandom(class UNavigationHandle* NavHandle, int InMinDist, int InMaxPathVisits)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_Random.FindRandom"));

	UNavMeshGoal_Random_FindRandom_Params params;
	params.NavHandle = NavHandle;
	params.InMinDist = InMinDist;
	params.InMaxPathVisits = InMaxPathVisits;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMeshGoal_WithinDistanceEnvelope.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UNavMeshGoal_WithinDistanceEnvelope::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_WithinDistanceEnvelope.Recycle"));

	UNavMeshGoal_WithinDistanceEnvelope_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMeshGoal_WithinDistanceEnvelope.GoalWithinEnvelopeToLoc
// (PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UNavigationHandle*       NavHandle                      (Parm)
// struct FVector                 InEnvelopeTestPoint            (Parm)
// float                          InMaxDistance                  (Parm)
// float                          InMinDistance                  (Parm)
// float                          InMinTraversalDist             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UNavMeshGoal_WithinDistanceEnvelope::STATIC_GoalWithinEnvelopeToLoc(class UNavigationHandle* NavHandle, const struct FVector& InEnvelopeTestPoint, float InMaxDistance, float InMinDistance, float InMinTraversalDist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NavMeshGoal_WithinDistanceEnvelope.GoalWithinEnvelopeToLoc"));

	UNavMeshGoal_WithinDistanceEnvelope_GoalWithinEnvelopeToLoc_Params params;
	params.NavHandle = NavHandle;
	params.InEnvelopeTestPoint = InEnvelopeTestPoint;
	params.InMaxDistance = InMaxDistance;
	params.InMinDistance = InMinDistance;
	params.InMinTraversalDist = InMinTraversalDist;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PathConstraint.GetDumpString
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UPathConstraint::GetDumpString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathConstraint.GetDumpString"));

	UPathConstraint_GetDumpString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PathConstraint.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPathConstraint::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathConstraint.Recycle"));

	UPathConstraint_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_AlongLine.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_AlongLine::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_AlongLine.Recycle"));

	UPath_AlongLine_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_AlongLine.AlongLine
// (Final, Net, NetReliable, Operator)
// Parameters:
// class APawn*                   P                              (Parm)
// struct FVector                 Dir                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_AlongLine::AlongLine(class APawn* P, const struct FVector& Dir)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_AlongLine.AlongLine"));

	UPath_AlongLine_AlongLine_Params params;
	params.P = P;
	params.Dir = Dir;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_AvoidInEscapableNodes.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_AvoidInEscapableNodes::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_AvoidInEscapableNodes.Recycle"));

	UPath_AvoidInEscapableNodes_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_AvoidInEscapableNodes.DontGetStuck
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_AvoidInEscapableNodes::STATIC_DontGetStuck(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_AvoidInEscapableNodes.DontGetStuck"));

	UPath_AvoidInEscapableNodes_DontGetStuck_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_AvoidInEscapableNodes.CachePawnReacFlags
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// class APawn*                   P                              (Parm)

void UPath_AvoidInEscapableNodes::CachePawnReacFlags(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_AvoidInEscapableNodes.CachePawnReacFlags"));

	UPath_AvoidInEscapableNodes_CachePawnReacFlags_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_MinDistBetweenSpecsOfType.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_MinDistBetweenSpecsOfType::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_MinDistBetweenSpecsOfType.Recycle"));

	UPath_MinDistBetweenSpecsOfType_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_MinDistBetweenSpecsOfType.EnforceMinDist
// (Defined, Iterator, Latent, Singular, Event, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// float                          InMinDist                      (Parm)
// class UClass*                  InSpecClass                    (Parm)
// struct FVector                 LastLocation                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_MinDistBetweenSpecsOfType::STATIC_EnforceMinDist(class APawn* P, float InMinDist, class UClass* InSpecClass, const struct FVector& LastLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_MinDistBetweenSpecsOfType.EnforceMinDist"));

	UPath_MinDistBetweenSpecsOfType_EnforceMinDist_Params params;
	params.P = P;
	params.InMinDist = InMinDist;
	params.InSpecClass = InSpecClass;
	params.LastLocation = LastLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_TowardGoal.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_TowardGoal::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_TowardGoal.Recycle"));

	UPath_TowardGoal_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_TowardGoal.TowardGoal
// (Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)
// class AActor*                  Goal                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_TowardGoal::TowardGoal(class APawn* P, class AActor* Goal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_TowardGoal.TowardGoal"));

	UPath_TowardGoal_TowardGoal_Params params;
	params.P = P;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_TowardPoint.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_TowardPoint::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_TowardPoint.Recycle"));

	UPath_TowardPoint_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_TowardPoint.TowardPoint
// (Final, Latent, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)
// struct FVector                 Point                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_TowardPoint::TowardPoint(class APawn* P, const struct FVector& Point)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_TowardPoint.TowardPoint"));

	UPath_TowardPoint_TowardPoint_Params params;
	params.P = P;
	params.Point = Point;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_WithinDistanceEnvelope.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_WithinDistanceEnvelope::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_WithinDistanceEnvelope.Recycle"));

	UPath_WithinDistanceEnvelope_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_WithinDistanceEnvelope.StayWithinEnvelopeToLoc
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)
// struct FVector                 InEnvelopeTestPoint            (Parm)
// float                          InMaxDistance                  (Parm)
// float                          InMinDistance                  (Parm)
// bool                           bInSoft                        (OptionalParm, Parm)
// float                          InSoftStartPenalty             (OptionalParm, Parm)
// bool                           bOnlyTossOutSpecsThatLeave     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_WithinDistanceEnvelope::StayWithinEnvelopeToLoc(class APawn* P, const struct FVector& InEnvelopeTestPoint, float InMaxDistance, float InMinDistance, bool bInSoft, float InSoftStartPenalty, bool bOnlyTossOutSpecsThatLeave)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_WithinDistanceEnvelope.StayWithinEnvelopeToLoc"));

	UPath_WithinDistanceEnvelope_StayWithinEnvelopeToLoc_Params params;
	params.P = P;
	params.InEnvelopeTestPoint = InEnvelopeTestPoint;
	params.InMaxDistance = InMaxDistance;
	params.InMinDistance = InMinDistance;
	params.bInSoft = bInSoft;
	params.InSoftStartPenalty = InSoftStartPenalty;
	params.bOnlyTossOutSpecsThatLeave = bOnlyTossOutSpecsThatLeave;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Path_WithinTraversalDist.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPath_WithinTraversalDist::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_WithinTraversalDist.Recycle"));

	UPath_WithinTraversalDist_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Path_WithinTraversalDist.DontExceedMaxDist
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// float                          InMaxTraversalDist             (Parm)
// bool                           bInSoft                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPath_WithinTraversalDist::STATIC_DontExceedMaxDist(class APawn* P, float InMaxTraversalDist, bool bInSoft)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Path_WithinTraversalDist.DontExceedMaxDist"));

	UPath_WithinTraversalDist_DontExceedMaxDist_Params params;
	params.P = P;
	params.InMaxTraversalDist = InMaxTraversalDist;
	params.bInSoft = bInSoft;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PathGoalEvaluator.GetDumpString
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UPathGoalEvaluator::GetDumpString()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathGoalEvaluator.GetDumpString"));

	UPathGoalEvaluator_GetDumpString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PathGoalEvaluator.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UPathGoalEvaluator::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathGoalEvaluator.Recycle"));

	UPathGoalEvaluator_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Goal_AtActor.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UGoal_AtActor::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Goal_AtActor.Recycle"));

	UGoal_AtActor_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Goal_AtActor.AtActor
// (PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class APawn*                   P                              (Parm)
// class AActor*                  Goal                           (Parm)
// float                          Dist                           (OptionalParm, Parm)
// bool                           bReturnPartial                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGoal_AtActor::AtActor(class APawn* P, class AActor* Goal, float Dist, bool bReturnPartial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Goal_AtActor.AtActor"));

	UGoal_AtActor_AtActor_Params params;
	params.P = P;
	params.Goal = Goal;
	params.Dist = Dist;
	params.bReturnPartial = bReturnPartial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Goal_Null.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UGoal_Null::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Goal_Null.Recycle"));

	UGoal_Null_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Goal_Null.GoUntilBust
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// int                            InMaxPathVisits                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGoal_Null::STATIC_GoUntilBust(class APawn* P, int InMaxPathVisits)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Goal_Null.GoUntilBust"));

	UGoal_Null_GoUntilBust_Params params;
	params.P = P;
	params.InMaxPathVisits = InMaxPathVisits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.CreateForceField
// (Defined, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_ForceField*  AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASkeletalMeshActor::CreateForceField(class UAnimNotify_ForceField* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.CreateForceField"));

	ASkeletalMeshActor_CreateForceField_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.SkelMeshActorOnParticleSystemFinished
// (NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void ASkeletalMeshActor::SkelMeshActorOnParticleSystemFinished(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.SkelMeshActorOnParticleSystemFinished"));

	ASkeletalMeshActor_SkelMeshActorOnParticleSystemFinished_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.PlayParticleEffect
// (Final, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_PlayParticleEffect* AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASkeletalMeshActor::PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.PlayParticleEffect"));

	ASkeletalMeshActor_PlayParticleEffect_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ASkeletalMeshActor_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ASkeletalMeshActor::ApplyCheckpointRecord(struct ASkeletalMeshActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.ApplyCheckpointRecord"));

	ASkeletalMeshActor_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.SkeletalMeshActor.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ASkeletalMeshActor_FCheckpointRecord Record                         (Parm, OutParm)

void ASkeletalMeshActor::STATIC_CreateCheckpointRecord(struct ASkeletalMeshActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.CreateCheckpointRecord"));

	ASkeletalMeshActor_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.SkeletalMeshActor.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASkeletalMeshActor::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.ShouldSaveForCheckpoint"));

	ASkeletalMeshActor_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void ASkeletalMeshActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.TakeDamage"));

	ASkeletalMeshActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.DoKismetAttachment
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class AActor*                  Attachment                     (Parm)
// class USeqAct_AttachToActor*   Action                         (Parm)

void ASkeletalMeshActor::STATIC_DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.DoKismetAttachment"));

	ASkeletalMeshActor_DoKismetAttachment_Params params;
	params.Attachment = Attachment;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnSetSkelControlTarget
// (Final, Iterator, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class USeqAct_SetSkelControlTarget* Action                         (Parm)

void ASkeletalMeshActor::OnSetSkelControlTarget(class USeqAct_SetSkelControlTarget* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnSetSkelControlTarget"));

	ASkeletalMeshActor_OnSetSkelControlTarget_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnUpdatePhysBonesFromAnim
// (Defined, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class USeqAct_UpdatePhysBonesFromAnim* Action                         (Parm)

void ASkeletalMeshActor::OnUpdatePhysBonesFromAnim(class USeqAct_UpdatePhysBonesFromAnim* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnUpdatePhysBonesFromAnim"));

	ASkeletalMeshActor_OnUpdatePhysBonesFromAnim_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnSetMesh
// (Iterator, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class USeqAct_SetMesh*         Action                         (Parm)

void ASkeletalMeshActor::OnSetMesh(class USeqAct_SetMesh* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnSetMesh"));

	ASkeletalMeshActor_OnSetMesh_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.IsActorPlayingFaceFXAnim
// (Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASkeletalMeshActor::STATIC_IsActorPlayingFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.IsActorPlayingFaceFXAnim"));

	ASkeletalMeshActor_IsActorPlayingFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.GetActorFaceFXAsset
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAsset*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UFaceFXAsset* ASkeletalMeshActor::GetActorFaceFXAsset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.GetActorFaceFXAsset"));

	ASkeletalMeshActor_GetActorFaceFXAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.OnPlayFaceFXAnim
// (Final, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_PlayFaceFXAnim*  inAction                       (Parm)

void ASkeletalMeshActor::STATIC_OnPlayFaceFXAnim(class USeqAct_PlayFaceFXAnim* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnPlayFaceFXAnim"));

	ASkeletalMeshActor_OnPlayFaceFXAnim_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.GetFaceFXAudioComponent
// (Final, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAudioComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UAudioComponent* ASkeletalMeshActor::GetFaceFXAudioComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.GetFaceFXAudioComponent"));

	ASkeletalMeshActor_GetFaceFXAudioComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.StopActorFaceFXAnim
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void ASkeletalMeshActor::StopActorFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.StopActorFaceFXAnim"));

	ASkeletalMeshActor_StopActorFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.PlayActorFaceFXAnim
// (Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// struct FString                 SeqName                        (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASkeletalMeshActor::PlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.PlayActorFaceFXAnim"));

	ASkeletalMeshActor_PlayActorFaceFXAnim_Params params;
	params.AnimSet = AnimSet;
	params.GroupName = GroupName;
	params.SeqName = SeqName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshActor.MAT_FinishAnimControl
// (Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void ASkeletalMeshActor::STATIC_MAT_FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.MAT_FinishAnimControl"));

	ASkeletalMeshActor_MAT_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.FinishAnimControl
// (Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void ASkeletalMeshActor::FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.FinishAnimControl"));

	ASkeletalMeshActor_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.SetAnimPosition
// (Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void ASkeletalMeshActor::SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.SetAnimPosition"));

	ASkeletalMeshActor_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.MAT_BeginAnimControl
// (Final, Defined, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void ASkeletalMeshActor::STATIC_MAT_BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.MAT_BeginAnimControl"));

	ASkeletalMeshActor_MAT_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.BeginAnimControl
// (Final, Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void ASkeletalMeshActor::BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.BeginAnimControl"));

	ASkeletalMeshActor_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnSetMaterial
// (Defined, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetMaterial*     Action                         (Parm)

void ASkeletalMeshActor::STATIC_OnSetMaterial(class USeqAct_SetMaterial* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnSetMaterial"));

	ASkeletalMeshActor_OnSetMaterial_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ASkeletalMeshActor::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.OnToggle"));

	ASkeletalMeshActor_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ASkeletalMeshActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.ReplicatedEvent"));

	ASkeletalMeshActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.UpdateAnimSetList
// (Final, Defined, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ASkeletalMeshActor::UpdateAnimSetList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.UpdateAnimSetList"));

	ASkeletalMeshActor_UpdateAnimSetList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ASkeletalMeshActor::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.Destroyed"));

	ASkeletalMeshActor_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.UpdateComponentTickGroup
// (Final, Defined, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ASkeletalMeshActor::UpdateComponentTickGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.UpdateComponentTickGroup"));

	ASkeletalMeshActor_UpdateComponentTickGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.CollisionChanged
// (Latent, Net, Simulated, Native, HasOptionalParms)

void ASkeletalMeshActor::CollisionChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.CollisionChanged"));

	ASkeletalMeshActor_CollisionChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ASkeletalMeshActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActor.PostBeginPlay"));

	ASkeletalMeshActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorBasedOnExtremeContent.SetMaterialBasedOnExtremeContent
// (Event, HasOptionalParms)

void ASkeletalMeshActorBasedOnExtremeContent::SetMaterialBasedOnExtremeContent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorBasedOnExtremeContent.SetMaterialBasedOnExtremeContent"));

	ASkeletalMeshActorBasedOnExtremeContent_SetMaterialBasedOnExtremeContent_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorBasedOnExtremeContent.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ASkeletalMeshActorBasedOnExtremeContent::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorBasedOnExtremeContent.PostBeginPlay"));

	ASkeletalMeshActorBasedOnExtremeContent_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.SetSkelControlScale
// (Defined, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void ASkeletalMeshActorMAT::SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.SetSkelControlScale"));

	ASkeletalMeshActorMAT_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.SetMorphWeight
// (Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void ASkeletalMeshActorMAT::SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.SetMorphWeight"));

	ASkeletalMeshActorMAT_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.FinishAnimControl
// (Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void ASkeletalMeshActorMAT::FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.FinishAnimControl"));

	ASkeletalMeshActorMAT_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.MAT_SetAnimPosition
// (Final, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void ASkeletalMeshActorMAT::STATIC_MAT_SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.MAT_SetAnimPosition"));

	ASkeletalMeshActorMAT_MAT_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.SetAnimPosition
// (Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void ASkeletalMeshActorMAT::SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.SetAnimPosition"));

	ASkeletalMeshActorMAT_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.ClearAnimNodes
// (Final, Defined, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void ASkeletalMeshActorMAT::ClearAnimNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.ClearAnimNodes"));

	ASkeletalMeshActorMAT_ClearAnimNodes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.CacheAnimNodes
// (Final, Iterator, Latent, PreOperator, Simulated, Native, HasOptionalParms)

void ASkeletalMeshActorMAT::CacheAnimNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.CacheAnimNodes"));

	ASkeletalMeshActorMAT_CacheAnimNodes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.PostInitAnimTree
// (Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void ASkeletalMeshActorMAT::PostInitAnimTree(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.PostInitAnimTree"));

	ASkeletalMeshActorMAT_PostInitAnimTree_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ASkeletalMeshActorMAT::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.Destroyed"));

	ASkeletalMeshActorMAT_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.MAT_SetSkelControlStrength
// (Final, PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          ControlStrength                (Parm)

void ASkeletalMeshActorMAT::STATIC_MAT_SetSkelControlStrength(const struct FName& SkelControlName, float ControlStrength)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.MAT_SetSkelControlStrength"));

	ASkeletalMeshActorMAT_MAT_SetSkelControlStrength_Params params;
	params.SkelControlName = SkelControlName;
	params.ControlStrength = ControlStrength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.MAT_SetSkelControlScale
// (PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void ASkeletalMeshActorMAT::STATIC_MAT_SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.MAT_SetSkelControlScale"));

	ASkeletalMeshActorMAT_MAT_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.MAT_SetMorphWeight
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void ASkeletalMeshActorMAT::STATIC_MAT_SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.MAT_SetMorphWeight"));

	ASkeletalMeshActorMAT_MAT_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActorMAT.MAT_SetAnimWeights
// (Defined, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// TArray<struct FAnimSlotInfo>   SlotInfos                      (Parm, NeedCtorLink)

void ASkeletalMeshActorMAT::STATIC_MAT_SetAnimWeights(TArray<struct FAnimSlotInfo> SlotInfos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshActorMAT.MAT_SetAnimWeights"));

	ASkeletalMeshActorMAT_MAT_SetAnimWeights_Params params;
	params.SlotInfos = SlotInfos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify.OnAnimNodeSequenceBecomeRelevant
// (Final, Iterator, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       OwningNode                     (Parm)

void UAnimNotify::OnAnimNodeSequenceBecomeRelevant(class UAnimNodeSequence* OwningNode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify.OnAnimNodeSequenceBecomeRelevant"));

	UAnimNotify_OnAnimNodeSequenceBecomeRelevant_Params params;
	params.OwningNode = OwningNode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify.OnAnimNodeSequenceCeaseRelevant
// (Defined, Iterator, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       OwningNode                     (Parm)

void UAnimNotify::OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify.OnAnimNodeSequenceCeaseRelevant"));

	UAnimNotify_OnAnimNodeSequenceCeaseRelevant_Params params;
	params.OwningNode = OwningNode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify.FindNextNotifyOfClass
// (Final, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)
// class UClass*                  NotifyClass                    (Parm)
// struct FAnimNotifyEvent        OutEvent                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAnimNotify::STATIC_FindNextNotifyOfClass(class UAnimNodeSequence* AnimSeqInstigator, class UClass* NotifyClass, struct FAnimNotifyEvent* OutEvent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify.FindNextNotifyOfClass"));

	UAnimNotify_FindNextNotifyOfClass_Params params;
	params.AnimSeqInstigator = AnimSeqInstigator;
	params.NotifyClass = NotifyClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutEvent != nullptr)
		*OutEvent = params.OutEvent;

	return params.ReturnValue;
}


// Function Engine.AnimNotify_AkEvent.GetAkEventToPlay
// (Defined, Net, Simulated, Native, Event, Static)
// Parameters:
// class USkeletalMeshComponent*  skel                           (Parm, EditInline)
// class UAkEvent*                ReturnValue                    (Parm, OutParm, ReturnParm)

class UAkEvent* UAnimNotify_AkEvent::STATIC_GetAkEventToPlay(class USkeletalMeshComponent* skel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_AkEvent.GetAkEventToPlay"));

	UAnimNotify_AkEvent_GetAkEventToPlay_Params params;
	params.skel = skel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify_PlayParticleEffect.GetParticleChannels
// (Final, Iterator, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class USkeletalMeshComponent*  skel                           (Parm, EditInline)
// struct FParticleChannelContainer ReturnValue                    (Parm, OutParm, ReturnParm)

struct FParticleChannelContainer UAnimNotify_PlayParticleEffect::STATIC_GetParticleChannels(class USkeletalMeshComponent* skel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_PlayParticleEffect.GetParticleChannels"));

	UAnimNotify_PlayParticleEffect_GetParticleChannels_Params params;
	params.skel = skel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify_PlayParticleEffect.GetParticleSystemToPlay
// (Defined, Iterator, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class USkeletalMeshComponent*  skel                           (Parm, EditInline)
// class UParticleSystem*         ReturnValue                    (Parm, OutParm, ReturnParm)

class UParticleSystem* UAnimNotify_PlayParticleEffect::STATIC_GetParticleSystemToPlay(class USkeletalMeshComponent* skel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_PlayParticleEffect.GetParticleSystemToPlay"));

	UAnimNotify_PlayParticleEffect_GetParticleSystemToPlay_Params params;
	params.skel = skel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify_Scripted.NotifyEnd
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Owner                          (Parm)
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)

void UAnimNotify_Scripted::NotifyEnd(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_Scripted.NotifyEnd"));

	UAnimNotify_Scripted_NotifyEnd_Params params;
	params.Owner = Owner;
	params.AnimSeqInstigator = AnimSeqInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify_Scripted.Notify
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Owner                          (Parm)
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)

void UAnimNotify_Scripted::Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_Scripted.Notify"));

	UAnimNotify_Scripted_Notify_Params params;
	params.Owner = Owner;
	params.AnimSeqInstigator = AnimSeqInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify_PawnMaterialParam.Notify
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Owner                          (Parm)
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)

void UAnimNotify_PawnMaterialParam::Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_PawnMaterialParam.Notify"));

	UAnimNotify_PawnMaterialParam_Notify_Params params;
	params.Owner = Owner;
	params.AnimSeqInstigator = AnimSeqInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify_ViewShake.Notify
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Owner                          (Parm)
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)

void UAnimNotify_ViewShake::Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_ViewShake.Notify"));

	UAnimNotify_ViewShake_Notify_Params params;
	params.Owner = Owner;
	params.AnimSeqInstigator = AnimSeqInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify_Sound.GetSoundCueToPlay
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class USkeletalMeshComponent*  skel                           (Parm, EditInline)
// class USoundCue*               ReturnValue                    (Parm, OutParm, ReturnParm)

class USoundCue* UAnimNotify_Sound::STATIC_GetSoundCueToPlay(class USkeletalMeshComponent* skel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_Sound.GetSoundCueToPlay"));

	UAnimNotify_Sound_GetSoundCueToPlay_Params params;
	params.skel = skel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify_Trails.GetNumSteps
// (Defined, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            InLastTrailIndex               (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UAnimNotify_Trails::STATIC_GetNumSteps(int InLastTrailIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_Trails.GetNumSteps"));

	UAnimNotify_Trails_GetNumSteps_Params params;
	params.InLastTrailIndex = InLastTrailIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNode.ReplayAnim
// (Defined, Iterator, Latent, PreOperator, Singular, Native, HasOptionalParms)

void UAnimNode::ReplayAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.ReplayAnim"));

	UAnimNode_ReplayAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode.StopAnim
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void UAnimNode::StopAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.StopAnim"));

	UAnimNode_StopAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode.PlayAnim
// (Iterator, Net, HasOptionalParms)
// Parameters:
// bool                           bLoop                          (OptionalParm, Parm)
// float                          Rate                           (OptionalParm, Parm)
// float                          StartTime                      (OptionalParm, Parm)

void UAnimNode::PlayAnim(bool bLoop, float Rate, float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.PlayAnim"));

	UAnimNode_PlayAnim_Params params;
	params.bLoop = bLoop;
	params.Rate = Rate;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode.GetNodesByClassWrapper
// (Iterator, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// TArray<class UAnimNode*>       Nodes                          (Parm, OutParm, NeedCtorLink)
// class UClass*                  BaseClass                      (Parm)

void UAnimNode::STATIC_GetNodesByClassWrapper(class UClass* BaseClass, TArray<class UAnimNode*>* Nodes)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.GetNodesByClassWrapper"));

	UAnimNode_GetNodesByClassWrapper_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Nodes != nullptr)
		*Nodes = params.Nodes;
}


// Function Engine.AnimNode.FindAnimNode
// (Defined, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FName                   InNodeName                     (Parm)
// class UAnimNode*               ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNode* UAnimNode::STATIC_FindAnimNode(const struct FName& InNodeName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.FindAnimNode"));

	UAnimNode_FindAnimNode_Params params;
	params.InNodeName = InNodeName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNode.OnCeaseRelevant
// (Defined, Latent, Exec, Native, HasOptionalParms)

void UAnimNode::OnCeaseRelevant()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.OnCeaseRelevant"));

	UAnimNode_OnCeaseRelevant_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode.OnBecomeRelevant
// (Final, Latent, Exec, Native, HasOptionalParms)

void UAnimNode::OnBecomeRelevant()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.OnBecomeRelevant"));

	UAnimNode_OnBecomeRelevant_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode.OnInit
// (Final, Iterator, PreOperator, Exec, Native, HasOptionalParms)

void UAnimNode::OnInit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode.OnInit"));

	UAnimNode_OnInit_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlendBase.ReplayAnim
// (Defined, Iterator, Latent, PreOperator, Singular, Native, HasOptionalParms)

void UAnimNodeBlendBase::ReplayAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendBase.ReplayAnim"));

	UAnimNodeBlendBase_ReplayAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlendBase.StopAnim
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void UAnimNodeBlendBase::StopAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendBase.StopAnim"));

	UAnimNodeBlendBase_StopAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlendBase.PlayAnim
// (Iterator, Net, HasOptionalParms)
// Parameters:
// bool                           bLoop                          (OptionalParm, Parm)
// float                          Rate                           (OptionalParm, Parm)
// float                          StartTime                      (OptionalParm, Parm)

void UAnimNodeBlendBase::PlayAnim(bool bLoop, float Rate, float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendBase.PlayAnim"));

	UAnimNodeBlendBase_PlayAnim_Params params;
	params.bLoop = bLoop;
	params.Rate = Rate;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNode_MultiBlendPerBone.SetMaskWeight
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            MaskIndex                      (Parm)
// float                          DesiredWeight                  (Parm)
// float                          BlendTime                      (Parm)

void UAnimNode_MultiBlendPerBone::SetMaskWeight(int MaskIndex, float DesiredWeight, float BlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNode_MultiBlendPerBone.SetMaskWeight"));

	UAnimNode_MultiBlendPerBone_SetMaskWeight_Params params;
	params.MaskIndex = MaskIndex;
	params.DesiredWeight = DesiredWeight;
	params.BlendTime = BlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeAimOffset.SetActiveProfileByIndex
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ProfileIndex                   (Parm)

void UAnimNodeAimOffset::SetActiveProfileByIndex(int ProfileIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeAimOffset.SetActiveProfileByIndex"));

	UAnimNodeAimOffset_SetActiveProfileByIndex_Params params;
	params.ProfileIndex = ProfileIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeAimOffset.SetActiveProfileByName
// (Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ProfileName                    (Parm)

void UAnimNodeAimOffset::SetActiveProfileByName(const struct FName& ProfileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeAimOffset.SetActiveProfileByName"));

	UAnimNodeAimOffset_SetActiveProfileByName_Params params;
	params.ProfileName = ProfileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlend.SetBlendTarget
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          BlendTarget                    (Parm)
// float                          BlendTime                      (Parm)

void UAnimNodeBlend::SetBlendTarget(float BlendTarget, float BlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlend.SetBlendTarget"));

	UAnimNodeBlend_SetBlendTarget_Params params;
	params.BlendTarget = BlendTarget;
	params.BlendTime = BlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeAdditiveBlending.SetBlendTarget
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          BlendTarget                    (Parm)
// float                          BlendTime                      (Parm)

void UAnimNodeAdditiveBlending::SetBlendTarget(float BlendTarget, float BlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeAdditiveBlending.SetBlendTarget"));

	UAnimNodeAdditiveBlending_SetBlendTarget_Params params;
	params.BlendTarget = BlendTarget;
	params.BlendTime = BlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlendPerBone.SetBlendTarget
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          BlendTarget                    (Parm)
// float                          BlendTime                      (Parm)

void UAnimNodeBlendPerBone::SetBlendTarget(float BlendTarget, float BlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendPerBone.SetBlendTarget"));

	UAnimNodeBlendPerBone_SetBlendTarget_Params params;
	params.BlendTarget = BlendTarget;
	params.BlendTime = BlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeCrossfader.GetActiveChild
// (Final, Iterator, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimNodeCrossfader::STATIC_GetActiveChild()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeCrossfader.GetActiveChild"));

	UAnimNodeCrossfader_GetActiveChild_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeCrossfader.GetAnimName
// (Final, Defined, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UAnimNodeCrossfader::STATIC_GetAnimName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeCrossfader.GetAnimName"));

	UAnimNodeCrossfader_GetAnimName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeCrossfader.BlendToLoopingAnim
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Operator)
// Parameters:
// struct FName                   AnimSeqName                    (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          Rate                           (OptionalParm, Parm)

void UAnimNodeCrossfader::BlendToLoopingAnim(const struct FName& AnimSeqName, float BlendInTime, float Rate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeCrossfader.BlendToLoopingAnim"));

	UAnimNodeCrossfader_BlendToLoopingAnim_Params params;
	params.AnimSeqName = AnimSeqName;
	params.BlendInTime = BlendInTime;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeCrossfader.PlayOneShotAnim
// (Final, Iterator, Singular, NetReliable, HasOptionalParms)
// Parameters:
// struct FName                   AnimSeqName                    (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bDontBlendOut                  (OptionalParm, Parm)
// float                          Rate                           (OptionalParm, Parm)

void UAnimNodeCrossfader::PlayOneShotAnim(const struct FName& AnimSeqName, float BlendInTime, float BlendOutTime, bool bDontBlendOut, float Rate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeCrossfader.PlayOneShotAnim"));

	UAnimNodeCrossfader_PlayOneShotAnim_Params params;
	params.AnimSeqName = AnimSeqName;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bDontBlendOut = bDontBlendOut;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.SetPlayRate
// (Defined, Latent, Net, NetReliable, Exec, Operator, HasOptionalParms)
// Parameters:
// float                          fPlayRate                      (Parm)

void UAnimNodePlayCustomAnim::SetPlayRate(float fPlayRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.SetPlayRate"));

	UAnimNodePlayCustomAnim_SetPlayRate_Params params;
	params.fPlayRate = fPlayRate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.SetRootBoneAxisOption
// (Final, Defined, Iterator, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERootBoneAxis>     AxisX                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisY                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisZ                          (OptionalParm, Parm)

void UAnimNodePlayCustomAnim::SetRootBoneAxisOption(TEnumAsByte<ERootBoneAxis> AxisX, TEnumAsByte<ERootBoneAxis> AxisY, TEnumAsByte<ERootBoneAxis> AxisZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.SetRootBoneAxisOption"));

	UAnimNodePlayCustomAnim_SetRootBoneAxisOption_Params params;
	params.AxisX = AxisX;
	params.AxisY = AxisY;
	params.AxisZ = AxisZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.GetCustomAnimNodeSeq
// (PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimNodePlayCustomAnim::STATIC_GetCustomAnimNodeSeq()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.GetCustomAnimNodeSeq"));

	UAnimNodePlayCustomAnim_GetCustomAnimNodeSeq_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodePlayCustomAnim.SetActorAnimEndNotification
// (Final, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewStatus                     (Parm)

void UAnimNodePlayCustomAnim::SetActorAnimEndNotification(bool bNewStatus)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.SetActorAnimEndNotification"));

	UAnimNodePlayCustomAnim_SetActorAnimEndNotification_Params params;
	params.bNewStatus = bNewStatus;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.SetCustomAnim
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)

void UAnimNodePlayCustomAnim::SetCustomAnim(const struct FName& AnimName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.SetCustomAnim"));

	UAnimNodePlayCustomAnim_SetCustomAnim_Params params;
	params.AnimName = AnimName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.StopCustomAnim
// (Defined, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// float                          BlendOutTime                   (Parm)

void UAnimNodePlayCustomAnim::StopCustomAnim(float BlendOutTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.StopCustomAnim"));

	UAnimNodePlayCustomAnim_StopCustomAnim_Params params;
	params.BlendOutTime = BlendOutTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.PlayCustomAnimByDuration
// (Iterator, Latent, Net, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)
// float                          Duration                       (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLooping                       (OptionalParm, Parm)
// bool                           bOverride                      (OptionalParm, Parm)

void UAnimNodePlayCustomAnim::PlayCustomAnimByDuration(const struct FName& AnimName, float Duration, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.PlayCustomAnimByDuration"));

	UAnimNodePlayCustomAnim_PlayCustomAnimByDuration_Params params;
	params.AnimName = AnimName;
	params.Duration = Duration;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLooping = bLooping;
	params.bOverride = bOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodePlayCustomAnim.PlayCustomAnim
// (Final, Defined, Latent, Net, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)
// float                          Rate                           (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLooping                       (OptionalParm, Parm)
// bool                           bOverride                      (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodePlayCustomAnim::PlayCustomAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodePlayCustomAnim.PlayCustomAnim"));

	UAnimNodePlayCustomAnim_PlayCustomAnim_Params params;
	params.AnimName = AnimName;
	params.Rate = Rate;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLooping = bLooping;
	params.bOverride = bOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeBlendList.SetActiveChild
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ChildIndex                     (Parm)
// float                          BlendTime                      (Parm)

void UAnimNodeBlendList::SetActiveChild(int ChildIndex, float BlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendList.SetActiveChild"));

	UAnimNodeBlendList_SetActiveChild_Params params;
	params.ChildIndex = ChildIndex;
	params.BlendTime = BlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeBlendMultiBone.SetTargetStartBone
// (Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            TargetIdx                      (Parm)
// struct FName                   StartBoneName                  (Parm)
// float                          PerBoneIncrease                (OptionalParm, Parm)

void UAnimNodeBlendMultiBone::SetTargetStartBone(int TargetIdx, const struct FName& StartBoneName, float PerBoneIncrease)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeBlendMultiBone.SetTargetStartBone"));

	UAnimNodeBlendMultiBone_SetTargetStartBone_Params params;
	params.TargetIdx = TargetIdx;
	params.StartBoneName = StartBoneName;
	params.PerBoneIncrease = PerBoneIncrease;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.TickChildWeights
// (PreOperator, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// float                          DeltaSeconds                   (Parm)

void UAnimNodeSlot::TickChildWeights(float DeltaSeconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.TickChildWeights"));

	UAnimNodeSlot_TickChildWeights_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.SetRootBoneRotationOption
// (Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERootRotationOption> AxisX                          (OptionalParm, Parm)
// TEnumAsByte<ERootRotationOption> AxisY                          (OptionalParm, Parm)
// TEnumAsByte<ERootRotationOption> AxisZ                          (OptionalParm, Parm)

void UAnimNodeSlot::SetRootBoneRotationOption(TEnumAsByte<ERootRotationOption> AxisX, TEnumAsByte<ERootRotationOption> AxisY, TEnumAsByte<ERootRotationOption> AxisZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.SetRootBoneRotationOption"));

	UAnimNodeSlot_SetRootBoneRotationOption_Params params;
	params.AxisX = AxisX;
	params.AxisY = AxisY;
	params.AxisZ = AxisZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.SetRootBoneAxisOption
// (Final, Defined, Iterator, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERootBoneAxis>     AxisX                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisY                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisZ                          (OptionalParm, Parm)

void UAnimNodeSlot::SetRootBoneAxisOption(TEnumAsByte<ERootBoneAxis> AxisX, TEnumAsByte<ERootBoneAxis> AxisY, TEnumAsByte<ERootBoneAxis> AxisZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.SetRootBoneAxisOption"));

	UAnimNodeSlot_SetRootBoneAxisOption_Params params;
	params.AxisX = AxisX;
	params.AxisY = AxisY;
	params.AxisZ = AxisZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.GetCustomAnimNodeSeq
// (PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimNodeSlot::STATIC_GetCustomAnimNodeSeq()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.GetCustomAnimNodeSeq"));

	UAnimNodeSlot_GetCustomAnimNodeSeq_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSlot.SetActorAnimEndNotification
// (Final, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewStatus                     (Parm)

void UAnimNodeSlot::SetActorAnimEndNotification(bool bNewStatus)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.SetActorAnimEndNotification"));

	UAnimNodeSlot_SetActorAnimEndNotification_Params params;
	params.bNewStatus = bNewStatus;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.SetCustomAnim
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)

void UAnimNodeSlot::SetCustomAnim(const struct FName& AnimName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.SetCustomAnim"));

	UAnimNodeSlot_SetCustomAnim_Params params;
	params.AnimName = AnimName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.SetAllowPauseAnims
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSet                           (Parm)

void UAnimNodeSlot::SetAllowPauseAnims(bool bSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.SetAllowPauseAnims"));

	UAnimNodeSlot_SetAllowPauseAnims_Params params;
	params.bSet = bSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.StopCustomAnim
// (Defined, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// float                          BlendOutTime                   (Parm)

void UAnimNodeSlot::StopCustomAnim(float BlendOutTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.StopCustomAnim"));

	UAnimNodeSlot_StopCustomAnim_Params params;
	params.BlendOutTime = BlendOutTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSlot.GetPlayedAnimation
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UAnimNodeSlot::STATIC_GetPlayedAnimation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.GetPlayedAnimation"));

	UAnimNodeSlot_GetPlayedAnimation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSlot.PlayCustomAnimByDuration
// (Iterator, Latent, Net, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)
// float                          Duration                       (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLooping                       (OptionalParm, Parm)
// bool                           bOverride                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAnimNodeSlot::PlayCustomAnimByDuration(const struct FName& AnimName, float Duration, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.PlayCustomAnimByDuration"));

	UAnimNodeSlot_PlayCustomAnimByDuration_Params params;
	params.AnimName = AnimName;
	params.Duration = Duration;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLooping = bLooping;
	params.bOverride = bOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSlot.PlayCustomAnim
// (Final, Defined, Latent, Net, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)
// float                          Rate                           (Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLooping                       (OptionalParm, Parm)
// bool                           bOverride                      (OptionalParm, Parm)
// float                          StartTime                      (OptionalParm, Parm)
// float                          EndTime                        (OptionalParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSlot::PlayCustomAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, float EndTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSlot.PlayCustomAnim"));

	UAnimNodeSlot_PlayCustomAnim_Params params;
	params.AnimName = AnimName;
	params.Rate = Rate;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLooping = bLooping;
	params.bOverride = bOverride;
	params.StartTime = StartTime;
	params.EndTime = EndTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSynch.SetGroupRateScale
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          NewRateScale                   (Parm)

void UAnimNodeSynch::SetGroupRateScale(const struct FName& GroupName, float NewRateScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.SetGroupRateScale"));

	UAnimNodeSynch_SetGroupRateScale_Params params;
	params.GroupName = GroupName;
	params.NewRateScale = NewRateScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSynch.GetRelativePosition
// (Final, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSynch::STATIC_GetRelativePosition(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.GetRelativePosition"));

	UAnimNodeSynch_GetRelativePosition_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSynch.ForceRelativePosition
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          RelativePosition               (Parm)

void UAnimNodeSynch::STATIC_ForceRelativePosition(const struct FName& GroupName, float RelativePosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.ForceRelativePosition"));

	UAnimNodeSynch_ForceRelativePosition_Params params;
	params.GroupName = GroupName;
	params.RelativePosition = RelativePosition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSynch.GetMasterNodeOfGroup
// (Final, Defined, Iterator, Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimNodeSynch::STATIC_GetMasterNodeOfGroup(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.GetMasterNodeOfGroup"));

	UAnimNodeSynch_GetMasterNodeOfGroup_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSynch.RemoveNodeFromGroup
// (Iterator, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)
// struct FName                   GroupName                      (Parm)

void UAnimNodeSynch::RemoveNodeFromGroup(class UAnimNodeSequence* SeqNode, const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.RemoveNodeFromGroup"));

	UAnimNodeSynch_RemoveNodeFromGroup_Params params;
	params.SeqNode = SeqNode;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSynch.AddNodeToGroup
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)
// struct FName                   GroupName                      (Parm)

void UAnimNodeSynch::AddNodeToGroup(class UAnimNodeSequence* SeqNode, const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSynch.AddNodeToGroup"));

	UAnimNodeSynch_AddNodeToGroup_Params params;
	params.SeqNode = SeqNode;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimTree.GetGroupIndex
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UAnimTree::STATIC_GetGroupIndex(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.GetGroupIndex"));

	UAnimTree_GetGroupIndex_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.GetGroupRateScale
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimTree::STATIC_GetGroupRateScale(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.GetGroupRateScale"));

	UAnimTree_GetGroupRateScale_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.SetGroupRateScale
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          NewRateScale                   (Parm)

void UAnimTree::SetGroupRateScale(const struct FName& GroupName, float NewRateScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.SetGroupRateScale"));

	UAnimTree_SetGroupRateScale_Params params;
	params.GroupName = GroupName;
	params.NewRateScale = NewRateScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimTree.GetGroupRelativePosition
// (Exec, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimTree::STATIC_GetGroupRelativePosition(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.GetGroupRelativePosition"));

	UAnimTree_GetGroupRelativePosition_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.ForceGroupRelativePosition
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// float                          RelativePosition               (Parm)

void UAnimTree::STATIC_ForceGroupRelativePosition(const struct FName& GroupName, float RelativePosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.ForceGroupRelativePosition"));

	UAnimTree_ForceGroupRelativePosition_Params params;
	params.GroupName = GroupName;
	params.RelativePosition = RelativePosition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimTree.GetGroupNotifyMaster
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimTree::STATIC_GetGroupNotifyMaster(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.GetGroupNotifyMaster"));

	UAnimTree_GetGroupNotifyMaster_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.GetGroupSynchMaster
// (Final, Exec, Native, Event, Static)
// Parameters:
// struct FName                   GroupName                      (Parm)
// class UAnimNodeSequence*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNodeSequence* UAnimTree::STATIC_GetGroupSynchMaster(const struct FName& GroupName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.GetGroupSynchMaster"));

	UAnimTree_GetGroupSynchMaster_Params params;
	params.GroupName = GroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.SetAnimGroupForNode
// (Defined, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNodeSequence*       SeqNode                        (Parm)
// struct FName                   GroupName                      (Parm)
// bool                           bCreateIfNotFound              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAnimTree::SetAnimGroupForNode(class UAnimNodeSequence* SeqNode, const struct FName& GroupName, bool bCreateIfNotFound)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.SetAnimGroupForNode"));

	UAnimTree_SetAnimGroupForNode_Params params;
	params.SeqNode = SeqNode;
	params.GroupName = GroupName;
	params.bCreateIfNotFound = bCreateIfNotFound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.SetUseSavedPose
// (Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bUseSaved                      (Parm)

void UAnimTree::SetUseSavedPose(bool bUseSaved)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.SetUseSavedPose"));

	UAnimTree_SetUseSavedPose_Params params;
	params.bUseSaved = bUseSaved;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimTree.FindMorphNode
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   InNodeName                     (Parm)
// class UMorphNodeBase*          ReturnValue                    (Parm, OutParm, ReturnParm)

class UMorphNodeBase* UAnimTree::STATIC_FindMorphNode(const struct FName& InNodeName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.FindMorphNode"));

	UAnimTree_FindMorphNode_Params params;
	params.InNodeName = InNodeName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimTree.FindSkelControl
// (Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   InControlName                  (Parm)
// class USkelControlBase*        ReturnValue                    (Parm, OutParm, ReturnParm)

class USkelControlBase* UAnimTree::STATIC_FindSkelControl(const struct FName& InControlName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimTree.FindSkelControl"));

	UAnimTree_FindSkelControl_Params params;
	params.InControlName = InControlName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.SetRootBoneRotationOption
// (Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERootRotationOption> AxisX                          (OptionalParm, Parm)
// TEnumAsByte<ERootRotationOption> AxisY                          (OptionalParm, Parm)
// TEnumAsByte<ERootRotationOption> AxisZ                          (OptionalParm, Parm)

void UAnimNodeSequence::SetRootBoneRotationOption(TEnumAsByte<ERootRotationOption> AxisX, TEnumAsByte<ERootRotationOption> AxisY, TEnumAsByte<ERootRotationOption> AxisZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.SetRootBoneRotationOption"));

	UAnimNodeSequence_SetRootBoneRotationOption_Params params;
	params.AxisX = AxisX;
	params.AxisY = AxisY;
	params.AxisZ = AxisZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.SetRootBoneAxisOption
// (Final, Defined, Iterator, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ERootBoneAxis>     AxisX                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisY                          (OptionalParm, Parm)
// TEnumAsByte<ERootBoneAxis>     AxisZ                          (OptionalParm, Parm)

void UAnimNodeSequence::SetRootBoneAxisOption(TEnumAsByte<ERootBoneAxis> AxisX, TEnumAsByte<ERootBoneAxis> AxisY, TEnumAsByte<ERootBoneAxis> AxisZ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.SetRootBoneAxisOption"));

	UAnimNodeSequence_SetRootBoneAxisOption_Params params;
	params.AxisX = AxisX;
	params.AxisY = AxisY;
	params.AxisZ = AxisZ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.GetTimeLeft
// (Defined, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_GetTimeLeft()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.GetTimeLeft"));

	UAnimNodeSequence_GetTimeLeft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.GetAnimPlaybackLength
// (Iterator, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_GetAnimPlaybackLength()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.GetAnimPlaybackLength"));

	UAnimNodeSequence_GetAnimPlaybackLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.GetGlobalPlayRate
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_GetGlobalPlayRate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.GetGlobalPlayRate"));

	UAnimNodeSequence_GetGlobalPlayRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.GetGroupRelativePosition
// (Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_GetGroupRelativePosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.GetGroupRelativePosition"));

	UAnimNodeSequence_GetGroupRelativePosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.FindGroupPosition
// (Final, Iterator, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// float                          GroupRelativePosition          (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_FindGroupPosition(float GroupRelativePosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.FindGroupPosition"));

	UAnimNodeSequence_FindGroupPosition_Params params;
	params.GroupRelativePosition = GroupRelativePosition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.FindGroupRelativePosition
// (Defined, Iterator, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// float                          GroupRelativePosition          (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_FindGroupRelativePosition(float GroupRelativePosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.FindGroupRelativePosition"));

	UAnimNodeSequence_FindGroupRelativePosition_Params params;
	params.GroupRelativePosition = GroupRelativePosition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.GetNormalizedPosition
// (Final, Iterator, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimNodeSequence::STATIC_GetNormalizedPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.GetNormalizedPosition"));

	UAnimNodeSequence_GetNormalizedPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNodeSequence.SetPosition
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// float                          NewTime                        (Parm)
// bool                           bFireNotifies                  (Parm)

void UAnimNodeSequence::SetPosition(float NewTime, bool bFireNotifies)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.SetPosition"));

	UAnimNodeSequence_SetPosition_Params params;
	params.NewTime = NewTime;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.ReplayAnim
// (Defined, Iterator, Latent, PreOperator, Singular, Native, HasOptionalParms)

void UAnimNodeSequence::ReplayAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.ReplayAnim"));

	UAnimNodeSequence_ReplayAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.StopAnim
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void UAnimNodeSequence::StopAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.StopAnim"));

	UAnimNodeSequence_StopAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.PlayAnim
// (Iterator, Net, HasOptionalParms)
// Parameters:
// bool                           bLoop                          (OptionalParm, Parm)
// float                          InRate                         (OptionalParm, Parm)
// float                          StartTime                      (OptionalParm, Parm)

void UAnimNodeSequence::PlayAnim(bool bLoop, float InRate, float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.PlayAnim"));

	UAnimNodeSequence_PlayAnim_Params params;
	params.bLoop = bLoop;
	params.InRate = InRate;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequence.SetAnim
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   Sequence                       (Parm)

void UAnimNodeSequence::SetAnim(const struct FName& Sequence)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequence.SetAnim"));

	UAnimNodeSequence_SetAnim_Params params;
	params.Sequence = Sequence;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNodeSequenceBlendByAim.CheckAnimsUpToDate
// (Final, Defined, Iterator, Net, NetReliable, Exec, Native, Event, Operator)

void UAnimNodeSequenceBlendByAim::CheckAnimsUpToDate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNodeSequenceBlendByAim.CheckAnimsUpToDate"));

	UAnimNodeSequenceBlendByAim_CheckAnimsUpToDate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MorphNodeMultiPose.UpdateMorphTarget
// (NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UMorphTarget*            Target                         (Parm)
// float                          InWeight                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMorphNodeMultiPose::UpdateMorphTarget(class UMorphTarget* Target, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphNodeMultiPose.UpdateMorphTarget"));

	UMorphNodeMultiPose_UpdateMorphTarget_Params params;
	params.Target = Target;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MorphNodeMultiPose.RemoveMorphTarget
// (Defined, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// struct FName                   MorphTargetName                (Parm)

void UMorphNodeMultiPose::RemoveMorphTarget(const struct FName& MorphTargetName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphNodeMultiPose.RemoveMorphTarget"));

	UMorphNodeMultiPose_RemoveMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MorphNodeMultiPose.AddMorphTarget
// (Final, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FName                   MorphTargetName                (Parm)
// float                          InWeight                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMorphNodeMultiPose::AddMorphTarget(const struct FName& MorphTargetName, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphNodeMultiPose.AddMorphTarget"));

	UMorphNodeMultiPose_AddMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MorphNodePose.SetMorphTarget
// (Latent, Event, HasOptionalParms)
// Parameters:
// struct FName                   MorphTargetName                (Parm)

void UMorphNodePose::SetMorphTarget(const struct FName& MorphTargetName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphNodePose.SetMorphTarget"));

	UMorphNodePose_SetMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MorphNodeWeight.SetNodeWeight
// (Final, Defined, Iterator, PreOperator, Event, HasOptionalParms)
// Parameters:
// float                          NewWeight                      (Parm)

void UMorphNodeWeight::SetNodeWeight(float NewWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphNodeWeight.SetNodeWeight"));

	UMorphNodeWeight_SetNodeWeight_Params params;
	params.NewWeight = NewWeight;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlBase.GetControlMetadataWeight
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkelControlBase::STATIC_GetControlMetadataWeight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlBase.GetControlMetadataWeight"));

	USkelControlBase_GetControlMetadataWeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkelControlBase.TickSkelControl
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void USkelControlBase::TickSkelControl(float DeltaTime, class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlBase.TickSkelControl"));

	USkelControlBase_TickSkelControl_Params params;
	params.DeltaTime = DeltaTime;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlBase.SetSkelControlStrength
// (Iterator, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// float                          NewStrength                    (Parm)
// float                          InBlendTime                    (OptionalParm, Parm)

void USkelControlBase::SetSkelControlStrength(float NewStrength, float InBlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlBase.SetSkelControlStrength"));

	USkelControlBase_SetSkelControlStrength_Params params;
	params.NewStrength = NewStrength;
	params.InBlendTime = InBlendTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlBase.SetSkelControlActive
// (Final, Defined, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bInActive                      (Parm)

void USkelControlBase::SetSkelControlActive(bool bInActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlBase.SetSkelControlActive"));

	USkelControlBase_SetSkelControlActive_Params params;
	params.bInActive = bInActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlLookAt.CanLookAtPoint
// (Final, Defined, Iterator, Net, Exec, Native, Event, Operator)
// Parameters:
// struct FVector                 PointLoc                       (Parm)
// bool                           bDrawDebugInfo                 (OptionalParm, Parm)
// bool                           bDebugUsePersistentLines       (OptionalParm, Parm)
// bool                           bDebugFlushLinesFirst          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkelControlLookAt::CanLookAtPoint(const struct FVector& PointLoc, bool bDrawDebugInfo, bool bDebugUsePersistentLines, bool bDebugFlushLinesFirst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlLookAt.CanLookAtPoint"));

	USkelControlLookAt_CanLookAtPoint_Params params;
	params.PointLoc = PointLoc;
	params.bDrawDebugInfo = bDrawDebugInfo;
	params.bDebugUsePersistentLines = bDebugUsePersistentLines;
	params.bDebugFlushLinesFirst = bDebugFlushLinesFirst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkelControlLookAt.SetLookAtAlpha
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DesiredAlpha                   (Parm)
// float                          DesiredBlendTime               (Parm)

void USkelControlLookAt::SetLookAtAlpha(float DesiredAlpha, float DesiredBlendTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlLookAt.SetLookAtAlpha"));

	USkelControlLookAt_SetLookAtAlpha_Params params;
	params.DesiredAlpha = DesiredAlpha;
	params.DesiredBlendTime = DesiredBlendTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlLookAt.InterpolateTargetLocation
// (Iterator, Net, Exec, Operator, Static)
// Parameters:
// float                          DeltaTime                      (Parm)

void USkelControlLookAt::STATIC_InterpolateTargetLocation(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlLookAt.InterpolateTargetLocation"));

	USkelControlLookAt_InterpolateTargetLocation_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkelControlLookAt.SetTargetLocation
// (Final, Defined, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewTargetLocation              (Parm)

void USkelControlLookAt::SetTargetLocation(const struct FVector& NewTargetLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkelControlLookAt.SetTargetLocation"));

	USkelControlLookAt_SetTargetLocation_Params params;
	params.NewTargetLocation = NewTargetLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSequence.GetNotifyTimeByClass
// (Defined, Iterator, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// class UClass*                  NotifyClass                    (Parm)
// float                          PlayRate                       (OptionalParm, Parm)
// float                          StartPosition                  (OptionalParm, Parm)
// class UAnimNotify*             out_Notify                     (OptionalParm, Parm, OutParm)
// float                          out_Duration                   (OptionalParm, Parm, OutParm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UAnimSequence::STATIC_GetNotifyTimeByClass(class UClass* NotifyClass, float PlayRate, float StartPosition, class UAnimNotify** out_Notify, float* out_Duration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimSequence.GetNotifyTimeByClass"));

	UAnimSequence_GetNotifyTimeByClass_Params params;
	params.NotifyClass = NotifyClass;
	params.PlayRate = PlayRate;
	params.StartPosition = StartPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Notify != nullptr)
		*out_Notify = params.out_Notify;
	if (out_Duration != nullptr)
		*out_Duration = params.out_Duration;

	return params.ReturnValue;
}


// Function Engine.MorphTargetSet.FindMorphTarget
// (Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   MorphTargetName                (Parm)
// class UMorphTarget*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UMorphTarget* UMorphTargetSet::STATIC_FindMorphTarget(const struct FName& MorphTargetName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MorphTargetSet.FindMorphTarget"));

	UMorphTargetSet_FindMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.SetParentRelativeLocation
// (Iterator, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// struct FVector                 relLoc                         (Parm)

void UDecalComponent::SetParentRelativeLocation(const struct FVector& relLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DecalComponent.SetParentRelativeLocation"));

	UDecalComponent_SetParentRelativeLocation_Params params;
	params.relLoc = relLoc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.IsWaitingForResetToDefaultsToComplete
// (Iterator, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UDecalComponent::STATIC_IsWaitingForResetToDefaultsToComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DecalComponent.IsWaitingForResetToDefaultsToComplete"));

	UDecalComponent_IsWaitingForResetToDefaultsToComplete_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.GetDecalMaterial
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInterface* UDecalComponent::STATIC_GetDecalMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DecalComponent.GetDecalMaterial"));

	UDecalComponent_GetDecalMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.SetDecalMaterial
// (Final, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      NewDecalMaterial               (Parm)

void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DecalComponent.SetDecalMaterial"));

	UDecalComponent_SetDecalMaterial_Params params;
	params.NewDecalMaterial = NewDecalMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.ResetToDefaults
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, Operator, HasOptionalParms)

void UDecalComponent::ResetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DecalComponent.ResetToDefaults"));

	UDecalComponent_ResetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FogVolumeDensityInfo.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct AFogVolumeDensityInfo_FCheckpointRecord Record                         (Const, Parm, OutParm)

void AFogVolumeDensityInfo::ApplyCheckpointRecord(struct AFogVolumeDensityInfo_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.ApplyCheckpointRecord"));

	AFogVolumeDensityInfo_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.FogVolumeDensityInfo.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct AFogVolumeDensityInfo_FCheckpointRecord Record                         (Parm, OutParm)

void AFogVolumeDensityInfo::STATIC_CreateCheckpointRecord(struct AFogVolumeDensityInfo_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.CreateCheckpointRecord"));

	AFogVolumeDensityInfo_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.FogVolumeDensityInfo.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFogVolumeDensityInfo::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.ShouldSaveForCheckpoint"));

	AFogVolumeDensityInfo_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FogVolumeDensityInfo.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AFogVolumeDensityInfo::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.OnToggle"));

	AFogVolumeDensityInfo_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FogVolumeDensityInfo.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AFogVolumeDensityInfo::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.ReplicatedEvent"));

	AFogVolumeDensityInfo_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FogVolumeDensityInfo.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AFogVolumeDensityInfo::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityInfo.PostBeginPlay"));

	AFogVolumeDensityInfo_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void UExponentialHeightFogComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ExponentialHeightFogComponent.SetEnabled"));

	UExponentialHeightFogComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FogVolumeDensityComponent.SetViewOriginOverride
// (Final, Defined, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FVector                 InViewOriginOverride           (Parm)
// bool                           bInUsePositionOverride         (Parm)

void UFogVolumeDensityComponent::SetViewOriginOverride(const struct FVector& InViewOriginOverride, bool bInUsePositionOverride)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityComponent.SetViewOriginOverride"));

	UFogVolumeDensityComponent_SetViewOriginOverride_Params params;
	params.InViewOriginOverride = InViewOriginOverride;
	params.bInUsePositionOverride = bInUsePositionOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FogVolumeDensityComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void UFogVolumeDensityComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FogVolumeDensityComponent.SetEnabled"));

	UFogVolumeDensityComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.OnSetMaterial
// (Defined, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetMaterial*     Action                         (Parm)

void AApexDestructibleActor::STATIC_OnSetMaterial(class USeqAct_SetMaterial* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.OnSetMaterial"));

	AApexDestructibleActor_OnSetMaterial_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AApexDestructibleActor::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.TakeRadiusDamage"));

	AApexDestructibleActor_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AApexDestructibleActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.TakeDamage"));

	AApexDestructibleActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AApexDestructibleActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.PostBeginPlay"));

	AApexDestructibleActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.CacheFractureEffects
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Operator)

void AApexDestructibleActor::CacheFractureEffects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.CacheFractureEffects"));

	AApexDestructibleActor_CacheFractureEffects_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ApexDestructibleActor.SpawnFractureEmitter
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystem*         EmitterTemplate                (Parm)
// struct FVector                 SpawnLocation                  (Parm)
// struct FVector                 SpawnDirection                 (Parm)

void AApexDestructibleActor::SpawnFractureEmitter(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FVector& SpawnDirection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ApexDestructibleActor.SpawnFractureEmitter"));

	AApexDestructibleActor_SpawnFractureEmitter_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.SpawnLocation = SpawnLocation;
	params.SpawnDirection = SpawnDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.NotifyHitByExplosion
// (Final, Latent, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             InstigatorController           (Parm)
// float                          DamageAmount                   (Parm)
// class UClass*                  dmgType                        (Parm)

void AFracturedStaticMeshActor::STATIC_NotifyHitByExplosion(class AController* InstigatorController, float DamageAmount, class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.NotifyHitByExplosion"));

	AFracturedStaticMeshActor_NotifyHitByExplosion_Params params;
	params.InstigatorController = InstigatorController;
	params.DamageAmount = DamageAmount;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.SetLoseChunkReplacementMaterial
// (Final, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)

void AFracturedStaticMeshActor::SetLoseChunkReplacementMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.SetLoseChunkReplacementMaterial"));

	AFracturedStaticMeshActor_SetLoseChunkReplacementMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.HideFragmentsToMaximizeMemoryUsage
// (Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void AFracturedStaticMeshActor::HideFragmentsToMaximizeMemoryUsage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.HideFragmentsToMaximizeMemoryUsage"));

	AFracturedStaticMeshActor_HideFragmentsToMaximizeMemoryUsage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.HideOneFragment
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void AFracturedStaticMeshActor::HideOneFragment()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.HideOneFragment"));

	AFracturedStaticMeshActor_HideOneFragment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.ResetVisibility
// (Defined, NetReliable, Exec, Native, HasOptionalParms)

void AFracturedStaticMeshActor::ResetVisibility()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.ResetVisibility"));

	AFracturedStaticMeshActor_ResetVisibility_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.BreakOffPartsInRadius
// (Defined, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// float                          RBStrength                     (Parm)
// bool                           bWantPhysChunksAndParticles    (Parm)

void AFracturedStaticMeshActor::BreakOffPartsInRadius(const struct FVector& Origin, float Radius, float RBStrength, bool bWantPhysChunksAndParticles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.BreakOffPartsInRadius"));

	AFracturedStaticMeshActor_BreakOffPartsInRadius_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.RBStrength = RBStrength;
	params.bWantPhysChunksAndParticles = bWantPhysChunksAndParticles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.Explode
// (Final, Defined, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)

void AFracturedStaticMeshActor::Explode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.Explode"));

	AFracturedStaticMeshActor_Explode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AFracturedStaticMeshActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.TakeDamage"));

	AFracturedStaticMeshActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.RemoveDecals
// (Final, Defined, Iterator, Latent, Native, HasOptionalParms)
// Parameters:
// int                            IndexToRemoveDecalsFrom        (Parm)

void AFracturedStaticMeshActor::RemoveDecals(int IndexToRemoveDecalsFrom)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.RemoveDecals"));

	AFracturedStaticMeshActor_RemoveDecals_Params params;
	params.IndexToRemoveDecalsFrom = IndexToRemoveDecalsFrom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.FractureEffectIsRelevant
// (Final, Defined, Iterator, PreOperator, Native, Event, Static)
// Parameters:
// bool                           bForceDedicated                (Parm)
// class APawn*                   EffectInstigator               (Parm)
// unsigned char                  bWantPhysChunksAndParticles    (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFracturedStaticMeshActor::STATIC_FractureEffectIsRelevant(bool bForceDedicated, class APawn* EffectInstigator, unsigned char* bWantPhysChunksAndParticles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.FractureEffectIsRelevant"));

	AFracturedStaticMeshActor_FractureEffectIsRelevant_Params params;
	params.bForceDedicated = bForceDedicated;
	params.EffectInstigator = EffectInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bWantPhysChunksAndParticles != nullptr)
		*bWantPhysChunksAndParticles = params.bWantPhysChunksAndParticles;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshActor.IsFracturedByDamageType
// (Defined, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// class UClass*                  dmgType                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFracturedStaticMeshActor::STATIC_IsFracturedByDamageType(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.IsFracturedByDamageType"));

	AFracturedStaticMeshActor_IsFracturedByDamageType_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshActor.SpawnDeferredParts
// (Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFracturedStaticMeshActor::SpawnDeferredParts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.SpawnDeferredParts"));

	AFracturedStaticMeshActor_SpawnDeferredParts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshActor.BreakOffIsolatedIslands
// (Final, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          FragmentVis                    (Parm, OutParm, NeedCtorLink)
// TArray<int>                    IgnoreFrags                    (Parm, NeedCtorLink)
// struct FVector                 ChunkDir                       (Parm)
// TArray<class AFracturedStaticMeshPart*> DisableCollWithPart            (Parm, NeedCtorLink)
// bool                           bWantPhysChunks                (Parm)

void AFracturedStaticMeshActor::BreakOffIsolatedIslands(TArray<int> IgnoreFrags, const struct FVector& ChunkDir, TArray<class AFracturedStaticMeshPart*> DisableCollWithPart, bool bWantPhysChunks, TArray<unsigned char>* FragmentVis)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.BreakOffIsolatedIslands"));

	AFracturedStaticMeshActor_BreakOffIsolatedIslands_Params params;
	params.IgnoreFrags = IgnoreFrags;
	params.ChunkDir = ChunkDir;
	params.DisableCollWithPart = DisableCollWithPart;
	params.bWantPhysChunks = bWantPhysChunks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FragmentVis != nullptr)
		*FragmentVis = params.FragmentVis;
}


// Function Engine.FracturedStaticMeshActor.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct AFracturedStaticMeshActor_FCheckpointRecord Record                         (Const, Parm, OutParm, NeedCtorLink)

void AFracturedStaticMeshActor::ApplyCheckpointRecord(struct AFracturedStaticMeshActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.ApplyCheckpointRecord"));

	AFracturedStaticMeshActor_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.FracturedStaticMeshActor.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct AFracturedStaticMeshActor_FCheckpointRecord Record                         (Parm, OutParm, NeedCtorLink)

void AFracturedStaticMeshActor::STATIC_CreateCheckpointRecord(struct AFracturedStaticMeshActor_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.CreateCheckpointRecord"));

	AFracturedStaticMeshActor_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.FracturedStaticMeshActor.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AFracturedStaticMeshActor::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.ShouldSaveForCheckpoint"));

	AFracturedStaticMeshActor_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshActor.ResetHealth
// (Final, Iterator, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void AFracturedStaticMeshActor::ResetHealth()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.ResetHealth"));

	AFracturedStaticMeshActor_ResetHealth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AFracturedStaticMeshActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.PostBeginPlay"));

	AFracturedStaticMeshActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshActor.SpawnPartMulti
// (Final, Iterator, PreOperator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// TArray<int>                    ChunkIndices                   (Parm, NeedCtorLink)
// struct FVector                 InitialVel                     (Parm)
// struct FVector                 InitialAngVel                  (Parm)
// float                          RelativeScale                  (Parm)
// bool                           bExplosion                     (Parm)
// class AFracturedStaticMeshPart* ReturnValue                    (Parm, OutParm, ReturnParm)

class AFracturedStaticMeshPart* AFracturedStaticMeshActor::SpawnPartMulti(TArray<int> ChunkIndices, const struct FVector& InitialVel, const struct FVector& InitialAngVel, float RelativeScale, bool bExplosion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.SpawnPartMulti"));

	AFracturedStaticMeshActor_SpawnPartMulti_Params params;
	params.ChunkIndices = ChunkIndices;
	params.InitialVel = InitialVel;
	params.InitialAngVel = InitialAngVel;
	params.RelativeScale = RelativeScale;
	params.bExplosion = bExplosion;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshActor.SpawnPart
// (Iterator, PreOperator, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// int                            ChunkIndex                     (Parm)
// struct FVector                 InitialVel                     (Parm)
// struct FVector                 InitialAngVel                  (Parm)
// float                          RelativeScale                  (Parm)
// bool                           bExplosion                     (Parm)
// class AFracturedStaticMeshPart* ReturnValue                    (Parm, OutParm, ReturnParm)

class AFracturedStaticMeshPart* AFracturedStaticMeshActor::SpawnPart(int ChunkIndex, const struct FVector& InitialVel, const struct FVector& InitialAngVel, float RelativeScale, bool bExplosion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshActor.SpawnPart"));

	AFracturedStaticMeshActor_SpawnPart_Params params;
	params.ChunkIndex = ChunkIndex;
	params.InitialVel = InitialVel;
	params.InitialAngVel = InitialAngVel;
	params.RelativeScale = RelativeScale;
	params.bExplosion = bExplosion;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshPart.BreakOffPartsInRadius
// (Defined, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// float                          RBStrength                     (Parm)
// bool                           bWantPhysChunksAndParticles    (Parm)

void AFracturedStaticMeshPart::BreakOffPartsInRadius(const struct FVector& Origin, float Radius, float RBStrength, bool bWantPhysChunksAndParticles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.BreakOffPartsInRadius"));

	AFracturedStaticMeshPart_BreakOffPartsInRadius_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.RBStrength = RBStrength;
	params.bWantPhysChunksAndParticles = bWantPhysChunksAndParticles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.Explode
// (Final, Defined, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)

void AFracturedStaticMeshPart::Explode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.Explode"));

	AFracturedStaticMeshPart_Explode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void AFracturedStaticMeshPart::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.FellOutOfWorld"));

	AFracturedStaticMeshPart_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.TryToCleanUp
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)

void AFracturedStaticMeshPart::TryToCleanUp()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.TryToCleanUp"));

	AFracturedStaticMeshPart_TryToCleanUp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AFracturedStaticMeshPart::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.TakeDamage"));

	AFracturedStaticMeshPart_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.RecyclePart
// (Final, Iterator, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// bool                           bAddToFreePool                 (Parm)

void AFracturedStaticMeshPart::RecyclePart(bool bAddToFreePool)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.RecyclePart"));

	AFracturedStaticMeshPart_RecyclePart_Params params;
	params.bAddToFreePool = bAddToFreePool;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshPart.Initialize
// (Defined, Latent, PreOperator, Net, Simulated, Operator, Static)

void AFracturedStaticMeshPart::STATIC_Initialize()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshPart.Initialize"));

	AFracturedStaticMeshPart_Initialize_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void AFractureManager::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.Tick"));

	AFractureManager_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.ReturnPartActor
// (Final, Defined, Iterator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AFracturedStaticMeshPart* Part                           (Parm)

void AFractureManager::ReturnPartActor(class AFracturedStaticMeshPart* Part)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.ReturnPartActor"));

	AFractureManager_ReturnPartActor_Params params;
	params.Part = Part;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.SpawnPartActor
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AFracturedStaticMeshActor* Parent                         (Parm)
// struct FVector                 SpawnLocation                  (Parm)
// struct FRotator                SpawnRotation                  (Parm)
// class AFracturedStaticMeshPart* ReturnValue                    (Parm, OutParm, ReturnParm)

class AFracturedStaticMeshPart* AFractureManager::SpawnPartActor(class AFracturedStaticMeshActor* Parent, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.SpawnPartActor"));

	AFractureManager_SpawnPartActor_Params params;
	params.Parent = Parent;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.GetFSMPart
// (PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AFracturedStaticMeshActor* Parent                         (Parm)
// struct FVector                 SpawnLocation                  (Parm)
// struct FRotator                SpawnRotation                  (Parm)
// class AFracturedStaticMeshPart* ReturnValue                    (Parm, OutParm, ReturnParm)

class AFracturedStaticMeshPart* AFractureManager::STATIC_GetFSMPart(class AFracturedStaticMeshActor* Parent, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.GetFSMPart"));

	AFractureManager_GetFSMPart_Params params;
	params.Parent = Parent;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.ResetPoolVisibility
// (Defined, Iterator, NetReliable, Native, HasOptionalParms)

void AFractureManager::ResetPoolVisibility()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.ResetPoolVisibility"));

	AFractureManager_ResetPoolVisibility_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.CreateFSMParts
// (Defined, Iterator, Exec, Static)

void AFractureManager::STATIC_CreateFSMParts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.CreateFSMParts"));

	AFractureManager_CreateFSMParts_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.CleanUpFSMParts
// (Final, Defined, Singular, Simulated, Exec, Native, Event, Operator)

void AFractureManager::CleanUpFSMParts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.CleanUpFSMParts"));

	AFractureManager_CleanUpFSMParts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AFractureManager::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.Destroyed"));

	AFractureManager_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.PreBeginPlay
// (Latent, Net, Simulated)

void AFractureManager::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.PreBeginPlay"));

	AFractureManager_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FractureManager.GetFSMFractureCullDistanceScale
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AFractureManager::STATIC_GetFSMFractureCullDistanceScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.GetFSMFractureCullDistanceScale"));

	AFractureManager_GetFSMFractureCullDistanceScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.GetFSMRadialSpawnChanceScale
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AFractureManager::STATIC_GetFSMRadialSpawnChanceScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.GetFSMRadialSpawnChanceScale"));

	AFractureManager_GetFSMRadialSpawnChanceScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.GetFSMDirectSpawnChanceScale
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AFractureManager::STATIC_GetFSMDirectSpawnChanceScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.GetFSMDirectSpawnChanceScale"));

	AFractureManager_GetFSMDirectSpawnChanceScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.GetNumFSMPartsScale
// (Defined, Iterator, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AFractureManager::STATIC_GetNumFSMPartsScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.GetNumFSMPartsScale"));

	AFractureManager_GetNumFSMPartsScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FractureManager.SpawnChunkDestroyEffect
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystem*         Effect                         (Parm)
// struct FBox                    ChunkBox                       (Parm)
// struct FVector                 ChunkDir                       (Parm)
// float                          Scale                          (Parm)

void AFractureManager::SpawnChunkDestroyEffect(class UParticleSystem* Effect, const struct FBox& ChunkBox, const struct FVector& ChunkDir, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FractureManager.SpawnChunkDestroyEffect"));

	AFractureManager_SpawnChunkDestroyEffect_Params params;
	params.Effect = Effect;
	params.ChunkBox = ChunkBox;
	params.ChunkDir = ChunkDir;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflection.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AImageReflection::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflection.OnToggle"));

	AImageReflection_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflection.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AImageReflection::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflection.ReplicatedEvent"));

	AImageReflection_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflection.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AImageReflection::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflection.PostBeginPlay"));

	AImageReflection_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflectionShadowPlane.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AImageReflectionShadowPlane::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflectionShadowPlane.OnToggle"));

	AImageReflectionShadowPlane_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflectionShadowPlane.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AImageReflectionShadowPlane::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflectionShadowPlane.ReplicatedEvent"));

	AImageReflectionShadowPlane_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflectionShadowPlane.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AImageReflectionShadowPlane::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflectionShadowPlane.PostBeginPlay"));

	AImageReflectionShadowPlane_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageReflectionShadowPlaneComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void UImageReflectionShadowPlaneComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageReflectionShadowPlaneComponent.SetEnabled"));

	UImageReflectionShadowPlaneComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedBaseComponent.GetNumVisibleFragments
// (Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UFracturedBaseComponent::STATIC_GetNumVisibleFragments()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedBaseComponent.GetNumVisibleFragments"));

	UFracturedBaseComponent_GetNumVisibleFragments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedBaseComponent.GetNumFragments
// (Final, Iterator, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UFracturedBaseComponent::STATIC_GetNumFragments()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedBaseComponent.GetNumFragments"));

	UFracturedBaseComponent_GetNumFragments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedBaseComponent.IsFragmentVisible
// (Iterator, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFracturedBaseComponent::STATIC_IsFragmentVisible(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedBaseComponent.IsFragmentVisible"));

	UFracturedBaseComponent_IsFragmentVisible_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedBaseComponent.GetVisibleFragments
// (Final, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// TArray<unsigned char>          ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<unsigned char> UFracturedBaseComponent::STATIC_GetVisibleFragments()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedBaseComponent.GetVisibleFragments"));

	UFracturedBaseComponent_GetVisibleFragments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedBaseComponent.SetStaticMesh
// (Defined, NetReliable, Event, HasOptionalParms)
// Parameters:
// class UStaticMesh*             NewMesh                        (Parm)
// bool                           bForce                         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFracturedBaseComponent::SetStaticMesh(class UStaticMesh* NewMesh, bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedBaseComponent.SetStaticMesh"));

	UFracturedBaseComponent_SetStaticMesh_Params params;
	params.NewMesh = NewMesh;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.GetFracturedMeshPhysMaterial
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UPhysicalMaterial*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicalMaterial* UFracturedStaticMeshComponent::STATIC_GetFracturedMeshPhysMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetFracturedMeshPhysMaterial"));

	UFracturedStaticMeshComponent_GetFracturedMeshPhysMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.RecreatePhysState
// (Final, PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)

void UFracturedStaticMeshComponent::RecreatePhysState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.RecreatePhysState"));

	UFracturedStaticMeshComponent_RecreatePhysState_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FracturedStaticMeshComponent.GetBoundaryHiddenFragments
// (Final, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<int>                    AdditionalVisibleFragments     (Parm, NeedCtorLink)
// TArray<int>                    ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<int> UFracturedStaticMeshComponent::STATIC_GetBoundaryHiddenFragments(TArray<int> AdditionalVisibleFragments)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetBoundaryHiddenFragments"));

	UFracturedStaticMeshComponent_GetBoundaryHiddenFragments_Params params;
	params.AdditionalVisibleFragments = AdditionalVisibleFragments;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.GetFragmentGroups
// (Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TArray<int>                    IgnoreFragments                (Parm, NeedCtorLink)
// float                          MinConnectionArea              (Parm)
// TArray<struct FFragmentGroup>  ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<struct FFragmentGroup> UFracturedStaticMeshComponent::STATIC_GetFragmentGroups(TArray<int> IgnoreFragments, float MinConnectionArea)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetFragmentGroups"));

	UFracturedStaticMeshComponent_GetFragmentGroups_Params params;
	params.IgnoreFragments = IgnoreFragments;
	params.MinConnectionArea = MinConnectionArea;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.GetCoreFragmentIndex
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UFracturedStaticMeshComponent::STATIC_GetCoreFragmentIndex()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetCoreFragmentIndex"));

	UFracturedStaticMeshComponent_GetCoreFragmentIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.GetFragmentAverageExteriorNormal
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UFracturedStaticMeshComponent::STATIC_GetFragmentAverageExteriorNormal(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetFragmentAverageExteriorNormal"));

	UFracturedStaticMeshComponent_GetFragmentAverageExteriorNormal_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.GetFragmentBox
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// struct FBox                    ReturnValue                    (Parm, OutParm, ReturnParm)

struct FBox UFracturedStaticMeshComponent::STATIC_GetFragmentBox(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.GetFragmentBox"));

	UFracturedStaticMeshComponent_GetFragmentBox_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.IsNoPhysFragment
// (Defined, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFracturedStaticMeshComponent::STATIC_IsNoPhysFragment(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.IsNoPhysFragment"));

	UFracturedStaticMeshComponent_IsNoPhysFragment_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.IsRootFragment
// (Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFracturedStaticMeshComponent::STATIC_IsRootFragment(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.IsRootFragment"));

	UFracturedStaticMeshComponent_IsRootFragment_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.IsFragmentDestroyable
// (Final, Defined, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            FragmentIndex                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFracturedStaticMeshComponent::STATIC_IsFragmentDestroyable(int FragmentIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.IsFragmentDestroyable"));

	UFracturedStaticMeshComponent_IsFragmentDestroyable_Params params;
	params.FragmentIndex = FragmentIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FracturedStaticMeshComponent.SetVisibleFragments
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          VisibilityFactors              (Parm, NeedCtorLink)

void UFracturedStaticMeshComponent::SetVisibleFragments(TArray<unsigned char> VisibilityFactors)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FracturedStaticMeshComponent.SetVisibleFragments"));

	UFracturedStaticMeshComponent_SetVisibleFragments_Params params;
	params.VisibilityFactors = VisibilityFactors;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageBasedReflectionComponent.OnUpdatePropertyReflectionColor
// (Defined, Iterator, Singular, Simulated, Native, Event, Operator, Static)

void UImageBasedReflectionComponent::STATIC_OnUpdatePropertyReflectionColor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageBasedReflectionComponent.OnUpdatePropertyReflectionColor"));

	UImageBasedReflectionComponent_OnUpdatePropertyReflectionColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageBasedReflectionComponent.UpdateImageReflectionParameters
// (Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void UImageBasedReflectionComponent::UpdateImageReflectionParameters()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageBasedReflectionComponent.UpdateImageReflectionParameters"));

	UImageBasedReflectionComponent_UpdateImageReflectionParameters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImageBasedReflectionComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void UImageBasedReflectionComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ImageBasedReflectionComponent.SetEnabled"));

	UImageBasedReflectionComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedStaticMeshComponent.ShouldStreamInstanceBuffer
// (Final, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInstancedStaticMeshComponent::ShouldStreamInstanceBuffer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InstancedStaticMeshComponent.ShouldStreamInstanceBuffer"));

	UInstancedStaticMeshComponent_ShouldStreamInstanceBuffer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstance.IsInMapOrTransientPackage
// (Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstance::STATIC_IsInMapOrTransientPackage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.IsInMapOrTransientPackage"));

	UMaterialInstance_IsInMapOrTransientPackage_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstance.ClearParameterValues
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void UMaterialInstance::ClearParameterValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.ClearParameterValues"));

	UMaterialInstance_ClearParameterValues_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstance.SetFontParameterValue
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UFont*                   FontValue                      (Parm)
// int                            FontPage                       (Parm)

void UMaterialInstance::SetFontParameterValue(const struct FName& ParameterName, class UFont* FontValue, int FontPage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetFontParameterValue"));

	UMaterialInstance_SetFontParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.FontValue = FontValue;
	params.FontPage = FontPage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstance.GetTextureParameterValue
// (Final, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                Value                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstance::STATIC_GetTextureParameterValue(const struct FName& ParameterName, class UTexture** Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.GetTextureParameterValue"));

	UMaterialInstance_GetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.MaterialInstance.SetTextureParameterValue
// (Final, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                Value                          (Parm)

void UMaterialInstance::SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetTextureParameterValue"));

	UMaterialInstance_SetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstance.SetScalarCurveParameterValue
// (Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveFloat       Value                          (Const, Parm, OutParm, NeedCtorLink)

void UMaterialInstance::SetScalarCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveFloat* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetScalarCurveParameterValue"));

	UMaterialInstance_SetScalarCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstance.SetScalarParameterValue
// (Defined, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Value                          (Parm)

void UMaterialInstance::SetScalarParameterValue(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetScalarParameterValue"));

	UMaterialInstance_SetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstance.SetVectorParameterValue
// (Defined, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            Value                          (Const, Parm, OutParm)

void UMaterialInstance::SetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetVectorParameterValue"));

	UMaterialInstance_SetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstance.SetParent
// (Defined, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      NewParent                      (Parm)

void UMaterialInstance::SetParent(class UMaterialInterface* NewParent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstance.SetParent"));

	UMaterialInstance_SetParent_Params params;
	params.NewParent = NewParent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.ClearParameterValues
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void UMaterialInstanceConstant::ClearParameterValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.ClearParameterValues"));

	UMaterialInstanceConstant_ClearParameterValues_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.GetMobileVectorParameterValue
// (Final, Defined, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstanceConstant::STATIC_GetMobileVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.GetMobileVectorParameterValue"));

	UMaterialInstanceConstant_GetMobileVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.GetMobileTextureParameterValue
// (Defined, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstanceConstant::STATIC_GetMobileTextureParameterValue(const struct FName& ParameterName, class UTexture** OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.GetMobileTextureParameterValue"));

	UMaterialInstanceConstant_GetMobileTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.GetMobileScalarParameterValue
// (Final, Latent, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          OutValue                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstanceConstant::STATIC_GetMobileScalarParameterValue(const struct FName& ParameterName, float* OutValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.GetMobileScalarParameterValue"));

	UMaterialInstanceConstant_GetMobileScalarParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValue != nullptr)
		*OutValue = params.OutValue;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.SetFontParameterValue
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UFont*                   FontValue                      (Parm)
// int                            FontPage                       (Parm)

void UMaterialInstanceConstant::SetFontParameterValue(const struct FName& ParameterName, class UFont* FontValue, int FontPage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetFontParameterValue"));

	UMaterialInstanceConstant_SetFontParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.FontValue = FontValue;
	params.FontPage = FontPage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.SetVectorParameterValue
// (Defined, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            Value                          (Const, Parm, OutParm)

void UMaterialInstanceConstant::SetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetVectorParameterValue"));

	UMaterialInstanceConstant_SetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceConstant.SetTextureParameterValue
// (Final, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                Value                          (Parm)

void UMaterialInstanceConstant::SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetTextureParameterValue"));

	UMaterialInstanceConstant_SetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.SetScalarParameterValue
// (Defined, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Value                          (Parm)

void UMaterialInstanceConstant::SetScalarParameterValue(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetScalarParameterValue"));

	UMaterialInstanceConstant_SetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.SetParent
// (Defined, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      NewParent                      (Parm)

void UMaterialInstanceConstant::SetParent(class UMaterialInterface* NewParent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetParent"));

	UMaterialInstanceConstant_SetParent_Params params;
	params.NewParent = NewParent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.SetParameterStateInterp
// (Final, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// struct FName                   FromStateName                  (Parm)
// struct FName                   ToStateName                    (Parm)
// float                          fInterpAmt                     (Parm)

void UMaterialInstanceConstant::SetParameterStateInterp(const struct FName& FromStateName, const struct FName& ToStateName, float fInterpAmt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetParameterStateInterp"));

	UMaterialInstanceConstant_SetParameterStateInterp_Params params;
	params.FromStateName = FromStateName;
	params.ToStateName = ToStateName;
	params.fInterpAmt = fInterpAmt;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.SetParameterState
// (Latent, Singular, Event, HasOptionalParms)
// Parameters:
// struct FName                   StateName                      (Parm)

void UMaterialInstanceConstant::SetParameterState(const struct FName& StateName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.SetParameterState"));

	UMaterialInstanceConstant_SetParameterState_Params params;
	params.StateName = StateName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceConstant.HasState
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   StateName                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstanceConstant::STATIC_HasState(const struct FName& StateName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceConstant.HasState"));

	UMaterialInstanceConstant_HasState_Params params;
	params.StateName = StateName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceTimeVarying.CheckForVectorParameterConflicts
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UMaterialInstanceTimeVarying::CheckForVectorParameterConflicts(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.CheckForVectorParameterConflicts"));

	UMaterialInstanceTimeVarying_CheckForVectorParameterConflicts_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceTimeVarying.GetMaxDurationFromAllParameters
// (Final, Defined, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UMaterialInstanceTimeVarying::STATIC_GetMaxDurationFromAllParameters()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.GetMaxDurationFromAllParameters"));

	UMaterialInstanceTimeVarying_GetMaxDurationFromAllParameters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceTimeVarying.ClearParameterValues
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void UMaterialInstanceTimeVarying::ClearParameterValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.ClearParameterValues"));

	UMaterialInstanceTimeVarying_ClearParameterValues_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetFontParameterValue
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UFont*                   FontValue                      (Parm)
// int                            FontPage                       (Parm)

void UMaterialInstanceTimeVarying::SetFontParameterValue(const struct FName& ParameterName, class UFont* FontValue, int FontPage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetFontParameterValue"));

	UMaterialInstanceTimeVarying_SetFontParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.FontValue = FontValue;
	params.FontPage = FontPage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetVectorStartTime
// (Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Value                          (Parm)

void UMaterialInstanceTimeVarying::SetVectorStartTime(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetVectorStartTime"));

	UMaterialInstanceTimeVarying_SetVectorStartTime_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetLinearColorCurveParameterValue
// (PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveLinearColor Value                          (Const, Parm, OutParm, NeedCtorLink)

void UMaterialInstanceTimeVarying::SetLinearColorCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveLinearColor* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetLinearColorCurveParameterValue"));

	UMaterialInstanceTimeVarying_SetLinearColorCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceTimeVarying.SetLinearColorParameterValue
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            Value                          (Const, Parm, OutParm)

void UMaterialInstanceTimeVarying::SetLinearColorParameterValue(const struct FName& ParameterName, struct FLinearColor* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetLinearColorParameterValue"));

	UMaterialInstanceTimeVarying_SetLinearColorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceTimeVarying.SetVectorCurveParameterValue
// (Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveVector      Value                          (Const, Parm, OutParm, NeedCtorLink)

void UMaterialInstanceTimeVarying::SetVectorCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveVector* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetVectorCurveParameterValue"));

	UMaterialInstanceTimeVarying_SetVectorCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceTimeVarying.SetVectorParameterValue
// (Defined, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            Value                          (Const, Parm, OutParm)

void UMaterialInstanceTimeVarying::SetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetVectorParameterValue"));

	UMaterialInstanceTimeVarying_SetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceTimeVarying.SetTextureParameterValue
// (Final, Iterator, Latent, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UTexture*                Value                          (Parm)

void UMaterialInstanceTimeVarying::SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetTextureParameterValue"));

	UMaterialInstanceTimeVarying_SetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetDuration
// (Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          Value                          (Parm)

void UMaterialInstanceTimeVarying::SetDuration(float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetDuration"));

	UMaterialInstanceTimeVarying_SetDuration_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetScalarStartTime
// (Final, Defined, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Value                          (Parm)

void UMaterialInstanceTimeVarying::SetScalarStartTime(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetScalarStartTime"));

	UMaterialInstanceTimeVarying_SetScalarStartTime_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetScalarCurveParameterValue
// (Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FInterpCurveFloat       Value                          (Const, Parm, OutParm, NeedCtorLink)

void UMaterialInstanceTimeVarying::SetScalarCurveParameterValue(const struct FName& ParameterName, struct FInterpCurveFloat* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetScalarCurveParameterValue"));

	UMaterialInstanceTimeVarying_SetScalarCurveParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.MaterialInstanceTimeVarying.SetScalarParameterValue
// (Defined, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Value                          (Parm)

void UMaterialInstanceTimeVarying::SetScalarParameterValue(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetScalarParameterValue"));

	UMaterialInstanceTimeVarying_SetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceTimeVarying.SetParent
// (Defined, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// class UMaterialInterface*      NewParent                      (Parm)

void UMaterialInstanceTimeVarying::SetParent(class UMaterialInterface* NewParent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MaterialInstanceTimeVarying.SetParent"));

	UMaterialInstanceTimeVarying_SetParent_Params params;
	params.NewParent = NewParent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterCameraLensEffectBase.UpdateLocation
// (Final, Defined, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 CamLoc                         (Const, Parm, OutParm)
// struct FRotator                CamRot                         (Const, Parm, OutParm)
// float                          CamFOVDeg                      (Parm)

void AEmitterCameraLensEffectBase::UpdateLocation(float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.UpdateLocation"));

	AEmitterCameraLensEffectBase_UpdateLocation_Params params;
	params.CamFOVDeg = CamFOVDeg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CamLoc != nullptr)
		*CamLoc = params.CamLoc;
	if (CamRot != nullptr)
		*CamRot = params.CamRot;
}


// Function Engine.EmitterCameraLensEffectBase.ActivateLensEffect
// (Final, Defined, Singular, Simulated, Exec, Native, Event)

void AEmitterCameraLensEffectBase::ActivateLensEffect()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.ActivateLensEffect"));

	AEmitterCameraLensEffectBase_ActivateLensEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterCameraLensEffectBase.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AEmitterCameraLensEffectBase::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.PostBeginPlay"));

	AEmitterCameraLensEffectBase_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterCameraLensEffectBase.NotifyRetriggered
// (Final, Defined, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)

void AEmitterCameraLensEffectBase::STATIC_NotifyRetriggered()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.NotifyRetriggered"));

	AEmitterCameraLensEffectBase_NotifyRetriggered_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterCameraLensEffectBase.RegisterCamera
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class ACamera*                 C                              (Parm)

void AEmitterCameraLensEffectBase::RegisterCamera(class ACamera* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.RegisterCamera"));

	AEmitterCameraLensEffectBase_RegisterCamera_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterCameraLensEffectBase.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AEmitterCameraLensEffectBase::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterCameraLensEffectBase.Destroyed"));

	AEmitterCameraLensEffectBase_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleEventManager.HandleParticleModuleEventSendToGame
// (Defined, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UParticleModuleEventSendToGame* InEvent                        (Parm)
// struct FVector                 InCollideDirection             (Const, Parm, OutParm)
// struct FVector                 InHitLocation                  (Const, Parm, OutParm)
// struct FVector                 InHitNormal                    (Const, Parm, OutParm)
// struct FName                   InBoneName                     (Const, Parm, OutParm)

void AParticleEventManager::HandleParticleModuleEventSendToGame(class UParticleModuleEventSendToGame* InEvent, struct FVector* InCollideDirection, struct FVector* InHitLocation, struct FVector* InHitNormal, struct FName* InBoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleEventManager.HandleParticleModuleEventSendToGame"));

	AParticleEventManager_HandleParticleModuleEventSendToGame_Params params;
	params.InEvent = InEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InCollideDirection != nullptr)
		*InCollideDirection = params.InCollideDirection;
	if (InHitLocation != nullptr)
		*InHitLocation = params.InHitLocation;
	if (InHitNormal != nullptr)
		*InHitNormal = params.InHitNormal;
	if (InBoneName != nullptr)
		*InBoneName = params.InBoneName;
}


// Function Engine.ParticleSystemComponent.SetFOV
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewFOV                         (Parm)

void UParticleSystemComponent::SetFOV(float NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetFOV"));

	UParticleSystemComponent_SetFOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.UpdateEmitterMasks
// (Defined, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void UParticleSystemComponent::UpdateEmitterMasks()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.UpdateEmitterMasks"));

	UParticleSystemComponent_UpdateEmitterMasks_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetStopSpawning
// (Iterator, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            InEmitterIndex                 (Parm)
// bool                           bInStopSpawning                (Parm)

void UParticleSystemComponent::SetStopSpawning(int InEmitterIndex, bool bInStopSpawning)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetStopSpawning"));

	UParticleSystemComponent_SetStopSpawning_Params params;
	params.InEmitterIndex = InEmitterIndex;
	params.bInStopSpawning = bInStopSpawning;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.ResetToDefaults
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, Operator, HasOptionalParms)

void UParticleSystemComponent::ResetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.ResetToDefaults"));

	UParticleSystemComponent_ResetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetActive
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNowActive                     (Parm)
// bool                           bFlagAsJustAttached            (OptionalParm, Parm)

void UParticleSystemComponent::SetActive(bool bNowActive, bool bFlagAsJustAttached)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetActive"));

	UParticleSystemComponent_SetActive_Params params;
	params.bNowActive = bNowActive;
	params.bFlagAsJustAttached = bFlagAsJustAttached;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.ClearParameter
// (Final, Defined, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// TEnumAsByte<EParticleSysParamType> ParameterType                  (OptionalParm, Parm)

void UParticleSystemComponent::ClearParameter(const struct FName& ParameterName, TEnumAsByte<EParticleSysParamType> ParameterType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.ClearParameter"));

	UParticleSystemComponent_ClearParameter_Params params;
	params.ParameterName = ParameterName;
	params.ParameterType = ParameterType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.GetValueNameParameter
// (Defined, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ParameterName                  (Const, Parm)
// struct FName                   Param                          (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetValueNameParameter(const struct FName& ParameterName, struct FName* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetValueNameParameter"));

	UParticleSystemComponent_GetValueNameParameter_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Param != nullptr)
		*Param = params.Param;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetMaterialParameter
// (Final, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InName                         (Const, Parm)
// class UMaterialInterface*      OutMaterial                    (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetMaterialParameter(const struct FName& InName, class UMaterialInterface** OutMaterial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetMaterialParameter"));

	UParticleSystemComponent_GetMaterialParameter_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMaterial != nullptr)
		*OutMaterial = params.OutMaterial;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetActorParameter
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   InName                         (Const, Parm)
// class AActor*                  OutActor                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetActorParameter(const struct FName& InName, class AActor** OutActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetActorParameter"));

	UParticleSystemComponent_GetActorParameter_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActor != nullptr)
		*OutActor = params.OutActor;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetColorParameter
// (Defined, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   InName                         (Const, Parm)
// struct FColor                  OutColor                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetColorParameter(const struct FName& InName, struct FColor* OutColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetColorParameter"));

	UParticleSystemComponent_GetColorParameter_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutColor != nullptr)
		*OutColor = params.OutColor;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetVectorParameter
// (Final, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InName                         (Const, Parm)
// struct FVector                 OutVector                      (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetVectorParameter(const struct FName& InName, struct FVector* OutVector)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetVectorParameter"));

	UParticleSystemComponent_GetVectorParameter_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutVector != nullptr)
		*OutVector = params.OutVector;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetFloatParameter
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   InName                         (Const, Parm)
// float                          OutFloat                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetFloatParameter(const struct FName& InName, float* OutFloat)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetFloatParameter"));

	UParticleSystemComponent_GetFloatParameter_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFloat != nullptr)
		*OutFloat = params.OutFloat;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SetValueNameParameter
// (Final, Defined, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FName                   Param                          (Parm)

void UParticleSystemComponent::SetValueNameParameter(const struct FName& ParameterName, const struct FName& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetValueNameParameter"));

	UParticleSystemComponent_SetValueNameParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetMaterialParameter
// (Final, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class UMaterialInterface*      Param                          (Parm)

void UParticleSystemComponent::SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetMaterialParameter"));

	UParticleSystemComponent_SetMaterialParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetActorParameter
// (Final, Defined, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class AActor*                  Param                          (Parm)

void UParticleSystemComponent::SetActorParameter(const struct FName& ParameterName, class AActor* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetActorParameter"));

	UParticleSystemComponent_SetActorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetColorParameter
// (Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FColor                  Param                          (Parm)

void UParticleSystemComponent::SetColorParameter(const struct FName& ParameterName, const struct FColor& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetColorParameter"));

	UParticleSystemComponent_SetColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetVectorRandParameter
// (Final, Defined, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FVector                 Param                          (Const, Parm, OutParm)
// struct FVector                 ParamLow                       (Const, Parm, OutParm)

void UParticleSystemComponent::SetVectorRandParameter(const struct FName& ParameterName, struct FVector* Param, struct FVector* ParamLow)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetVectorRandParameter"));

	UParticleSystemComponent_SetVectorRandParameter_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Param != nullptr)
		*Param = params.Param;
	if (ParamLow != nullptr)
		*ParamLow = params.ParamLow;
}


// Function Engine.ParticleSystemComponent.SetVectorParameter
// (Final, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FVector                 Param                          (Parm)

void UParticleSystemComponent::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetVectorParameter"));

	UParticleSystemComponent_SetVectorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetFloatRandParameter
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Param                          (Parm)
// float                          ParamLow                       (Parm)

void UParticleSystemComponent::SetFloatRandParameter(const struct FName& ParameterName, float Param, float ParamLow)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetFloatRandParameter"));

	UParticleSystemComponent_SetFloatRandParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;
	params.ParamLow = ParamLow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetFloatParameter
// (Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Param                          (Parm)

void UParticleSystemComponent::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetFloatParameter"));

	UParticleSystemComponent_SetFloatParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.GetEditorLODLevel
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UParticleSystemComponent::STATIC_GetEditorLODLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetEditorLODLevel"));

	UParticleSystemComponent_GetEditorLODLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetLODLevel
// (Latent, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UParticleSystemComponent::STATIC_GetLODLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetLODLevel"));

	UParticleSystemComponent_GetLODLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SetEditorLODLevel
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            InLODLevel                     (Parm)

void UParticleSystemComponent::SetEditorLODLevel(int InLODLevel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetEditorLODLevel"));

	UParticleSystemComponent_SetEditorLODLevel_Params params;
	params.InLODLevel = InLODLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetLODLevel
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            InLODLevel                     (Parm)
// bool                           bIgnoreBias                    (OptionalParm, Parm)

void UParticleSystemComponent::SetLODLevel(int InLODLevel, bool bIgnoreBias)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetLODLevel"));

	UParticleSystemComponent_SetLODLevel_Params params;
	params.InLODLevel = InLODLevel;
	params.bIgnoreBias = bIgnoreBias;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SystemHasDurationElapsed
// (Final, Defined, Iterator, Latent, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::SystemHasDurationElapsed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SystemHasDurationElapsed"));

	UParticleSystemComponent_SystemHasDurationElapsed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SystemHasCompleted
// (Defined, Iterator, Latent, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::SystemHasCompleted()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SystemHasCompleted"));

	UParticleSystemComponent_SystemHasCompleted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetMaxLifespan
// (Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UParticleSystemComponent::STATIC_GetMaxLifespan()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetMaxLifespan"));

	UParticleSystemComponent_GetMaxLifespan_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.DetermineDesiredLODLevel
// (Defined, Iterator, PreOperator, Net, NetReliable, Native, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UParticleSystemComponent::STATIC_DetermineDesiredLODLevel()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.DetermineDesiredLODLevel"));

	UParticleSystemComponent_DetermineDesiredLODLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.DetermineLODLevelForLocation
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Native, Static)
// Parameters:
// struct FVector                 EffectLocation                 (Const, Parm, OutParm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UParticleSystemComponent::STATIC_DetermineLODLevelForLocation(struct FVector* EffectLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.DetermineLODLevelForLocation"));

	UParticleSystemComponent_DetermineLODLevelForLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EffectLocation != nullptr)
		*EffectLocation = params.EffectLocation;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
// (Final, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// float                          NewTargetStrength              (Parm)
// int                            TargetIndex                    (Parm)

void UParticleSystemComponent::SetBeamTargetStrength(int EmitterIndex, float NewTargetStrength, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamTargetStrength"));

	UParticleSystemComponent_SetBeamTargetStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTargetStrength = NewTargetStrength;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
// (Defined, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// struct FVector                 NewTangentPoint                (Parm)
// int                            TargetIndex                    (Parm)

void UParticleSystemComponent::SetBeamTargetTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamTargetTangent"));

	UParticleSystemComponent_SetBeamTargetTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
// (Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// struct FVector                 NewTargetPoint                 (Parm)
// int                            TargetIndex                    (Parm)

void UParticleSystemComponent::SetBeamTargetPoint(int EmitterIndex, const struct FVector& NewTargetPoint, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamTargetPoint"));

	UParticleSystemComponent_SetBeamTargetPoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTargetPoint = NewTargetPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
// (Defined, Iterator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// float                          NewSourceStrength              (Parm)
// int                            SourceIndex                    (Parm)

void UParticleSystemComponent::SetBeamSourceStrength(int EmitterIndex, float NewSourceStrength, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamSourceStrength"));

	UParticleSystemComponent_SetBeamSourceStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewSourceStrength = NewSourceStrength;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
// (Final, Defined, Iterator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// struct FVector                 NewTangentPoint                (Parm)
// int                            SourceIndex                    (Parm)

void UParticleSystemComponent::SetBeamSourceTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamSourceTangent"));

	UParticleSystemComponent_SetBeamSourceTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
// (Final, Iterator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// struct FVector                 NewSourcePoint                 (Parm)
// int                            SourceIndex                    (Parm)

void UParticleSystemComponent::SetBeamSourcePoint(int EmitterIndex, const struct FVector& NewSourcePoint, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamSourcePoint"));

	UParticleSystemComponent_SetBeamSourcePoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewSourcePoint = NewSourcePoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamDistance
// (Final, Defined, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// float                          Distance                       (Parm)

void UParticleSystemComponent::SetBeamDistance(int EmitterIndex, float Distance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamDistance"));

	UParticleSystemComponent_SetBeamDistance_Params params;
	params.EmitterIndex = EmitterIndex;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamEndPoint
// (Iterator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// struct FVector                 NewEndPoint                    (Parm)

void UParticleSystemComponent::SetBeamEndPoint(int EmitterIndex, const struct FVector& NewEndPoint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamEndPoint"));

	UParticleSystemComponent_SetBeamEndPoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewEndPoint = NewEndPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTessellationFactor
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// float                          NewFactor                      (Parm)

void UParticleSystemComponent::SetBeamTessellationFactor(int EmitterIndex, float NewFactor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamTessellationFactor"));

	UParticleSystemComponent_SetBeamTessellationFactor_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewFactor = NewFactor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamType
// (Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// int                            NewMethod                      (Parm)

void UParticleSystemComponent::SetBeamType(int EmitterIndex, int NewMethod)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetBeamType"));

	UParticleSystemComponent_SetBeamType_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewMethod = NewMethod;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.RewindEmitterInstances
// (Final, Iterator, PreOperator, Net, NetReliable, Native, HasOptionalParms)

void UParticleSystemComponent::RewindEmitterInstances()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.RewindEmitterInstances"));

	UParticleSystemComponent_RewindEmitterInstances_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.RewindEmitterInstance
// (Iterator, PreOperator, Net, NetReliable, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)

void UParticleSystemComponent::RewindEmitterInstance(int EmitterIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.RewindEmitterInstance"));

	UParticleSystemComponent_RewindEmitterInstance_Params params;
	params.EmitterIndex = EmitterIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetKillOnCompleted
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// bool                           bKill                          (Parm)

void UParticleSystemComponent::SetKillOnCompleted(int EmitterIndex, bool bKill)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetKillOnCompleted"));

	UParticleSystemComponent_SetKillOnCompleted_Params params;
	params.EmitterIndex = EmitterIndex;
	params.bKill = bKill;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetKillOnDeactivate
// (Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            EmitterIndex                   (Parm)
// bool                           bKill                          (Parm)

void UParticleSystemComponent::SetKillOnDeactivate(int EmitterIndex, bool bKill)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetKillOnDeactivate"));

	UParticleSystemComponent_SetKillOnDeactivate_Params params;
	params.EmitterIndex = EmitterIndex;
	params.bKill = bKill;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.GetSkipBoundsUpdate
// (Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetSkipBoundsUpdate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetSkipBoundsUpdate"));

	UParticleSystemComponent_GetSkipBoundsUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SetSkipBoundsUpdate
// (Final, Defined, Iterator, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bInSkipBoundsUpdate            (Parm)

void UParticleSystemComponent::SetSkipBoundsUpdate(bool bInSkipBoundsUpdate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetSkipBoundsUpdate"));

	UParticleSystemComponent_SetSkipBoundsUpdate_Params params;
	params.bInSkipBoundsUpdate = bInSkipBoundsUpdate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.GetSkipUpdateDynamicDataDuringTick
// (Final, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UParticleSystemComponent::STATIC_GetSkipUpdateDynamicDataDuringTick()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.GetSkipUpdateDynamicDataDuringTick"));

	UParticleSystemComponent_GetSkipUpdateDynamicDataDuringTick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.SetSkipUpdateDynamicDataDuringTick
// (Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bInSkipUpdateDynamicDataDuringTick (Parm)

void UParticleSystemComponent::SetSkipUpdateDynamicDataDuringTick(bool bInSkipUpdateDynamicDataDuringTick)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetSkipUpdateDynamicDataDuringTick"));

	UParticleSystemComponent_SetSkipUpdateDynamicDataDuringTick_Params params;
	params.bInSkipUpdateDynamicDataDuringTick = bInSkipUpdateDynamicDataDuringTick;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.KillParticlesInEmitter
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FName                   InEmitterName                  (Parm)

void UParticleSystemComponent::STATIC_KillParticlesInEmitter(const struct FName& InEmitterName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.KillParticlesInEmitter"));

	UParticleSystemComponent_KillParticlesInEmitter_Params params;
	params.InEmitterName = InEmitterName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.KillParticlesForced
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Operator, Static)

void UParticleSystemComponent::STATIC_KillParticlesForced()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.KillParticlesForced"));

	UParticleSystemComponent_KillParticlesForced_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.DeactivateSystem
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Static)

void UParticleSystemComponent::STATIC_DeactivateSystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.DeactivateSystem"));

	UParticleSystemComponent_DeactivateSystem_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.ActivateSystem
// (Final, Latent, Singular, Simulated, Exec, Native, Event)
// Parameters:
// bool                           bFlagAsJustAttached            (OptionalParm, Parm)

void UParticleSystemComponent::ActivateSystem(bool bFlagAsJustAttached)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.ActivateSystem"));

	UParticleSystemComponent_ActivateSystem_Params params;
	params.bFlagAsJustAttached = bFlagAsJustAttached;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetTemplate
// (Final, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystem*         NewTemplate                    (Parm)

void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.SetTemplate"));

	UParticleSystemComponent_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.OnSystemDurationElapsed
// (Final, Defined, Iterator, Latent, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PSystem                        (Parm, EditInline)

void UParticleSystemComponent::OnSystemDurationElapsed(class UParticleSystemComponent* PSystem)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.OnSystemDurationElapsed"));

	UParticleSystemComponent_OnSystemDurationElapsed_Params params;
	params.PSystem = PSystem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.OnSystemFinished
// (PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PSystem                        (Parm, EditInline)

void UParticleSystemComponent::OnSystemFinished(class UParticleSystemComponent* PSystem)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleSystemComponent.OnSystemFinished"));

	UParticleSystemComponent_OnSystemFinished_Params params;
	params.PSystem = PSystem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleEmitter.GetMaxLifespan
// (Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          InComponentDelay               (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UParticleEmitter::STATIC_GetMaxLifespan(float InComponentDelay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleEmitter.GetMaxLifespan"));

	UParticleEmitter_GetMaxLifespan_Params params;
	params.InComponentDelay = InComponentDelay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleModuleEventSendToGame.DoEvent
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// struct FVector                 InCollideDirection             (Const, Parm, OutParm)
// struct FVector                 InHitLocation                  (Const, Parm, OutParm)
// struct FVector                 InHitNormal                    (Const, Parm, OutParm)
// struct FName                   InBoneName                     (Const, Parm, OutParm)

void UParticleModuleEventSendToGame::STATIC_DoEvent(struct FVector* InCollideDirection, struct FVector* InHitLocation, struct FVector* InHitNormal, struct FName* InBoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ParticleModuleEventSendToGame.DoEvent"));

	UParticleModuleEventSendToGame_DoEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InCollideDirection != nullptr)
		*InCollideDirection = params.InCollideDirection;
	if (InHitLocation != nullptr)
		*InHitLocation = params.InHitLocation;
	if (InHitNormal != nullptr)
		*InHitNormal = params.InHitNormal;
	if (InBoneName != nullptr)
		*InBoneName = params.InBoneName;
}


// Function Engine.KActor.ClientTouchEffects
// (PreOperator, Singular, Static)

void AKActor::STATIC_ClientTouchEffects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.ClientTouchEffects"));

	AKActor_ClientTouchEffects_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AKActor::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.Touch"));

	AKActor_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.ClientWeaponHitEffects
// (Latent, PreOperator, Singular, Static)
// Parameters:
// struct FVector                 ImpactLocation                 (Parm)
// struct FVector                 ImpactNormal                   (Parm)

void AKActor::STATIC_ClientWeaponHitEffects(const struct FVector& ImpactLocation, const struct FVector& ImpactNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.ClientWeaponHitEffects"));

	AKActor_ClientWeaponHitEffects_Params params;
	params.ImpactLocation = ImpactLocation;
	params.ImpactNormal = ImpactNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.OnWeaponHit
// (Latent, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FImpactInfo             Impact                         (Parm)
// float                          ImpulseScale                   (OptionalParm, Parm)

void AKActor::STATIC_OnWeaponHit(const struct FImpactInfo& Impact, float ImpulseScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.OnWeaponHit"));

	AKActor_OnWeaponHit_Params params;
	params.Impact = Impact;
	params.ImpulseScale = ImpulseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AKActor::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.Reset"));

	AKActor_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.OnTeleport
// (Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Teleport*        inAction                       (Parm)

void AKActor::STATIC_OnTeleport(class USeqAct_Teleport* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.OnTeleport"));

	AKActor_OnTeleport_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AKActor::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.OnToggle"));

	AKActor_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AKActor::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.TakeRadiusDamage"));

	AKActor_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AKActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.TakeDamage"));

	AKActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.ApplyImpulse
// (Final, Defined, Iterator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ImpulseDir                     (Parm)
// float                          ImpulseMag                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class UClass*                  DamageType                     (OptionalParm, Parm)

void AKActor::ApplyImpulse(const struct FVector& ImpulseDir, float ImpulseMag, const struct FVector& HitLocation, const struct FTraceHitInfo& HitInfo, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.ApplyImpulse"));

	AKActor_ApplyImpulse_Params params;
	params.ImpulseDir = ImpulseDir;
	params.ImpulseMag = ImpulseMag;
	params.HitLocation = HitLocation;
	params.HitInfo = HitInfo;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AKActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.ReplicatedEvent"));

	AKActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.SpawnedByKismet
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void AKActor::SpawnedByKismet()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.SpawnedByKismet"));

	AKActor_SpawnedByKismet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.SetPhysicalCollisionProperties
// (Final, PreOperator, Singular, Event, HasOptionalParms)

void AKActor::SetPhysicalCollisionProperties()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.SetPhysicalCollisionProperties"));

	AKActor_SetPhysicalCollisionProperties_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AKActor::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.Destroyed"));

	AKActor_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void AKActor::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.FellOutOfWorld"));

	AKActor_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AKActor::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.PostBeginPlay"));

	AKActor_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.ResolveRBState
// (PreOperator, NetReliable, Native, HasOptionalParms)

void AKActor::ResolveRBState()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.ResolveRBState"));

	AKActor_ResolveRBState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActor.GetKActorPhysMaterial
// (Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// class UPhysicalMaterial*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicalMaterial* AKActor::STATIC_GetKActorPhysMaterial()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActor.GetKActorPhysMaterial"));

	AKActor_GetKActorPhysMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KActorFromStatic.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AKActorFromStatic::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.TakeRadiusDamage"));

	AKActorFromStatic_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AKActorFromStatic::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.Touch"));

	AKActorFromStatic_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.Bump
// (Iterator, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitNormal                      (Parm)

void AKActorFromStatic::Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.Bump"));

	AKActorFromStatic_Bump_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.ReceiveImpulse
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AKActorFromStatic::ReceiveImpulse(class APawn* Other, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.ReceiveImpulse"));

	AKActorFromStatic_ReceiveImpulse_Params params;
	params.Other = Other;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.ApplyImpulse
// (Final, Defined, Iterator, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ImpulseDir                     (Parm)
// float                          ImpulseMag                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class UClass*                  DamageType                     (OptionalParm, Parm)

void AKActorFromStatic::ApplyImpulse(const struct FVector& ImpulseDir, float ImpulseMag, const struct FVector& HitLocation, const struct FTraceHitInfo& HitInfo, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.ApplyImpulse"));

	AKActorFromStatic_ApplyImpulse_Params params;
	params.ImpulseDir = ImpulseDir;
	params.ImpulseMag = ImpulseMag;
	params.HitLocation = HitLocation;
	params.HitInfo = HitInfo;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.MakeDynamic
// (PreOperator, Net, Exec, Native, Operator, Static)
// Parameters:
// class UStaticMeshComponent*    MovableMesh                    (Parm, EditInline)
// class AKActorFromStatic*       ReturnValue                    (Parm, OutParm, ReturnParm)

class AKActorFromStatic* AKActorFromStatic::STATIC_MakeDynamic(class UStaticMeshComponent* MovableMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.MakeDynamic"));

	AKActorFromStatic_MakeDynamic_Params params;
	params.MovableMesh = MovableMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KActorFromStatic.MakeStatic
// (Final, Defined, PreOperator, Net, Exec, Native, Operator, Static)

void AKActorFromStatic::STATIC_MakeStatic()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.MakeStatic"));

	AKActorFromStatic_MakeStatic_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.BecomeStatic
// (Final, Simulated, Native, Operator)

void AKActorFromStatic::BecomeStatic()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.BecomeStatic"));

	AKActorFromStatic_BecomeStatic_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.OnWakeRBPhysics
// (Final, Defined, PreOperator, Singular, Exec, Native, HasOptionalParms)

void AKActorFromStatic::OnWakeRBPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.OnWakeRBPhysics"));

	AKActorFromStatic_OnWakeRBPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.OnSleepRBPhysics
// (Defined, Iterator, Latent, Singular, Exec, Native, HasOptionalParms)

void AKActorFromStatic::OnSleepRBPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.OnSleepRBPhysics"));

	AKActorFromStatic_OnSleepRBPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorFromStatic.DisablePrecomputedLighting
// (Final, Defined, Latent, Simulated, Native, Static)

void AKActorFromStatic::STATIC_DisablePrecomputedLighting()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorFromStatic.DisablePrecomputedLighting"));

	AKActorFromStatic_DisablePrecomputedLighting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorSpawnable.ResetComponents
// (Final, Defined, Iterator, PreOperator, Singular, Net, Native, HasOptionalParms)

void AKActorSpawnable::ResetComponents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorSpawnable.ResetComponents"));

	AKActorSpawnable_ResetComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorSpawnable.RecycleInternal
// (Final, Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void AKActorSpawnable::RecycleInternal()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorSpawnable.RecycleInternal"));

	AKActorSpawnable_RecycleInternal_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorSpawnable.Recycle
// (Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void AKActorSpawnable::Recycle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorSpawnable.Recycle"));

	AKActorSpawnable_Recycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KActorSpawnable.Initialize
// (Defined, Latent, PreOperator, Net, Simulated, Operator, Static)

void AKActorSpawnable::STATIC_Initialize()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KActorSpawnable.Initialize"));

	AKActorSpawnable_Initialize_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.DoKismetAttachment
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class AActor*                  Attachment                     (Parm)
// class USeqAct_AttachToActor*   Action                         (Parm)

void AKAsset::STATIC_DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.DoKismetAttachment"));

	AKAsset_DoKismetAttachment_Params params;
	params.Attachment = Attachment;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.OnTeleport
// (Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Teleport*        inAction                       (Parm)

void AKAsset::STATIC_OnTeleport(class USeqAct_Teleport* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.OnTeleport"));

	AKAsset_OnTeleport_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AKAsset::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.OnToggle"));

	AKAsset_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AKAsset::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.TakeRadiusDamage"));

	AKAsset_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AKAsset::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.TakeDamage"));

	AKAsset_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AKAsset::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.ReplicatedEvent"));

	AKAsset_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.SetMeshAndPhysAsset
// (Final, Defined, Event, HasOptionalParms)
// Parameters:
// class USkeletalMesh*           NewMesh                        (Parm)
// class UPhysicsAsset*           NewPhysAsset                   (Parm)

void AKAsset::SetMeshAndPhysAsset(class USkeletalMesh* NewMesh, class UPhysicsAsset* NewPhysAsset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.SetMeshAndPhysAsset"));

	AKAsset_SetMeshAndPhysAsset_Params params;
	params.NewMesh = NewMesh;
	params.NewPhysAsset = NewPhysAsset;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KAsset.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AKAsset::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.KAsset.PostBeginPlay"));

	AKAsset_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DisplayDebugProperty
// (Latent, PreOperator, Simulated, Native, Static)
// Parameters:
// TArray<struct FString>         sPropertyStrings               (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 sPropText                      (Parm, OutParm, NeedCtorLink)
// struct FString                 sValueText                     (Parm, OutParm, NeedCtorLink)

void APawn::STATIC_DisplayDebugProperty(TArray<struct FString>* sPropertyStrings, struct FString* sPropText, struct FString* sValueText)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DisplayDebugProperty"));

	APawn_DisplayDebugProperty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (sPropertyStrings != nullptr)
		*sPropertyStrings = params.sPropertyStrings;
	if (sPropText != nullptr)
		*sPropText = params.sPropText;
	if (sValueText != nullptr)
		*sValueText = params.sValueText;
}


// Function Engine.Pawn.OnSetVelocity
// (Iterator, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetVelocity*     Action                         (Parm)

void APawn::STATIC_OnSetVelocity(class USeqAct_SetVelocity* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnSetVelocity"));

	APawn_OnSetVelocity_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Speak
// (Final, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class USoundCue*               Cue                            (Parm)

void APawn::Speak(class USoundCue* Cue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Speak"));

	APawn_Speak_Params params;
	params.Cue = Cue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetScalarParameterInterp
// (Final, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FScalarParameterInterpStruct ScalarParameterInterp          (Const, Parm, OutParm)

void APawn::SetScalarParameterInterp(struct FScalarParameterInterpStruct* ScalarParameterInterp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetScalarParameterInterp"));

	APawn_SetScalarParameterInterp_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ScalarParameterInterp != nullptr)
		*ScalarParameterInterp = params.ScalarParameterInterp;
}


// Function Engine.Pawn.SetRootMotionInterpCurrentTime
// (Final, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// float                          inTime                         (Parm)
// float                          DeltaTime                      (OptionalParm, Parm)
// bool                           bUpdateSkelPose                (OptionalParm, Parm)

void APawn::SetRootMotionInterpCurrentTime(float inTime, float DeltaTime, bool bUpdateSkelPose)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetRootMotionInterpCurrentTime"));

	APawn_SetRootMotionInterpCurrentTime_Params params;
	params.inTime = inTime;
	params.DeltaTime = DeltaTime;
	params.bUpdateSkelPose = bUpdateSkelPose;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetCinematicMode
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInCinematicMode               (Parm)

void APawn::SetCinematicMode(bool bInCinematicMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetCinematicMode"));

	APawn_SetCinematicMode_Params params;
	params.bInCinematicMode = bInCinematicMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ZeroMovementVariables
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Operator, HasOptionalParms)

void APawn::ZeroMovementVariables()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ZeroMovementVariables"));

	APawn_ZeroMovementVariables_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClearPathStep
// (Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void APawn::ClearPathStep()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClearPathStep"));

	APawn_ClearPathStep_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DrawPathStep
// (PreOperator, Net, Exec, Native, Static)
// Parameters:
// class UCanvas*                 C                              (Parm)

void APawn::STATIC_DrawPathStep(class UCanvas* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DrawPathStep"));

	APawn_DrawPathStep_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.IncrementPathChild
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)
// Parameters:
// int                            Cnt                            (Parm)
// class UCanvas*                 C                              (Parm)

void APawn::STATIC_IncrementPathChild(int Cnt, class UCanvas* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IncrementPathChild"));

	APawn_IncrementPathChild_Params params;
	params.Cnt = Cnt;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.IncrementPathStep
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)
// Parameters:
// int                            Cnt                            (Parm)
// class UCanvas*                 C                              (Parm)

void APawn::STATIC_IncrementPathStep(int Cnt, class UCanvas* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IncrementPathStep"));

	APawn_IncrementPathStep_Params params;
	params.Cnt = Cnt;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CreatePathGoalEvaluator
// (Defined, PreOperator, Exec, Static)
// Parameters:
// class UClass*                  GoalEvalClass                  (Parm)
// class UPathGoalEvaluator*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UPathGoalEvaluator* APawn::STATIC_CreatePathGoalEvaluator(class UClass* GoalEvalClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CreatePathGoalEvaluator"));

	APawn_CreatePathGoalEvaluator_Params params;
	params.GoalEvalClass = GoalEvalClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CreatePathConstraint
// (Final, PreOperator, Exec, Static)
// Parameters:
// class UClass*                  ConstraintClass                (Parm)
// class UPathConstraint*         ReturnValue                    (Parm, OutParm, ReturnParm)

class UPathConstraint* APawn::STATIC_CreatePathConstraint(class UClass* ConstraintClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CreatePathConstraint"));

	APawn_CreatePathConstraint_Params params;
	params.ConstraintClass = ConstraintClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AddGoalEvaluator
// (Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UPathGoalEvaluator*      Evaluator                      (Parm)

void APawn::AddGoalEvaluator(class UPathGoalEvaluator* Evaluator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AddGoalEvaluator"));

	APawn_AddGoalEvaluator_Params params;
	params.Evaluator = Evaluator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddPathConstraint
// (Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class UPathConstraint*         Constraint                     (Parm)

void APawn::AddPathConstraint(class UPathConstraint* Constraint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AddPathConstraint"));

	APawn_AddPathConstraint_Params params;
	params.Constraint = Constraint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClearConstraints
// (Latent, Net, Simulated, Exec, Native, Event, Operator)

void APawn::ClearConstraints()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClearConstraints"));

	APawn_ClearConstraints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SoakPause
// (Final, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::SoakPause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SoakPause"));

	APawn_SoakPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.BecomeViewTarget
// (Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void APawn::BecomeViewTarget(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BecomeViewTarget"));

	APawn_BecomeViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MessagePlayer
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)

void APawn::MessagePlayer(const struct FString& msg)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MessagePlayer"));

	APawn_MessagePlayer_Params params;
	params.msg = msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.HandleTeleport
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// TArray<class UObject*>         DestList                       (Parm, NeedCtorLink)
// bool                           bUpdateRotation                (Parm)
// bool                           bCheckOverlap                  (Parm)
// float                          TeleportDistance               (OptionalParm, Parm)
// TArray<class AVolume*>         TeleportVolumes                (OptionalParm, Parm, NeedCtorLink)
// int                            PreferredDestIndex             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_HandleTeleport(TArray<class UObject*> DestList, bool bUpdateRotation, bool bCheckOverlap, float TeleportDistance, TArray<class AVolume*> TeleportVolumes, int PreferredDestIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HandleTeleport"));

	APawn_HandleTeleport_Params params;
	params.DestList = DestList;
	params.bUpdateRotation = bUpdateRotation;
	params.bCheckOverlap = bCheckOverlap;
	params.TeleportDistance = TeleportDistance;
	params.TeleportVolumes = TeleportVolumes;
	params.PreferredDestIndex = PreferredDestIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.OnTeleport
// (Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Teleport*        Action                         (Parm)

void APawn::STATIC_OnTeleport(class USeqAct_Teleport* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnTeleport"));

	APawn_OnTeleport_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnSetMaterial
// (Defined, Iterator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetMaterial*     Action                         (Parm)

void APawn::STATIC_OnSetMaterial(class USeqAct_SetMaterial* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnSetMaterial"));

	APawn_OnSetMaterial_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetDamageScaling
// (Defined, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetDamageScaling()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetDamageScaling"));

	APawn_GetDamageScaling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.DoKismetAttachment
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// class AActor*                  Attachment                     (Parm)
// class USeqAct_AttachToActor*   Action                         (Parm)

void APawn::STATIC_DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DoKismetAttachment"));

	APawn_DoKismetAttachment_Params params;
	params.Attachment = Attachment;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SpawnedByKismet
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::SpawnedByKismet()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SpawnedByKismet"));

	APawn_SpawnedByKismet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.IsStationary
// (Final, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsStationary()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsStationary"));

	APawn_IsStationary_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetCollisionExtent
// (Defined, Iterator, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APawn::STATIC_GetCollisionExtent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetCollisionExtent"));

	APawn_GetCollisionExtent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetCollisionHeight
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetCollisionHeight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetCollisionHeight"));

	APawn_GetCollisionHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetCollisionRadius
// (PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetCollisionRadius()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetCollisionRadius"));

	APawn_GetCollisionRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CheatFly
// (Latent, Net, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CheatFly()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CheatFly"));

	APawn_CheatFly_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CheatGhost
// (Final, Defined, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CheatGhost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CheatGhost"));

	APawn_CheatGhost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CheatWalk
// (Iterator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CheatWalk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CheatWalk"));

	APawn_CheatWalk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.PlayWeaponSwitch
// (Defined, Latent, Singular, NetReliable, HasOptionalParms)
// Parameters:
// class AWeapon*                 OldWeapon                      (Parm)
// class AWeapon*                 NewWeapon                      (Parm)

void APawn::PlayWeaponSwitch(class AWeapon* OldWeapon, class AWeapon* NewWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayWeaponSwitch"));

	APawn_PlayWeaponSwitch_Params params;
	params.OldWeapon = OldWeapon;
	params.NewWeapon = NewWeapon;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetActiveWeapon
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AWeapon*                 NewWeapon                      (Parm)
// bool                           bForceFastClear                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::SetActiveWeapon(class AWeapon* NewWeapon, bool bForceFastClear)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetActiveWeapon"));

	APawn_SetActiveWeapon_Params params;
	params.NewWeapon = NewWeapon;
	params.bForceFastClear = bForceFastClear;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.TossInventory
// (Exec, Native, Event, HasOptionalParms)
// Parameters:
// class AInventory*              Inv                            (Parm)
// struct FVector                 ForceVelocity                  (OptionalParm, Parm)

void APawn::TossInventory(class AInventory* Inv, const struct FVector& ForceVelocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TossInventory"));

	APawn_TossInventory_Params params;
	params.Inv = Inv;
	params.ForceVelocity = ForceVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ThrowActiveWeapon
// (Defined, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bDestroyWeap                   (OptionalParm, Parm)

void APawn::ThrowActiveWeapon(bool bDestroyWeap)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ThrowActiveWeapon"));

	APawn_ThrowActiveWeapon_Params params;
	params.bDestroyWeap = bDestroyWeap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DrawHUD
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// class AHUD*                    H                              (Parm)

void APawn::STATIC_DrawHUD(class AHUD* H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DrawHUD"));

	APawn_DrawHUD_Params params;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FindInventoryType
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  DesiredClass                   (Parm)
// bool                           bAllowSubclass                 (OptionalParm, Parm)
// class AInventory*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AInventory* APawn::FindInventoryType(class UClass* DesiredClass, bool bAllowSubclass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FindInventoryType"));

	APawn_FindInventoryType_Params params;
	params.DesiredClass = DesiredClass;
	params.bAllowSubclass = bAllowSubclass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CreateInventory
// (Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  NewInvClass                    (Parm)
// bool                           bDoNotActivate                 (OptionalParm, Parm)
// class AInventory*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AInventory* APawn::CreateInventory(class UClass* NewInvClass, bool bDoNotActivate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CreateInventory"));

	APawn_CreateInventory_Params params;
	params.NewInvClass = NewInvClass;
	params.bDoNotActivate = bDoNotActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AddDefaultInventory
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void APawn::AddDefaultInventory()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AddDefaultInventory"));

	APawn_AddDefaultInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StopDriving
// (Final, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AVehicle*                V                              (Parm)

void APawn::StopDriving(class AVehicle* V)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StopDriving"));

	APawn_StopDriving_Params params;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StartDriving
// (Final, Defined, Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AVehicle*                V                              (Parm)

void APawn::StartDriving(class AVehicle* V)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StartDriving"));

	APawn_StartDriving_Params params;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CanThrowWeapon
// (Final, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanThrowWeapon()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanThrowWeapon"));

	APawn_CanThrowWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.Suicide
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::Suicide()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Suicide"));

	APawn_Suicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetVehicleBase
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AVehicle*                ReturnValue                    (Parm, OutParm, ReturnParm)

class AVehicle* APawn::STATIC_GetVehicleBase()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetVehicleBase"));

	APawn_GetVehicleBase_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.PlayLanded
// (Defined, Iterator, Latent, PreOperator, NetReliable, HasOptionalParms)
// Parameters:
// float                          ImpactVel                      (Parm)

void APawn::PlayLanded(float ImpactVel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayLanded"));

	APawn_PlayLanded_Params params;
	params.ImpactVel = ImpactVel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CannotJumpNow
// (Defined, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CannotJumpNow()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CannotJumpNow"));

	APawn_CannotJumpNow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.PlayFootStepSound
// (Final, Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            FootDown                       (Parm)
// TEnumAsByte<EFootstepTypes>    FootStepType                   (Parm)

void APawn::PlayFootStepSound(int FootDown, TEnumAsByte<EFootstepTypes> FootStepType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayFootStepSound"));

	APawn_PlayFootStepSound_Params params;
	params.FootDown = FootDown;
	params.FootStepType = FootStepType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TornOff
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::TornOff()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TornOff"));

	APawn_TornOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayDying
// (Final, Iterator, Latent, Net, HasOptionalParms)
// Parameters:
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLoc                         (Parm)

void APawn::PlayDying(class UClass* DamageType, const struct FVector& HitLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayDying"));

	APawn_PlayDying_Params params;
	params.DamageType = DamageType;
	params.HitLoc = HitLoc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetDyingPhysics
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)

void APawn::SetDyingPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetDyingPhysics"));

	APawn_SetDyingPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TurnOff
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, HasOptionalParms)

void APawn::TurnOff()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TurnOff"));

	APawn_TurnOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayHit
// (Final, Defined, Latent, PreOperator, NetReliable, HasOptionalParms)
// Parameters:
// float                          Damage                         (Parm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 Momentum                       (Parm)
// struct FTraceHitInfo           HitInfo                        (Parm)

void APawn::PlayHit(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayHit"));

	APawn_PlayHit_Params params;
	params.Damage = Damage;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayDyingSound
// (Defined, Iterator, Latent, Net, HasOptionalParms)

void APawn::PlayDyingSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayDyingSound"));

	APawn_PlayDyingSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DoJump
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bUpdating                      (Parm)
// float                          JumpZSpeed                     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::DoJump(bool bUpdating, float JumpZSpeed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DoJump"));

	APawn_DoJump_Params params;
	params.bUpdating = bUpdating;
	params.JumpZSpeed = JumpZSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CheckWaterJump
// (Final, Iterator, Singular, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FVector                 WallNormal                     (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CheckWaterJump(struct FVector* WallNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CheckWaterJump"));

	APawn_CheckWaterJump_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WallNormal != nullptr)
		*WallNormal = params.WallNormal;

	return params.ReturnValue;
}


// Function Engine.Pawn.TakeDrowningDamage
// (Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)

void APawn::TakeDrowningDamage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TakeDrowningDamage"));

	APawn_TakeDrowningDamage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.BreathTimer
// (Final, Defined, PreOperator, Simulated, Native, HasOptionalParms)

void APawn::BreathTimer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BreathTimer"));

	APawn_BreathTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TouchingWaterVolume
// (Defined, Singular, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::TouchingWaterVolume()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TouchingWaterVolume"));

	APawn_TouchingWaterVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.HeadVolumeChange
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APhysicsVolume*          newHeadVolume                  (Parm)

void APawn::HeadVolumeChange(class APhysicsVolume* newHeadVolume)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HeadVolumeChange"));

	APawn_HeadVolumeChange_Params params;
	params.newHeadVolume = newHeadVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TickSpecial
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)

void APawn::TickSpecial(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TickSpecial"));

	APawn_TickSpecial_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Landed
// (Final, PreOperator, Singular, Simulated)
// Parameters:
// struct FVector                 HitNormal                      (Parm)
// class AActor*                  FloorActor                     (Parm)

void APawn::Landed(const struct FVector& HitNormal, class AActor* FloorActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Landed"));

	APawn_Landed_Params params;
	params.HitNormal = HitNormal;
	params.FloorActor = FloorActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Falling
// (PreOperator, Singular, Simulated)

void APawn::Falling()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Falling"));

	APawn_Falling_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DelayTriggerDeath
// (Defined, Singular, Net, Native, Static)

void APawn::STATIC_DelayTriggerDeath()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DelayTriggerDeath"));

	APawn_DelayTriggerDeath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Died
// (Final, Singular, Net, NetReliable, Native, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Died"));

	APawn_Died_Params params;
	params.Killer = Killer;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.ThrowWeaponOnDeath
// (Iterator, NetReliable, Simulated, Native, Event, HasOptionalParms)

void APawn::ThrowWeaponOnDeath()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ThrowWeaponOnDeath"));

	APawn_ThrowWeaponOnDeath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetTeam
// (Final, Defined, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// class ATeamInfo*               ReturnValue                    (Parm, OutParm, ReturnParm)

class ATeamInfo* APawn::STATIC_GetTeam()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetTeam"));

	APawn_GetTeam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char APawn::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetTeamNum"));

	APawn_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void APawn::TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TakeDamage"));

	APawn_TakeDamage_Params params;
	params.Damage = Damage;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetKillInstigator
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// class UClass*                  DamageType                     (Parm)
// class AController*             ReturnValue                    (Parm, OutParm, ReturnParm)

class AController* APawn::SetKillInstigator(class AController* InstigatedBy, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetKillInstigator"));

	APawn_SetKillInstigator_Params params;
	params.InstigatedBy = InstigatedBy;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.NotifyTakeHit
// (Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// int                            Damage                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 Momentum                       (Parm)
// class AActor*                  DamageCauser                   (Parm)

void APawn::STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.NotifyTakeHit"));

	APawn_NotifyTakeHit_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TakeRadiusDamageOnBones
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// TArray<struct FName>           Bones                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::TakeRadiusDamageOnBones(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, TArray<struct FName> Bones)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TakeRadiusDamageOnBones"));

	APawn_TakeRadiusDamageOnBones_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.Bones = Bones;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.PruneDamagedBoneList
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// TArray<struct FName>           Bones                          (Parm, OutParm, NeedCtorLink)

void APawn::PruneDamagedBoneList(TArray<struct FName>* Bones)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PruneDamagedBoneList"));

	APawn_PruneDamagedBoneList_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Bones != nullptr)
		*Bones = params.Bones;
}


// Function Engine.Pawn.HealDamage
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            Amount                         (Parm)
// class AController*             Healer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::HealDamage(int Amount, class AController* Healer, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HealDamage"));

	APawn_HealDamage_Params params;
	params.Amount = Amount;
	params.Healer = Healer;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AdjustDamage
// (Latent, Net, Operator)
// Parameters:
// int                            InDamage                       (Parm, OutParm)
// struct FVector                 Momentum                       (Parm, OutParm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (Parm)
// class AActor*                  DamageCauser                   (Parm)

void APawn::AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AdjustDamage"));

	APawn_AdjustDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InDamage != nullptr)
		*InDamage = params.InDamage;
	if (Momentum != nullptr)
		*Momentum = params.Momentum;
}


// Function Engine.Pawn.SetMovementPhysics
// (Defined, Latent, Event, HasOptionalParms)

void APawn::SetMovementPhysics()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetMovementPhysics"));

	APawn_SetMovementPhysics_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Gasp
// (Iterator, Singular, Simulated, Native, Event, Static)

void APawn::STATIC_Gasp()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Gasp"));

	APawn_Gasp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnGiveInventory
// (Defined, Singular, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_GiveInventory*   inAction                       (Parm)

void APawn::STATIC_OnGiveInventory(class USeqAct_GiveInventory* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnGiveInventory"));

	APawn_OnGiveInventory_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnAssignController
// (Final, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_AssignController* inAction                       (Parm)

void APawn::STATIC_OnAssignController(class USeqAct_AssignController* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnAssignController"));

	APawn_OnAssignController_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ReceivedNewEvent
// (Final, Latent, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USequenceEvent*          Evt                            (Parm)

void APawn::ReceivedNewEvent(class USequenceEvent* Evt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ReceivedNewEvent"));

	APawn_ReceivedNewEvent_Params params;
	params.Evt = Evt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SpawnDefaultController
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Event, HasOptionalParms)

void APawn::SpawnDefaultController()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SpawnDefaultController"));

	APawn_SpawnDefaultController_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PostBeginPlay
// (Final, Latent, Net, Simulated)

void APawn::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PostBeginPlay"));

	APawn_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PreBeginPlay
// (Latent, Net, Simulated)

void APawn::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PreBeginPlay"));

	APawn_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Destroyed
// (Iterator, Latent, Singular, Simulated)

void APawn::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Destroyed"));

	APawn_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.DetachFromController
// (Final, Latent, Net, NetReliable, Native, Static)
// Parameters:
// bool                           bDestroyController             (OptionalParm, Parm)

void APawn::STATIC_DetachFromController(bool bDestroyController)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DetachFromController"));

	APawn_DetachFromController_Params params;
	params.bDestroyController = bDestroyController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CrushedBy
// (Defined, Iterator, Singular, Exec, Static)
// Parameters:
// class APawn*                   OtherPawn                      (Parm)

void APawn::STATIC_CrushedBy(class APawn* OtherPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CrushedBy"));

	APawn_CrushedBy_Params params;
	params.OtherPawn = OtherPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CanBeBaseForPawn
// (Defined, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// class APawn*                   aPawn                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanBeBaseForPawn(class APawn* aPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanBeBaseForPawn"));

	APawn_CanBeBaseForPawn_Params params;
	params.aPawn = aPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.BaseChange
// (Final, Defined, Iterator, PreOperator, Singular, Simulated)

void APawn::BaseChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BaseChange"));

	APawn_BaseChange_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StuckOnPawn
// (Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   OtherPawn                      (Parm)

void APawn::StuckOnPawn(class APawn* OtherPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StuckOnPawn"));

	APawn_StuckOnPawn_Params params;
	params.OtherPawn = OtherPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.JumpOffPawn
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Operator, Static)

void APawn::STATIC_JumpOffPawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.JumpOffPawn"));

	APawn_JumpOffPawn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.gibbedBy
// (Final, Defined, Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  Other                          (Parm)

void APawn::STATIC_gibbedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.gibbedBy"));

	APawn_gibbedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.EncroachedBy
// (Final, Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void APawn::EncroachedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.EncroachedBy"));

	APawn_EncroachedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.EncroachingOn
// (Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::EncroachingOn(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.EncroachingOn"));

	APawn_EncroachingOn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.FaceRotation
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Event, Static)
// Parameters:
// struct FRotator                NewRotation                    (Parm)
// float                          DeltaTime                      (Parm)

void APawn::STATIC_FaceRotation(const struct FRotator& NewRotation, float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FaceRotation"));

	APawn_FaceRotation_Params params;
	params.NewRotation = NewRotation;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.UpdatePawnRotation
// (Final, Defined, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)

void APawn::UpdatePawnRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.UpdatePawnRotation"));

	APawn_UpdatePawnRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClientSetRotation
// (Defined, Iterator, Singular, Static)
// Parameters:
// struct FRotator                NewRotation                    (Parm)

void APawn::STATIC_ClientSetRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClientSetRotation"));

	APawn_ClientSetRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClientRestart
// (Defined, Latent, PreOperator, Singular, Simulated, Native, HasOptionalParms)

void APawn::ClientRestart()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClientRestart"));

	APawn_ClientRestart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.Restart
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Native, HasOptionalParms)

void APawn::Restart()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Restart"));

	APawn_Restart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.TakeFallingDamage
// (Final, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)

void APawn::TakeFallingDamage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TakeFallingDamage"));

	APawn_TakeFallingDamage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.KilledBy
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APawn*                   EventInstigator                (Parm)

void APawn::KilledBy(class APawn* EventInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.KilledBy"));

	APawn_KilledBy_Params params;
	params.EventInstigator = EventInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddVelocity
// (Final, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewVelocity                    (Parm)
// struct FVector                 HitLocation                    (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)

void APawn::AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AddVelocity"));

	APawn_AddVelocity_Params params;
	params.NewVelocity = NewVelocity;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.HandleMomentum
// (Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 Momentum                       (Parm)
// struct FVector                 HitLocation                    (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)

void APawn::STATIC_HandleMomentum(const struct FVector& Momentum, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HandleMomentum"));

	APawn_HandleMomentum_Params params;
	params.Momentum = Momentum;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StartCrouch
// (Defined, Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          HeightAdjust                   (Parm)

void APawn::StartCrouch(float HeightAdjust)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StartCrouch"));

	APawn_StartCrouch_Params params;
	params.HeightAdjust = HeightAdjust;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.EndCrouch
// (Final, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          HeightAdjust                   (Parm)

void APawn::EndCrouch(float HeightAdjust)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.EndCrouch"));

	APawn_EndCrouch_Params params;
	params.HeightAdjust = HeightAdjust;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ShouldCrouch
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bCrouch                        (Parm)

void APawn::ShouldCrouch(bool bCrouch)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ShouldCrouch"));

	APawn_ShouldCrouch_Params params;
	params.bCrouch = bCrouch;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.UnCrouch
// (Defined, Latent, Simulated, Exec, Native, Event, HasOptionalParms)

void APawn::UnCrouch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.UnCrouch"));

	APawn_UnCrouch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OutsideWorldBounds
// (Final, Iterator, PreOperator, Singular, Exec, Native, HasOptionalParms)

void APawn::OutsideWorldBounds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OutsideWorldBounds"));

	APawn_OutsideWorldBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FellOutOfWorld
// (Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UClass*                  dmgType                        (Parm)

void APawn::FellOutOfWorld(class UClass* dmgType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FellOutOfWorld"));

	APawn_FellOutOfWorld_Params params;
	params.dmgType = dmgType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClientMessage
// (Final, Defined, PreOperator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void APawn::ClientMessage(const struct FString& S, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClientMessage"));

	APawn_ClientMessage_Params params;
	params.S = S;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.HandlePickup
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AInventory*              Inv                            (Parm)

void APawn::STATIC_HandlePickup(class AInventory* Inv)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HandlePickup"));

	APawn_HandlePickup_Params params;
	params.Inv = Inv;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.LineOfSightTo
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Native, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_LineOfSightTo(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.LineOfSightTo"));

	APawn_LineOfSightTo_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SetMoveTarget
// (Final, Defined, Latent, Event, HasOptionalParms)
// Parameters:
// class AActor*                  NewTarget                      (Parm)

void APawn::SetMoveTarget(class AActor* NewTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetMoveTarget"));

	APawn_SetMoveTarget_Params params;
	params.NewTarget = NewTarget;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.InGodMode
// (Final, Latent, PreOperator, Singular, Simulated, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_InGodMode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.InGodMode"));

	APawn_InGodMode_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SetViewRotation
// (Final, Iterator, Latent, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)

void APawn::SetViewRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetViewRotation"));

	APawn_SetViewRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetAdjustedAimFor
// (Iterator, Latent, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// class AWeapon*                 W                              (Parm)
// struct FVector                 StartFireLoc                   (Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator APawn::STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetAdjustedAimFor"));

	APawn_GetAdjustedAimFor_Params params;
	params.W = W;
	params.StartFireLoc = StartFireLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.InFreeCam
// (Final, Iterator, PreOperator, Singular, Simulated, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_InFreeCam()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.InFreeCam"));

	APawn_InFreeCam_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetBaseAimRotation
// (Final, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AWeapon*                 W                              (Parm)
// bool                           bIgnoreAutoLock                (OptionalParm, Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator APawn::GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetBaseAimRotation"));

	APawn_GetBaseAimRotation_Params params;
	params.W = W;
	params.bIgnoreAutoLock = bIgnoreAutoLock;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetPawnViewLocation
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APawn::GetPawnViewLocation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetPawnViewLocation"));

	APawn_GetPawnViewLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetViewRotation
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator APawn::GetViewRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetViewRotation"));

	APawn_GetViewRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetActorEyesViewPoint
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 out_Location                   (Parm, OutParm)
// struct FRotator                out_Rotation                   (Parm, OutParm)

void APawn::GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetActorEyesViewPoint"));

	APawn_GetActorEyesViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Location != nullptr)
		*out_Location = params.out_Location;
	if (out_Rotation != nullptr)
		*out_Rotation = params.out_Rotation;
}


// Function Engine.Pawn.IsFirstPerson
// (Defined, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::IsFirstPerson()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsFirstPerson"));

	APawn_IsFirstPerson_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsPlayerPawn
// (Iterator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsPlayerPawn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsPlayerPawn"));

	APawn_IsPlayerPawn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsLocallyControlled
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsLocallyControlled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsLocallyControlled"));

	APawn_IsLocallyControlled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsHumanControlled
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// class AController*             PawnController                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsHumanControlled(class AController* PawnController)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsHumanControlled"));

	APawn_IsHumanControlled_Params params;
	params.PawnController = PawnController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void APawn::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DisplayDebug"));

	APawn_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Pawn.ClimbLadder
// (Final, Defined, Iterator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class ALadderVolume*           L                              (Parm)

void APawn::ClimbLadder(class ALadderVolume* L)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClimbLadder"));

	APawn_ClimbLadder_Params params;
	params.L = L;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.EndClimbLadder
// (Final, Iterator, Event, Static)
// Parameters:
// class ALadderVolume*           OldLadder                      (Parm)

void APawn::STATIC_EndClimbLadder(class ALadderVolume* OldLadder)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.EndClimbLadder"));

	APawn_EndClimbLadder_Params params;
	params.OldLadder = OldLadder;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CanSplash
// (Final, Iterator, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanSplash()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanSplash"));

	APawn_CanSplash_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.RangedAttackTime
// (Final, Defined, Net, NetReliable, Exec, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::RangedAttackTime()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.RangedAttackTime"));

	APawn_RangedAttackTime_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.RecommendLongRangedAttack
// (Final, Defined, Latent, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::RecommendLongRangedAttack()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.RecommendLongRangedAttack"));

	APawn_RecommendLongRangedAttack_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CanGrabLadder
// (Final, Iterator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanGrabLadder()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanGrabLadder"));

	APawn_CanGrabLadder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.DropToGround
// (Final, Iterator, NetReliable, Exec, Native, Static)

void APawn::STATIC_DropToGround()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.DropToGround"));

	APawn_DropToGround_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetDefaultCameraMode
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class APlayerController*       RequestedBy                    (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName APawn::STATIC_GetDefaultCameraMode(class APlayerController* RequestedBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetDefaultCameraMode"));

	APawn_GetDefaultCameraMode_Params params;
	params.RequestedBy = RequestedBy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.UnPossessed
// (Defined, Iterator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void APawn::UnPossessed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.UnPossessed"));

	APawn_UnPossessed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.UpdateControllerOnPossess
// (Final, Defined, Iterator, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bVehicleTransition             (Parm)

void APawn::UpdateControllerOnPossess(bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.UpdateControllerOnPossess"));

	APawn_UpdateControllerOnPossess_Params params;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PossessedBy
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// class AController*             C                              (Parm)
// bool                           bVehicleTransition             (Parm)

void APawn::PossessedBy(class AController* C, bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PossessedBy"));

	APawn_PossessedBy_Params params;
	params.C = C;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.NotifyTeamChanged
// (Defined, Singular, Net, Simulated, Exec, Event, Operator, Static)

void APawn::STATIC_NotifyTeamChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.NotifyTeamChanged"));

	APawn_NotifyTeamChanged_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayTeleportEffect
// (Final, Latent, Singular, NetReliable, HasOptionalParms)
// Parameters:
// bool                           bOut                           (Parm)
// bool                           bSound                         (Parm)

void APawn::PlayTeleportEffect(bool bOut, bool bSound)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayTeleportEffect"));

	APawn_PlayTeleportEffect_Params params;
	params.bOut = bOut;
	params.bSound = bSound;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APawn::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetHumanReadableName"));

	APawn_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.NeedToTurn
// (Iterator, Latent, Net, NetReliable, Simulated, Event, Operator, Static)
// Parameters:
// struct FVector                 targ                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_NeedToTurn(const struct FVector& targ)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.NeedToTurn"));

	APawn_NeedToTurn_Params params;
	params.targ = targ;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsFiring
// (Final, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::IsFiring()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsFiring"));

	APawn_IsFiring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.HasRangedAttack
// (PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_HasRangedAttack()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.HasRangedAttack"));

	APawn_HasRangedAttack_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.FireOnRelease
// (Defined, Iterator, PreOperator, Net, NetReliable, Exec, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_FireOnRelease()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FireOnRelease"));

	APawn_FireOnRelease_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.TooCloseToAttack
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::TooCloseToAttack(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TooCloseToAttack"));

	APawn_TooCloseToAttack_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CanAttack
// (PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanAttack(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanAttack"));

	APawn_CanAttack_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.BotFire
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Event, Operator)
// Parameters:
// bool                           bFinished                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::BotFire(bool bFinished)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BotFire"));

	APawn_BotFire_Params params;
	params.bFinished = bFinished;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.WeaponStoppedFiring
// (Defined, Iterator, Simulated, Operator, HasOptionalParms)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// bool                           bViaReplication                (Parm)

void APawn::WeaponStoppedFiring(class AWeapon* InWeapon, bool bViaReplication)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.WeaponStoppedFiring"));

	APawn_WeaponStoppedFiring_Params params;
	params.InWeapon = InWeapon;
	params.bViaReplication = bViaReplication;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.WeaponFired
// (Iterator, Simulated, Operator, HasOptionalParms)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// bool                           bViaReplication                (Parm)
// struct FVector                 HitLocation                    (OptionalParm, Parm)

void APawn::WeaponFired(class AWeapon* InWeapon, bool bViaReplication, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.WeaponFired"));

	APawn_WeaponFired_Params params;
	params.InWeapon = InWeapon;
	params.bViaReplication = bViaReplication;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FlashLocationUpdated
// (Final, Defined, Simulated, Exec, Event, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// struct FVector                 InFlashLocation                (Parm)
// bool                           bViaReplication                (Parm)

void APawn::STATIC_FlashLocationUpdated(class AWeapon* InWeapon, const struct FVector& InFlashLocation, bool bViaReplication)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FlashLocationUpdated"));

	APawn_FlashLocationUpdated_Params params;
	params.InWeapon = InWeapon;
	params.InFlashLocation = InFlashLocation;
	params.bViaReplication = bViaReplication;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClearFlashLocation
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)

void APawn::ClearFlashLocation(class AWeapon* InWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClearFlashLocation"));

	APawn_ClearFlashLocation_Params params;
	params.InWeapon = InWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClearFlashCount
// (Defined, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)

void APawn::ClearFlashCount(class AWeapon* InWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClearFlashCount"));

	APawn_ClearFlashCount_Params params;
	params.InWeapon = InWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FlashCountUpdated
// (Final, Simulated, Exec, Event, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// unsigned char                  InFlashCount                   (Parm)
// bool                           bViaReplication                (Parm)

void APawn::STATIC_FlashCountUpdated(class AWeapon* InWeapon, unsigned char InFlashCount, bool bViaReplication)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FlashCountUpdated"));

	APawn_FlashCountUpdated_Params params;
	params.InWeapon = InWeapon;
	params.InFlashCount = InFlashCount;
	params.bViaReplication = bViaReplication;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.IncrementFlashCount
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// unsigned char                  InFiringMode                   (Parm)

void APawn::STATIC_IncrementFlashCount(class AWeapon* InWeapon, unsigned char InFiringMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IncrementFlashCount"));

	APawn_IncrementFlashCount_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FiringModeUpdated
// (Final, Latent, PreOperator, Net, NetReliable, Exec, Event, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// unsigned char                  InFiringMode                   (Parm)
// bool                           bViaReplication                (Parm)

void APawn::STATIC_FiringModeUpdated(class AWeapon* InWeapon, unsigned char InFiringMode, bool bViaReplication)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FiringModeUpdated"));

	APawn_FiringModeUpdated_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;
	params.bViaReplication = bViaReplication;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetFiringMode
// (Defined, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// unsigned char                  InFiringMode                   (Parm)

void APawn::SetFiringMode(class AWeapon* InWeapon, unsigned char InFiringMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetFiringMode"));

	APawn_SetFiringMode_Params params;
	params.InWeapon = InWeapon;
	params.InFiringMode = InFiringMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetWeaponFiringMode
// (Defined, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AWeapon*                 InWeapon                       (Parm)
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char APawn::STATIC_GetWeaponFiringMode(class AWeapon* InWeapon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetWeaponFiringMode"));

	APawn_GetWeaponFiringMode_Params params;
	params.InWeapon = InWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.StopFire
// (Final, Defined, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)

void APawn::StopFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StopFire"));

	APawn_StopFire_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StartFire
// (Final, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::StartFire()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StartFire"));

	APawn_StartFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.StopFiring
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::StopFiring()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StopFiring"));

	APawn_StopFiring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APawn::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.Reset"));

	APawn_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayerChangedTeam
// (Final, Singular, Net, HasOptionalParms)

void APawn::PlayerChangedTeam()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayerChangedTeam"));

	APawn_PlayerChangedTeam_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetBaseEyeheight
// (Defined, Singular, Net, Simulated, Exec, Native, HasOptionalParms)

void APawn::SetBaseEyeheight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetBaseEyeheight"));

	APawn_SetBaseEyeheight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SpecialMoveThruEdge
// (Final, Defined, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<ENavMeshEdgeType>  EdgeType                       (Parm)
// int                            Dir                            (Parm)
// struct FVector                 MoveStart                      (Parm)
// struct FVector                 MoveDest                       (Parm)
// class AActor*                  RelActor                       (OptionalParm, Parm)
// int                            RelItem                        (OptionalParm, Parm)
// class UNavigationHandle*       NavHandle                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::SpecialMoveThruEdge(TEnumAsByte<ENavMeshEdgeType> EdgeType, int Dir, const struct FVector& MoveStart, const struct FVector& MoveDest, class AActor* RelActor, int RelItem, class UNavigationHandle* NavHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SpecialMoveThruEdge"));

	APawn_SpecialMoveThruEdge_Params params;
	params.EdgeType = EdgeType;
	params.Dir = Dir;
	params.MoveStart = MoveStart;
	params.MoveDest = MoveDest;
	params.RelActor = RelActor;
	params.RelItem = RelItem;
	params.NavHandle = NavHandle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SpecialMoveTo
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        Start                          (Parm)
// class ANavigationPoint*        End                            (Parm)
// class AActor*                  Next                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::SpecialMoveTo(class ANavigationPoint* Start, class ANavigationPoint* End, class AActor* Next)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SpecialMoveTo"));

	APawn_SpecialMoveTo_Params params;
	params.Start = Start;
	params.End = End;
	params.Next = Next;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetAirControl
// (Final, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetAirControl()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetAirControl"));

	APawn_GetAirControl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.TermRagdoll
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::TermRagdoll()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.TermRagdoll"));

	APawn_TermRagdoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.InitRagdoll
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_InitRagdoll()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.InitRagdoll"));

	APawn_InitRagdoll_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetBoundingCylinder
// (Final, Defined, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          CollisionRadius                (Parm, OutParm)
// float                          CollisionHeight                (Parm, OutParm)

void APawn::STATIC_GetBoundingCylinder(float* CollisionRadius, float* CollisionHeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetBoundingCylinder"));

	APawn_GetBoundingCylinder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CollisionRadius != nullptr)
		*CollisionRadius = params.CollisionRadius;
	if (CollisionHeight != nullptr)
		*CollisionHeight = params.CollisionHeight;
}


// Function Engine.Pawn.ReachedDesiredRotation
// (Final, Defined, Latent, PreOperator, Simulated, Exec, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::ReachedDesiredRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ReachedDesiredRotation"));

	APawn_ReachedDesiredRotation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SetPushesRigidBodies
// (Final, Iterator, Net, Event, HasOptionalParms)
// Parameters:
// bool                           NewPush                        (Parm)

void APawn::SetPushesRigidBodies(bool NewPush)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetPushesRigidBodies"));

	APawn_SetPushesRigidBodies_Params params;
	params.NewPush = NewPush;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ForceCrouch
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Exec, Event, Static)

void APawn::STATIC_ForceCrouch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ForceCrouch"));

	APawn_ForceCrouch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ReachedPoint
// (Iterator, Latent, PreOperator, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FVector                 Point                          (Parm)
// class AActor*                  NewAnchor                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::ReachedPoint(const struct FVector& Point, class AActor* NewAnchor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ReachedPoint"));

	APawn_ReachedPoint_Params params;
	params.Point = Point;
	params.NewAnchor = NewAnchor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.ReachedDestination
// (Defined, Iterator, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Goal                           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::ReachedDestination(class AActor* Goal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ReachedDestination"));

	APawn_ReachedDestination_Params params;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetBestAnchor
// (Defined, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  TestActor                      (Parm)
// struct FVector                 TestLocation                   (Parm)
// bool                           bStartPoint                    (Parm)
// bool                           bOnlyCheckVisible              (Parm)
// float                          out_Dist                       (Parm, OutParm)
// class ANavigationPoint*        ReturnValue                    (Parm, OutParm, ReturnParm)

class ANavigationPoint* APawn::STATIC_GetBestAnchor(class AActor* TestActor, const struct FVector& TestLocation, bool bStartPoint, bool bOnlyCheckVisible, float* out_Dist)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetBestAnchor"));

	APawn_GetBestAnchor_Params params;
	params.TestActor = TestActor;
	params.TestLocation = TestLocation;
	params.bStartPoint = bStartPoint;
	params.bOnlyCheckVisible = bOnlyCheckVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Dist != nullptr)
		*out_Dist = params.out_Dist;

	return params.ReturnValue;
}


// Function Engine.Pawn.SetAnchor
// (Final, Defined, Iterator, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ANavigationPoint*        NewAnchor                      (Parm)

void APawn::SetAnchor(class ANavigationPoint* NewAnchor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetAnchor"));

	APawn_SetAnchor_Params params;
	params.NewAnchor = NewAnchor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetRemoteViewPitch
// (Final, Iterator, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// int                            NewRemoteViewPitch             (Parm)

void APawn::SetRemoteViewPitch(int NewRemoteViewPitch)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetRemoteViewPitch"));

	APawn_SetRemoteViewPitch_Params params;
	params.NewRemoteViewPitch = NewRemoteViewPitch;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.IsInvisibleToAI
// (Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsInvisibleToAI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsInvisibleToAI"));

	APawn_IsInvisibleToAI_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsValidEnemyTargetFor
// (Defined, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Const, Parm)
// bool                           bNoPRIisEnemy                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsValidEnemyTargetFor(class APlayerReplicationInfo* PRI, bool bNoPRIisEnemy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsValidEnemyTargetFor"));

	APawn_IsValidEnemyTargetFor_Params params;
	params.PRI = PRI;
	params.bNoPRIisEnemy = bNoPRIisEnemy;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetFallDuration
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetFallDuration()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetFallDuration"));

	APawn_GetFallDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SuggestJumpVelocity
// (Final, Latent, PreOperator, Singular, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 JumpVelocity                   (Parm, OutParm)
// struct FVector                 Destination                    (Parm)
// struct FVector                 Start                          (Parm)
// bool                           bRequireFallLanding            (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::SuggestJumpVelocity(const struct FVector& Destination, const struct FVector& Start, bool bRequireFallLanding, struct FVector* JumpVelocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SuggestJumpVelocity"));

	APawn_SuggestJumpVelocity_Params params;
	params.Destination = Destination;
	params.Start = Start;
	params.bRequireFallLanding = bRequireFallLanding;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (JumpVelocity != nullptr)
		*JumpVelocity = params.JumpVelocity;

	return params.ReturnValue;
}


// Function Engine.Pawn.ValidAnchor
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::ValidAnchor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ValidAnchor"));

	APawn_ValidAnchor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AdjustDestination
// (Final, Latent, Net, Operator)
// Parameters:
// class AActor*                  GoalActor                      (Parm)
// struct FVector                 Dest                           (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector APawn::AdjustDestination(class AActor* GoalActor, const struct FVector& Dest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AdjustDestination"));

	APawn_AdjustDestination_Params params;
	params.GoalActor = GoalActor;
	params.Dest = Dest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsAliveAndWell
// (Final, Defined, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsAliveAndWell()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsAliveAndWell"));

	APawn_IsAliveAndWell_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void APawn::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ReplicatedEvent"));

	APawn_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetSkelControlScale
// (Defined, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void APawn::SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetSkelControlScale"));

	APawn_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetMorphWeight
// (Iterator, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void APawn::SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetMorphWeight"));

	APawn_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetActorFaceFXAsset
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAsset*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UFaceFXAsset* APawn::GetActorFaceFXAsset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetActorFaceFXAsset"));

	APawn_GetActorFaceFXAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.FaceFXAudioFinished
// (Singular, Net, NetReliable, Simulated, Event, Static)
// Parameters:
// class UAudioComponent*         AC                             (Parm, EditInline)

void APawn::STATIC_FaceFXAudioFinished(class UAudioComponent* AC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FaceFXAudioFinished"));

	APawn_FaceFXAudioFinished_Params params;
	params.AC = AC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnPlayFaceFXAnim
// (Final, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_PlayFaceFXAnim*  inAction                       (Parm)

void APawn::STATIC_OnPlayFaceFXAnim(class USeqAct_PlayFaceFXAnim* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.OnPlayFaceFXAnim"));

	APawn_OnPlayFaceFXAnim_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CanActorPlayFaceFXAnim
// (Defined, Iterator, Latent, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::CanActorPlayFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CanActorPlayFaceFXAnim"));

	APawn_CanActorPlayFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsActorPlayingFaceFXAnim
// (Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsActorPlayingFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsActorPlayingFaceFXAnim"));

	APawn_IsActorPlayingFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetFaceFXAudioComponent
// (Final, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAudioComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UAudioComponent* APawn::GetFaceFXAudioComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetFaceFXAudioComponent"));

	APawn_GetFaceFXAudioComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.StopActorFaceFXAnim
// (Iterator, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void APawn::StopActorFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.StopActorFaceFXAnim"));

	APawn_StopActorFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PlayActorFaceFXAnim
// (Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          AnimSet                        (Parm)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// struct FString                 SeqName                        (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::PlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PlayActorFaceFXAnim"));

	APawn_PlayActorFaceFXAnim_Params params;
	params.AnimSet = AnimSet;
	params.GroupName = GroupName;
	params.SeqName = SeqName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.MAT_FinishAIGroup
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void APawn::MAT_FinishAIGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_FinishAIGroup"));

	APawn_MAT_FinishAIGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_BeginAIGroup
// (Iterator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 StartLoc                       (Parm)
// struct FRotator                StartRot                       (Parm)

void APawn::MAT_BeginAIGroup(const struct FVector& StartLoc, const struct FRotator& StartRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_BeginAIGroup"));

	APawn_MAT_BeginAIGroup_Params params;
	params.StartLoc = StartLoc;
	params.StartRot = StartRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FinishAIGroup
// (Final, Net, NetReliable, Exec, Event, Static)

void APawn::STATIC_FinishAIGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FinishAIGroup"));

	APawn_FinishAIGroup_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.BeginAIGroup
// (Final, Iterator, Latent, Simulated, Native, Operator)

void APawn::BeginAIGroup()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BeginAIGroup"));

	APawn_BeginAIGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.InterpolationFinished
// (Final, Defined, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)

void APawn::InterpolationFinished(class USeqAct_Interp* InterpAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.InterpolationFinished"));

	APawn_InterpolationFinished_Params params;
	params.InterpAction = InterpAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.InterpolationStarted
// (Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class USeqAct_Interp*          InterpAction                   (Parm)
// class UInterpGroupInst*        GroupInst                      (Parm)

void APawn::InterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.InterpolationStarted"));

	APawn_InterpolationStarted_Params params;
	params.InterpAction = InterpAction;
	params.GroupInst = GroupInst;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetGroundSpeed
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetGroundSpeed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetGroundSpeed"));

	APawn_GetGroundSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.MAT_SetSkelControlStrength
// (Final, PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          ControlStrength                (Parm)

void APawn::STATIC_MAT_SetSkelControlStrength(const struct FName& SkelControlName, float ControlStrength)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_SetSkelControlStrength"));

	APawn_MAT_SetSkelControlStrength_Params params;
	params.SkelControlName = SkelControlName;
	params.ControlStrength = ControlStrength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_SetSkelControlScale
// (PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SkelControlName                (Parm)
// float                          Scale                          (Parm)

void APawn::STATIC_MAT_SetSkelControlScale(const struct FName& SkelControlName, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_SetSkelControlScale"));

	APawn_MAT_SetSkelControlScale_Params params;
	params.SkelControlName = SkelControlName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_SetMorphWeight
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   MorphNodeName                  (Parm)
// float                          MorphWeight                    (Parm)

void APawn::STATIC_MAT_SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_SetMorphWeight"));

	APawn_MAT_SetMorphWeight_Params params;
	params.MorphNodeName = MorphNodeName;
	params.MorphWeight = MorphWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_SetAnimWeights
// (Defined, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// TArray<struct FAnimSlotInfo>   SlotInfos                      (Parm, NeedCtorLink)

void APawn::STATIC_MAT_SetAnimWeights(TArray<struct FAnimSlotInfo> SlotInfos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_SetAnimWeights"));

	APawn_MAT_SetAnimWeights_Params params;
	params.SlotInfos = SlotInfos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_SetAnimPosition
// (Final, Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void APawn::STATIC_MAT_SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_SetAnimPosition"));

	APawn_MAT_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetAnimPosition
// (Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SlotName                       (Parm)
// int                            ChannelIndex                   (Parm)
// struct FName                   InAnimSeqName                  (Parm)
// float                          InPosition                     (Parm)
// bool                           bFireNotifies                  (Parm)
// bool                           bLooping                       (Parm)
// bool                           bEnableRootMotion              (Parm)

void APawn::SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetAnimPosition"));

	APawn_SetAnimPosition_Params params;
	params.SlotName = SlotName;
	params.ChannelIndex = ChannelIndex;
	params.InAnimSeqName = InAnimSeqName;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;
	params.bLooping = bLooping;
	params.bEnableRootMotion = bEnableRootMotion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_FinishAnimControl
// (Iterator, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void APawn::STATIC_MAT_FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_FinishAnimControl"));

	APawn_MAT_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.FinishAnimControl
// (Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void APawn::FinishAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FinishAnimControl"));

	APawn_FinishAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.MAT_BeginAnimControl
// (Final, Defined, Latent, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void APawn::STATIC_MAT_BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.MAT_BeginAnimControl"));

	APawn_MAT_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.BeginAnimControl
// (Final, Defined, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// class UInterpGroup*            InInterpGroup                  (Parm)

void APawn::BeginAnimControl(class UInterpGroup* InInterpGroup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BeginAnimControl"));

	APawn_BeginAnimControl_Params params;
	params.InInterpGroup = InInterpGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.RestoreAnimSetsToDefault
// (Defined, Iterator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::RestoreAnimSetsToDefault()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.RestoreAnimSetsToDefault"));

	APawn_RestoreAnimSetsToDefault_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AnimSetListUpdated
// (Final, Iterator, Simulated, Native, HasOptionalParms)

void APawn::AnimSetListUpdated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AnimSetListUpdated"));

	APawn_AnimSetListUpdated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddAnimSets
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// TArray<class UAnimSet*>        CustomAnimSets                 (Const, Parm, OutParm, NeedCtorLink)

void APawn::AddAnimSets(TArray<class UAnimSet*>* CustomAnimSets)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.AddAnimSets"));

	APawn_AddAnimSets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CustomAnimSets != nullptr)
		*CustomAnimSets = params.CustomAnimSets;
}


// Function Engine.Pawn.BuildScriptAnimSetList
// (Iterator, Latent, PreOperator, Simulated, Native, HasOptionalParms)

void APawn::BuildScriptAnimSetList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.BuildScriptAnimSetList"));

	APawn_BuildScriptAnimSetList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.UpdateAnimSetList
// (Final, Defined, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void APawn::UpdateAnimSetList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.UpdateAnimSetList"));

	APawn_UpdateAnimSetList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ClearAnimNodes
// (Final, Defined, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void APawn::ClearAnimNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ClearAnimNodes"));

	APawn_ClearAnimNodes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.CacheAnimNodes
// (Final, Iterator, Latent, PreOperator, Simulated, Native, HasOptionalParms)

void APawn::CacheAnimNodes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CacheAnimNodes"));

	APawn_CacheAnimNodes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PostInitAnimTree
// (Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void APawn::PostInitAnimTree(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PostInitAnimTree"));

	APawn_PostInitAnimTree_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.GetJumpSpeedMultiplier
// (Final, Defined, PreOperator, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float APawn::STATIC_GetJumpSpeedMultiplier()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.GetJumpSpeedMultiplier"));

	APawn_GetJumpSpeedMultiplier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsDesiredRotationLocked
// (Defined, Iterator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsDesiredRotationLocked()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsDesiredRotationLocked"));

	APawn_IsDesiredRotationLocked_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsDesiredRotationInUse
// (Final, Iterator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::STATIC_IsDesiredRotationInUse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.IsDesiredRotationInUse"));

	APawn_IsDesiredRotationInUse_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.CheckDesiredRotation
// (Latent, Net, NetReliable, Exec, Native, Event, Operator)

void APawn::CheckDesiredRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.CheckDesiredRotation"));

	APawn_CheckDesiredRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ResetDesiredRotation
// (Final, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void APawn::ResetDesiredRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.ResetDesiredRotation"));

	APawn_ResetDesiredRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.LockDesiredRotation
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Native, Operator, Static)
// Parameters:
// bool                           Lock                           (Parm)
// bool                           InUnlockWhenReached            (OptionalParm, Parm)

void APawn::STATIC_LockDesiredRotation(bool Lock, bool InUnlockWhenReached)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.LockDesiredRotation"));

	APawn_LockDesiredRotation_Params params;
	params.Lock = Lock;
	params.InUnlockWhenReached = InUnlockWhenReached;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetDesiredRotation
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FRotator                TargetDesiredRotation          (Parm)
// bool                           InLockDesiredRotation          (OptionalParm, Parm)
// bool                           InUnlockWhenReached            (OptionalParm, Parm)
// float                          InterpolationTime              (OptionalParm, Parm)
// bool                           bResetRotationRate             (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::SetDesiredRotation(const struct FRotator& TargetDesiredRotation, bool InLockDesiredRotation, bool InUnlockWhenReached, float InterpolationTime, bool bResetRotationRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.SetDesiredRotation"));

	APawn_SetDesiredRotation_Params params;
	params.TargetDesiredRotation = TargetDesiredRotation;
	params.InLockDesiredRotation = InLockDesiredRotation;
	params.InUnlockWhenReached = InUnlockWhenReached;
	params.InterpolationTime = InterpolationTime;
	params.bResetRotationRate = bResetRotationRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.FlushDeferredMoves
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)

void APawn::STATIC_FlushDeferredMoves()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.FlushDeferredMoves"));

	APawn_FlushDeferredMoves_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PickWallAdjust
// (Defined, PreOperator, HasOptionalParms)
// Parameters:
// struct FVector                 WallHitNormal                  (Parm)
// class AActor*                  HitActor                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APawn::PickWallAdjust(const struct FVector& WallHitNormal, class AActor* HitActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Pawn.PickWallAdjust"));

	APawn_PickWallAdjust_Params params;
	params.WallHitNormal = WallHitNormal;
	params.HitActor = HitActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.ZeroMovementVariables
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Operator, HasOptionalParms)

void AVehicle::ZeroMovementVariables()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.ZeroMovementVariables"));

	AVehicle_ZeroMovementVariables_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.NotifyDriverTakeHit
// (Defined, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// int                            Damage                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 Momentum                       (Parm)

void AVehicle::STATIC_NotifyDriverTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.NotifyDriverTakeHit"));

	AVehicle_NotifyDriverTakeHit_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.Momentum = Momentum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AVehicle::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.ReplicatedEvent"));

	AVehicle_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DrivingStatusChanged
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Static)

void AVehicle::STATIC_DrivingStatusChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DrivingStatusChanged"));

	AVehicle_DrivingStatusChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.SetDriving
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           B                              (Parm)

void AVehicle::SetDriving(bool B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.SetDriving"));

	AVehicle_SetDriving_Params params;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.GetEntryLocation
// (PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AVehicle::GetEntryLocation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetEntryLocation"));

	AVehicle_GetEntryLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.CrushedBy
// (Defined, Iterator, Singular, Exec, Static)
// Parameters:
// class APawn*                   OtherPawn                      (Parm)

void AVehicle::STATIC_CrushedBy(class APawn* OtherPawn)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.CrushedBy"));

	AVehicle_CrushedBy_Params params;
	params.OtherPawn = OtherPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.PancakeOther
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator, Static)
// Parameters:
// class APawn*                   Other                          (Parm)

void AVehicle::STATIC_PancakeOther(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PancakeOther"));

	AVehicle_PancakeOther_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.EncroachingOn
// (Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::EncroachingOn(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.EncroachingOn"));

	AVehicle_EncroachingOn_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.GetCollisionDamageInstigator
// (Final, Iterator, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AController*             ReturnValue                    (Parm, OutParm, ReturnParm)

class AController* AVehicle::STATIC_GetCollisionDamageInstigator()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetCollisionDamageInstigator"));

	AVehicle_GetCollisionDamageInstigator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.EncroachedBy
// (Final, Defined, Latent, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AVehicle::EncroachedBy(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.EncroachedBy"));

	AVehicle_EncroachedBy_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.FaceRotation
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Event, Static)
// Parameters:
// struct FRotator                NewRotation                    (Parm)
// float                          DeltaTime                      (Parm)

void AVehicle::STATIC_FaceRotation(const struct FRotator& NewRotation, float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.FaceRotation"));

	AVehicle_FaceRotation_Params params;
	params.NewRotation = NewRotation;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.GetDefaultCameraMode
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class APlayerController*       RequestedBy                    (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName AVehicle::STATIC_GetDefaultCameraMode(class APlayerController* RequestedBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetDefaultCameraMode"));

	AVehicle_GetDefaultCameraMode_Params params;
	params.RequestedBy = RequestedBy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.PlayDying
// (Final, Iterator, Latent, Net, HasOptionalParms)
// Parameters:
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLoc                         (Parm)

void AVehicle::PlayDying(class UClass* DamageType, const struct FVector& HitLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PlayDying"));

	AVehicle_PlayDying_Params params;
	params.DamageType = DamageType;
	params.HitLoc = HitLoc;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DriverDied
// (Final, Iterator, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class UClass*                  DamageType                     (Parm)

void AVehicle::STATIC_DriverDied(class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DriverDied"));

	AVehicle_DriverDied_Params params;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.Died
// (Final, Singular, Net, NetReliable, Native, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::STATIC_Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.Died"));

	AVehicle_Died_Params params;
	params.Killer = Killer;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.ThrowActiveWeapon
// (Defined, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bDestroyWeap                   (OptionalParm, Parm)

void AVehicle::ThrowActiveWeapon(bool bDestroyWeap)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.ThrowActiveWeapon"));

	AVehicle_ThrowActiveWeapon_Params params;
	params.bDestroyWeap = bDestroyWeap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.AdjustDriverDamage
// (Defined, Latent, Net, Operator)
// Parameters:
// int                            Damage                         (Parm, OutParm)
// class AController*             InstigatedBy                   (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm, OutParm)
// class UClass*                  DamageType                     (Parm)

void AVehicle::AdjustDriverDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, int* Damage, struct FVector* Momentum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.AdjustDriverDamage"));

	AVehicle_AdjustDriverDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Damage != nullptr)
		*Damage = params.Damage;
	if (Momentum != nullptr)
		*Momentum = params.Momentum;
}


// Function Engine.Vehicle.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AVehicle::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.TakeDamage"));

	AVehicle_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.SetKillInstigator
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// class UClass*                  DamageType                     (Parm)
// class AController*             ReturnValue                    (Parm, OutParm, ReturnParm)

class AController* AVehicle::SetKillInstigator(class AController* InstigatedBy, class UClass* DamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.SetKillInstigator"));

	AVehicle_SetKillInstigator_Params params;
	params.InstigatedBy = InstigatedBy;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.UnPossessed
// (Defined, Iterator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void AVehicle::UnPossessed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.UnPossessed"));

	AVehicle_UnPossessed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.TryExitPos
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   ExitingDriver                  (Parm)
// struct FVector                 ExitPos                        (Parm)
// bool                           bMustFindGround                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::TryExitPos(class APawn* ExitingDriver, const struct FVector& ExitPos, bool bMustFindGround)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.TryExitPos"));

	AVehicle_TryExitPos_Params params;
	params.ExitingDriver = ExitingDriver;
	params.ExitPos = ExitPos;
	params.bMustFindGround = bMustFindGround;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.FindAutoExit
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// class APawn*                   ExitingDriver                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::STATIC_FindAutoExit(class APawn* ExitingDriver)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.FindAutoExit"));

	AVehicle_FindAutoExit_Params params;
	params.ExitingDriver = ExitingDriver;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.PlaceExitingDriver
// (Final, Iterator, PreOperator, Singular, HasOptionalParms)
// Parameters:
// class APawn*                   ExitingDriver                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::PlaceExitingDriver(class APawn* ExitingDriver)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PlaceExitingDriver"));

	AVehicle_PlaceExitingDriver_Params params;
	params.ExitingDriver = ExitingDriver;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.DriverLeft
// (Latent, PreOperator, Singular, Net, Exec, Native, Static)

void AVehicle::STATIC_DriverLeft()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DriverLeft"));

	AVehicle_DriverLeft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.SetInputs
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InForward                      (Parm)
// float                          InStrafe                       (Parm)
// float                          InUp                           (Parm)

void AVehicle::SetInputs(float InForward, float InStrafe, float InUp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.SetInputs"));

	AVehicle_SetInputs_Params params;
	params.InForward = InForward;
	params.InStrafe = InStrafe;
	params.InUp = InUp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DriverLeave
// (Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bForceLeave                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::DriverLeave(bool bForceLeave)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DriverLeave"));

	AVehicle_DriverLeave_Params params;
	params.bForceLeave = bForceLeave;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.GetExitRotation
// (Defined, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AController*             C                              (Parm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator AVehicle::STATIC_GetExitRotation(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetExitRotation"));

	AVehicle_GetExitRotation_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.ContinueOnFoot
// (Final, Defined, Latent, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::ContinueOnFoot()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.ContinueOnFoot"));

	AVehicle_ContinueOnFoot_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.DetachDriver
// (Defined, Iterator, Net, NetReliable, Native, Static)
// Parameters:
// class APawn*                   P                              (Parm)

void AVehicle::STATIC_DetachDriver(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DetachDriver"));

	AVehicle_DetachDriver_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.AttachDriver
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class APawn*                   P                              (Parm)

void AVehicle::AttachDriver(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.AttachDriver"));

	AVehicle_AttachDriver_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.EntryAnnouncement
// (Final, Defined, Net, Event, Static)
// Parameters:
// class AController*             C                              (Parm)

void AVehicle::STATIC_EntryAnnouncement(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.EntryAnnouncement"));

	AVehicle_EntryAnnouncement_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.PossessedBy
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// class AController*             C                              (Parm)
// bool                           bVehicleTransition             (Parm)

void AVehicle::PossessedBy(class AController* C, bool bVehicleTransition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PossessedBy"));

	AVehicle_PossessedBy_Params params;
	params.C = C;
	params.bVehicleTransition = bVehicleTransition;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DriverEnter
// (Defined, Iterator, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::STATIC_DriverEnter(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DriverEnter"));

	AVehicle_DriverEnter_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.TryToDrive
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::TryToDrive(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.TryToDrive"));

	AVehicle_TryToDrive_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.AnySeatAvailable
// (Final, Defined, NetReliable, Simulated, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::AnySeatAvailable()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.AnySeatAvailable"));

	AVehicle_AnySeatAvailable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.CanEnterVehicle
// (Final, Defined, Net, Exec, Native, Event, Operator)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::CanEnterVehicle(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.CanEnterVehicle"));

	AVehicle_CanEnterVehicle_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.Destroyed_HandleDriver
// (Defined, Iterator, PreOperator, Singular, NetReliable, Native, Static)

void AVehicle::STATIC_Destroyed_HandleDriver()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.Destroyed_HandleDriver"));

	AVehicle_Destroyed_HandleDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AVehicle::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.Destroyed"));

	AVehicle_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.CheatFly
// (Latent, Net, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::CheatFly()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.CheatFly"));

	AVehicle_CheatFly_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.CheatGhost
// (Final, Defined, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::CheatGhost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.CheatGhost"));

	AVehicle_CheatGhost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.CheatWalk
// (Iterator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AVehicle::CheatWalk()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.CheatWalk"));

	AVehicle_CheatWalk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AVehicle::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PostBeginPlay"));

	AVehicle_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.SetBaseEyeheight
// (Defined, Singular, Net, Simulated, Exec, Native, HasOptionalParms)

void AVehicle::SetBaseEyeheight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.SetBaseEyeheight"));

	AVehicle_SetBaseEyeheight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.PlayerChangedTeam
// (Final, Singular, Net, HasOptionalParms)

void AVehicle::PlayerChangedTeam()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.PlayerChangedTeam"));

	AVehicle_PlayerChangedTeam_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DriverRadiusDamage
// (Defined, Latent, PreOperator, Singular, Net, Exec, Native, Static)
// Parameters:
// float                          DamageAmount                   (Parm)
// float                          DamageRadius                   (Parm)
// class AController*             EventInstigator                (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HitLocation                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AVehicle::STATIC_DriverRadiusDamage(float DamageAmount, float DamageRadius, class AController* EventInstigator, class UClass* DamageType, float Momentum, const struct FVector& HitLocation, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DriverRadiusDamage"));

	AVehicle_DriverRadiusDamage_Params params;
	params.DamageAmount = DamageAmount;
	params.DamageRadius = DamageRadius;
	params.EventInstigator = EventInstigator;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HitLocation = HitLocation;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void AVehicle::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.TakeRadiusDamage"));

	AVehicle_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.GetTargetLocation
// (Defined, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  RequestedBy                    (OptionalParm, Parm)
// bool                           bRequestAlternateLoc           (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector AVehicle::STATIC_GetTargetLocation(class AActor* RequestedBy, bool bRequestAlternateLoc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetTargetLocation"));

	AVehicle_GetTargetLocation_Params params;
	params.RequestedBy = RequestedBy;
	params.bRequestAlternateLoc = bRequestAlternateLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.GetMaxRiseForce
// (Final, Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AVehicle::STATIC_GetMaxRiseForce()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.GetMaxRiseForce"));

	AVehicle_GetMaxRiseForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Vehicle.Suicide
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void AVehicle::Suicide()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.Suicide"));

	AVehicle_Suicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Vehicle.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void AVehicle::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.DisplayDebug"));

	AVehicle_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Vehicle.NotifyTeamChanged
// (Defined, Singular, Net, Simulated, Exec, Event, Operator, Static)

void AVehicle::STATIC_NotifyTeamChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Vehicle.NotifyTeamChanged"));

	AVehicle_NotifyTeamChanged_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.GetSVehicleDebug
// (Iterator, Simulated, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FString>         DebugInfo                      (Parm, OutParm, NeedCtorLink)

void ASVehicle::STATIC_GetSVehicleDebug(TArray<struct FString>* DebugInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.GetSVehicleDebug"));

	ASVehicle_GetSVehicleDebug_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DebugInfo != nullptr)
		*DebugInfo = params.DebugInfo;
}


// Function Engine.SVehicle.HermiteEval
// (Final, Latent, Operator, Static)
// Parameters:
// float                          Slip                           (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ASVehicle::STATIC_HermiteEval(float Slip)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.HermiteEval"));

	ASVehicle_HermiteEval_Params params;
	params.Slip = Slip;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.DisplayWheelsDebug
// (Final, Latent, Singular, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          YL                             (Parm)

void ASVehicle::STATIC_DisplayWheelsDebug(class AHUD* HUD, float YL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.DisplayWheelsDebug"));

	ASVehicle_DisplayWheelsDebug_Params params;
	params.HUD = HUD;
	params.YL = YL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void ASVehicle::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.DisplayDebug"));

	ASVehicle_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.SVehicle.PostTeleport
// (Final, Iterator, Latent, PreOperator, Simulated, HasOptionalParms)
// Parameters:
// class ATeleporter*             OutTeleporter                  (Parm)

void ASVehicle::PostTeleport(class ATeleporter* OutTeleporter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.PostTeleport"));

	ASVehicle_PostTeleport_Params params;
	params.OutTeleporter = OutTeleporter;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.SuspensionHeavyShift
// (Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// float                          Delta                          (Parm)

void ASVehicle::SuspensionHeavyShift(float Delta)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.SuspensionHeavyShift"));

	ASVehicle_SuspensionHeavyShift_Params params;
	params.Delta = Delta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.RigidBodyCollision
// (Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     HitComponent                   (Parm, EditInline)
// class UPrimitiveComponent*     OtherComponent                 (Parm, EditInline)
// struct FCollisionImpactData    RigidCollisionData             (Const, Parm, OutParm, NeedCtorLink)
// int                            ContactIndex                   (Parm)

void ASVehicle::RigidBodyCollision(class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int ContactIndex, struct FCollisionImpactData* RigidCollisionData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.RigidBodyCollision"));

	ASVehicle_RigidBodyCollision_Params params;
	params.HitComponent = HitComponent;
	params.OtherComponent = OtherComponent;
	params.ContactIndex = ContactIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (RigidCollisionData != nullptr)
		*RigidCollisionData = params.RigidCollisionData;
}


// Function Engine.SVehicle.DrivingStatusChanged
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, Static)

void ASVehicle::STATIC_DrivingStatusChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.DrivingStatusChanged"));

	ASVehicle_DrivingStatusChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.VehiclePlayExitSound
// (Final, PreOperator, Operator, HasOptionalParms)

void ASVehicle::VehiclePlayExitSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.VehiclePlayExitSound"));

	ASVehicle_VehiclePlayExitSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.VehiclePlayEnterSound
// (PreOperator, Operator, HasOptionalParms)

void ASVehicle::VehiclePlayEnterSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.VehiclePlayEnterSound"));

	ASVehicle_VehiclePlayEnterSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.StopEngineSoundTimed
// (Iterator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void ASVehicle::StopEngineSoundTimed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.StopEngineSoundTimed"));

	ASVehicle_StopEngineSoundTimed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.StopEngineSound
// (Final, Defined, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void ASVehicle::StopEngineSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.StopEngineSound"));

	ASVehicle_StopEngineSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.StartEngineSoundTimed
// (Latent, Singular, Simulated, Exec, Event, HasOptionalParms)

void ASVehicle::StartEngineSoundTimed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.StartEngineSoundTimed"));

	ASVehicle_StartEngineSoundTimed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.StartEngineSound
// (Final, Defined, Iterator, Singular, Simulated, Exec, Event, HasOptionalParms)

void ASVehicle::StartEngineSound()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.StartEngineSound"));

	ASVehicle_StartEngineSound_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.HasWheelsOnGround
// (Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASVehicle::STATIC_HasWheelsOnGround()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.HasWheelsOnGround"));

	ASVehicle_HasWheelsOnGround_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.TryToDrive
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class APawn*                   P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASVehicle::TryToDrive(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.TryToDrive"));

	ASVehicle_TryToDrive_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.GetDefaultCameraMode
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class APlayerController*       RequestedBy                    (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName ASVehicle::STATIC_GetDefaultCameraMode(class APlayerController* RequestedBy)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.GetDefaultCameraMode"));

	ASVehicle_GetDefaultCameraMode_Params params;
	params.RequestedBy = RequestedBy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.CalcCamera
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// float                          fDeltaTime                     (Parm)
// struct FVector                 out_CamLoc                     (Parm, OutParm)
// struct FRotator                out_CamRot                     (Parm, OutParm)
// float                          out_FOV                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASVehicle::CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.CalcCamera"));

	ASVehicle_CalcCamera_Params params;
	params.fDeltaTime = fDeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_CamLoc != nullptr)
		*out_CamLoc = params.out_CamLoc;
	if (out_CamRot != nullptr)
		*out_CamRot = params.out_CamRot;
	if (out_FOV != nullptr)
		*out_FOV = params.out_FOV;

	return params.ReturnValue;
}


// Function Engine.SVehicle.Died
// (Final, Singular, Net, NetReliable, Native, Static)
// Parameters:
// class AController*             Killer                         (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FVector                 HitLocation                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASVehicle::STATIC_Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.Died"));

	ASVehicle_Died_Params params;
	params.Killer = Killer;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.AddVelocity
// (Final, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewVelocity                    (Parm)
// struct FVector                 HitLocation                    (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)

void ASVehicle::AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.AddVelocity"));

	ASVehicle_AddVelocity_Params params;
	params.NewVelocity = NewVelocity;
	params.HitLocation = HitLocation;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.InitVehicleRagdoll
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Operator, Static)
// Parameters:
// class USkeletalMesh*           RagdollMesh                    (Parm)
// class UPhysicsAsset*           RagdollPhysAsset               (Parm)
// struct FVector                 ActorMove                      (Parm)
// bool                           bClearAnimTree                 (Parm)

void ASVehicle::STATIC_InitVehicleRagdoll(class USkeletalMesh* RagdollMesh, class UPhysicsAsset* RagdollPhysAsset, const struct FVector& ActorMove, bool bClearAnimTree)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.InitVehicleRagdoll"));

	ASVehicle_InitVehicleRagdoll_Params params;
	params.RagdollMesh = RagdollMesh;
	params.RagdollPhysAsset = RagdollPhysAsset;
	params.ActorMove = ActorMove;
	params.bClearAnimTree = bClearAnimTree;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.TakeRadiusDamage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, Event, HasOptionalParms)
// Parameters:
// class AController*             InstigatedBy                   (Parm)
// float                          BaseDamage                     (Parm)
// float                          DamageRadius                   (Parm)
// class UClass*                  DamageType                     (Parm)
// float                          Momentum                       (Parm)
// struct FVector                 HurtOrigin                     (Parm)
// bool                           bFullDamage                    (Parm)
// class AActor*                  DamageCauser                   (Parm)
// float                          DamageFalloffExponent          (OptionalParm, Parm)

void ASVehicle::TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class AActor* DamageCauser, float DamageFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.TakeRadiusDamage"));

	ASVehicle_TakeRadiusDamage_Params params;
	params.InstigatedBy = InstigatedBy;
	params.BaseDamage = BaseDamage;
	params.DamageRadius = DamageRadius;
	params.DamageType = DamageType;
	params.Momentum = Momentum;
	params.HurtOrigin = HurtOrigin;
	params.bFullDamage = bFullDamage;
	params.DamageCauser = DamageCauser;
	params.DamageFalloffExponent = DamageFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.StopVehicleSounds
// (Final, PreOperator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void ASVehicle::StopVehicleSounds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.StopVehicleSounds"));

	ASVehicle_StopVehicleSounds_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.TurnOff
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, HasOptionalParms)

void ASVehicle::TurnOff()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.TurnOff"));

	ASVehicle_TurnOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ASVehicle::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.Destroyed"));

	ASVehicle_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.PostInitAnimTree
// (Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  SkelComp                       (Parm, EditInline)

void ASVehicle::PostInitAnimTree(class USkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.PostInitAnimTree"));

	ASVehicle_PostInitAnimTree_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ASVehicle::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.PostBeginPlay"));

	ASVehicle_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.SetWheelCollision
// (Defined, PreOperator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// int                            WheelNum                       (Parm)
// bool                           bCollision                     (Parm)

void ASVehicle::SetWheelCollision(int WheelNum, bool bCollision)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.SetWheelCollision"));

	ASVehicle_SetWheelCollision_Params params;
	params.WheelNum = WheelNum;
	params.bCollision = bCollision;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.IsSleeping
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASVehicle::STATIC_IsSleeping()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.IsSleeping"));

	ASVehicle_IsSleeping_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SVehicle.AddTorque
// (Final, Iterator, PreOperator, Singular, Operator)
// Parameters:
// struct FVector                 Torque                         (Parm)

void ASVehicle::AddTorque(const struct FVector& Torque)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.AddTorque"));

	ASVehicle_AddTorque_Params params;
	params.Torque = Torque;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.AddImpulse
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Impulse                        (Parm)

void ASVehicle::AddImpulse(const struct FVector& Impulse)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.AddImpulse"));

	ASVehicle_AddImpulse_Params params;
	params.Impulse = Impulse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SVehicle.AddForce
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FVector                 Force                          (Parm)

void ASVehicle::AddForce(const struct FVector& Force)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SVehicle.AddForce"));

	ASVehicle_AddForce_Params params;
	params.Force = Force;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.OnToggleConstraintDrive
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleConstraintDrive* Action                         (Parm)

void ARB_ConstraintActor::STATIC_OnToggleConstraintDrive(class USeqAct_ToggleConstraintDrive* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.OnToggleConstraintDrive"));

	ARB_ConstraintActor_OnToggleConstraintDrive_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ARB_ConstraintActor::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.OnToggle"));

	ARB_ConstraintActor_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.OnDestroy
// (Final, Defined, Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Destroy*         Action                         (Parm)

void ARB_ConstraintActor::STATIC_OnDestroy(class USeqAct_Destroy* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.OnDestroy"));

	ARB_ConstraintActor_OnDestroy_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.TermConstraint
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, HasOptionalParms)

void ARB_ConstraintActor::TermConstraint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.TermConstraint"));

	ARB_ConstraintActor_TermConstraint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.InitConstraint
// (Defined, PreOperator, Net, Simulated, Operator, Static)
// Parameters:
// class AActor*                  Actor1                         (Parm)
// class AActor*                  Actor2                         (Parm)
// struct FName                   Actor1Bone                     (OptionalParm, Parm)
// struct FName                   Actor2Bone                     (OptionalParm, Parm)
// float                          BreakThreshold                 (OptionalParm, Parm)

void ARB_ConstraintActor::STATIC_InitConstraint(class AActor* Actor1, class AActor* Actor2, const struct FName& Actor1Bone, const struct FName& Actor2Bone, float BreakThreshold)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.InitConstraint"));

	ARB_ConstraintActor_InitConstraint_Params params;
	params.Actor1 = Actor1;
	params.Actor2 = Actor2;
	params.Actor1Bone = Actor1Bone;
	params.Actor2Bone = Actor2Bone;
	params.BreakThreshold = BreakThreshold;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintActor.SetDisableCollision
// (PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           NewDisableCollision            (Parm)

void ARB_ConstraintActor::SetDisableCollision(bool NewDisableCollision)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintActor.SetDisableCollision"));

	ARB_ConstraintActor_SetDisableCollision_Params params;
	params.NewDisableCollision = NewDisableCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_LineImpulseActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ARB_LineImpulseActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_LineImpulseActor.ReplicatedEvent"));

	ARB_LineImpulseActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_LineImpulseActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ARB_LineImpulseActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_LineImpulseActor.OnToggle"));

	ARB_LineImpulseActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_LineImpulseActor.FireLineImpulse
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Event, Static)

void ARB_LineImpulseActor::STATIC_FireLineImpulse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_LineImpulseActor.FireLineImpulse"));

	ARB_LineImpulseActor_FireLineImpulse_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_RadialImpulseActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ARB_RadialImpulseActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_RadialImpulseActor.ReplicatedEvent"));

	ARB_RadialImpulseActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_RadialImpulseActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ARB_RadialImpulseActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_RadialImpulseActor.OnToggle"));

	ARB_RadialImpulseActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Thruster.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ARB_Thruster::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Thruster.OnToggle"));

	ARB_Thruster_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WorldAttractor.OnSetWorldAttractorParam
// (Final, Iterator, Latent, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_SetWorldAttractorParam* Action                         (Parm)

void AWorldAttractor::STATIC_OnSetWorldAttractorParam(class USeqAct_SetWorldAttractorParam* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WorldAttractor.OnSetWorldAttractorParam"));

	AWorldAttractor_OnSetWorldAttractorParam_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_RadialImpulseComponent.FireImpulse
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 Origin                         (Parm)

void URB_RadialImpulseComponent::STATIC_FireImpulse(const struct FVector& Origin)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_RadialImpulseComponent.FireImpulse"));

	URB_RadialImpulseComponent_FireImpulse_Params params;
	params.Origin = Origin;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Handle.GetOrientation
// (Iterator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FQuat URB_Handle::STATIC_GetOrientation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.GetOrientation"));

	URB_Handle_GetOrientation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_Handle.SetOrientation
// (Final, Defined, Iterator, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// struct FQuat                   NewOrientation                 (Const, Parm, OutParm)

void URB_Handle::SetOrientation(struct FQuat* NewOrientation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.SetOrientation"));

	URB_Handle_SetOrientation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewOrientation != nullptr)
		*NewOrientation = params.NewOrientation;
}


// Function Engine.RB_Handle.UpdateSmoothLocation
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Const, Parm, OutParm)

void URB_Handle::UpdateSmoothLocation(struct FVector* NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.UpdateSmoothLocation"));

	URB_Handle_UpdateSmoothLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewLocation != nullptr)
		*NewLocation = params.NewLocation;
}


// Function Engine.RB_Handle.SetSmoothLocation
// (Final, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Parm)
// float                          MoveTime                       (Parm)

void URB_Handle::SetSmoothLocation(const struct FVector& NewLocation, float MoveTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.SetSmoothLocation"));

	URB_Handle_SetSmoothLocation_Params params;
	params.NewLocation = NewLocation;
	params.MoveTime = MoveTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Handle.SetLocation
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewLocation                    (Parm)

void URB_Handle::SetLocation(const struct FVector& NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.SetLocation"));

	URB_Handle_SetLocation_Params params;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Handle.ReleaseComponent
// (Latent, Singular, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void URB_Handle::ReleaseComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.ReleaseComponent"));

	URB_Handle_ReleaseComponent_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Handle.GrabComponent
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class UPrimitiveComponent*     Component                      (Parm, EditInline)
// struct FName                   InBoneName                     (Parm)
// struct FVector                 GrabLocation                   (Parm)
// bool                           bConstrainRotation             (Parm)

void URB_Handle::STATIC_GrabComponent(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Handle.GrabComponent"));

	URB_Handle_GrabComponent_Params params;
	params.Component = Component;
	params.InBoneName = InBoneName;
	params.GrabLocation = GrabLocation;
	params.bConstrainRotation = bConstrainRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Spring.Clear
// (Final, Defined, Iterator, Latent, NetReliable, Native, Event, HasOptionalParms)

void URB_Spring::Clear()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Spring.Clear"));

	URB_Spring_Clear_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_Spring.SetComponents
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     InComponent1                   (Parm, EditInline)
// struct FName                   InBoneName1                    (Parm)
// struct FVector                 Position1                      (Parm)
// class UPrimitiveComponent*     InComponent2                   (Parm, EditInline)
// struct FName                   InBoneName2                    (Parm)
// struct FVector                 Position2                      (Parm)

void URB_Spring::SetComponents(class UPrimitiveComponent* InComponent1, const struct FName& InBoneName1, const struct FVector& Position1, class UPrimitiveComponent* InComponent2, const struct FName& InBoneName2, const struct FVector& Position2)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_Spring.SetComponents"));

	URB_Spring_SetComponents_Params params;
	params.InComponent1 = InComponent1;
	params.InBoneName1 = InBoneName1;
	params.Position1 = Position1;
	params.InComponent2 = InComponent2;
	params.InBoneName2 = InBoneName2;
	params.Position2 = Position2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicalMaterial.GetPhysicalMaterialProperty
// (Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UClass*                  DesiredClass                   (Parm)
// class UPhysicalMaterialPropertyBase* ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicalMaterialPropertyBase* UPhysicalMaterial::STATIC_GetPhysicalMaterialProperty(class UClass* DesiredClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicalMaterial.GetPhysicalMaterialProperty"));

	UPhysicalMaterial_GetPhysicalMaterialProperty_Params params;
	params.DesiredClass = DesiredClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicalMaterial.FindFractureSounds
// (Defined, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class USoundCue*               OutSoundExplosion              (Parm, OutParm)
// class USoundCue*               OutSoundSingle                 (Parm, OutParm)

void UPhysicalMaterial::STATIC_FindFractureSounds(class USoundCue** OutSoundExplosion, class USoundCue** OutSoundSingle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicalMaterial.FindFractureSounds"));

	UPhysicalMaterial_FindFractureSounds_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSoundExplosion != nullptr)
		*OutSoundExplosion = params.OutSoundExplosion;
	if (OutSoundSingle != nullptr)
		*OutSoundSingle = params.OutSoundSingle;
}


// Function Engine.PhysicalMaterial.FindPhysEffectInfo
// (Final, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// TEnumAsByte<EPhysEffectType>   Type                           (Parm)
// struct FPhysEffectInfo         ReturnValue                    (Parm, OutParm, ReturnParm)

struct FPhysEffectInfo UPhysicalMaterial::STATIC_FindPhysEffectInfo(TEnumAsByte<EPhysEffectType> Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicalMaterial.FindPhysEffectInfo"));

	UPhysicalMaterial_FindPhysEffectInfo_Params params;
	params.Type = Type;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsAsset.FindBodyIndex
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FName                   BodyName                       (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UPhysicsAsset::STATIC_FindBodyIndex(const struct FName& BodyName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAsset.FindBodyIndex"));

	UPhysicsAsset_FindBodyIndex_Params params;
	params.BodyName = BodyName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsAssetInstance.FindConstraintInstance
// (Final, Latent, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ConName                        (Parm)
// class UPhysicsAsset*           InAsset                        (Parm)
// class URB_ConstraintInstance*  ReturnValue                    (Parm, OutParm, ReturnParm)

class URB_ConstraintInstance* UPhysicsAssetInstance::STATIC_FindConstraintInstance(const struct FName& ConName, class UPhysicsAsset* InAsset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.FindConstraintInstance"));

	UPhysicsAssetInstance_FindConstraintInstance_Params params;
	params.ConName = ConName;
	params.InAsset = InAsset;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsAssetInstance.FindBodyInstance
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FName                   BodyName                       (Parm)
// class UPhysicsAsset*           InAsset                        (Parm)
// class URB_BodyInstance*        ReturnValue                    (Parm, OutParm, ReturnParm)

class URB_BodyInstance* UPhysicsAssetInstance::STATIC_FindBodyInstance(const struct FName& BodyName, class UPhysicsAsset* InAsset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.FindBodyInstance"));

	UPhysicsAssetInstance_FindBodyInstance_Params params;
	params.BodyName = BodyName;
	params.InAsset = InAsset;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsAssetInstance.SetFullAnimWeightBonesFixed
// (Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewFixed                      (Parm)
// class USkeletalMeshComponent*  SkelMesh                       (Parm, EditInline)

void UPhysicsAssetInstance::SetFullAnimWeightBonesFixed(bool bNewFixed, class USkeletalMeshComponent* SkelMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetFullAnimWeightBonesFixed"));

	UPhysicsAssetInstance_SetFullAnimWeightBonesFixed_Params params;
	params.bNewFixed = bNewFixed;
	params.SkelMesh = SkelMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetFullAnimWeightBlockRigidBody
// (Final, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewBlockRigidBody             (Parm)
// class USkeletalMeshComponent*  SkelMesh                       (Parm, EditInline)

void UPhysicsAssetInstance::SetFullAnimWeightBlockRigidBody(bool bNewBlockRigidBody, class USkeletalMeshComponent* SkelMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetFullAnimWeightBlockRigidBody"));

	UPhysicsAssetInstance_SetFullAnimWeightBlockRigidBody_Params params;
	params.bNewBlockRigidBody = bNewBlockRigidBody;
	params.SkelMesh = SkelMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetNamedBodiesBlockRigidBody
// (Defined, Iterator, Latent, Event, HasOptionalParms)
// Parameters:
// bool                           bNewBlockRigidBody             (Parm)
// TArray<struct FName>           BoneNames                      (Parm, NeedCtorLink)
// class USkeletalMeshComponent*  SkelMesh                       (Parm, EditInline)

void UPhysicsAssetInstance::SetNamedBodiesBlockRigidBody(bool bNewBlockRigidBody, TArray<struct FName> BoneNames, class USkeletalMeshComponent* SkelMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetNamedBodiesBlockRigidBody"));

	UPhysicsAssetInstance_SetNamedBodiesBlockRigidBody_Params params;
	params.bNewBlockRigidBody = bNewBlockRigidBody;
	params.BoneNames = BoneNames;
	params.SkelMesh = SkelMesh;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetNamedRBBoneSprings
// (Defined, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bEnable                        (Parm)
// TArray<struct FName>           BoneNames                      (Parm, NeedCtorLink)
// float                          InBoneLinearSpring             (Parm)
// float                          InBoneAngularSpring            (Parm)
// class USkeletalMeshComponent*  SkelMeshComp                   (Parm, EditInline)

void UPhysicsAssetInstance::SetNamedRBBoneSprings(bool bEnable, TArray<struct FName> BoneNames, float InBoneLinearSpring, float InBoneAngularSpring, class USkeletalMeshComponent* SkelMeshComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetNamedRBBoneSprings"));

	UPhysicsAssetInstance_SetNamedRBBoneSprings_Params params;
	params.bEnable = bEnable;
	params.BoneNames = BoneNames;
	params.InBoneLinearSpring = InBoneLinearSpring;
	params.InBoneAngularSpring = InBoneAngularSpring;
	params.SkelMeshComp = SkelMeshComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetNamedMotorsAngularVelocityDrive
// (Final, PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)
// TArray<struct FName>           BoneNames                      (Parm, NeedCtorLink)
// class USkeletalMeshComponent*  SkelMeshComp                   (Parm, EditInline)
// bool                           bSetOtherBodiesToComplement    (OptionalParm, Parm)

void UPhysicsAssetInstance::SetNamedMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, TArray<struct FName> BoneNames, class USkeletalMeshComponent* SkelMeshComp, bool bSetOtherBodiesToComplement)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetNamedMotorsAngularVelocityDrive"));

	UPhysicsAssetInstance_SetNamedMotorsAngularVelocityDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.BoneNames = BoneNames;
	params.SkelMeshComp = SkelMeshComp;
	params.bSetOtherBodiesToComplement = bSetOtherBodiesToComplement;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetNamedMotorsAngularPositionDrive
// (PreOperator, Event, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)
// TArray<struct FName>           BoneNames                      (Parm, NeedCtorLink)
// class USkeletalMeshComponent*  SkelMeshComp                   (Parm, EditInline)
// bool                           bSetOtherBodiesToComplement    (OptionalParm, Parm)

void UPhysicsAssetInstance::SetNamedMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, TArray<struct FName> BoneNames, class USkeletalMeshComponent* SkelMeshComp, bool bSetOtherBodiesToComplement)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetNamedMotorsAngularPositionDrive"));

	UPhysicsAssetInstance_SetNamedMotorsAngularPositionDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.BoneNames = BoneNames;
	params.SkelMeshComp = SkelMeshComp;
	params.bSetOtherBodiesToComplement = bSetOtherBodiesToComplement;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetAllMotorsAngularDriveParams
// (Final, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InSpring                       (Parm)
// float                          InDamping                      (Parm)
// float                          InForceLimit                   (Parm)
// class USkeletalMeshComponent*  SkelMesh                       (OptionalParm, Parm, EditInline)
// bool                           bSkipFullAnimWeightBodies      (OptionalParm, Parm)

void UPhysicsAssetInstance::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, class USkeletalMeshComponent* SkelMesh, bool bSkipFullAnimWeightBodies)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetAllMotorsAngularDriveParams"));

	UPhysicsAssetInstance_SetAllMotorsAngularDriveParams_Params params;
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;
	params.SkelMesh = SkelMesh;
	params.bSkipFullAnimWeightBodies = bSkipFullAnimWeightBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetAllMotorsAngularVelocityDrive
// (Final, Defined, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)
// class USkeletalMeshComponent*  SkelMeshComp                   (Parm, EditInline)
// bool                           bSkipFullAnimWeightBodies      (OptionalParm, Parm)

void UPhysicsAssetInstance::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, class USkeletalMeshComponent* SkelMeshComp, bool bSkipFullAnimWeightBodies)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetAllMotorsAngularVelocityDrive"));

	UPhysicsAssetInstance_SetAllMotorsAngularVelocityDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.SkelMeshComp = SkelMeshComp;
	params.bSkipFullAnimWeightBodies = bSkipFullAnimWeightBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetAllMotorsAngularPositionDrive
// (Defined, Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)
// class USkeletalMeshComponent*  SkelMesh                       (OptionalParm, Parm, EditInline)
// bool                           bSkipFullAnimWeightBodies      (OptionalParm, Parm)

void UPhysicsAssetInstance::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, class USkeletalMeshComponent* SkelMesh, bool bSkipFullAnimWeightBodies)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetAllMotorsAngularPositionDrive"));

	UPhysicsAssetInstance_SetAllMotorsAngularPositionDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.SkelMesh = SkelMesh;
	params.bSkipFullAnimWeightBodies = bSkipFullAnimWeightBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.ForceAllBodiesBelowUnfixed
// (Singular, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// struct FName                   InBoneName                     (Const, Parm, OutParm)
// class UPhysicsAsset*           InAsset                        (Parm)
// class USkeletalMeshComponent*  InSkelMesh                     (Parm, EditInline)
// bool                           InbInstanceAlwaysFullAnimWeight (Parm)

void UPhysicsAssetInstance::STATIC_ForceAllBodiesBelowUnfixed(class UPhysicsAsset* InAsset, class USkeletalMeshComponent* InSkelMesh, bool InbInstanceAlwaysFullAnimWeight, struct FName* InBoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.ForceAllBodiesBelowUnfixed"));

	UPhysicsAssetInstance_ForceAllBodiesBelowUnfixed_Params params;
	params.InAsset = InAsset;
	params.InSkelMesh = InSkelMesh;
	params.InbInstanceAlwaysFullAnimWeight = InbInstanceAlwaysFullAnimWeight;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InBoneName != nullptr)
		*InBoneName = params.InBoneName;
}


// Function Engine.PhysicsAssetInstance.SetNamedBodiesFixed
// (Final, Defined, Iterator, Latent, Event, HasOptionalParms)
// Parameters:
// bool                           bNewFixed                      (Parm)
// TArray<struct FName>           BoneNames                      (Parm, NeedCtorLink)
// class USkeletalMeshComponent*  SkelMesh                       (Parm, EditInline)
// bool                           bSetOtherBodiesToComplement    (OptionalParm, Parm)
// bool                           bSkipFullAnimWeightBodies      (OptionalParm, Parm)

void UPhysicsAssetInstance::SetNamedBodiesFixed(bool bNewFixed, TArray<struct FName> BoneNames, class USkeletalMeshComponent* SkelMesh, bool bSetOtherBodiesToComplement, bool bSkipFullAnimWeightBodies)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetNamedBodiesFixed"));

	UPhysicsAssetInstance_SetNamedBodiesFixed_Params params;
	params.bNewFixed = bNewFixed;
	params.BoneNames = BoneNames;
	params.SkelMesh = SkelMesh;
	params.bSetOtherBodiesToComplement = bSetOtherBodiesToComplement;
	params.bSkipFullAnimWeightBodies = bSkipFullAnimWeightBodies;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetAllBodiesFixed
// (Latent, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewFixed                      (Parm)

void UPhysicsAssetInstance::SetAllBodiesFixed(bool bNewFixed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetAllBodiesFixed"));

	UPhysicsAssetInstance_SetAllBodiesFixed_Params params;
	params.bNewFixed = bNewFixed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.GetTotalMassBelowBone
// (Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InBoneName                     (Parm)
// class UPhysicsAsset*           InAsset                        (Parm)
// class USkeletalMesh*           InSkelMesh                     (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UPhysicsAssetInstance::STATIC_GetTotalMassBelowBone(const struct FName& InBoneName, class UPhysicsAsset* InAsset, class USkeletalMesh* InSkelMesh)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.GetTotalMassBelowBone"));

	UPhysicsAssetInstance_GetTotalMassBelowBone_Params params;
	params.InBoneName = InBoneName;
	params.InAsset = InAsset;
	params.InSkelMesh = InSkelMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsAssetInstance.SetAngularDriveScale
// (Iterator, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InAngularSpringScale           (Parm)
// float                          InAngularDampingScale          (Parm)
// float                          InAngularForceLimitScale       (Parm)

void UPhysicsAssetInstance::SetAngularDriveScale(float InAngularSpringScale, float InAngularDampingScale, float InAngularForceLimitScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetAngularDriveScale"));

	UPhysicsAssetInstance_SetAngularDriveScale_Params params;
	params.InAngularSpringScale = InAngularSpringScale;
	params.InAngularDampingScale = InAngularDampingScale;
	params.InAngularForceLimitScale = InAngularForceLimitScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsAssetInstance.SetLinearDriveScale
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InLinearSpringScale            (Parm)
// float                          InLinearDampingScale           (Parm)
// float                          InLinearForceLimitScale        (Parm)

void UPhysicsAssetInstance::SetLinearDriveScale(float InLinearSpringScale, float InLinearDampingScale, float InLinearForceLimitScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PhysicsAssetInstance.SetLinearDriveScale"));

	UPhysicsAssetInstance_SetLinearDriveScale_Params params;
	params.InLinearSpringScale = InLinearSpringScale;
	params.InLinearDampingScale = InLinearDampingScale;
	params.InLinearForceLimitScale = InLinearForceLimitScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.UpdateDampingProperties
// (PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void URB_BodyInstance::UpdateDampingProperties()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.UpdateDampingProperties"));

	URB_BodyInstance_UpdateDampingProperties_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.UpdateMassProperties
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class URB_BodySetup*           Setup                          (Parm)

void URB_BodyInstance::UpdateMassProperties(class URB_BodySetup* Setup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.UpdateMassProperties"));

	URB_BodyInstance_UpdateMassProperties_Params params;
	params.Setup = Setup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.SetContactReportForceThreshold
// (Final, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          Threshold                      (Parm)

void URB_BodyInstance::SetContactReportForceThreshold(float Threshold)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetContactReportForceThreshold"));

	URB_BodyInstance_SetContactReportForceThreshold_Params params;
	params.Threshold = Threshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.EnableCollisionResponse
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// bool                           bEnableResponse                (Parm)

void URB_BodyInstance::STATIC_EnableCollisionResponse(bool bEnableResponse)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.EnableCollisionResponse"));

	URB_BodyInstance_EnableCollisionResponse_Params params;
	params.bEnableResponse = bEnableResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.SetPhysMaterialOverride
// (Iterator, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class UPhysicalMaterial*       NewPhysMaterial                (Parm)

void URB_BodyInstance::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetPhysMaterialOverride"));

	URB_BodyInstance_SetPhysMaterialOverride_Params params;
	params.NewPhysMaterial = NewPhysMaterial;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.SetBlockRigidBody
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewBlockRigidBody             (Parm)

void URB_BodyInstance::SetBlockRigidBody(bool bNewBlockRigidBody)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetBlockRigidBody"));

	URB_BodyInstance_SetBlockRigidBody_Params params;
	params.bNewBlockRigidBody = bNewBlockRigidBody;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.SetBoneSpringTarget
// (Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FMatrix                 InBoneTarget                   (Const, Parm, OutParm)
// bool                           bTeleport                      (Parm)

void URB_BodyInstance::SetBoneSpringTarget(bool bTeleport, struct FMatrix* InBoneTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetBoneSpringTarget"));

	URB_BodyInstance_SetBoneSpringTarget_Params params;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InBoneTarget != nullptr)
		*InBoneTarget = params.InBoneTarget;
}


// Function Engine.RB_BodyInstance.SetBoneSpringParams
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InLinearSpring                 (Parm)
// float                          InLinearDamping                (Parm)
// float                          InAngularSpring                (Parm)
// float                          InAngularDamping               (Parm)

void URB_BodyInstance::SetBoneSpringParams(float InLinearSpring, float InLinearDamping, float InAngularSpring, float InAngularDamping)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetBoneSpringParams"));

	URB_BodyInstance_SetBoneSpringParams_Params params;
	params.InLinearSpring = InLinearSpring;
	params.InLinearDamping = InLinearDamping;
	params.InAngularSpring = InAngularSpring;
	params.InAngularDamping = InAngularDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.EnableBoneSpring
// (Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// bool                           bInEnableLinear                (Parm)
// bool                           bInEnableAngular               (Parm)
// struct FMatrix                 InBoneTarget                   (Const, Parm, OutParm)

void URB_BodyInstance::STATIC_EnableBoneSpring(bool bInEnableLinear, bool bInEnableAngular, struct FMatrix* InBoneTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.EnableBoneSpring"));

	URB_BodyInstance_EnableBoneSpring_Params params;
	params.bInEnableLinear = bInEnableLinear;
	params.bInEnableAngular = bInEnableAngular;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InBoneTarget != nullptr)
		*InBoneTarget = params.InBoneTarget;
}


// Function Engine.RB_BodyInstance.GetUnrealWorldVelocityAtPoint
// (Final, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 Point                          (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector URB_BodyInstance::STATIC_GetUnrealWorldVelocityAtPoint(const struct FVector& Point)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetUnrealWorldVelocityAtPoint"));

	URB_BodyInstance_GetUnrealWorldVelocityAtPoint_Params params;
	params.Point = Point;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.GetUnrealWorldAngularVelocity
// (Defined, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector URB_BodyInstance::STATIC_GetUnrealWorldAngularVelocity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetUnrealWorldAngularVelocity"));

	URB_BodyInstance_GetUnrealWorldAngularVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.GetUnrealWorldVelocity
// (Iterator, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector URB_BodyInstance::STATIC_GetUnrealWorldVelocity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetUnrealWorldVelocity"));

	URB_BodyInstance_GetUnrealWorldVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.GetUnrealWorldTM
// (Final, Defined, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FMatrix URB_BodyInstance::STATIC_GetUnrealWorldTM()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetUnrealWorldTM"));

	URB_BodyInstance_GetUnrealWorldTM_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.GetPhysicsAssetInstance
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UPhysicsAssetInstance*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicsAssetInstance* URB_BodyInstance::STATIC_GetPhysicsAssetInstance()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetPhysicsAssetInstance"));

	URB_BodyInstance_GetPhysicsAssetInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.IsValidBodyInstance
// (Defined, Iterator, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool URB_BodyInstance::STATIC_IsValidBodyInstance()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.IsValidBodyInstance"));

	URB_BodyInstance_IsValidBodyInstance_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.IsFixed
// (PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool URB_BodyInstance::STATIC_IsFixed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.IsFixed"));

	URB_BodyInstance_IsFixed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_BodyInstance.SetFixed
// (Final, Defined, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewFixed                      (Parm)

void URB_BodyInstance::SetFixed(bool bNewFixed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.SetFixed"));

	URB_BodyInstance_SetFixed_Params params;
	params.bNewFixed = bNewFixed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_BodyInstance.GetBodyMass
// (Final, Defined, Iterator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float URB_BodyInstance::STATIC_GetBodyMass()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_BodyInstance.GetBodyMass"));

	URB_BodyInstance_GetBodyMass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_ConstraintInstance.MoveKinActorTransform
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Event, Operator, Static)
// Parameters:
// struct FMatrix                 NewTM                          (Parm, OutParm)

void URB_ConstraintInstance::STATIC_MoveKinActorTransform(struct FMatrix* NewTM)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.MoveKinActorTransform"));

	URB_ConstraintInstance_MoveKinActorTransform_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewTM != nullptr)
		*NewTM = params.NewTM;
}


// Function Engine.RB_ConstraintInstance.SetLinearLimitSize
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewLimitSize                   (Parm)

void URB_ConstraintInstance::SetLinearLimitSize(float NewLimitSize)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearLimitSize"));

	URB_ConstraintInstance_SetLinearLimitSize_Params params;
	params.NewLimitSize = NewLimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularDOFLimitScale
// (Defined, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InSwing1LimitScale             (Parm)
// float                          InSwing2LimitScale             (Parm)
// float                          InTwistLimitScale              (Parm)
// class URB_ConstraintSetup*     InSetup                        (Parm)

void URB_ConstraintInstance::SetAngularDOFLimitScale(float InSwing1LimitScale, float InSwing2LimitScale, float InTwistLimitScale, class URB_ConstraintSetup* InSetup)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularDOFLimitScale"));

	URB_ConstraintInstance_SetAngularDOFLimitScale_Params params;
	params.InSwing1LimitScale = InSwing1LimitScale;
	params.InSwing2LimitScale = InSwing2LimitScale;
	params.InTwistLimitScale = InTwistLimitScale;
	params.InSetup = InSetup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularDriveParams
// (Final, Defined, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InSpring                       (Parm)
// float                          InDamping                      (Parm)
// float                          InForceLimit                   (Parm)

void URB_ConstraintInstance::SetAngularDriveParams(float InSpring, float InDamping, float InForceLimit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularDriveParams"));

	URB_ConstraintInstance_SetAngularDriveParams_Params params;
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularVelocityTarget
// (Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InVelTarget                    (Parm)

void URB_ConstraintInstance::SetAngularVelocityTarget(const struct FVector& InVelTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularVelocityTarget"));

	URB_ConstraintInstance_SetAngularVelocityTarget_Params params;
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularPositionTarget
// (Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FQuat                   InPosTarget                    (Const, Parm, OutParm)

void URB_ConstraintInstance::SetAngularPositionTarget(struct FQuat* InPosTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularPositionTarget"));

	URB_ConstraintInstance_SetAngularPositionTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InPosTarget != nullptr)
		*InPosTarget = params.InPosTarget;
}


// Function Engine.RB_ConstraintInstance.SetLinearDriveParams
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          InSpring                       (Parm)
// float                          InDamping                      (Parm)
// float                          InForceLimit                   (Parm)

void URB_ConstraintInstance::SetLinearDriveParams(float InSpring, float InDamping, float InForceLimit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearDriveParams"));

	URB_ConstraintInstance_SetLinearDriveParams_Params params;
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetLinearVelocityTarget
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InVelTarget                    (Parm)

void URB_ConstraintInstance::SetLinearVelocityTarget(const struct FVector& InVelTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearVelocityTarget"));

	URB_ConstraintInstance_SetLinearVelocityTarget_Params params;
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetLinearPositionTarget
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InPosTarget                    (Parm)

void URB_ConstraintInstance::SetLinearPositionTarget(const struct FVector& InPosTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearPositionTarget"));

	URB_ConstraintInstance_SetLinearPositionTarget_Params params;
	params.InPosTarget = InPosTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularVelocityDrive
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)

void URB_ConstraintInstance::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularVelocityDrive"));

	URB_ConstraintInstance_SetAngularVelocityDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetAngularPositionDrive
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableSwingDrive              (Parm)
// bool                           bEnableTwistDrive              (Parm)

void URB_ConstraintInstance::SetAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetAngularPositionDrive"));

	URB_ConstraintInstance_SetAngularPositionDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetLinearVelocityDrive
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableXDrive                  (Parm)
// bool                           bEnableYDrive                  (Parm)
// bool                           bEnableZDrive                  (Parm)

void URB_ConstraintInstance::SetLinearVelocityDrive(bool bEnableXDrive, bool bEnableYDrive, bool bEnableZDrive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearVelocityDrive"));

	URB_ConstraintInstance_SetLinearVelocityDrive_Params params;
	params.bEnableXDrive = bEnableXDrive;
	params.bEnableYDrive = bEnableYDrive;
	params.bEnableZDrive = bEnableZDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.SetLinearPositionDrive
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bEnableXDrive                  (Parm)
// bool                           bEnableYDrive                  (Parm)
// bool                           bEnableZDrive                  (Parm)

void URB_ConstraintInstance::SetLinearPositionDrive(bool bEnableXDrive, bool bEnableYDrive, bool bEnableZDrive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.SetLinearPositionDrive"));

	URB_ConstraintInstance_SetLinearPositionDrive_Params params;
	params.bEnableXDrive = bEnableXDrive;
	params.bEnableYDrive = bEnableYDrive;
	params.bEnableZDrive = bEnableZDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.GetConstraintLocation
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector URB_ConstraintInstance::STATIC_GetConstraintLocation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.GetConstraintLocation"));

	URB_ConstraintInstance_GetConstraintLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_ConstraintInstance.GetPhysicsAssetInstance
// (Final, Latent, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class UPhysicsAssetInstance*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UPhysicsAssetInstance* URB_ConstraintInstance::STATIC_GetPhysicsAssetInstance()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.GetPhysicsAssetInstance"));

	URB_ConstraintInstance_GetPhysicsAssetInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RB_ConstraintInstance.TermConstraint
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, HasOptionalParms)

void URB_ConstraintInstance::TermConstraint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.TermConstraint"));

	URB_ConstraintInstance_TermConstraint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_ConstraintInstance.InitConstraint
// (Defined, PreOperator, Net, Simulated, Operator, Static)
// Parameters:
// class UPrimitiveComponent*     PrimComp1                      (Parm, EditInline)
// class UPrimitiveComponent*     PrimComp2                      (Parm, EditInline)
// class URB_ConstraintSetup*     Setup                          (Parm)
// float                          Scale                          (Parm)
// class AActor*                  InOwner                        (Parm)
// class UPrimitiveComponent*     InPrimComp                     (Parm, EditInline)
// bool                           bMakeKinForBody1               (Parm)

void URB_ConstraintInstance::STATIC_InitConstraint(class UPrimitiveComponent* PrimComp1, class UPrimitiveComponent* PrimComp2, class URB_ConstraintSetup* Setup, float Scale, class AActor* InOwner, class UPrimitiveComponent* InPrimComp, bool bMakeKinForBody1)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_ConstraintInstance.InitConstraint"));

	URB_ConstraintInstance_InitConstraint_Params params;
	params.PrimComp1 = PrimComp1;
	params.PrimComp2 = PrimComp2;
	params.Setup = Setup;
	params.Scale = Scale;
	params.InOwner = InOwner;
	params.InPrimComp = InPrimComp;
	params.bMakeKinForBody1 = bMakeKinForBody1;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxGenericForceFieldBrush.StopsProjectile
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AProjectile*             P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ANxGenericForceFieldBrush::StopsProjectile(class AProjectile* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxGenericForceFieldBrush.StopsProjectile"));

	ANxGenericForceFieldBrush_StopsProjectile_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NxGenericForceFieldBrush.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ANxGenericForceFieldBrush::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxGenericForceFieldBrush.PostBeginPlay"));

	ANxGenericForceFieldBrush_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceField.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ANxForceField::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceField.OnToggle"));

	ANxForceField_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceField.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxForceField::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceField.DoInitRBPhys"));

	ANxForceField_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxCylindricalForceFieldCapsule.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxCylindricalForceFieldCapsule::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxCylindricalForceFieldCapsule.DoInitRBPhys"));

	ANxCylindricalForceFieldCapsule_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceFieldGeneric.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxForceFieldGeneric::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceFieldGeneric.DoInitRBPhys"));

	ANxForceFieldGeneric_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceFieldRadial.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxForceFieldRadial::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceFieldRadial.DoInitRBPhys"));

	ANxForceFieldRadial_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceFieldTornado.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxForceFieldTornado::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceFieldTornado.DoInitRBPhys"));

	ANxForceFieldTornado_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxGenericForceFieldBox.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void ANxGenericForceFieldBox::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxGenericForceFieldBox.DoInitRBPhys"));

	ANxGenericForceFieldBox_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceFieldSpawnable.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ANxForceFieldSpawnable::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceFieldSpawnable.OnToggle"));

	ANxForceFieldSpawnable_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_CylindricalForceActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ARB_CylindricalForceActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_CylindricalForceActor.OnToggle"));

	ARB_CylindricalForceActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RB_RadialForceActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ARB_RadialForceActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.RB_RadialForceActor.OnToggle"));

	ARB_RadialForceActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NxForceFieldComponent.DoInitRBPhys
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Static)

void UNxForceFieldComponent::STATIC_DoInitRBPhys()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.NxForceFieldComponent.DoInitRBPhys"));

	UNxForceFieldComponent_DoInitRBPhys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShape.GetDrawComponent
// (Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UPrimitiveComponent* UForceFieldShape::GetDrawComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShape.GetDrawComponent"));

	UForceFieldShape_GetDrawComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShape.FillByCylinder
// (Final, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          BottomRadius                   (Parm)
// float                          TopRadius                      (Parm)
// float                          Height                         (Parm)
// float                          HeightOffset                   (Parm)

void UForceFieldShape::FillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShape.FillByCylinder"));

	UForceFieldShape_FillByCylinder_Params params;
	params.BottomRadius = BottomRadius;
	params.TopRadius = TopRadius;
	params.Height = Height;
	params.HeightOffset = HeightOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShape.FillByCapsule
// (Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Height                         (Parm)
// float                          Radius                         (Parm)

void UForceFieldShape::FillByCapsule(float Height, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShape.FillByCapsule"));

	UForceFieldShape_FillByCapsule_Params params;
	params.Height = Height;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShape.FillByBox
// (Final, Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Dimension                      (Parm)

void UForceFieldShape::FillByBox(const struct FVector& Dimension)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShape.FillByBox"));

	UForceFieldShape_FillByBox_Params params;
	params.Dimension = Dimension;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShape.FillBySphere
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Radius                         (Parm)

void UForceFieldShape::FillBySphere(float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShape.FillBySphere"));

	UForceFieldShape_FillBySphere_Params params;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeBox.GetDrawComponent
// (Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UPrimitiveComponent* UForceFieldShapeBox::GetDrawComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.GetDrawComponent"));

	UForceFieldShapeBox_GetDrawComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeBox.FillByCylinder
// (Final, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          BottomRadius                   (Parm)
// float                          TopRadius                      (Parm)
// float                          Height                         (Parm)
// float                          HeightOffset                   (Parm)

void UForceFieldShapeBox::FillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.FillByCylinder"));

	UForceFieldShapeBox_FillByCylinder_Params params;
	params.BottomRadius = BottomRadius;
	params.TopRadius = TopRadius;
	params.Height = Height;
	params.HeightOffset = HeightOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeBox.FillByCapsule
// (Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Height                         (Parm)
// float                          Radius                         (Parm)

void UForceFieldShapeBox::FillByCapsule(float Height, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.FillByCapsule"));

	UForceFieldShapeBox_FillByCapsule_Params params;
	params.Height = Height;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeBox.FillByBox
// (Final, Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Extent                         (Parm)

void UForceFieldShapeBox::FillByBox(const struct FVector& Extent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.FillByBox"));

	UForceFieldShapeBox_FillByBox_Params params;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeBox.FillBySphere
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Radius                         (Parm)

void UForceFieldShapeBox::FillBySphere(float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.FillBySphere"));

	UForceFieldShapeBox_FillBySphere_Params params;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeBox.GetRadii
// (Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UForceFieldShapeBox::GetRadii()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeBox.GetRadii"));

	UForceFieldShapeBox_GetRadii_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeCapsule.GetDrawComponent
// (Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UPrimitiveComponent* UForceFieldShapeCapsule::GetDrawComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.GetDrawComponent"));

	UForceFieldShapeCapsule_GetDrawComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeCapsule.FillByCylinder
// (Final, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          BottomRadius                   (Parm)
// float                          TopRadius                      (Parm)
// float                          Height                         (Parm)
// float                          HeightOffset                   (Parm)

void UForceFieldShapeCapsule::FillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.FillByCylinder"));

	UForceFieldShapeCapsule_FillByCylinder_Params params;
	params.BottomRadius = BottomRadius;
	params.TopRadius = TopRadius;
	params.Height = Height;
	params.HeightOffset = HeightOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeCapsule.FillByCapsule
// (Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Height                         (Parm)
// float                          Radius                         (Parm)

void UForceFieldShapeCapsule::FillByCapsule(float Height, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.FillByCapsule"));

	UForceFieldShapeCapsule_FillByCapsule_Params params;
	params.Height = Height;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeCapsule.FillByBox
// (Final, Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Extent                         (Parm)

void UForceFieldShapeCapsule::FillByBox(const struct FVector& Extent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.FillByBox"));

	UForceFieldShapeCapsule_FillByBox_Params params;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeCapsule.FillBySphere
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Radius                         (Parm)

void UForceFieldShapeCapsule::FillBySphere(float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.FillBySphere"));

	UForceFieldShapeCapsule_FillBySphere_Params params;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeCapsule.GetRadius
// (Final, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UForceFieldShapeCapsule::GetRadius()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.GetRadius"));

	UForceFieldShapeCapsule_GetRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeCapsule.GetHeight
// (Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UForceFieldShapeCapsule::GetHeight()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeCapsule.GetHeight"));

	UForceFieldShapeCapsule_GetHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeSphere.GetDrawComponent
// (Defined, Iterator, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UPrimitiveComponent*     ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UPrimitiveComponent* UForceFieldShapeSphere::GetDrawComponent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.GetDrawComponent"));

	UForceFieldShapeSphere_GetDrawComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ForceFieldShapeSphere.FillByCylinder
// (Final, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          BottomRadius                   (Parm)
// float                          TopRadius                      (Parm)
// float                          Height                         (Parm)
// float                          HeightOffset                   (Parm)

void UForceFieldShapeSphere::FillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.FillByCylinder"));

	UForceFieldShapeSphere_FillByCylinder_Params params;
	params.BottomRadius = BottomRadius;
	params.TopRadius = TopRadius;
	params.Height = Height;
	params.HeightOffset = HeightOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeSphere.FillByCapsule
// (Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Height                         (Parm)
// float                          Radius                         (Parm)

void UForceFieldShapeSphere::FillByCapsule(float Height, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.FillByCapsule"));

	UForceFieldShapeSphere_FillByCapsule_Params params;
	params.Height = Height;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeSphere.FillByBox
// (Final, Defined, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FVector                 Extent                         (Parm)

void UForceFieldShapeSphere::FillByBox(const struct FVector& Extent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.FillByBox"));

	UForceFieldShapeSphere_FillByBox_Params params;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeSphere.FillBySphere
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          Radius                         (Parm)

void UForceFieldShapeSphere::FillBySphere(float Radius)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.FillBySphere"));

	UForceFieldShapeSphere_FillBySphere_Params params;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFieldShapeSphere.GetRadius
// (Final, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UForceFieldShapeSphere::GetRadius()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ForceFieldShapeSphere.GetRadius"));

	UForceFieldShapeSphere_GetRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USequenceObject::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.GetObjClassVersion"));

	USequenceObject_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.ShouldClearNameOnPasting
// (Final, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceObject::ShouldClearNameOnPasting()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.ShouldClearNameOnPasting"));

	USequenceObject_ShouldClearNameOnPasting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.IsPastingIntoLevelSequenceAllowed
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceObject::IsPastingIntoLevelSequenceAllowed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.IsPastingIntoLevelSequenceAllowed"));

	USequenceObject_IsPastingIntoLevelSequenceAllowed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.IsValidLevelSequenceObject
// (PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceObject::IsValidLevelSequenceObject()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.IsValidLevelSequenceObject"));

	USequenceObject_IsValidLevelSequenceObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.GetWorldInfo
// (Defined, Iterator, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AWorldInfo*              ReturnValue                    (Parm, OutParm, ReturnParm)

class AWorldInfo* USequenceObject::STATIC_GetWorldInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.GetWorldInfo"));

	USequenceObject_GetWorldInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceObject.ScriptLog
// (Defined, Simulated, Exec)
// Parameters:
// struct FString                 LogText                        (Parm, NeedCtorLink)
// bool                           bWarning                       (OptionalParm, Parm)

void USequenceObject::ScriptLog(const struct FString& LogText, bool bWarning)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceObject.ScriptLog"));

	USequenceObject_ScriptLog_Params params;
	params.LogText = LogText;
	params.bWarning = bWarning;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.ForceActivateOutput
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// int                            OutputIdx                      (Parm)

void USequenceOp::STATIC_ForceActivateOutput(int OutputIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.ForceActivateOutput"));

	USequenceOp_ForceActivateOutput_Params params;
	params.OutputIdx = OutputIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.ForceActivateInput
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Event, Static)
// Parameters:
// int                            InputIdx                       (Parm)

void USequenceOp::STATIC_ForceActivateInput(int InputIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.ForceActivateInput"));

	USequenceOp_ForceActivateInput_Params params;
	params.InputIdx = InputIdx;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.GetController
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class AActor*                  TheActor                       (Parm)
// class AController*             ReturnValue                    (Parm, OutParm, ReturnParm)

class AController* USequenceOp::STATIC_GetController(class AActor* TheActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetController"));

	USequenceOp_GetController_Params params;
	params.TheActor = TheActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceOp.GetPawn
// (Final, Iterator, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  TheActor                       (Parm)
// class APawn*                   ReturnValue                    (Parm, OutParm, ReturnParm)

class APawn* USequenceOp::STATIC_GetPawn(class AActor* TheActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetPawn"));

	USequenceOp_GetPawn_Params params;
	params.TheActor = TheActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceOp.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USequenceOp::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.Reset"));

	USequenceOp_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.PublishLinkedVariableValues
// (Final, Defined, Iterator, Latent, Net, Exec, HasOptionalParms)

void USequenceOp::PublishLinkedVariableValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.PublishLinkedVariableValues"));

	USequenceOp_PublishLinkedVariableValues_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.PopulateLinkedVariableValues
// (Final, Singular, Net, NetReliable, HasOptionalParms)

void USequenceOp::PopulateLinkedVariableValues()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.PopulateLinkedVariableValues"));

	USequenceOp_PopulateLinkedVariableValues_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.VersionUpdated
// (Final, Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            OldVersion                     (Parm)
// int                            NewVersion                     (Parm)

void USequenceOp::VersionUpdated(int OldVersion, int NewVersion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.VersionUpdated"));

	USequenceOp_VersionUpdated_Params params;
	params.OldVersion = OldVersion;
	params.NewVersion = NewVersion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.Deactivated
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Native, HasOptionalParms)

void USequenceOp::Deactivated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.Deactivated"));

	USequenceOp_Deactivated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USequenceOp::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.Activated"));

	USequenceOp_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceOp.ActivateNamedOutputLink
// (Iterator, Singular, Simulated, Exec, Native, Event)
// Parameters:
// struct FString                 LinkDesc                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceOp::ActivateNamedOutputLink(const struct FString& LinkDesc)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.ActivateNamedOutputLink"));

	USequenceOp_ActivateNamedOutputLink_Params params;
	params.LinkDesc = LinkDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceOp.ActivateOutputLink
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Event)
// Parameters:
// int                            OutputIdx                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceOp::ActivateOutputLink(int OutputIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.ActivateOutputLink"));

	USequenceOp_ActivateOutputLink_Params params;
	params.OutputIdx = OutputIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SequenceOp.LinkedVariables
// (Defined, Latent, Singular, Net, NetReliable, Native, Operator, Static)
// Parameters:
// class UClass*                  VarClass                       (Parm)
// class USequenceVariable*       OutVariable                    (Parm, OutParm)
// struct FString                 inDesc                         (OptionalParm, Parm, NeedCtorLink)

void USequenceOp::STATIC_LinkedVariables(class UClass* VarClass, const struct FString& inDesc, class USequenceVariable** OutVariable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.LinkedVariables"));

	USequenceOp_LinkedVariables_Params params;
	params.VarClass = VarClass;
	params.inDesc = inDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutVariable != nullptr)
		*OutVariable = params.OutVariable;
}


// Function Engine.SequenceOp.GetBoolVars
// (PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<unsigned char>          boolVars                       (Parm, OutParm, NeedCtorLink)
// struct FString                 inDesc                         (OptionalParm, Parm, NeedCtorLink)

void USequenceOp::STATIC_GetBoolVars(const struct FString& inDesc, TArray<unsigned char>* boolVars)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetBoolVars"));

	USequenceOp_GetBoolVars_Params params;
	params.inDesc = inDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (boolVars != nullptr)
		*boolVars = params.boolVars;
}


// Function Engine.SequenceOp.GetInterpDataVars
// (Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// TArray<class UInterpData*>     outIData                       (Parm, OutParm, NeedCtorLink)
// struct FString                 inDesc                         (OptionalParm, Parm, NeedCtorLink)

void USequenceOp::STATIC_GetInterpDataVars(const struct FString& inDesc, TArray<class UInterpData*>* outIData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetInterpDataVars"));

	USequenceOp_GetInterpDataVars_Params params;
	params.inDesc = inDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (outIData != nullptr)
		*outIData = params.outIData;
}


// Function Engine.SequenceOp.GetObjectVars
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// TArray<class UObject*>         objVars                        (Parm, OutParm, NeedCtorLink)
// struct FString                 inDesc                         (OptionalParm, Parm, NeedCtorLink)

void USequenceOp::STATIC_GetObjectVars(const struct FString& inDesc, TArray<class UObject*>* objVars)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetObjectVars"));

	USequenceOp_GetObjectVars_Params params;
	params.inDesc = inDesc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (objVars != nullptr)
		*objVars = params.objVars;
}


// Function Engine.SequenceOp.GetLinkedObjects
// (Final, Iterator, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// TArray<class USequenceObject*> out_Objects                    (Parm, OutParm, NeedCtorLink)
// class UClass*                  ObjectType                     (OptionalParm, Parm)
// bool                           bRecurse                       (OptionalParm, Parm)

void USequenceOp::STATIC_GetLinkedObjects(class UClass* ObjectType, bool bRecurse, TArray<class USequenceObject*>* out_Objects)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.GetLinkedObjects"));

	USequenceOp_GetLinkedObjects_Params params;
	params.ObjectType = ObjectType;
	params.bRecurse = bRecurse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Objects != nullptr)
		*out_Objects = params.out_Objects;
}


// Function Engine.SequenceOp.HasLinkedOps
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// bool                           bConsiderInputLinks            (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceOp::STATIC_HasLinkedOps(bool bConsiderInputLinks)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceOp.HasLinkedOps"));

	USequenceOp_HasLinkedOps_Params params;
	params.bConsiderInputLinks = bConsiderInputLinks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Sequence.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnabled                     (Parm)

void USequence::SetEnabled(bool bInEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Sequence.SetEnabled"));

	USequence_SetEnabled_Params params;
	params.bInEnabled = bInEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Sequence.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USequence::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Sequence.Reset"));

	USequence_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Sequence.FindSeqObjectsByName
// (Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FString                 SeqObjName                     (Parm, NeedCtorLink)
// bool                           bCheckComment                  (Parm)
// TArray<class USequenceObject*> OutputObjects                  (Parm, OutParm, NeedCtorLink)
// bool                           bRecursive                     (OptionalParm, Parm)
// bool                           bUseFullLevelName              (OptionalParm, Parm)

void USequence::STATIC_FindSeqObjectsByName(const struct FString& SeqObjName, bool bCheckComment, bool bRecursive, bool bUseFullLevelName, TArray<class USequenceObject*>* OutputObjects)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Sequence.FindSeqObjectsByName"));

	USequence_FindSeqObjectsByName_Params params;
	params.SeqObjName = SeqObjName;
	params.bCheckComment = bCheckComment;
	params.bRecursive = bRecursive;
	params.bUseFullLevelName = bUseFullLevelName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutputObjects != nullptr)
		*OutputObjects = params.OutputObjects;
}


// Function Engine.Sequence.FindSeqObjectsByClass
// (Final, Iterator, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class UClass*                  DesiredClass                   (Parm)
// bool                           bRecursive                     (Parm)
// TArray<class USequenceObject*> OutputObjects                  (Parm, OutParm, NeedCtorLink)

void USequence::STATIC_FindSeqObjectsByClass(class UClass* DesiredClass, bool bRecursive, TArray<class USequenceObject*>* OutputObjects)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Sequence.FindSeqObjectsByClass"));

	USequence_FindSeqObjectsByClass_Params params;
	params.DesiredClass = DesiredClass;
	params.bRecursive = bRecursive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutputObjects != nullptr)
		*OutputObjects = params.OutputObjects;
}


// Function Engine.PrefabSequence.GetOwnerPrefab
// (Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// class APrefabInstance*         ReturnValue                    (Parm, OutParm, ReturnParm)

class APrefabInstance* UPrefabSequence::STATIC_GetOwnerPrefab()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrefabSequence.GetOwnerPrefab"));

	UPrefabSequence_GetOwnerPrefab_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrefabSequence.SetOwnerPrefab
// (Final, Defined, Singular, Event, HasOptionalParms)
// Parameters:
// class APrefabInstance*         InOwner                        (Parm)

void UPrefabSequence::SetOwnerPrefab(class APrefabInstance* InOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PrefabSequence.SetOwnerPrefab"));

	UPrefabSequence_SetOwnerPrefab_Params params;
	params.InOwner = InOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_ActivateRemoteEvent.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ActivateRemoteEvent::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ActivateRemoteEvent.GetObjClassVersion"));

	USeqAct_ActivateRemoteEvent_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_CameraFade.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_CameraFade::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_CameraFade.GetObjClassVersion"));

	USeqAct_CameraFade_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_CameraLookAt.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_CameraLookAt::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_CameraLookAt.GetObjClassVersion"));

	USeqAct_CameraLookAt_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_CameraShake.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_CameraShake::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_CameraShake.GetObjClassVersion"));

	USeqAct_CameraShake_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ChangeCollision.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ChangeCollision::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ChangeCollision.GetObjClassVersion"));

	USeqAct_ChangeCollision_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ConvertToString.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ConvertToString::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ConvertToString.GetObjClassVersion"));

	USeqAct_ConvertToString_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_DrawText.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_DrawText::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_DrawText.GetObjClassVersion"));

	USeqAct_DrawText_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_GetLocationAndRotation.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_GetLocationAndRotation::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_GetLocationAndRotation.GetObjClassVersion"));

	USeqAct_GetLocationAndRotation_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_GetVelocity.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_GetVelocity::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_GetVelocity.GetObjClassVersion"));

	USeqAct_GetVelocity_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_HeadTrackingControl.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_HeadTrackingControl::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_HeadTrackingControl.Activated"));

	USeqAct_HeadTrackingControl_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_HeadTrackingControl.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_HeadTrackingControl::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_HeadTrackingControl.GetObjClassVersion"));

	USeqAct_HeadTrackingControl_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Latent.Update
// (Final, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqAct_Latent::Update(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Latent.Update"));

	USeqAct_Latent_Update_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Latent.AbortFor
// (Defined, Singular, Net, NetReliable, Exec, Native, Event)
// Parameters:
// class AActor*                  latentActor                    (Parm)

void USeqAct_Latent::AbortFor(class AActor* latentActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Latent.AbortFor"));

	USeqAct_Latent_AbortFor_Params params;
	params.latentActor = latentActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_ActorFactory.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ActorFactory::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ActorFactory.GetObjClassVersion"));

	USeqAct_ActorFactory_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ProjectileFactory.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ProjectileFactory::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ProjectileFactory.GetObjClassVersion"));

	USeqAct_ProjectileFactory_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_AIMoveToActor.PickDestination
// (Defined, HasOptionalParms)
// Parameters:
// class AActor*                  Requestor                      (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* USeqAct_AIMoveToActor::PickDestination(class AActor* Requestor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_AIMoveToActor.PickDestination"));

	USeqAct_AIMoveToActor_PickDestination_Params params;
	params.Requestor = Requestor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_AIMoveToActor.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_AIMoveToActor::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_AIMoveToActor.GetObjClassVersion"));

	USeqAct_AIMoveToActor_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Delay.ResetDelayActive
// (Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void USeqAct_Delay::ResetDelayActive()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Delay.ResetDelayActive"));

	USeqAct_Delay_ResetDelayActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Delay.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USeqAct_Delay::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Delay.Reset"));

	USeqAct_Delay_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Interp.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_Interp::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Interp.GetObjClassVersion"));

	USeqAct_Interp_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Interp.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USeqAct_Interp::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Interp.Reset"));

	USeqAct_Interp_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Interp.AddPlayerToDirectorTracks
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class APlayerController*       PC                             (Parm)

void USeqAct_Interp::AddPlayerToDirectorTracks(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Interp.AddPlayerToDirectorTracks"));

	USeqAct_Interp_AddPlayerToDirectorTracks_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Interp.Stop
// (Final, Defined, Iterator, Latent, Singular, Net, Exec)

void USeqAct_Interp::Stop()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Interp.Stop"));

	USeqAct_Interp_Stop_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Interp.SetPosition
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Event, HasOptionalParms)
// Parameters:
// float                          NewPosition                    (Parm)
// bool                           bJump                          (OptionalParm, Parm)

void USeqAct_Interp::SetPosition(float NewPosition, bool bJump)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Interp.SetPosition"));

	USeqAct_Interp_SetPosition_Params params;
	params.NewPosition = NewPosition;
	params.bJump = bJump;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_PlaySound.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_PlaySound::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_PlaySound.GetObjClassVersion"));

	USeqAct_PlaySound_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_StreamInTextures.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_StreamInTextures::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_StreamInTextures.GetObjClassVersion"));

	USeqAct_StreamInTextures_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_WaitForLevelsVisible.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_WaitForLevelsVisible::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_WaitForLevelsVisible.Activated"));

	USeqAct_WaitForLevelsVisible_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_WaitForLevelsVisible.CheckLevelsVisible
// (Iterator, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqAct_WaitForLevelsVisible::CheckLevelsVisible()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_WaitForLevelsVisible.CheckLevelsVisible"));

	USeqAct_WaitForLevelsVisible_CheckLevelsVisible_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Log.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_Log::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Log.GetObjClassVersion"));

	USeqAct_Log_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ModifyHealth.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ModifyHealth::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ModifyHealth.GetObjClassVersion"));

	USeqAct_ModifyHealth_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ParticleEventGenerator.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ParticleEventGenerator::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ParticleEventGenerator.GetObjClassVersion"));

	USeqAct_ParticleEventGenerator_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_PlayCameraAnim.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_PlayCameraAnim::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_PlayCameraAnim.GetObjClassVersion"));

	USeqAct_PlayCameraAnim_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetCameraTarget.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetCameraTarget::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetCameraTarget.GetObjClassVersion"));

	USeqAct_SetCameraTarget_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetFloat.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetFloat::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetFloat.GetObjClassVersion"));

	USeqAct_SetFloat_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetInt.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetInt::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetInt.GetObjClassVersion"));

	USeqAct_SetInt_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetLocation.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetLocation::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetLocation.GetObjClassVersion"));

	USeqAct_SetLocation_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetObject.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetObject::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetObject.GetObjClassVersion"));

	USeqAct_SetObject_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetString.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetString::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetString.GetObjClassVersion"));

	USeqAct_SetString_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_RandomSwitch.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_RandomSwitch::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_RandomSwitch.GetObjClassVersion"));

	USeqAct_RandomSwitch_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Trace.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_Trace::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Trace.GetObjClassVersion"));

	USeqAct_Trace_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_CompareBool.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqCond_CompareBool::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_CompareBool.GetObjClassVersion"));

	USeqCond_CompareBool_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_GetServerType.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqCond_GetServerType::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_GetServerType.GetObjClassVersion"));

	USeqCond_GetServerType_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_IsBenchmarking.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqCond_IsBenchmarking::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_IsBenchmarking.GetObjClassVersion"));

	USeqCond_IsBenchmarking_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_IsLoggedIn.CheckLogins
// (Defined, Iterator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqCond_IsLoggedIn::CheckLogins()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_IsLoggedIn.CheckLogins"));

	USeqCond_IsLoggedIn_CheckLogins_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_IsPIE.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqCond_IsPIE::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_IsPIE.GetObjClassVersion"));

	USeqCond_IsPIE_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_SwitchBase.RemoveValueEntry
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            RemoveIndex                    (Parm)

void USeqCond_SwitchBase::RemoveValueEntry(int RemoveIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchBase.RemoveValueEntry"));

	USeqCond_SwitchBase_RemoveValueEntry_Params params;
	params.RemoveIndex = RemoveIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchBase.InsertValueEntry
// (Final, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            InsertIndex                    (Parm)

void USeqCond_SwitchBase::InsertValueEntry(int InsertIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchBase.InsertValueEntry"));

	USeqCond_SwitchBase_InsertValueEntry_Params params;
	params.InsertIndex = InsertIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchBase.IsFallThruEnabled
// (Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ValueIndex                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqCond_SwitchBase::IsFallThruEnabled(int ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchBase.IsFallThruEnabled"));

	USeqCond_SwitchBase_IsFallThruEnabled_Params params;
	params.ValueIndex = ValueIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_SwitchBase.VerifyDefaultCaseValue
// (Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void USeqCond_SwitchBase::VerifyDefaultCaseValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchBase.VerifyDefaultCaseValue"));

	USeqCond_SwitchBase_VerifyDefaultCaseValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchClass.RemoveValueEntry
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            RemoveIndex                    (Parm)

void USeqCond_SwitchClass::RemoveValueEntry(int RemoveIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchClass.RemoveValueEntry"));

	USeqCond_SwitchClass_RemoveValueEntry_Params params;
	params.RemoveIndex = RemoveIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchClass.InsertValueEntry
// (Final, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            InsertIndex                    (Parm)

void USeqCond_SwitchClass::InsertValueEntry(int InsertIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchClass.InsertValueEntry"));

	USeqCond_SwitchClass_InsertValueEntry_Params params;
	params.InsertIndex = InsertIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchClass.IsFallThruEnabled
// (Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ValueIndex                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqCond_SwitchClass::IsFallThruEnabled(int ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchClass.IsFallThruEnabled"));

	USeqCond_SwitchClass_IsFallThruEnabled_Params params;
	params.ValueIndex = ValueIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_SwitchClass.VerifyDefaultCaseValue
// (Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void USeqCond_SwitchClass::VerifyDefaultCaseValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchClass.VerifyDefaultCaseValue"));

	USeqCond_SwitchClass_VerifyDefaultCaseValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchObject.RemoveValueEntry
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            RemoveIndex                    (Parm)

void USeqCond_SwitchObject::RemoveValueEntry(int RemoveIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchObject.RemoveValueEntry"));

	USeqCond_SwitchObject_RemoveValueEntry_Params params;
	params.RemoveIndex = RemoveIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchObject.InsertValueEntry
// (Final, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            InsertIndex                    (Parm)

void USeqCond_SwitchObject::InsertValueEntry(int InsertIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchObject.InsertValueEntry"));

	USeqCond_SwitchObject_InsertValueEntry_Params params;
	params.InsertIndex = InsertIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqCond_SwitchObject.IsFallThruEnabled
// (Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ValueIndex                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqCond_SwitchObject::IsFallThruEnabled(int ValueIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchObject.IsFallThruEnabled"));

	USeqCond_SwitchObject_IsFallThruEnabled_Params params;
	params.ValueIndex = ValueIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqCond_SwitchObject.VerifyDefaultCaseValue
// (Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void USeqCond_SwitchObject::VerifyDefaultCaseValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqCond_SwitchObject.VerifyDefaultCaseValue"));

	USeqCond_SwitchObject_VerifyDefaultCaseValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceEvent.Toggled
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void USequenceEvent::Toggled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceEvent.Toggled"));

	USequenceEvent_Toggled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceEvent.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USequenceEvent::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceEvent.Reset"));

	USequenceEvent_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SequenceEvent.CheckActivate
// (Defined, Iterator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  InOriginator                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// bool                           bTest                          (OptionalParm, Parm)
// TArray<int>                    ActivateIndices                (Const, OptionalParm, Parm, OutParm, NeedCtorLink)
// bool                           bPushTop                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USequenceEvent::CheckActivate(class AActor* InOriginator, class AActor* InInstigator, bool bTest, bool bPushTop, TArray<int>* ActivateIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceEvent.CheckActivate"));

	USequenceEvent_CheckActivate_Params params;
	params.InOriginator = InOriginator;
	params.InInstigator = InInstigator;
	params.bTest = bTest;
	params.bPushTop = bPushTop;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActivateIndices != nullptr)
		*ActivateIndices = params.ActivateIndices;

	return params.ReturnValue;
}


// Function Engine.SequenceEvent.RegisterEvent
// (Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USequenceEvent::RegisterEvent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SequenceEvent.RegisterEvent"));

	USequenceEvent_RegisterEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_LevelLoaded.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_LevelLoaded::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_LevelLoaded.GetObjClassVersion"));

	USeqEvent_LevelLoaded_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_Mover.NotifyFinishedOpen
// (Final, Defined, Iterator, Net, Simulated, Exec, Event, Operator, Static)

void USeqEvent_Mover::STATIC_NotifyFinishedOpen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Mover.NotifyFinishedOpen"));

	USeqEvent_Mover_NotifyFinishedOpen_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Mover.NotifyDetached
// (Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Parm)

void USeqEvent_Mover::STATIC_NotifyDetached(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Mover.NotifyDetached"));

	USeqEvent_Mover_NotifyDetached_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Mover.NotifyAttached
// (Final, Iterator, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AActor*                  Other                          (Parm)

void USeqEvent_Mover::STATIC_NotifyAttached(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Mover.NotifyAttached"));

	USeqEvent_Mover_NotifyAttached_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Mover.NotifyEncroachingOn
// (Iterator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class AActor*                  Hit                            (Parm)

void USeqEvent_Mover::STATIC_NotifyEncroachingOn(class AActor* Hit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Mover.NotifyEncroachingOn"));

	USeqEvent_Mover_NotifyEncroachingOn_Params params;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Mover.RegisterEvent
// (Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USeqEvent_Mover::RegisterEvent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Mover.RegisterEvent"));

	USeqEvent_Mover_RegisterEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_ParticleEvent.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_ParticleEvent::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_ParticleEvent.GetObjClassVersion"));

	USeqEvent_ParticleEvent_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_RemoteEvent.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_RemoteEvent::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_RemoteEvent.GetObjClassVersion"));

	USeqEvent_RemoteEvent_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_TakeDamage.Toggled
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void USeqEvent_TakeDamage::Toggled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_TakeDamage.Toggled"));

	USeqEvent_TakeDamage_Toggled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_TakeDamage.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_TakeDamage::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_TakeDamage.GetObjClassVersion"));

	USeqEvent_TakeDamage_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_TakeDamage.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USeqEvent_TakeDamage::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_TakeDamage.Reset"));

	USeqEvent_TakeDamage_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_TakeDamage.HandleDamage
// (Final, PreOperator, Singular, Net, Simulated, Event, HasOptionalParms)
// Parameters:
// class AActor*                  InOriginator                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// class UClass*                  inDamageType                   (Parm)
// int                            inAmount                       (Parm)

void USeqEvent_TakeDamage::HandleDamage(class AActor* InOriginator, class AActor* InInstigator, class UClass* inDamageType, int inAmount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_TakeDamage.HandleDamage"));

	USeqEvent_TakeDamage_HandleDamage_Params params;
	params.InOriginator = InOriginator;
	params.InInstigator = InInstigator;
	params.inDamageType = inDamageType;
	params.inAmount = inAmount;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_TakeDamage.IsValidDamageType
// (Final, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// class UClass*                  inDamageType                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqEvent_TakeDamage::STATIC_IsValidDamageType(class UClass* inDamageType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_TakeDamage.IsValidDamageType"));

	USeqEvent_TakeDamage_IsValidDamageType_Params params;
	params.inDamageType = inDamageType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_Touch.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_Touch::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Touch.GetObjClassVersion"));

	USeqEvent_Touch_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_Touch.NotifyTouchingPawnDied
// (Iterator, Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class APawn*                   P                              (Parm)

void USeqEvent_Touch::STATIC_NotifyTouchingPawnDied(class APawn* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Touch.NotifyTouchingPawnDied"));

	USeqEvent_Touch_NotifyTouchingPawnDied_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Touch.Toggled
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void USeqEvent_Touch::Toggled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Touch.Toggled"));

	USeqEvent_Touch_Toggled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqEvent_Touch.CheckUnTouchActivate
// (Final, Defined, Singular, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  InOriginator                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// bool                           bTest                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqEvent_Touch::CheckUnTouchActivate(class AActor* InOriginator, class AActor* InInstigator, bool bTest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Touch.CheckUnTouchActivate"));

	USeqEvent_Touch_CheckUnTouchActivate_Params params;
	params.InOriginator = InOriginator;
	params.InInstigator = InInstigator;
	params.bTest = bTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_Touch.CheckTouchActivate
// (Singular, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  InOriginator                   (Parm)
// class AActor*                  InInstigator                   (Parm)
// bool                           bTest                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqEvent_Touch::CheckTouchActivate(class AActor* InOriginator, class AActor* InInstigator, bool bTest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_Touch.CheckTouchActivate"));

	USeqEvent_Touch_CheckTouchActivate_Params params;
	params.InOriginator = InOriginator;
	params.InInstigator = InInstigator;
	params.bTest = bTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqVar_Object.SetObjectValue
// (Defined, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// class UObject*                 NewValue                       (Parm)

void USeqVar_Object::SetObjectValue(class UObject* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_Object.SetObjectValue"));

	USeqVar_Object_SetObjectValue_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqVar_Object.GetObjectValue
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* USeqVar_Object::STATIC_GetObjectValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_Object.GetObjectValue"));

	USeqVar_Object_GetObjectValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqVar_ObjectList.SetObjectValue
// (Defined, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// class UObject*                 NewValue                       (Parm)

void USeqVar_ObjectList::SetObjectValue(class UObject* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_ObjectList.SetObjectValue"));

	USeqVar_ObjectList_SetObjectValue_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqVar_ObjectList.GetObjectValue
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* USeqVar_ObjectList::STATIC_GetObjectValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_ObjectList.GetObjectValue"));

	USeqVar_ObjectList_GetObjectValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqVar_Player.GetObjectValue
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* USeqVar_Player::STATIC_GetObjectValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_Player.GetObjectValue"));

	USeqVar_Player_GetObjectValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqVar_Player.UpdatePlayersList
// (Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USeqVar_Player::UpdatePlayersList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqVar_Player.UpdatePlayersList"));

	USeqVar_Player_UpdatePlayersList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSoundSimpleToggleable.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct AAmbientSoundSimpleToggleable_FCheckpointRecord Record                         (Const, Parm, OutParm)

void AAmbientSoundSimpleToggleable::ApplyCheckpointRecord(struct AAmbientSoundSimpleToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.ApplyCheckpointRecord"));

	AAmbientSoundSimpleToggleable_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.AmbientSoundSimpleToggleable.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct AAmbientSoundSimpleToggleable_FCheckpointRecord Record                         (Parm, OutParm)

void AAmbientSoundSimpleToggleable::STATIC_CreateCheckpointRecord(struct AAmbientSoundSimpleToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.CreateCheckpointRecord"));

	AAmbientSoundSimpleToggleable_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.AmbientSoundSimpleToggleable.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AAmbientSoundSimpleToggleable::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.OnToggle"));

	AAmbientSoundSimpleToggleable_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSoundSimpleToggleable.StopPlaying
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void AAmbientSoundSimpleToggleable::StopPlaying()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.StopPlaying"));

	AAmbientSoundSimpleToggleable_StopPlaying_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSoundSimpleToggleable.StartPlaying
// (Final, Net, Simulated, Exec, Event, HasOptionalParms)

void AAmbientSoundSimpleToggleable::StartPlaying()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.StartPlaying"));

	AAmbientSoundSimpleToggleable_StartPlaying_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSoundSimpleToggleable.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AAmbientSoundSimpleToggleable::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.ReplicatedEvent"));

	AAmbientSoundSimpleToggleable_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSoundSimpleToggleable.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AAmbientSoundSimpleToggleable::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AmbientSoundSimpleToggleable.PostBeginPlay"));

	AAmbientSoundSimpleToggleable_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundComponentPool.ReturnComponent
// (Final, PreOperator, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// class UActorComponent*         InComponent                    (Parm, EditInline)

void ASoundComponentPool::ReturnComponent(class UActorComponent* InComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundComponentPool.ReturnComponent"));

	ASoundComponentPool_ReturnComponent_Params params;
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundComponentPool.AllocateComponent
// (Final, Defined, Iterator, Singular, NetReliable, Operator)
// Parameters:
// struct FVector                 InLocation                     (Parm)
// class UActorComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UActorComponent* ASoundComponentPool::AllocateComponent(const struct FVector& InLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundComponentPool.AllocateComponent"));

	ASoundComponentPool_AllocateComponent_Params params;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SoundNodeWave.GeneratePCMData
// (Final, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          Buffer                         (Parm, OutParm, NeedCtorLink)
// int                            SamplesNeeded                  (Parm)

void USoundNodeWave::GeneratePCMData(int SamplesNeeded, TArray<unsigned char>* Buffer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWave.GeneratePCMData"));

	USoundNodeWave_GeneratePCMData_Params params;
	params.SamplesNeeded = SamplesNeeded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Buffer != nullptr)
		*Buffer = params.Buffer;
}


// Function Engine.SoundNodeWaveStreaming.GeneratePCMData
// (Final, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          Buffer                         (Parm, OutParm, NeedCtorLink)
// int                            SamplesNeeded                  (Parm)

void USoundNodeWaveStreaming::GeneratePCMData(int SamplesNeeded, TArray<unsigned char>* Buffer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWaveStreaming.GeneratePCMData"));

	USoundNodeWaveStreaming_GeneratePCMData_Params params;
	params.SamplesNeeded = SamplesNeeded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Buffer != nullptr)
		*Buffer = params.Buffer;
}


// Function Engine.SoundNodeWaveStreaming.AvailableAudioBytes
// (Final, Iterator, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USoundNodeWaveStreaming::AvailableAudioBytes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWaveStreaming.AvailableAudioBytes"));

	USoundNodeWaveStreaming_AvailableAudioBytes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SoundNodeWaveStreaming.ResetAudio
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void USoundNodeWaveStreaming::ResetAudio()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWaveStreaming.ResetAudio"));

	USoundNodeWaveStreaming_ResetAudio_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundNodeWaveStreaming.QueueSilence
// (Final, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// float                          Seconds                        (Parm)

void USoundNodeWaveStreaming::QueueSilence(float Seconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWaveStreaming.QueueSilence"));

	USoundNodeWaveStreaming_QueueSilence_Params params;
	params.Seconds = Seconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundNodeWaveStreaming.QueueAudio
// (Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<unsigned char>          Data                           (Parm, NeedCtorLink)

void USoundNodeWaveStreaming::QueueAudio(TArray<unsigned char> Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SoundNodeWaveStreaming.QueueAudio"));

	USoundNodeWaveStreaming_QueueAudio_Params params;
	params.Data = Data;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Terrain.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ATerrain::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Terrain.PostBeginPlay"));

	ATerrain_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Terrain.CalcLayerBounds
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)

void ATerrain::CalcLayerBounds()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Terrain.CalcLayerBounds"));

	ATerrain_CalcLayerBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TerrainLayerSetup.PostBeginPlay
// (Final, Latent, Net, Simulated)

void UTerrainLayerSetup::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TerrainLayerSetup.PostBeginPlay"));

	UTerrainLayerSetup_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DataStoreClient.DebugDumpDataStoreInfo
// (Latent, PreOperator, Net, Simulated, Exec, Static)
// Parameters:
// bool                           bVerbose                       (Parm)

void UDataStoreClient::STATIC_DebugDumpDataStoreInfo(bool bVerbose)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.DebugDumpDataStoreInfo"));

	UDataStoreClient_DebugDumpDataStoreInfo_Params params;
	params.bVerbose = bVerbose;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DataStoreClient.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UDataStoreClient::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.NotifyGameSessionEnded"));

	UDataStoreClient_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DataStoreClient.FindDataStoreClass
// (Final, Defined, Latent, NetReliable, Exec, Event, Static)
// Parameters:
// class UClass*                  RequiredMetaClass              (Parm)
// class UClass*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class UClass* UDataStoreClient::STATIC_FindDataStoreClass(class UClass* RequiredMetaClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.FindDataStoreClass"));

	UDataStoreClient_FindDataStoreClass_Params params;
	params.RequiredMetaClass = RequiredMetaClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataStoreClient.GetPlayerDataStoreClasses
// (NetReliable, Exec, Native, Event, Static)
// Parameters:
// TArray<class UClass*>          out_DataStoreClasses           (Parm, OutParm, NeedCtorLink)

void UDataStoreClient::STATIC_GetPlayerDataStoreClasses(TArray<class UClass*>* out_DataStoreClasses)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.GetPlayerDataStoreClasses"));

	UDataStoreClient_GetPlayerDataStoreClasses_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_DataStoreClasses != nullptr)
		*out_DataStoreClasses = params.out_DataStoreClasses;
}


// Function Engine.DataStoreClient.FindPlayerDataStoreIndex
// (Defined, Latent, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UDataStoreClient::STATIC_FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.FindPlayerDataStoreIndex"));

	UDataStoreClient_FindPlayerDataStoreIndex_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataStoreClient.UnregisterDataStore
// (Final, Defined, Iterator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class UUIDataStore*            DataStore                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UDataStoreClient::UnregisterDataStore(class UUIDataStore* DataStore)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.UnregisterDataStore"));

	UDataStoreClient_UnregisterDataStore_Params params;
	params.DataStore = DataStore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataStoreClient.RegisterDataStore
// (Latent, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// class UUIDataStore*            DataStore                      (Parm)
// class ULocalPlayer*            PlayerOwner                    (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UDataStoreClient::RegisterDataStore(class UUIDataStore* DataStore, class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.RegisterDataStore"));

	UDataStoreClient_RegisterDataStore_Params params;
	params.DataStore = DataStore;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataStoreClient.CreateDataStore
// (Iterator, Exec, Static)
// Parameters:
// class UClass*                  DataStoreClass                 (Parm)
// class UUIDataStore*            ReturnValue                    (Parm, OutParm, ReturnParm, CoerceParm)

class UUIDataStore* UDataStoreClient::STATIC_CreateDataStore(class UClass* DataStoreClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.CreateDataStore"));

	UDataStoreClient_CreateDataStore_Params params;
	params.DataStoreClass = DataStoreClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataStoreClient.FindDataStore
// (Defined, Latent, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   DataStoreTag                   (Parm)
// class ULocalPlayer*            PlayerOwner                    (OptionalParm, Parm)
// class UUIDataStore*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIDataStore* UDataStoreClient::STATIC_FindDataStore(const struct FName& DataStoreTag, class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DataStoreClient.FindDataStore"));

	UDataStoreClient_FindDataStore_Params params;
	params.DataStoreTag = DataStoreTag;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Console.UpdateCompleteIndices
// (Defined, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void UConsole::UpdateCompleteIndices()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.UpdateCompleteIndices"));

	UConsole_UpdateCompleteIndices_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.BuildRuntimeAutoCompleteList
// (PreOperator, Singular, Net, Native, Event, Operator)
// Parameters:
// bool                           bForce                         (OptionalParm, Parm)

void UConsole::BuildRuntimeAutoCompleteList(bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.BuildRuntimeAutoCompleteList"));

	UConsole_BuildRuntimeAutoCompleteList_Params params;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.AppendInputText
// (Final, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct FString                 Text                           (Parm, NeedCtorLink)

void UConsole::AppendInputText(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.AppendInputText"));

	UConsole_AppendInputText_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.ProcessControlKey
// (Defined, Latent, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FName                   Key                            (Parm)
// TEnumAsByte<EInputEvent>       Event                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UConsole::ProcessControlKey(const struct FName& Key, TEnumAsByte<EInputEvent> Event)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.ProcessControlKey"));

	UConsole_ProcessControlKey_Params params;
	params.Key = Key;
	params.Event = Event;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Console.FlushPlayerInput
// (Net, Simulated, Exec, Event, Static)

void UConsole::STATIC_FlushPlayerInput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.FlushPlayerInput"));

	UConsole_FlushPlayerInput_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.InputChar
// (Defined, Iterator, Latent, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FString                 Unicode                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UConsole::InputChar(int ControllerId, const struct FString& Unicode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.InputChar"));

	UConsole_InputChar_Params params;
	params.ControllerId = ControllerId;
	params.Unicode = Unicode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Console.InputKey
// (Defined, Iterator, Singular, NetReliable, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// struct FName                   Key                            (Parm)
// TEnumAsByte<EInputEvent>       Event                          (Parm)
// float                          AmountDepressed                (OptionalParm, Parm)
// bool                           bGamepad                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UConsole::STATIC_InputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed, bool bGamepad)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.InputKey"));

	UConsole_InputKey_Params params;
	params.ControllerId = ControllerId;
	params.Key = Key;
	params.Event = Event;
	params.AmountDepressed = AmountDepressed;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Console.PostRender_Console
// (Defined, Latent, PreOperator, Simulated, HasOptionalParms)
// Parameters:
// class UCanvas*                 Canvas                         (Parm)

void UConsole::PostRender_Console(class UCanvas* Canvas)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.PostRender_Console"));

	UConsole_PostRender_Console_Params params;
	params.Canvas = Canvas;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.StartTyping
// (Latent, PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, CoerceParm, NeedCtorLink)

void UConsole::StartTyping(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.StartTyping"));

	UConsole_StartTyping_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.OutputText
// (Iterator, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, CoerceParm, NeedCtorLink)

void UConsole::OutputText(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.OutputText"));

	UConsole_OutputText_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.OutputTextLine
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Text                           (Parm, CoerceParm, NeedCtorLink)

void UConsole::STATIC_OutputTextLine(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.OutputTextLine"));

	UConsole_OutputTextLine_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.ClearOutput
// (Defined, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)

void UConsole::ClearOutput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.ClearOutput"));

	UConsole_ClearOutput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.ConsoleCommand
// (Iterator, Latent, Singular, Net, Simulated, Static)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)

void UConsole::STATIC_ConsoleCommand(const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.ConsoleCommand"));

	UConsole_ConsoleCommand_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.PurgeCommandFromHistory
// (Final, Latent, PreOperator, Net, Exec, HasOptionalParms)
// Parameters:
// struct FString                 Command                        (Parm, NeedCtorLink)

void UConsole::PurgeCommandFromHistory(const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.PurgeCommandFromHistory"));

	UConsole_PurgeCommandFromHistory_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.SetCursorPos
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Position                       (Parm)

void UConsole::SetCursorPos(int Position)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.SetCursorPos"));

	UConsole_SetCursorPos_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.SetInputText
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, NeedCtorLink)

void UConsole::SetInputText(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.SetInputText"));

	UConsole_SetInputText_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Console.Initialized
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Event, Operator)

void UConsole::Initialized()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Console.Initialized"));

	UConsole_Initialized_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Input.SetBind
// (Final, Iterator, Latent, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   BindName                       (Const, Parm, OutParm)
// struct FString                 Command                        (Parm, NeedCtorLink)

void UInput::SetBind(const struct FString& Command, struct FName* BindName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Input.SetBind"));

	UInput_SetBind_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BindName != nullptr)
		*BindName = params.BindName;
}


// Function Engine.Input.GetKeybindWithCurrentModifiers
// (Final, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FName                   Key                            (Const, Parm, OutParm)
// struct FKeyBind                ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FKeyBind UInput::STATIC_GetKeybindWithCurrentModifiers(struct FName* Key)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Input.GetKeybindWithCurrentModifiers"));

	UInput_GetKeybindWithCurrentModifiers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Key != nullptr)
		*Key = params.Key;

	return params.ReturnValue;
}


// Function Engine.Input.GetBind
// (Defined, Iterator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   Key                            (Const, Parm, OutParm)
// struct FKeyBind                ModifierKeyBind                (Const, OptionalParm, Parm, OutParm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UInput::STATIC_GetBind(struct FName* Key, struct FKeyBind* ModifierKeyBind)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Input.GetBind"));

	UInput_GetBind_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Key != nullptr)
		*Key = params.Key;
	if (ModifierKeyBind != nullptr)
		*ModifierKeyBind = params.ModifierKeyBind;

	return params.ReturnValue;
}


// Function Engine.Input.ResetInput
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void UInput::ResetInput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Input.ResetInput"));

	UInput_ResetInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.PreClientTravel
// (Iterator, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 PendingURL                     (Parm, NeedCtorLink)
// TEnumAsByte<ETravelType>       TravelType                     (Parm)
// bool                           bIsSeamlessTravel              (Parm)

void UPlayerInput::PreClientTravel(const struct FString& PendingURL, TEnumAsByte<ETravelType> TravelType, bool bIsSeamlessTravel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.PreClientTravel"));

	UPlayerInput_PreClientTravel_Params params;
	params.PendingURL = PendingURL;
	params.TravelType = TravelType;
	params.bIsSeamlessTravel = bIsSeamlessTravel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.ClientInitInputSystem
// (Iterator, Latent, Static)

void UPlayerInput::STATIC_ClientInitInputSystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.ClientInitInputSystem"));

	UPlayerInput_ClientInitInputSystem_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.InitInputSystem
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void UPlayerInput::InitInputSystem()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.InitInputSystem"));

	UPlayerInput_InitInputSystem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.SmartJump
// (Defined, Net, NetReliable, Simulated, Event, HasOptionalParms)

void UPlayerInput::SmartJump()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.SmartJump"));

	UPlayerInput_SmartJump_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.Jump
// (Iterator, PreOperator, NetReliable, Const)

void UPlayerInput::Jump()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.Jump"));

	UPlayerInput_Jump_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.PlayerInput
// (Final, Defined, Singular, NetReliable)
// Parameters:
// float                          DeltaTime                      (Parm)

void UPlayerInput::PlayerInput(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.PlayerInput"));

	UPlayerInput_PlayerInput_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.DrawHUD
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Exec, Native, Static)
// Parameters:
// class AHUD*                    H                              (Parm)

void UPlayerInput::STATIC_DrawHUD(class AHUD* H)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.DrawHUD"));

	UPlayerInput_DrawHUD_Params params;
	params.H = H;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.SetSensitivity
// (Latent, Singular, Net, Event, HasOptionalParms)
// Parameters:
// float                          F                              (Parm)

void UPlayerInput::SetSensitivity(float F)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.SetSensitivity"));

	UPlayerInput_SetSensitivity_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.InvertTurn
// (Iterator, Latent, Singular, Net, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPlayerInput::STATIC_InvertTurn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.InvertTurn"));

	UPlayerInput_InvertTurn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerInput.InvertMouse
// (Final, Defined, Latent, Singular, Net, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UPlayerInput::STATIC_InvertMouse()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.InvertMouse"));

	UPlayerInput_InvertMouse_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerInput.CancelMobileInput
// (Final, Defined, Latent, PreOperator, Singular, Exec, Native, Event, Operator)

void UPlayerInput::CancelMobileInput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerInput.CancelMobileInput"));

	UPlayerInput_CancelMobileInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UISceneClient.InitializeSceneClient
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)

void UUISceneClient::InitializeSceneClient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UISceneClient.InitializeSceneClient"));

	UUISceneClient_InitializeSceneClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UISceneClient.GetInverseCanvasToScreen
// (Final, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FMatrix UUISceneClient::STATIC_GetInverseCanvasToScreen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UISceneClient.GetInverseCanvasToScreen"));

	UUISceneClient_GetInverseCanvasToScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UISceneClient.GetCanvasToScreen
// (Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FMatrix UUISceneClient::STATIC_GetCanvasToScreen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UISceneClient.GetCanvasToScreen"));

	UUISceneClient_GetCanvasToScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UISceneClient.IsUIActive
// (Defined, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// int                            Flags                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUISceneClient::STATIC_IsUIActive(int Flags)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UISceneClient.IsUIActive"));

	UUISceneClient_IsUIActive_Params params;
	params.Flags = Flags;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UISoundTheme.ProcessSoundEvent
// (Final, Iterator, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SoundEventName                 (Parm)
// class APlayerController*       SoundOwner                     (OptionalParm, Parm)

void UUISoundTheme::ProcessSoundEvent(const struct FName& SoundEventName, class APlayerController* SoundOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UISoundTheme.ProcessSoundEvent"));

	UUISoundTheme_ProcessSoundEvent_Params params;
	params.SoundEventName = SoundEventName;
	params.SoundOwner = SoundOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStoreSubscriber.ClearBoundDataStores
// (Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void UUIDataStoreSubscriber::ClearBoundDataStores()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.ClearBoundDataStores"));

	UUIDataStoreSubscriber_ClearBoundDataStores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStoreSubscriber.GetBoundDataStores
// (Defined, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<class UUIDataStore*>    out_BoundDataStores            (Parm, OutParm, NeedCtorLink)

void UUIDataStoreSubscriber::STATIC_GetBoundDataStores(TArray<class UUIDataStore*>* out_BoundDataStores)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.GetBoundDataStores"));

	UUIDataStoreSubscriber_GetBoundDataStores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_BoundDataStores != nullptr)
		*out_BoundDataStores = params.out_BoundDataStores;
}


// Function Engine.UIDataStoreSubscriber.NotifyDataStoreValueUpdated
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class UUIDataStore*            SourceDataStore                (Parm)
// bool                           bValuesInvalidated             (Parm)
// struct FName                   PropertyTag                    (Parm)
// class UUIDataProvider*         SourceProvider                 (Parm)
// int                            ArrayIndex                     (Parm)

void UUIDataStoreSubscriber::STATIC_NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore, bool bValuesInvalidated, const struct FName& PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.NotifyDataStoreValueUpdated"));

	UUIDataStoreSubscriber_NotifyDataStoreValueUpdated_Params params;
	params.SourceDataStore = SourceDataStore;
	params.bValuesInvalidated = bValuesInvalidated;
	params.PropertyTag = PropertyTag;
	params.SourceProvider = SourceProvider;
	params.ArrayIndex = ArrayIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStoreSubscriber.RefreshSubscriberValue
// (Defined, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// int                            BindingIndex                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStoreSubscriber::RefreshSubscriberValue(int BindingIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.RefreshSubscriberValue"));

	UUIDataStoreSubscriber_RefreshSubscriberValue_Params params;
	params.BindingIndex = BindingIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStoreSubscriber.GetDataStoreBinding
// (Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            BindingIndex                   (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UUIDataStoreSubscriber::STATIC_GetDataStoreBinding(int BindingIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.GetDataStoreBinding"));

	UUIDataStoreSubscriber_GetDataStoreBinding_Params params;
	params.BindingIndex = BindingIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStoreSubscriber.SetDataStoreBinding
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 MarkupText                     (Parm, NeedCtorLink)
// int                            BindingIndex                   (OptionalParm, Parm)

void UUIDataStoreSubscriber::SetDataStoreBinding(const struct FString& MarkupText, int BindingIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStoreSubscriber.SetDataStoreBinding"));

	UUIDataStoreSubscriber_SetDataStoreBinding_Params params;
	params.MarkupText = MarkupText;
	params.BindingIndex = BindingIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStorePublisher.SaveSubscriberValue
// (Defined, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<class UUIDataStore*>    out_BoundDataStores            (Parm, OutParm, NeedCtorLink)
// int                            BindingIndex                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStorePublisher::SaveSubscriberValue(int BindingIndex, TArray<class UUIDataStore*>* out_BoundDataStores)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStorePublisher.SaveSubscriberValue"));

	UUIDataStorePublisher_SaveSubscriberValue_Params params;
	params.BindingIndex = BindingIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_BoundDataStores != nullptr)
		*out_BoundDataStores = params.out_BoundDataStores;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlinePlayerDataBase.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlinePlayerDataBase::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerDataBase.OnUnregister"));

	UUIDataProvider_OnlinePlayerDataBase_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerDataBase.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_OnlinePlayerDataBase::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerDataBase.OnRegister"));

	UUIDataProvider_OnlinePlayerDataBase_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnGameInviteReceived
// (Final, Iterator, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 InviterName                    (Parm, NeedCtorLink)

void UUIDataProvider_OnlineFriendMessages::STATIC_OnGameInviteReceived(unsigned char LocalUserNum, const struct FString& InviterName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnGameInviteReceived"));

	UUIDataProvider_OnlineFriendMessages_OnGameInviteReceived_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InviterName = InviterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlineFriendMessages::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnLoginChange"));

	UUIDataProvider_OnlineFriendMessages_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnFriendMessageReceived
// (Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            SendingPlayer                  (Parm)
// struct FString                 SendingNick                    (Parm, NeedCtorLink)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UUIDataProvider_OnlineFriendMessages::STATIC_OnFriendMessageReceived(unsigned char LocalUserNum, const struct FUniqueNetId& SendingPlayer, const struct FString& SendingNick, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnFriendMessageReceived"));

	UUIDataProvider_OnlineFriendMessages_OnFriendMessageReceived_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SendingPlayer = SendingPlayer;
	params.SendingNick = SendingNick;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnFriendInviteReceived
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            RequestingPlayer               (Parm)
// struct FString                 RequestingNick                 (Parm, NeedCtorLink)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UUIDataProvider_OnlineFriendMessages::STATIC_OnFriendInviteReceived(unsigned char LocalUserNum, const struct FUniqueNetId& RequestingPlayer, const struct FString& RequestingNick, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnFriendInviteReceived"));

	UUIDataProvider_OnlineFriendMessages_OnFriendInviteReceived_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RequestingPlayer = RequestingPlayer;
	params.RequestingNick = RequestingNick;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.ReadMessages
// (Defined, Iterator, PreOperator, Singular, Simulated, Exec, HasOptionalParms)

void UUIDataProvider_OnlineFriendMessages::ReadMessages()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.ReadMessages"));

	UUIDataProvider_OnlineFriendMessages_ReadMessages_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlineFriendMessages::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnUnregister"));

	UUIDataProvider_OnlineFriendMessages_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriendMessages.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_OnlineFriendMessages::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriendMessages.OnRegister"));

	UUIDataProvider_OnlineFriendMessages_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriends.RefreshFriendsList
// (Final, Defined, Iterator, Latent, Singular, Net, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlineFriends::RefreshFriendsList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriends.RefreshFriendsList"));

	UUIDataProvider_OnlineFriends_RefreshFriendsList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriends.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlineFriends::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriends.OnLoginChange"));

	UUIDataProvider_OnlineFriends_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriends.OnFriendsReadComplete
// (Final, Defined, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UUIDataProvider_OnlineFriends::STATIC_OnFriendsReadComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriends.OnFriendsReadComplete"));

	UUIDataProvider_OnlineFriends_OnFriendsReadComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriends.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlineFriends::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriends.OnUnregister"));

	UUIDataProvider_OnlineFriends_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineFriends.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_OnlineFriends::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineFriends.OnRegister"));

	UUIDataProvider_OnlineFriends_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePartyChatList.RefreshMembersList
// (PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlinePartyChatList::RefreshMembersList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePartyChatList.RefreshMembersList"));

	UUIDataProvider_OnlinePartyChatList_RefreshMembersList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePartyChatList.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlinePartyChatList::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePartyChatList.OnLoginChange"));

	UUIDataProvider_OnlinePartyChatList_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePartyChatList.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlinePartyChatList::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePartyChatList.OnUnregister"));

	UUIDataProvider_OnlinePartyChatList_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePartyChatList.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_OnlinePartyChatList::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePartyChatList.OnRegister"));

	UUIDataProvider_OnlinePartyChatList_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnExternalUIChange
// (Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bIsOpening                     (Parm)

void UUIDataProvider_OnlinePlayerStorage::STATIC_OnExternalUIChange(bool bIsOpening)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnExternalUIChange"));

	UUIDataProvider_OnlinePlayerStorage_OnExternalUIChange_Params params;
	params.bIsOpening = bIsOpening;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnStorageDeviceChange
// (Final, Defined, Iterator, Latent, Exec, Native, Event, Static)

void UUIDataProvider_OnlinePlayerStorage::STATIC_OnStorageDeviceChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnStorageDeviceChange"));

	UUIDataProvider_OnlinePlayerStorage_OnStorageDeviceChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnDeviceSelectionComplete
// (Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UUIDataProvider_OnlinePlayerStorage::STATIC_OnDeviceSelectionComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnDeviceSelectionComplete"));

	UUIDataProvider_OnlinePlayerStorage_OnDeviceSelectionComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.ShowDeviceSelection
// (Final, Defined, Iterator, PreOperator, Simulated, Event, HasOptionalParms)

void UUIDataProvider_OnlinePlayerStorage::ShowDeviceSelection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.ShowDeviceSelection"));

	UUIDataProvider_OnlinePlayerStorage_ShowDeviceSelection_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.RefreshStorageData
// (PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void UUIDataProvider_OnlinePlayerStorage::RefreshStorageData()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.RefreshStorageData"));

	UUIDataProvider_OnlinePlayerStorage_RefreshStorageData_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlinePlayerStorage::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnLoginChange"));

	UUIDataProvider_OnlinePlayerStorage_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnReadStorageComplete
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UUIDataProvider_OnlinePlayerStorage::STATIC_OnReadStorageComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnReadStorageComplete"));

	UUIDataProvider_OnlinePlayerStorage_OnReadStorageComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_OnlinePlayerStorage::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnUnregister"));

	UUIDataProvider_OnlinePlayerStorage_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_OnlinePlayerStorage::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.OnRegister"));

	UUIDataProvider_OnlinePlayerStorage_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.ClearReadCompleteDelegate
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlinePlayerStorage::ClearReadCompleteDelegate(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.ClearReadCompleteDelegate"));

	UUIDataProvider_OnlinePlayerStorage_ClearReadCompleteDelegate_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.AddReadCompleteDelegate
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlinePlayerStorage::AddReadCompleteDelegate(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.AddReadCompleteDelegate"));

	UUIDataProvider_OnlinePlayerStorage_AddReadCompleteDelegate_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.GetData
// (Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlinePlayerStorage::GetData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.GetData"));

	UUIDataProvider_OnlinePlayerStorage_GetData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.WriteData
// (Final, Defined, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlinePlayerStorage::WriteData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum, int DeviceID, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.WriteData"));

	UUIDataProvider_OnlinePlayerStorage_WriteData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlinePlayerStorage.ReadData
// (Final, Defined, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlinePlayerStorage::ReadData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum, int DeviceID, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlinePlayerStorage.ReadData"));

	UUIDataProvider_OnlinePlayerStorage_ReadData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.OnStorageDeviceChange
// (Final, Defined, Iterator, Latent, Exec, Native, Event, Static)

void UUIDataProvider_OnlineProfileSettings::STATIC_OnStorageDeviceChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.OnStorageDeviceChange"));

	UUIDataProvider_OnlineProfileSettings_OnStorageDeviceChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.RefreshStorageData
// (PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void UUIDataProvider_OnlineProfileSettings::RefreshStorageData()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.RefreshStorageData"));

	UUIDataProvider_OnlineProfileSettings_RefreshStorageData_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.ClearReadCompleteDelegate
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlineProfileSettings::ClearReadCompleteDelegate(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.ClearReadCompleteDelegate"));

	UUIDataProvider_OnlineProfileSettings_ClearReadCompleteDelegate_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.AddReadCompleteDelegate
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_OnlineProfileSettings::AddReadCompleteDelegate(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.AddReadCompleteDelegate"));

	UUIDataProvider_OnlineProfileSettings_AddReadCompleteDelegate_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.GetData
// (Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlineProfileSettings::GetData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.GetData"));

	UUIDataProvider_OnlineProfileSettings_GetData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.WriteData
// (Final, Defined, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlineProfileSettings::WriteData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum, int DeviceID, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.WriteData"));

	UUIDataProvider_OnlineProfileSettings_WriteData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_OnlineProfileSettings.ReadData
// (Final, Defined, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// TScriptInterface<class UOnlinePlayerInterface> PlayerInterface                (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataProvider_OnlineProfileSettings::ReadData(const TScriptInterface<class UOnlinePlayerInterface>& PlayerInterface, unsigned char LocalUserNum, int DeviceID, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_OnlineProfileSettings.ReadData"));

	UUIDataProvider_OnlineProfileSettings_ReadData_Params params;
	params.PlayerInterface = PlayerInterface;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_PlayerAchievements.UpdateAchievements
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)

void UUIDataProvider_PlayerAchievements::UpdateAchievements()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.UpdateAchievements"));

	UUIDataProvider_PlayerAchievements_UpdateAchievements_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataProvider_PlayerAchievements::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.OnLoginChange"));

	UUIDataProvider_PlayerAchievements_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataProvider_PlayerAchievements::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.OnUnregister"));

	UUIDataProvider_PlayerAchievements_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataProvider_PlayerAchievements::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.OnRegister"));

	UUIDataProvider_PlayerAchievements_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.OnPlayerAchievementUnlocked
// (Final, Defined, Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UUIDataProvider_PlayerAchievements::STATIC_OnPlayerAchievementUnlocked(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.OnPlayerAchievementUnlocked"));

	UUIDataProvider_PlayerAchievements_OnPlayerAchievementUnlocked_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.OnPlayerAchievementsChanged
// (Defined, Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// int                            TitleId                        (Parm)

void UUIDataProvider_PlayerAchievements::STATIC_OnPlayerAchievementsChanged(int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.OnPlayerAchievementsChanged"));

	UUIDataProvider_PlayerAchievements_OnPlayerAchievementsChanged_Params params;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.GetAchievementDetails
// (Defined, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// int                            AchievementId                  (Const, Parm)
// struct FAchievementDetails     OutAchievementDetails          (Parm, OutParm, NeedCtorLink)

void UUIDataProvider_PlayerAchievements::STATIC_GetAchievementDetails(int AchievementId, struct FAchievementDetails* OutAchievementDetails)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.GetAchievementDetails"));

	UUIDataProvider_PlayerAchievements_GetAchievementDetails_Params params;
	params.AchievementId = AchievementId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAchievementDetails != nullptr)
		*OutAchievementDetails = params.OutAchievementDetails;
}


// Function Engine.UIDataProvider_PlayerAchievements.GetAchievementIconPathName
// (Final, Defined, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// int                            AchievementId                  (Parm)
// bool                           bReturnLockedIcon              (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UUIDataProvider_PlayerAchievements::STATIC_GetAchievementIconPathName(int AchievementId, bool bReturnLockedIcon)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.GetAchievementIconPathName"));

	UUIDataProvider_PlayerAchievements_GetAchievementIconPathName_Params params;
	params.AchievementId = AchievementId;
	params.bReturnLockedIcon = bReturnLockedIcon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_PlayerAchievements.PopulateAchievementIcons
// (Singular, Net, NetReliable, HasOptionalParms)

void UUIDataProvider_PlayerAchievements::PopulateAchievementIcons()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.PopulateAchievementIcons"));

	UUIDataProvider_PlayerAchievements_PopulateAchievementIcons_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataProvider_PlayerAchievements.GetMaxTotalGamerScore
// (Defined, Iterator, PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataProvider_PlayerAchievements::STATIC_GetMaxTotalGamerScore()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.GetMaxTotalGamerScore"));

	UUIDataProvider_PlayerAchievements_GetMaxTotalGamerScore_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataProvider_PlayerAchievements.GetTotalGamerScore
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataProvider_PlayerAchievements::STATIC_GetTotalGamerScore()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataProvider_PlayerAchievements.GetTotalGamerScore"));

	UUIDataProvider_PlayerAchievements_GetTotalGamerScore_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore.GetDataStoreClient
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UDataStoreClient*        ReturnValue                    (Parm, OutParm, ReturnParm)

class UDataStoreClient* UUIDataStore::STATIC_GetDataStoreClient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.GetDataStoreClient"));

	UUIDataStore_GetDataStoreClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore.RefreshSubscribers
// (Defined, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   PropertyTag                    (OptionalParm, Parm)
// bool                           bInvalidateValues              (OptionalParm, Parm)
// class UUIDataProvider*         SourceProvider                 (OptionalParm, Parm)
// int                            ArrayIndex                     (OptionalParm, Parm)

void UUIDataStore::RefreshSubscribers(const struct FName& PropertyTag, bool bInvalidateValues, class UUIDataProvider* SourceProvider, int ArrayIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.RefreshSubscribers"));

	UUIDataStore_RefreshSubscribers_Params params;
	params.PropertyTag = PropertyTag;
	params.bInvalidateValues = bInvalidateValues;
	params.SourceProvider = SourceProvider;
	params.ArrayIndex = ArrayIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.NotifyGameSessionEnded"));

	UUIDataStore_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore.SubscriberDetached
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TScriptInterface<class UUIDataStoreSubscriber> Subscriber                     (Parm)

void UUIDataStore::SubscriberDetached(const TScriptInterface<class UUIDataStoreSubscriber>& Subscriber)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.SubscriberDetached"));

	UUIDataStore_SubscriberDetached_Params params;
	params.Subscriber = Subscriber;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore.SubscriberAttached
// (Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TScriptInterface<class UUIDataStoreSubscriber> Subscriber                     (Parm)

void UUIDataStore::SubscriberAttached(const TScriptInterface<class UUIDataStoreSubscriber>& Subscriber)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.SubscriberAttached"));

	UUIDataStore_SubscriberAttached_Params params;
	params.Subscriber = Subscriber;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore.Unregistered
// (Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore::Unregistered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.Unregistered"));

	UUIDataStore_Unregistered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore.Registered
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore::Registered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.Registered"));

	UUIDataStore_Registered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore.OnDataStoreValueUpdated
// (PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// class UUIDataStore*            SourceDataStore                (Parm)
// bool                           bValuesInvalidated             (Parm)
// struct FName                   PropertyTag                    (Parm)
// class UUIDataProvider*         SourceProvider                 (Parm)
// int                            ArrayIndex                     (Parm)

void UUIDataStore::OnDataStoreValueUpdated(class UUIDataStore* SourceDataStore, bool bValuesInvalidated, const struct FName& PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore.OnDataStoreValueUpdated"));

	UUIDataStore_OnDataStoreValueUpdated_Params params;
	params.SourceDataStore = SourceDataStore;
	params.bValuesInvalidated = bValuesInvalidated;
	params.PropertyTag = PropertyTag;
	params.SourceProvider = SourceProvider;
	params.ArrayIndex = ArrayIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_DynamicResource.Unregistered
// (Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_DynamicResource::Unregistered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_DynamicResource.Unregistered"));

	UUIDataStore_DynamicResource_Unregistered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_DynamicResource.Registered
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_DynamicResource::Registered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_DynamicResource.Registered"));

	UUIDataStore_DynamicResource_Registered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_DynamicResource.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataStore_DynamicResource::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_DynamicResource.OnLoginChange"));

	UUIDataStore_DynamicResource_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_DynamicResource.GetResourceProviders
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ProviderTag                    (Parm)
// TArray<class UUIResourceCombinationProvider*> out_Providers                  (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_DynamicResource::STATIC_GetResourceProviders(const struct FName& ProviderTag, TArray<class UUIResourceCombinationProvider*>* out_Providers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_DynamicResource.GetResourceProviders"));

	UUIDataStore_DynamicResource_GetResourceProviders_Params params;
	params.ProviderTag = ProviderTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Providers != nullptr)
		*out_Providers = params.out_Providers;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_DynamicResource.FindProviderTypeIndex
// (PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ProviderTag                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_DynamicResource::STATIC_FindProviderTypeIndex(const struct FName& ProviderTag)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_DynamicResource.FindProviderTypeIndex"));

	UUIDataStore_DynamicResource_FindProviderTypeIndex_Params params;
	params.ProviderTag = ProviderTag;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_GameResource.GetResourceProviders
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   ProviderTag                    (Parm)
// TArray<class UUIResourceDataProvider*> out_Providers                  (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_GameResource::STATIC_GetResourceProviders(const struct FName& ProviderTag, TArray<class UUIResourceDataProvider*>* out_Providers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_GameResource.GetResourceProviders"));

	UUIDataStore_GameResource_GetResourceProviders_Params params;
	params.ProviderTag = ProviderTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Providers != nullptr)
		*out_Providers = params.out_Providers;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_GameResource.FindProviderTypeIndex
// (PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ProviderTag                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_GameResource::STATIC_FindProviderTypeIndex(const struct FName& ProviderTag)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_GameResource.FindProviderTypeIndex"));

	UUIDataStore_GameResource_FindProviderTypeIndex_Params params;
	params.ProviderTag = ProviderTag;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_MenuItems.Unregistered
// (Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_MenuItems::Unregistered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_MenuItems.Unregistered"));

	UUIDataStore_MenuItems_Unregistered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_MenuItems.Registered
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_MenuItems::Registered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_MenuItems.Registered"));

	UUIDataStore_MenuItems_Registered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_MenuItems.OnGameSettingsChanged
// (Defined, Iterator, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class UUIDataProvider*         SourceProvider                 (Parm)
// struct FName                   PropTag                        (OptionalParm, Parm)

void UUIDataStore_MenuItems::STATIC_OnGameSettingsChanged(class UUIDataProvider* SourceProvider, const struct FName& PropTag)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_MenuItems.OnGameSettingsChanged"));

	UUIDataStore_MenuItems_OnGameSettingsChanged_Params params;
	params.SourceProvider = SourceProvider;
	params.PropTag = PropTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_GameState.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_GameState::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_GameState.NotifyGameSessionEnded"));

	UUIDataStore_GameState_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_GameState.OnRefreshDataFieldValue
// (Iterator, Singular, Exec, Native, HasOptionalParms)

void UUIDataStore_GameState::OnRefreshDataFieldValue()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_GameState.OnRefreshDataFieldValue"));

	UUIDataStore_GameState_OnRefreshDataFieldValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_Registry.SetData
// (Defined, Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Parm, NeedCtorLink)
// struct FString                 Value                          (Parm, NeedCtorLink)

void UUIDataStore_Registry::SetData(const struct FString& Key, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_Registry.SetData"));

	UUIDataStore_Registry_SetData_Params params;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_Registry.GetData
// (Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Key                            (Parm, NeedCtorLink)
// struct FString                 out_Data                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_Registry::GetData(const struct FString& Key, struct FString* out_Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_Registry.GetData"));

	UUIDataStore_Registry_GetData_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Data != nullptr)
		*out_Data = params.out_Data;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.ClearAllSearchResults
// (Final, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void UUIDataStore_OnlineGameSearch::ClearAllSearchResults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.ClearAllSearchResults"));

	UUIDataStore_OnlineGameSearch_ClearAllSearchResults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.MoveToPrevious
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bInvalidateExistingSearchResults (OptionalParm, Parm)

void UUIDataStore_OnlineGameSearch::MoveToPrevious(bool bInvalidateExistingSearchResults)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.MoveToPrevious"));

	UUIDataStore_OnlineGameSearch_MoveToPrevious_Params params;
	params.bInvalidateExistingSearchResults = bInvalidateExistingSearchResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.MoveToNext
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bInvalidateExistingSearchResults (OptionalParm, Parm)

void UUIDataStore_OnlineGameSearch::MoveToNext(bool bInvalidateExistingSearchResults)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.MoveToNext"));

	UUIDataStore_OnlineGameSearch_MoveToNext_Params params;
	params.bInvalidateExistingSearchResults = bInvalidateExistingSearchResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.SetCurrentByName
// (Final, Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SearchName                     (Parm)
// bool                           bInvalidateExistingSearchResults (OptionalParm, Parm)

void UUIDataStore_OnlineGameSearch::SetCurrentByName(const struct FName& SearchName, bool bInvalidateExistingSearchResults)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.SetCurrentByName"));

	UUIDataStore_OnlineGameSearch_SetCurrentByName_Params params;
	params.SearchName = SearchName;
	params.bInvalidateExistingSearchResults = bInvalidateExistingSearchResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.SetCurrentByIndex
// (Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            NewIndex                       (Parm)
// bool                           bInvalidateExistingSearchResults (OptionalParm, Parm)

void UUIDataStore_OnlineGameSearch::SetCurrentByIndex(int NewIndex, bool bInvalidateExistingSearchResults)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.SetCurrentByIndex"));

	UUIDataStore_OnlineGameSearch_SetCurrentByIndex_Params params;
	params.NewIndex = NewIndex;
	params.bInvalidateExistingSearchResults = bInvalidateExistingSearchResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.FindSearchConfigurationIndex
// (Iterator, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   SearchTag                      (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_OnlineGameSearch::STATIC_FindSearchConfigurationIndex(const struct FName& SearchTag)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.FindSearchConfigurationIndex"));

	UUIDataStore_OnlineGameSearch_FindSearchConfigurationIndex_Params params;
	params.SearchTag = SearchTag;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.GetActiveGameSearch
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UOnlineGameSearch*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineGameSearch* UUIDataStore_OnlineGameSearch::GetActiveGameSearch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.GetActiveGameSearch"));

	UUIDataStore_OnlineGameSearch_GetActiveGameSearch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.GetCurrentGameSearch
// (Final, Defined, Iterator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UOnlineGameSearch*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineGameSearch* UUIDataStore_OnlineGameSearch::GetCurrentGameSearch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.GetCurrentGameSearch"));

	UUIDataStore_OnlineGameSearch_GetCurrentGameSearch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.ShowHostGamercard
// (Iterator, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ControllerIndex                (Parm)
// int                            ListIndex                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSearch::ShowHostGamercard(unsigned char ControllerIndex, int ListIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.ShowHostGamercard"));

	UUIDataStore_OnlineGameSearch_ShowHostGamercard_Params params;
	params.ControllerIndex = ControllerIndex;
	params.ListIndex = ListIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.GetSearchResultFromIndex
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ListIndex                      (Parm)
// struct FOnlineGameSearchResult Result                         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSearch::GetSearchResultFromIndex(int ListIndex, struct FOnlineGameSearchResult* Result)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.GetSearchResultFromIndex"));

	UUIDataStore_OnlineGameSearch_GetSearchResultFromIndex_Params params;
	params.ListIndex = ListIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.OnSearchComplete
// (Simulated, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UUIDataStore_OnlineGameSearch::STATIC_OnSearchComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.OnSearchComplete"));

	UUIDataStore_OnlineGameSearch_OnSearchComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSearch.OverrideQuerySubmission
// (Final, Latent, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  ControllerId                   (Parm)
// class UOnlineGameSearch*       Search                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSearch::STATIC_OverrideQuerySubmission(unsigned char ControllerId, class UOnlineGameSearch* Search)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.OverrideQuerySubmission"));

	UUIDataStore_OnlineGameSearch_OverrideQuerySubmission_Params params;
	params.ControllerId = ControllerId;
	params.Search = Search;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.SubmitGameSearch
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ControllerIndex                (Parm)
// bool                           bInvalidateExistingSearchResults (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSearch::SubmitGameSearch(unsigned char ControllerIndex, bool bInvalidateExistingSearchResults)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.SubmitGameSearch"));

	UUIDataStore_OnlineGameSearch_SubmitGameSearch_Params params;
	params.ControllerIndex = ControllerIndex;
	params.bInvalidateExistingSearchResults = bInvalidateExistingSearchResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.InvalidateCurrentSearchResults
// (Final, Defined, Latent, PreOperator, Net, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSearch::STATIC_InvalidateCurrentSearchResults()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.InvalidateCurrentSearchResults"));

	UUIDataStore_OnlineGameSearch_InvalidateCurrentSearchResults_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSearch.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UUIDataStore_OnlineGameSearch::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSearch.Init"));

	UUIDataStore_OnlineGameSearch_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.GetCachedPlayerStorage
// (Final, Defined, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// class UOnlinePlayerStorage*    ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlinePlayerStorage* UUIDataStore_OnlinePlayerData::GetCachedPlayerStorage(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.GetCachedPlayerStorage"));

	UUIDataStore_OnlinePlayerData_GetCachedPlayerStorage_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlinePlayerData.GetCachedPlayerProfile
// (Defined, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ControllerId                   (Parm)
// class UOnlineProfileSettings*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineProfileSettings* UUIDataStore_OnlinePlayerData::GetCachedPlayerProfile(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.GetCachedPlayerProfile"));

	UUIDataStore_OnlinePlayerData_GetCachedPlayerProfile_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlinePlayerData.ClearDelegates
// (Final, Defined, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, Operator)

void UUIDataStore_OnlinePlayerData::ClearDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.ClearDelegates"));

	UUIDataStore_OnlinePlayerData_ClearDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.RegisterDelegates
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void UUIDataStore_OnlinePlayerData::RegisterDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.RegisterDelegates"));

	UUIDataStore_OnlinePlayerData_RegisterDelegates_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.OnPlayerDataChange
// (Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)

void UUIDataStore_OnlinePlayerData::STATIC_OnPlayerDataChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.OnPlayerDataChange"));

	UUIDataStore_OnlinePlayerData_OnPlayerDataChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UUIDataStore_OnlinePlayerData::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.OnLoginChange"));

	UUIDataStore_OnlinePlayerData_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.OnUnregister
// (Final, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UUIDataStore_OnlinePlayerData::OnUnregister()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.OnUnregister"));

	UUIDataStore_OnlinePlayerData_OnUnregister_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlinePlayerData.OnRegister
// (Final, Iterator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            InPlayer                       (Parm)

void UUIDataStore_OnlinePlayerData::OnRegister(class ULocalPlayer* InPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlinePlayerData.OnRegister"));

	UUIDataStore_OnlinePlayerData_OnRegister_Params params;
	params.InPlayer = InPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineStats.SortResultsByRank
// (Final, Iterator, Latent, PreOperator, Exec, Event, HasOptionalParms)
// Parameters:
// class UOnlineStatsRead*        StatsToSort                    (Parm)

void UUIDataStore_OnlineStats::SortResultsByRank(class UOnlineStatsRead* StatsToSort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.SortResultsByRank"));

	UUIDataStore_OnlineStats_SortResultsByRank_Params params;
	params.StatsToSort = StatsToSort;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineStats.OnReadComplete
// (Final, Iterator, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UUIDataStore_OnlineStats::OnReadComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.OnReadComplete"));

	UUIDataStore_OnlineStats_OnReadComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineStats.ShowGamercard
// (Final, Defined, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ConrollerIndex                 (Parm)
// int                            ListIndex                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineStats::ShowGamercard(unsigned char ConrollerIndex, int ListIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.ShowGamercard"));

	UUIDataStore_OnlineStats_ShowGamercard_Params params;
	params.ConrollerIndex = ConrollerIndex;
	params.ListIndex = ListIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineStats.RefreshStats
// (Final, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ControllerIndex                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineStats::RefreshStats(unsigned char ControllerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.RefreshStats"));

	UUIDataStore_OnlineStats_RefreshStats_Params params;
	params.ControllerIndex = ControllerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineStats.SetStatsReadInfo
// (Final, Defined, NetReliable, Event, HasOptionalParms)

void UUIDataStore_OnlineStats::SetStatsReadInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.SetStatsReadInfo"));

	UUIDataStore_OnlineStats_SetStatsReadInfo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineStats.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UUIDataStore_OnlineStats::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineStats.Init"));

	UUIDataStore_OnlineStats_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.Unregistered
// (Defined, Iterator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_OnlineGameSettings::Unregistered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.Unregistered"));

	UUIDataStore_OnlineGameSettings_Unregistered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.Registered
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class ULocalPlayer*            PlayerOwner                    (Parm)

void UUIDataStore_OnlineGameSettings::Registered(class ULocalPlayer* PlayerOwner)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.Registered"));

	UUIDataStore_OnlineGameSettings_Registered_Params params;
	params.PlayerOwner = PlayerOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.MoveToPrevious
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UUIDataStore_OnlineGameSettings::MoveToPrevious()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.MoveToPrevious"));

	UUIDataStore_OnlineGameSettings_MoveToPrevious_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.MoveToNext
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UUIDataStore_OnlineGameSettings::MoveToNext()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.MoveToNext"));

	UUIDataStore_OnlineGameSettings_MoveToNext_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.SetCurrentByName
// (Final, Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SettingsName                   (Parm)

void UUIDataStore_OnlineGameSettings::SetCurrentByName(const struct FName& SettingsName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.SetCurrentByName"));

	UUIDataStore_OnlineGameSettings_SetCurrentByName_Params params;
	params.SettingsName = SettingsName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.SetCurrentByIndex
// (Iterator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            NewIndex                       (Parm)

void UUIDataStore_OnlineGameSettings::SetCurrentByIndex(int NewIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.SetCurrentByIndex"));

	UUIDataStore_OnlineGameSettings_SetCurrentByIndex_Params params;
	params.NewIndex = NewIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIDataStore_OnlineGameSettings.GetCurrentProvider
// (Final, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UUIDataProvider_Settings* ReturnValue                    (Parm, OutParm, ReturnParm)

class UUIDataProvider_Settings* UUIDataStore_OnlineGameSettings::GetCurrentProvider()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.GetCurrentProvider"));

	UUIDataStore_OnlineGameSettings_GetCurrentProvider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSettings.GetCurrentGameSettings
// (Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class UOnlineGameSettings*     ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineGameSettings* UUIDataStore_OnlineGameSettings::GetCurrentGameSettings()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.GetCurrentGameSettings"));

	UUIDataStore_OnlineGameSettings_GetCurrentGameSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_OnlineGameSettings.CreateGame
// (Final, Defined, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// unsigned char                  ControllerIndex                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_OnlineGameSettings::CreateGame(unsigned char ControllerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_OnlineGameSettings.CreateGame"));

	UUIDataStore_OnlineGameSettings_CreateGame_Params params;
	params.ControllerIndex = ControllerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.HasAliasMappingForPlatform
// (Final, Net, NetReliable, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FName                   DesiredAlias                   (Parm)
// TEnumAsByte<EInputPlatformType> DesiredPlatform                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_InputAlias::STATIC_HasAliasMappingForPlatform(const struct FName& DesiredAlias, TEnumAsByte<EInputPlatformType> DesiredPlatform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.HasAliasMappingForPlatform"));

	UUIDataStore_InputAlias_HasAliasMappingForPlatform_Params params;
	params.DesiredAlias = DesiredAlias;
	params.DesiredPlatform = DesiredPlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.FindInputAliasIndex
// (Final, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   DesiredAlias                   (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_InputAlias::STATIC_FindInputAliasIndex(const struct FName& DesiredAlias)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.FindInputAliasIndex"));

	UUIDataStore_InputAlias_FindInputAliasIndex_Params params;
	params.DesiredAlias = DesiredAlias;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasInputKeyDataByIndex
// (Defined, Iterator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FRawInputKeyEventData   out_InputKeyData               (Parm, OutParm)
// int                            AliasIndex                     (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_InputAlias::STATIC_GetAliasInputKeyDataByIndex(int AliasIndex, TEnumAsByte<EInputPlatformType> OverridePlatform, struct FRawInputKeyEventData* out_InputKeyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasInputKeyDataByIndex"));

	UUIDataStore_InputAlias_GetAliasInputKeyDataByIndex_Params params;
	params.AliasIndex = AliasIndex;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_InputKeyData != nullptr)
		*out_InputKeyData = params.out_InputKeyData;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasInputKeyData
// (Final, Iterator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FRawInputKeyEventData   out_InputKeyData               (Parm, OutParm)
// struct FName                   DesiredAlias                   (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIDataStore_InputAlias::STATIC_GetAliasInputKeyData(const struct FName& DesiredAlias, TEnumAsByte<EInputPlatformType> OverridePlatform, struct FRawInputKeyEventData* out_InputKeyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasInputKeyData"));

	UUIDataStore_InputAlias_GetAliasInputKeyData_Params params;
	params.DesiredAlias = DesiredAlias;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_InputKeyData != nullptr)
		*out_InputKeyData = params.out_InputKeyData;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasInputKeyNameByIndex
// (Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            AliasIndex                     (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UUIDataStore_InputAlias::STATIC_GetAliasInputKeyNameByIndex(int AliasIndex, TEnumAsByte<EInputPlatformType> OverridePlatform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasInputKeyNameByIndex"));

	UUIDataStore_InputAlias_GetAliasInputKeyNameByIndex_Params params;
	params.AliasIndex = AliasIndex;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasInputKeyName
// (Final, Defined, Iterator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   DesiredAlias                   (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName UUIDataStore_InputAlias::STATIC_GetAliasInputKeyName(const struct FName& DesiredAlias, TEnumAsByte<EInputPlatformType> OverridePlatform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasInputKeyName"));

	UUIDataStore_InputAlias_GetAliasInputKeyName_Params params;
	params.DesiredAlias = DesiredAlias;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasFontMarkupByIndex
// (Iterator, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            AliasIndex                     (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UUIDataStore_InputAlias::STATIC_GetAliasFontMarkupByIndex(int AliasIndex, TEnumAsByte<EInputPlatformType> OverridePlatform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasFontMarkupByIndex"));

	UUIDataStore_InputAlias_GetAliasFontMarkupByIndex_Params params;
	params.AliasIndex = AliasIndex;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_InputAlias.GetAliasFontMarkup
// (Final, Defined, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   DesiredAlias                   (Parm)
// TEnumAsByte<EInputPlatformType> OverridePlatform               (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UUIDataStore_InputAlias::STATIC_GetAliasFontMarkup(const struct FName& DesiredAlias, TEnumAsByte<EInputPlatformType> OverridePlatform)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_InputAlias.GetAliasFontMarkup"));

	UUIDataStore_InputAlias_GetAliasFontMarkup_Params params;
	params.DesiredAlias = DesiredAlias;
	params.OverridePlatform = OverridePlatform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_StringAliasMap.GetStringWithFieldName
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 FieldName                      (Parm, NeedCtorLink)
// struct FString                 MappedString                   (Parm, OutParm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_StringAliasMap::STATIC_GetStringWithFieldName(const struct FString& FieldName, struct FString* MappedString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_StringAliasMap.GetStringWithFieldName"));

	UUIDataStore_StringAliasMap_GetStringWithFieldName_Params params;
	params.FieldName = FieldName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MappedString != nullptr)
		*MappedString = params.MappedString;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_StringAliasMap.FindMappingWithFieldName
// (Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FString                 FieldName                      (OptionalParm, Parm, NeedCtorLink)
// struct FString                 SetName                        (OptionalParm, Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UUIDataStore_StringAliasMap::STATIC_FindMappingWithFieldName(const struct FString& FieldName, const struct FString& SetName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_StringAliasMap.FindMappingWithFieldName"));

	UUIDataStore_StringAliasMap_FindMappingWithFieldName_Params params;
	params.FieldName = FieldName;
	params.SetName = SetName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIDataStore_StringAliasMap.GetPlayerOwner
// (Defined, Iterator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class ULocalPlayer*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ULocalPlayer* UUIDataStore_StringAliasMap::STATIC_GetPlayerOwner()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIDataStore_StringAliasMap.GetPlayerOwner"));

	UUIDataStore_StringAliasMap_GetPlayerOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIPropertyDataProvider.CanSupportComplexPropertyType
// (Iterator, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// class UProperty*               UnsupportedProperty            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUIPropertyDataProvider::CanSupportComplexPropertyType(class UProperty* UnsupportedProperty)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIPropertyDataProvider.CanSupportComplexPropertyType"));

	UUIPropertyDataProvider_CanSupportComplexPropertyType_Params params;
	params.UnsupportedProperty = UnsupportedProperty;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UIResourceDataProvider.InitializeProvider
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bIsEditor                      (Parm)

void UUIResourceDataProvider::InitializeProvider(bool bIsEditor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIResourceDataProvider.InitializeProvider"));

	UUIResourceDataProvider_InitializeProvider_Params params;
	params.bIsEditor = bIsEditor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIResourceCombinationProvider.ClearProviderReferences
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)

void UUIResourceCombinationProvider::ClearProviderReferences()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIResourceCombinationProvider.ClearProviderReferences"));

	UUIResourceCombinationProvider_ClearProviderReferences_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UIResourceCombinationProvider.InitializeProvider
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bIsEditor                      (Parm)
// class UUIResourceDataProvider* InStaticResourceProvider       (Parm)
// class UUIDataProvider_OnlineProfileSettings* InProfileProvider              (Parm)

void UUIResourceCombinationProvider::InitializeProvider(bool bIsEditor, class UUIResourceDataProvider* InStaticResourceProvider, class UUIDataProvider_OnlineProfileSettings* InProfileProvider)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UIResourceCombinationProvider.InitializeProvider"));

	UUIResourceCombinationProvider_InitializeProvider_Params params;
	params.bIsEditor = bIsEditor;
	params.InStaticResourceProvider = InStaticResourceProvider;
	params.InProfileProvider = InProfileProvider;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.FindLocalPlayerIndex
// (Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// class UPlayer*                 P                              (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UGameUISceneClient::STATIC_FindLocalPlayerIndex(class UPlayer* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.FindLocalPlayerIndex"));

	UGameUISceneClient_FindLocalPlayerIndex_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUISceneClient.NotifyPlayerRemoved
// (Final, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            RemovedPlayer                  (Parm)

void UGameUISceneClient::STATIC_NotifyPlayerRemoved(int PlayerIndex, class ULocalPlayer* RemovedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.NotifyPlayerRemoved"));

	UGameUISceneClient_NotifyPlayerRemoved_Params params;
	params.PlayerIndex = PlayerIndex;
	params.RemovedPlayer = RemovedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.NotifyPlayerAdded
// (Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// int                            PlayerIndex                    (Parm)
// class ULocalPlayer*            AddedPlayer                    (Parm)

void UGameUISceneClient::STATIC_NotifyPlayerAdded(int PlayerIndex, class ULocalPlayer* AddedPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.NotifyPlayerAdded"));

	UGameUISceneClient_NotifyPlayerAdded_Params params;
	params.PlayerIndex = PlayerIndex;
	params.AddedPlayer = AddedPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.NotifyGameSessionEnded
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)

void UGameUISceneClient::NotifyGameSessionEnded()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.NotifyGameSessionEnded"));

	UGameUISceneClient_NotifyGameSessionEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.NotifyClientTravel
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class APlayerController*       TravellingPlayer               (Parm)
// struct FString                 TravelURL                      (Parm, NeedCtorLink)
// TEnumAsByte<ETravelType>       TravelType                     (Parm)
// bool                           bIsSeamlessTravel              (Parm)

void UGameUISceneClient::STATIC_NotifyClientTravel(class APlayerController* TravellingPlayer, const struct FString& TravelURL, TEnumAsByte<ETravelType> TravelType, bool bIsSeamlessTravel)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.NotifyClientTravel"));

	UGameUISceneClient_NotifyClientTravel_Params params;
	params.TravellingPlayer = TravellingPlayer;
	params.TravelURL = TravelURL;
	params.TravelType = TravelType;
	params.bIsSeamlessTravel = bIsSeamlessTravel;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.PauseGame
// (Final, Defined, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bDesiredPauseState             (Parm)
// int                            PlayerIndex                    (OptionalParm, Parm)

void UGameUISceneClient::PauseGame(bool bDesiredPauseState, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.PauseGame"));

	UGameUISceneClient_PauseGame_Params params;
	params.bDesiredPauseState = bDesiredPauseState;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.CanUnpauseInternalUI
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UGameUISceneClient::CanUnpauseInternalUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.CanUnpauseInternalUI"));

	UGameUISceneClient_CanUnpauseInternalUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUISceneClient.RequestInputProcessingUpdate
// (Final, Defined, Latent, PreOperator, Net, Native, HasOptionalParms)

void UGameUISceneClient::RequestInputProcessingUpdate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.RequestInputProcessingUpdate"));

	UGameUISceneClient_RequestInputProcessingUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUISceneClient.GetCurrentNetMode
// (Final, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<ENetMode>          ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENetMode> UGameUISceneClient::STATIC_GetCurrentNetMode()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.GetCurrentNetMode"));

	UGameUISceneClient_GetCurrentNetMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUISceneClient.TgFlushPlayerInput
// (Final, Latent, Singular, Net, Simulated, Native, Event, HasOptionalParms)

void UGameUISceneClient::TgFlushPlayerInput()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameUISceneClient.TgFlushPlayerInput"));

	UGameUISceneClient_TgFlushPlayerInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedFoliageActor.ForceRemoveStreamGroups
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Event, Static)

void AInstancedFoliageActor::STATIC_ForceRemoveStreamGroups()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InstancedFoliageActor.ForceRemoveStreamGroups"));

	AInstancedFoliageActor_ForceRemoveStreamGroups_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedFoliageActor.QueueRemoveStreamGroups
// (Final, Iterator, Latent, NetReliable, Exec, HasOptionalParms)

void AInstancedFoliageActor::QueueRemoveStreamGroups()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InstancedFoliageActor.QueueRemoveStreamGroups"));

	AInstancedFoliageActor_QueueRemoveStreamGroups_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedFoliageActor.AddStreamGroups
// (Final, Defined, Iterator, Latent, Singular, Operator)

void AInstancedFoliageActor::AddStreamGroups()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InstancedFoliageActor.AddStreamGroups"));

	AInstancedFoliageActor_AddStreamGroups_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedFoliageActor.GenerateStreamGroups
// (Final, Defined, Latent, Singular, Simulated, Native, Event, Static)

void AInstancedFoliageActor::STATIC_GenerateStreamGroups()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InstancedFoliageActor.GenerateStreamGroups"));

	AInstancedFoliageActor_GenerateStreamGroups_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InteractiveFoliageActor.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AInteractiveFoliageActor::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InteractiveFoliageActor.Touch"));

	AInteractiveFoliageActor_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InteractiveFoliageActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AInteractiveFoliageActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InteractiveFoliageActor.TakeDamage"));

	AInteractiveFoliageActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidInfluenceActor.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AFluidInfluenceActor::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidInfluenceActor.ReplicatedEvent"));

	AFluidInfluenceActor_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidInfluenceActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void AFluidInfluenceActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidInfluenceActor.OnToggle"));

	AFluidInfluenceActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidSurfaceActor.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AFluidSurfaceActor::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidSurfaceActor.Touch"));

	AFluidSurfaceActor_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidSurfaceActor.TakeDamage
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Damage                         (Parm)
// class AController*             EventInstigator                (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 Momentum                       (Parm)
// class UClass*                  DamageType                     (Parm)
// struct FTraceHitInfo           HitInfo                        (OptionalParm, Parm)
// class AActor*                  DamageCauser                   (OptionalParm, Parm)

void AFluidSurfaceActor::TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidSurfaceActor.TakeDamage"));

	AFluidSurfaceActor_TakeDamage_Params params;
	params.Damage = Damage;
	params.EventInstigator = EventInstigator;
	params.HitLocation = HitLocation;
	params.Momentum = Momentum;
	params.DamageType = DamageType;
	params.HitInfo = HitInfo;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidSurfaceComponent.SetSimulationPosition
// (Defined, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FVector                 WorldPos                       (Parm)

void UFluidSurfaceComponent::SetSimulationPosition(const struct FVector& WorldPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidSurfaceComponent.SetSimulationPosition"));

	UFluidSurfaceComponent_SetSimulationPosition_Params params;
	params.WorldPos = WorldPos;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidSurfaceComponent.SetDetailPosition
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 WorldPos                       (Parm)

void UFluidSurfaceComponent::SetDetailPosition(const struct FVector& WorldPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidSurfaceComponent.SetDetailPosition"));

	UFluidSurfaceComponent_SetDetailPosition_Params params;
	params.WorldPos = WorldPos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FluidSurfaceComponent.ApplyForce
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct FVector                 WorldPos                       (Parm)
// float                          Strength                       (Parm)
// float                          Radius                         (Parm)
// bool                           bImpulse                       (OptionalParm, Parm)

void UFluidSurfaceComponent::ApplyForce(const struct FVector& WorldPos, float Strength, float Radius, bool bImpulse)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FluidSurfaceComponent.ApplyForce"));

	UFluidSurfaceComponent_ApplyForce_Params params;
	params.WorldPos = WorldPos;
	params.Strength = Strength;
	params.Radius = Radius;
	params.bImpulse = bImpulse;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpeedTreeComponent.SetMaterial
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<ESpeedTreeMeshType> MeshType                       (Parm)
// class UMaterialInterface*      Material                       (Parm)

void USpeedTreeComponent::SetMaterial(TEnumAsByte<ESpeedTreeMeshType> MeshType, class UMaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpeedTreeComponent.SetMaterial"));

	USpeedTreeComponent_SetMaterial_Params params;
	params.MeshType = MeshType;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpeedTreeComponent.GetMaterial
// (PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<ESpeedTreeMeshType> MeshType                       (Parm)
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInterface* USpeedTreeComponent::STATIC_GetMaterial(TEnumAsByte<ESpeedTreeMeshType> MeshType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpeedTreeComponent.GetMaterial"));

	USpeedTreeComponent_GetMaterial_Params params;
	params.MeshType = MeshType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LensFlareSource.SetActorParameter
// (Final, Defined, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// class AActor*                  Param                          (Parm)

void ALensFlareSource::SetActorParameter(const struct FName& ParameterName, class AActor* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetActorParameter"));

	ALensFlareSource_SetActorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.SetExtColorParameter
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Red                            (Parm)
// float                          Green                          (Parm)
// float                          Blue                           (Parm)
// float                          Alpha                          (Parm)

void ALensFlareSource::SetExtColorParameter(const struct FName& ParameterName, float Red, float Green, float Blue, float Alpha)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetExtColorParameter"));

	ALensFlareSource_SetExtColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Red = Red;
	params.Green = Green;
	params.Blue = Blue;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.SetColorParameter
// (Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FLinearColor            Param                          (Parm)

void ALensFlareSource::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetColorParameter"));

	ALensFlareSource_SetColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.SetVectorParameter
// (Final, Iterator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// struct FVector                 Param                          (Parm)

void ALensFlareSource::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetVectorParameter"));

	ALensFlareSource_SetVectorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.SetFloatParameter
// (Iterator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   ParameterName                  (Parm)
// float                          Param                          (Parm)

void ALensFlareSource::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetFloatParameter"));

	ALensFlareSource_SetFloatParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ALensFlareSource::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.ReplicatedEvent"));

	ALensFlareSource_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ALensFlareSource::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.OnToggle"));

	ALensFlareSource_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ALensFlareSource::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.PostBeginPlay"));

	ALensFlareSource_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareSource.SetTemplate
// (Final, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class ULensFlare*              NewTemplate                    (Parm)

void ALensFlareSource::SetTemplate(class ULensFlare* NewTemplate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareSource.SetTemplate"));

	ALensFlareSource_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareComponent.CreateAndSetMaterialInstanceConstant
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Static)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInstanceConstant* ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInstanceConstant* ULensFlareComponent::STATIC_CreateAndSetMaterialInstanceConstant(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.CreateAndSetMaterialInstanceConstant"));

	ULensFlareComponent_CreateAndSetMaterialInstanceConstant_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LensFlareComponent.SetMaterial
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInterface*      Material                       (Parm)

void ULensFlareComponent::SetMaterial(int ElementIndex, class UMaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.SetMaterial"));

	ULensFlareComponent_SetMaterial_Params params;
	params.ElementIndex = ElementIndex;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareComponent.GetMaterial
// (PreOperator, Singular, Exec, Native, Event, Static)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ReturnParm)

class UMaterialInterface* ULensFlareComponent::STATIC_GetMaterial(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.GetMaterial"));

	ULensFlareComponent_GetMaterial_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LensFlareComponent.SetIsActive
// (Final, Defined, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInIsActive                    (Parm)

void ULensFlareComponent::SetIsActive(bool bInIsActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.SetIsActive"));

	ULensFlareComponent_SetIsActive_Params params;
	params.bInIsActive = bInIsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareComponent.SetSourceColor
// (Iterator, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FLinearColor            InSourceColor                  (Parm)

void ULensFlareComponent::SetSourceColor(const struct FLinearColor& InSourceColor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.SetSourceColor"));

	ULensFlareComponent_SetSourceColor_Params params;
	params.InSourceColor = InSourceColor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LensFlareComponent.SetTemplate
// (Final, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class ULensFlare*              NewTemplate                    (Parm)
// bool                           bForceSet                      (OptionalParm, Parm)

void ULensFlareComponent::SetTemplate(class ULensFlare* NewTemplate, bool bForceSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LensFlareComponent.SetTemplate"));

	ULensFlareComponent_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;
	params.bForceSet = bForceSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureFlipBook.SetCurrentFrame
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Row                            (Parm)
// int                            Col                            (Parm)

void UTextureFlipBook::SetCurrentFrame(int Row, int Col)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureFlipBook.SetCurrentFrame"));

	UTextureFlipBook_SetCurrentFrame_Params params;
	params.Row = Row;
	params.Col = Col;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureFlipBook.Stop
// (Final, Defined, Iterator, Latent, Singular, Net, Exec)

void UTextureFlipBook::Stop()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureFlipBook.Stop"));

	UTextureFlipBook_Stop_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureFlipBook.Pause
// (Defined, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UTextureFlipBook::Pause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureFlipBook.Pause"));

	UTextureFlipBook_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureFlipBook.Play
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UTextureFlipBook::Play()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureFlipBook.Play"));

	UTextureFlipBook_Play_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Texture2DComposite.ResetSourceRegions
// (Latent, NetReliable, Native, HasOptionalParms)

void UTexture2DComposite::ResetSourceRegions()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DComposite.ResetSourceRegions"));

	UTexture2DComposite_ResetSourceRegions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Texture2DComposite.UpdateCompositeTexture
// (Iterator, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            NumMipsToGenerate              (Parm)

void UTexture2DComposite::UpdateCompositeTexture(int NumMipsToGenerate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DComposite.UpdateCompositeTexture"));

	UTexture2DComposite_UpdateCompositeTexture_Params params;
	params.NumMipsToGenerate = NumMipsToGenerate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Texture2DComposite.SourceTexturesFullyStreamedIn
// (Final, Defined, Iterator, Latent, Singular, Net, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTexture2DComposite::SourceTexturesFullyStreamedIn()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DComposite.SourceTexturesFullyStreamedIn"));

	UTexture2DComposite_SourceTexturesFullyStreamedIn_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2DDynamic.Create
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// int                            InSizeX                        (Parm)
// int                            InSizeY                        (Parm)
// TEnumAsByte<EPixelFormat>      InFormat                       (OptionalParm, Parm)
// bool                           InIsResolveTarget              (OptionalParm, Parm)
// class UTexture2DDynamic*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UTexture2DDynamic* UTexture2DDynamic::Create(int InSizeX, int InSizeY, TEnumAsByte<EPixelFormat> InFormat, bool InIsResolveTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DDynamic.Create"));

	UTexture2DDynamic_Create_Params params;
	params.InSizeX = InSizeX;
	params.InSizeY = InSizeY;
	params.InFormat = InFormat;
	params.InIsResolveTarget = InIsResolveTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2DDynamic.UpdateMipFromPNG
// (Final, Defined, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            MipIdx                         (Parm)
// TArray<unsigned char>          MipData                        (Const, Parm, OutParm, NeedCtorLink)

void UTexture2DDynamic::UpdateMipFromPNG(int MipIdx, TArray<unsigned char>* MipData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DDynamic.UpdateMipFromPNG"));

	UTexture2DDynamic_UpdateMipFromPNG_Params params;
	params.MipIdx = MipIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MipData != nullptr)
		*MipData = params.MipData;
}


// Function Engine.Texture2DDynamic.UpdateMipFromJPEG
// (Defined, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            MipIdx                         (Parm)
// TArray<unsigned char>          MipData                        (Const, Parm, OutParm, NeedCtorLink)
// int                            MaxTotalPixels                 (OptionalParm, Parm)

void UTexture2DDynamic::UpdateMipFromJPEG(int MipIdx, int MaxTotalPixels, TArray<unsigned char>* MipData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DDynamic.UpdateMipFromJPEG"));

	UTexture2DDynamic_UpdateMipFromJPEG_Params params;
	params.MipIdx = MipIdx;
	params.MaxTotalPixels = MaxTotalPixels;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MipData != nullptr)
		*MipData = params.MipData;
}


// Function Engine.Texture2DDynamic.UpdateMip
// (Final, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            MipIdx                         (Parm)
// TArray<unsigned char>          MipData                        (Const, Parm, OutParm, NeedCtorLink)

void UTexture2DDynamic::UpdateMip(int MipIdx, TArray<unsigned char>* MipData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DDynamic.UpdateMip"));

	UTexture2DDynamic_UpdateMip_Params params;
	params.MipIdx = MipIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MipData != nullptr)
		*MipData = params.MipData;
}


// Function Engine.Texture2DDynamic.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// int                            InSizeX                        (Parm)
// int                            InSizeY                        (Parm)
// TEnumAsByte<EPixelFormat>      InFormat                       (OptionalParm, Parm)
// bool                           InIsResolveTarget              (OptionalParm, Parm)

void UTexture2DDynamic::Init(int InSizeX, int InSizeY, TEnumAsByte<EPixelFormat> InFormat, bool InIsResolveTarget)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Texture2DDynamic.Init"));

	UTexture2DDynamic_Init_Params params;
	params.InSizeX = InSizeX;
	params.InSizeY = InSizeY;
	params.InFormat = InFormat;
	params.InIsResolveTarget = InIsResolveTarget;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureMovie.Stop
// (Final, Defined, Iterator, Latent, Singular, Net, Exec)

void UTextureMovie::Stop()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureMovie.Stop"));

	UTextureMovie_Stop_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureMovie.Pause
// (Defined, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)

void UTextureMovie::Pause()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureMovie.Pause"));

	UTextureMovie_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureMovie.Play
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UTextureMovie::Play()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureMovie.Play"));

	UTextureMovie_Play_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextureRenderTarget2D.Create
// (Final, Defined, PreOperator, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// int                            InSizeX                        (Parm)
// int                            InSizeY                        (Parm)
// TEnumAsByte<EPixelFormat>      InFormat                       (OptionalParm, Parm)
// struct FLinearColor            InClearColor                   (OptionalParm, Parm)
// bool                           bOnlyRenderOnce                (OptionalParm, Parm)
// class UTextureRenderTarget2D*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UTextureRenderTarget2D* UTextureRenderTarget2D::Create(int InSizeX, int InSizeY, TEnumAsByte<EPixelFormat> InFormat, const struct FLinearColor& InClearColor, bool bOnlyRenderOnce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TextureRenderTarget2D.Create"));

	UTextureRenderTarget2D_Create_Params params;
	params.InSizeX = InSizeX;
	params.InSizeY = InSizeY;
	params.InFormat = InFormat;
	params.InClearColor = InClearColor;
	params.bOnlyRenderOnce = bOnlyRenderOnce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ScriptedTexture.Render
// (Final, Defined, Latent, Net, Simulated, Native, Event, Operator)
// Parameters:
// class UCanvas*                 C                              (Parm)

void UScriptedTexture::Render(class UCanvas* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ScriptedTexture.Render"));

	UScriptedTexture_Render_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioDevice.FindSoundClass
// (Defined, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   SoundClassName                 (Parm)
// class USoundClass*             ReturnValue                    (Parm, OutParm, ReturnParm)

class USoundClass* UAudioDevice::STATIC_FindSoundClass(const struct FName& SoundClassName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioDevice.FindSoundClass"));

	UAudioDevice_FindSoundClass_Params params;
	params.SoundClassName = SoundClassName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioDevice.SetSoundMode
// (Final, Defined, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// struct FName                   NewMode                        (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAudioDevice::SetSoundMode(const struct FName& NewMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioDevice.SetSoundMode"));

	UAudioDevice_SetSoundMode_Params params;
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioDevice.ChangeAudioDevice
// (Final, Singular, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 NewAudioDevice                 (Parm, NeedCtorLink)

void UAudioDevice::ChangeAudioDevice(const struct FString& NewAudioDevice)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioDevice.ChangeAudioDevice"));

	UAudioDevice_ChangeAudioDevice_Params params;
	params.NewAudioDevice = NewAudioDevice;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioDevice.ListAudioDevices
// (Defined, PreOperator, Singular, Net, NetReliable, Native, Operator, Static)
// Parameters:
// TArray<struct FString>         InstalledDevices               (Parm, OutParm, AlwaysInit, NeedCtorLink)

void UAudioDevice::STATIC_ListAudioDevices(TArray<struct FString>* InstalledDevices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AudioDevice.ListAudioDevices"));

	UAudioDevice_ListAudioDevices_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InstalledDevices != nullptr)
		*InstalledDevices = params.InstalledDevices;
}


// Function Engine.Scout.PreBeginPlay
// (Latent, Net, Simulated)

void AScout::PreBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Scout.PreBeginPlay"));

	AScout_PreBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void ALight::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Light.OnToggle"));

	ALight_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ALight::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Light.ReplicatedEvent"));

	ALight_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightToggleable.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct APointLightToggleable_FCheckpointRecord Record                         (Const, Parm, OutParm)

void APointLightToggleable::ApplyCheckpointRecord(struct APointLightToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightToggleable.ApplyCheckpointRecord"));

	APointLightToggleable_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.PointLightToggleable.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct APointLightToggleable_FCheckpointRecord Record                         (Parm, OutParm)

void APointLightToggleable::STATIC_CreateCheckpointRecord(struct APointLightToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightToggleable.CreateCheckpointRecord"));

	APointLightToggleable_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.PointLightToggleable.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APointLightToggleable::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightToggleable.ShouldSaveForCheckpoint"));

	APointLightToggleable_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SpotLightToggleable.ApplyCheckpointRecord
// (Iterator, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// struct ASpotLightToggleable_FCheckpointRecord Record                         (Const, Parm, OutParm)

void ASpotLightToggleable::ApplyCheckpointRecord(struct ASpotLightToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpotLightToggleable.ApplyCheckpointRecord"));

	ASpotLightToggleable_ApplyCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.SpotLightToggleable.CreateCheckpointRecord
// (Defined, Exec, Static)
// Parameters:
// struct ASpotLightToggleable_FCheckpointRecord Record                         (Parm, OutParm)

void ASpotLightToggleable::STATIC_CreateCheckpointRecord(struct ASpotLightToggleable_FCheckpointRecord* Record)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpotLightToggleable.CreateCheckpointRecord"));

	ASpotLightToggleable_CreateCheckpointRecord_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Record != nullptr)
		*Record = params.Record;
}


// Function Engine.SpotLightToggleable.ShouldSaveForCheckpoint
// (Final, Iterator, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASpotLightToggleable::ShouldSaveForCheckpoint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpotLightToggleable.ShouldSaveForCheckpoint"));

	ASpotLightToggleable_ShouldSaveForCheckpoint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightComponent.OnUpdatePropertyLightColor
// (Iterator, Singular, Simulated, Native, Event, Operator, Static)

void ULightComponent::STATIC_OnUpdatePropertyLightColor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.OnUpdatePropertyLightColor"));

	ULightComponent_OnUpdatePropertyLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.OnUpdatePropertyBrightness
// (Final, Defined, Singular, Simulated, Native, Event, Operator, Static)

void ULightComponent::STATIC_OnUpdatePropertyBrightness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.OnUpdatePropertyBrightness"));

	ULightComponent_OnUpdatePropertyBrightness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.OnUpdatePropertyOcclusionMaskDarkness
// (Final, Iterator, Singular, Simulated, Native, Event, Operator, Static)

void ULightComponent::STATIC_OnUpdatePropertyOcclusionMaskDarkness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.OnUpdatePropertyOcclusionMaskDarkness"));

	ULightComponent_OnUpdatePropertyOcclusionMaskDarkness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.OnUpdatePropertyBloomTint
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Native, Event, Operator, Static)

void ULightComponent::STATIC_OnUpdatePropertyBloomTint()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.OnUpdatePropertyBloomTint"));

	ULightComponent_OnUpdatePropertyBloomTint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.OnUpdatePropertyBloomScale
// (Defined, Iterator, Latent, PreOperator, Simulated, Native, Event, Operator, Static)

void ULightComponent::STATIC_OnUpdatePropertyBloomScale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.OnUpdatePropertyBloomScale"));

	ULightComponent_OnUpdatePropertyBloomScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetDetailMode
// (Final, Defined, Iterator, Latent, NetReliable, Event, Operator, HasOptionalParms)
// Parameters:
// TEnumAsByte<EDetailMode>       NewDetailMode                  (Parm)

void ULightComponent::SetDetailMode(TEnumAsByte<EDetailMode> NewDetailMode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.SetDetailMode"));

	ULightComponent_SetDetailMode_Params params;
	params.NewDetailMode = NewDetailMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.UpdateLightShaftParameters
// (Defined, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ULightComponent::UpdateLightShaftParameters()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.UpdateLightShaftParameters"));

	ULightComponent_UpdateLightShaftParameters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.UpdateColorAndBrightness
// (Final, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ULightComponent::UpdateColorAndBrightness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.UpdateColorAndBrightness"));

	ULightComponent_UpdateColorAndBrightness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.GetDirection
// (Defined, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector ULightComponent::STATIC_GetDirection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.GetDirection"));

	ULightComponent_GetDirection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightComponent.GetOrigin
// (Final, Iterator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector ULightComponent::STATIC_GetOrigin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.GetOrigin"));

	ULightComponent_GetOrigin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightComponent.SetLightProperties
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewBrightness                  (OptionalParm, Parm)
// struct FColor                  NewLightColor                  (OptionalParm, Parm)
// class ULightFunction*          NewLightFunction               (OptionalParm, Parm)

void ULightComponent::SetLightProperties(float NewBrightness, const struct FColor& NewLightColor, class ULightFunction* NewLightFunction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.SetLightProperties"));

	ULightComponent_SetLightProperties_Params params;
	params.NewBrightness = NewBrightness;
	params.NewLightColor = NewLightColor;
	params.NewLightFunction = NewLightFunction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSetEnabled                    (Parm)

void ULightComponent::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightComponent.SetEnabled"));

	ULightComponent_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.OnUpdatePropertyBrightness
// (Final, Defined, Singular, Simulated, Native, Event, Operator, Static)

void UDirectionalLightComponent::STATIC_OnUpdatePropertyBrightness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DirectionalLightComponent.OnUpdatePropertyBrightness"));

	UDirectionalLightComponent_OnUpdatePropertyBrightness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.OnUpdatePropertyLightColor
// (Iterator, Singular, Simulated, Native, Event, Operator, Static)

void UDirectionalLightComponent::STATIC_OnUpdatePropertyLightColor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DirectionalLightComponent.OnUpdatePropertyLightColor"));

	UDirectionalLightComponent_OnUpdatePropertyLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.OnUpdatePropertyBrightness
// (Final, Defined, Singular, Simulated, Native, Event, Operator, Static)

void UPointLightComponent::STATIC_OnUpdatePropertyBrightness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightComponent.OnUpdatePropertyBrightness"));

	UPointLightComponent_OnUpdatePropertyBrightness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.OnUpdatePropertyLightColor
// (Iterator, Singular, Simulated, Native, Event, Operator, Static)

void UPointLightComponent::STATIC_OnUpdatePropertyLightColor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightComponent.OnUpdatePropertyLightColor"));

	UPointLightComponent_OnUpdatePropertyLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.SetTranslation
// (Final, Defined, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FVector                 NewTranslation                 (Parm)

void UPointLightComponent::SetTranslation(const struct FVector& NewTranslation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PointLightComponent.SetTranslation"));

	UPointLightComponent_SetTranslation_Params params;
	params.NewTranslation = NewTranslation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpotLightComponent.SetRotation
// (Defined, Latent, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// struct FRotator                NewRotation                    (Parm)

void USpotLightComponent::SetRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SpotLightComponent.SetRotation"));

	USpotLightComponent_SetRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightEnvironmentComponent.IsEnabled
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULightEnvironmentComponent::IsEnabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightEnvironmentComponent.IsEnabled"));

	ULightEnvironmentComponent_IsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightEnvironmentComponent.SetEnabled
// (Latent, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewEnabled                    (Parm)

void ULightEnvironmentComponent::SetEnabled(bool bNewEnabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LightEnvironmentComponent.SetEnabled"));

	ULightEnvironmentComponent_SetEnabled_Params params;
	params.bNewEnabled = bNewEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicLightEnvironmentComponent.ResetEnvironment
// (Defined, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)

void UDynamicLightEnvironmentComponent::ResetEnvironment()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicLightEnvironmentComponent.ResetEnvironment"));

	UDynamicLightEnvironmentComponent_ResetEnvironment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetMaterial
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ElementIndex                   (Parm)
// class UMaterialInterface*      Material                       (Parm)

void USkeletalMeshComponent::SetMaterial(int ElementIndex, class UMaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetMaterial"));

	USkeletalMeshComponent_SetMaterial_Params params;
	params.ElementIndex = ElementIndex;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetRotation
// (Final, Iterator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator USkeletalMeshComponent::STATIC_GetRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetRotation"));

	USkeletalMeshComponent_GetRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPosition
// (Defined, Iterator, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USkeletalMeshComponent::STATIC_GetPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetPosition"));

	USkeletalMeshComponent_GetPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.BreakConstraint
// (Defined, NetReliable, Exec, Event, Operator)
// Parameters:
// struct FVector                 Impulse                        (Parm)
// struct FVector                 HitLocation                    (Parm)
// struct FName                   InBoneName                     (Parm)
// bool                           bVelChange                     (OptionalParm, Parm)

void USkeletalMeshComponent::BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.BreakConstraint"));

	USkeletalMeshComponent_BreakConstraint_Params params;
	params.Impulse = Impulse;
	params.HitLocation = HitLocation;
	params.InBoneName = InBoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SkelMeshCompOnParticleSystemFinished
// (Final, Iterator, NetReliable, Simulated, Event, HasOptionalParms)
// Parameters:
// class UParticleSystemComponent* PSC                            (Parm, EditInline)

void USkeletalMeshComponent::SkelMeshCompOnParticleSystemFinished(class UParticleSystemComponent* PSC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SkelMeshCompOnParticleSystemFinished"));

	USkeletalMeshComponent_SkelMeshCompOnParticleSystemFinished_Params params;
	params.PSC = PSC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.PlayParticleEffect
// (Final, Iterator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_PlayParticleEffect* AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.PlayParticleEffect"));

	USkeletalMeshComponent_PlayParticleEffect_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPSCForPlayParticleEffect
// (Iterator, Latent, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// class UAnimNotify_PlayParticleEffect* AnimNotifyData                 (Const, Parm)
// class UParticleSystemComponent* ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UParticleSystemComponent* USkeletalMeshComponent::STATIC_GetPSCForPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetPSCForPlayParticleEffect"));

	USkeletalMeshComponent_GetPSCForPlayParticleEffect_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.CreateForceField
// (Defined, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class UAnimNotify_ForceField*  AnimNotifyData                 (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::CreateForceField(class UAnimNotify_ForceField* AnimNotifyData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.CreateForceField"));

	USkeletalMeshComponent_CreateForceField_Params params;
	params.AnimNotifyData = AnimNotifyData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.StopAnim
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void USkeletalMeshComponent::StopAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.StopAnim"));

	USkeletalMeshComponent_StopAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.PlayAnim
// (Iterator, Net, HasOptionalParms)
// Parameters:
// struct FName                   AnimName                       (Parm)
// float                          Duration                       (OptionalParm, Parm)
// bool                           bLoop                          (OptionalParm, Parm)
// bool                           bRestartIfAlreadyPlaying       (OptionalParm, Parm)
// float                          StartTime                      (OptionalParm, Parm)
// bool                           bPlayBackwards                 (OptionalParm, Parm)

void USkeletalMeshComponent::PlayAnim(const struct FName& AnimName, float Duration, bool bLoop, bool bRestartIfAlreadyPlaying, float StartTime, bool bPlayBackwards)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.PlayAnim"));

	USkeletalMeshComponent_PlayAnim_Params params;
	params.AnimName = AnimName;
	params.Duration = Duration;
	params.bLoop = bLoop;
	params.bRestartIfAlreadyPlaying = bRestartIfAlreadyPlaying;
	params.StartTime = StartTime;
	params.bPlayBackwards = bPlayBackwards;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ShowMaterialSection
// (Final, Latent, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            MaterialID                     (Parm)
// bool                           bShow                          (Parm)
// int                            LODIndex                       (Parm)

void USkeletalMeshComponent::ShowMaterialSection(int MaterialID, bool bShow, int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ShowMaterialSection"));

	USkeletalMeshComponent_ShowMaterialSection_Params params;
	params.MaterialID = MaterialID;
	params.bShow = bShow;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateMeshForBrokenConstraints
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USkeletalMeshComponent::UpdateMeshForBrokenConstraints()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateMeshForBrokenConstraints"));

	USkeletalMeshComponent_UpdateMeshForBrokenConstraints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UnHideBoneByName
// (Final, Defined, Iterator, Latent, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (Parm)

void USkeletalMeshComponent::UnHideBoneByName(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UnHideBoneByName"));

	USkeletalMeshComponent_UnHideBoneByName_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.HideBoneByName
// (Defined, Iterator, PreOperator, Operator, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// TEnumAsByte<EPhysBodyOp>       PhysBodyOption                 (Parm)

void USkeletalMeshComponent::STATIC_HideBoneByName(const struct FName& BoneName, TEnumAsByte<EPhysBodyOp> PhysBodyOption)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.HideBoneByName"));

	USkeletalMeshComponent_HideBoneByName_Params params;
	params.BoneName = BoneName;
	params.PhysBodyOption = PhysBodyOption;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.IsBoneHidden
// (Final, Defined, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            BoneIndex                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::STATIC_IsBoneHidden(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.IsBoneHidden"));

	USkeletalMeshComponent_IsBoneHidden_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.UnHideBone
// (Defined, Iterator, Latent, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            BoneIndex                      (Parm)

void USkeletalMeshComponent::UnHideBone(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UnHideBone"));

	USkeletalMeshComponent_UnHideBone_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.HideBone
// (Final, Iterator, PreOperator, Operator, Static)
// Parameters:
// int                            BoneIndex                      (Parm)
// TEnumAsByte<EPhysBodyOp>       PhysBodyOption                 (Parm)

void USkeletalMeshComponent::STATIC_HideBone(int BoneIndex, TEnumAsByte<EPhysBodyOp> PhysBodyOption)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.HideBone"));

	USkeletalMeshComponent_HideBone_Params params;
	params.BoneIndex = BoneIndex;
	params.PhysBodyOption = PhysBodyOption;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetFaceFXRegisterEx
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 RegName                        (Parm, NeedCtorLink)
// TEnumAsByte<EFaceFXRegOp>      RegOp                          (Parm)
// float                          FirstValue                     (Parm)
// float                          FirstInterpDuration            (Parm)
// float                          NextValue                      (Parm)
// float                          NextInterpDuration             (Parm)

void USkeletalMeshComponent::SetFaceFXRegisterEx(const struct FString& RegName, TEnumAsByte<EFaceFXRegOp> RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetFaceFXRegisterEx"));

	USkeletalMeshComponent_SetFaceFXRegisterEx_Params params;
	params.RegName = RegName;
	params.RegOp = RegOp;
	params.FirstValue = FirstValue;
	params.FirstInterpDuration = FirstInterpDuration;
	params.NextValue = NextValue;
	params.NextInterpDuration = NextInterpDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetFaceFXRegister
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 RegName                        (Parm, NeedCtorLink)
// float                          RegVal                         (Parm)
// TEnumAsByte<EFaceFXRegOp>      RegOp                          (Parm)
// float                          InterpDuration                 (OptionalParm, Parm)

void USkeletalMeshComponent::SetFaceFXRegister(const struct FString& RegName, float RegVal, TEnumAsByte<EFaceFXRegOp> RegOp, float InterpDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetFaceFXRegister"));

	USkeletalMeshComponent_SetFaceFXRegister_Params params;
	params.RegName = RegName;
	params.RegVal = RegVal;
	params.RegOp = RegOp;
	params.InterpDuration = InterpDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetFaceFXRegister
// (Iterator, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 RegName                        (Parm, NeedCtorLink)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetFaceFXRegister(const struct FString& RegName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetFaceFXRegister"));

	USkeletalMeshComponent_GetFaceFXRegister_Params params;
	params.RegName = RegName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.DeclareFaceFXRegister
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, Static)
// Parameters:
// struct FString                 RegName                        (Parm, NeedCtorLink)

void USkeletalMeshComponent::STATIC_DeclareFaceFXRegister(const struct FString& RegName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.DeclareFaceFXRegister"));

	USkeletalMeshComponent_DeclareFaceFXRegister_Params params;
	params.RegName = RegName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.IsPlayingFaceFXAnim
// (Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::STATIC_IsPlayingFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.IsPlayingFaceFXAnim"));

	USkeletalMeshComponent_IsPlayingFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.StopFaceFXAnim
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)

void USkeletalMeshComponent::StopFaceFXAnim()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.StopFaceFXAnim"));

	USkeletalMeshComponent_StopFaceFXAnim_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.PlayFaceFXAnim
// (Final, Latent, PreOperator, NetReliable, HasOptionalParms)
// Parameters:
// class UFaceFXAnimSet*          FaceFXAnimSetRef               (Parm)
// struct FString                 AnimName                       (Parm, NeedCtorLink)
// struct FString                 GroupName                      (Parm, NeedCtorLink)
// class USoundCue*               SoundCueToPlay                 (Parm)
// class UAkEvent*                AkEventToPlay                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::PlayFaceFXAnim(class UFaceFXAnimSet* FaceFXAnimSetRef, const struct FString& AnimName, const struct FString& GroupName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.PlayFaceFXAnim"));

	USkeletalMeshComponent_PlayFaceFXAnim_Params params;
	params.FaceFXAnimSetRef = FaceFXAnimSetRef;
	params.AnimName = AnimName;
	params.GroupName = GroupName;
	params.SoundCueToPlay = SoundCueToPlay;
	params.AkEventToPlay = AkEventToPlay;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.ToggleInstanceVertexWeights
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bEnable                        (Parm)
// int                            LODIdx                         (Parm)

void USkeletalMeshComponent::ToggleInstanceVertexWeights(bool bEnable, int LODIdx)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ToggleInstanceVertexWeights"));

	USkeletalMeshComponent_ToggleInstanceVertexWeights_Params params;
	params.bEnable = bEnable;
	params.LODIdx = LODIdx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateInstanceVertexWeightBones
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// TArray<struct FBonePair>       BonePairs                      (Parm, NeedCtorLink)

void USkeletalMeshComponent::UpdateInstanceVertexWeightBones(TArray<struct FBonePair> BonePairs)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateInstanceVertexWeightBones"));

	USkeletalMeshComponent_UpdateInstanceVertexWeightBones_Params params;
	params.BonePairs = BonePairs;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.FindInstanceVertexweightBonePair
// (Defined, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FBonePair               Bones                          (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USkeletalMeshComponent::STATIC_FindInstanceVertexweightBonePair(const struct FBonePair& Bones)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindInstanceVertexweightBonePair"));

	USkeletalMeshComponent_FindInstanceVertexweightBonePair_Params params;
	params.Bones = Bones;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.RemoveInstanceVertexWeightBoneParented
// (Final, Defined, Iterator, PreOperator, Native, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (Parm)

void USkeletalMeshComponent::RemoveInstanceVertexWeightBoneParented(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.RemoveInstanceVertexWeightBoneParented"));

	USkeletalMeshComponent_RemoveInstanceVertexWeightBoneParented_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AddInstanceVertexWeightBoneParented
// (PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FName                   BoneName                       (Parm)
// bool                           bPairWithParent                (OptionalParm, Parm)

void USkeletalMeshComponent::AddInstanceVertexWeightBoneParented(const struct FName& BoneName, bool bPairWithParent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AddInstanceVertexWeightBoneParented"));

	USkeletalMeshComponent_AddInstanceVertexWeightBoneParented_Params params;
	params.BoneName = BoneName;
	params.bPairWithParent = bPairWithParent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetBonesWithinRadius
// (Defined, Iterator, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 Origin                         (Parm)
// float                          Radius                         (Parm)
// int                            TraceFlags                     (Parm)
// TArray<struct FName>           out_Bones                      (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::STATIC_GetBonesWithinRadius(const struct FVector& Origin, float Radius, int TraceFlags, TArray<struct FName>* out_Bones)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBonesWithinRadius"));

	USkeletalMeshComponent_GetBonesWithinRadius_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.TraceFlags = TraceFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_Bones != nullptr)
		*out_Bones = params.out_Bones;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.UpdateAnimations
// (Defined, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USkeletalMeshComponent::UpdateAnimations()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateAnimations"));

	USkeletalMeshComponent_UpdateAnimations_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ForceSkelUpdate
// (Latent, Net, NetReliable, Simulated, Exec, Event, Static)

void USkeletalMeshComponent::STATIC_ForceSkelUpdate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ForceSkelUpdate"));

	USkeletalMeshComponent_ForceSkelUpdate_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateRBBonesFromSpaceBases
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bMoveUnfixedBodies             (Parm)
// bool                           bTeleport                      (Parm)

void USkeletalMeshComponent::UpdateRBBonesFromSpaceBases(bool bMoveUnfixedBodies, bool bTeleport)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateRBBonesFromSpaceBases"));

	USkeletalMeshComponent_UpdateRBBonesFromSpaceBases_Params params;
	params.bMoveUnfixedBodies = bMoveUnfixedBodies;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetHasPhysicsAssetInstance
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bHasInstance                   (Parm)
// bool                           bUseCurrentPosition            (OptionalParm, Parm)

void USkeletalMeshComponent::SetHasPhysicsAssetInstance(bool bHasInstance, bool bUseCurrentPosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetHasPhysicsAssetInstance"));

	USkeletalMeshComponent_SetHasPhysicsAssetInstance_Params params;
	params.bHasInstance = bHasInstance;
	params.bUseCurrentPosition = bUseCurrentPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.FindBodyInstanceNamed
// (NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// class URB_BodyInstance*        ReturnValue                    (Parm, OutParm, ReturnParm)

class URB_BodyInstance* USkeletalMeshComponent::STATIC_FindBodyInstanceNamed(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindBodyInstanceNamed"));

	USkeletalMeshComponent_FindBodyInstanceNamed_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
// (Final, Defined, Iterator, NetReliable, Exec, Event, Static)
// Parameters:
// int                            ConstraintIndex                (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USkeletalMeshComponent::STATIC_FindConstraintBoneName(int ConstraintIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindConstraintBoneName"));

	USkeletalMeshComponent_FindConstraintBoneName_Params params;
	params.ConstraintIndex = ConstraintIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindConstraintIndex
// (Latent, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   ConstraintName                 (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USkeletalMeshComponent::STATIC_FindConstraintIndex(const struct FName& ConstraintName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindConstraintIndex"));

	USkeletalMeshComponent_FindConstraintIndex_Params params;
	params.ConstraintName = ConstraintName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.InitMorphTargets
// (PreOperator, Singular, Net, Simulated, Operator, Static)

void USkeletalMeshComponent::STATIC_InitMorphTargets()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.InitMorphTargets"));

	USkeletalMeshComponent_InitMorphTargets_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.InitSkelControls
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Operator, Static)

void USkeletalMeshComponent::STATIC_InitSkelControls()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.InitSkelControls"));

	USkeletalMeshComponent_InitSkelControls_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateParentBoneMap
// (Defined, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USkeletalMeshComponent::UpdateParentBoneMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateParentBoneMap"));

	USkeletalMeshComponent_UpdateParentBoneMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetParentAnimComponent
// (Final, Defined, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// class USkeletalMeshComponent*  NewParentAnimComp              (Parm, EditInline)

void USkeletalMeshComponent::SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetParentAnimComponent"));

	USkeletalMeshComponent_SetParentAnimComponent_Params params;
	params.NewParentAnimComp = NewParentAnimComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAnimTreeTemplate
// (Final, Defined, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// class UAnimTree*               NewTemplate                    (Parm)

void USkeletalMeshComponent::SetAnimTreeTemplate(class UAnimTree* NewTemplate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetAnimTreeTemplate"));

	USkeletalMeshComponent_SetAnimTreeTemplate_Params params;
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetClosestCollidingBoneLocation
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 TestLocation                   (Parm)
// bool                           bCheckZeroExtent               (Parm)
// bool                           bCheckNonZeroExtent            (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USkeletalMeshComponent::STATIC_GetClosestCollidingBoneLocation(const struct FVector& TestLocation, bool bCheckZeroExtent, bool bCheckNonZeroExtent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClosestCollidingBoneLocation"));

	USkeletalMeshComponent_GetClosestCollidingBoneLocation_Params params;
	params.TestLocation = TestLocation;
	params.bCheckZeroExtent = bCheckZeroExtent;
	params.bCheckNonZeroExtent = bCheckNonZeroExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindClosestBone
// (Final, Defined, NetReliable, Exec, Event, Static)
// Parameters:
// struct FVector                 TestLocation                   (Parm)
// struct FVector                 BoneLocation                   (OptionalParm, Parm, OutParm)
// float                          IgnoreScale                    (OptionalParm, Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USkeletalMeshComponent::STATIC_FindClosestBone(const struct FVector& TestLocation, float IgnoreScale, struct FVector* BoneLocation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindClosestBone"));

	USkeletalMeshComponent_FindClosestBone_Params params;
	params.TestLocation = TestLocation;
	params.IgnoreScale = IgnoreScale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BoneLocation != nullptr)
		*BoneLocation = params.BoneLocation;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.TransformFromBoneSpace
// (Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (Parm)
// struct FVector                 InPosition                     (Parm)
// struct FRotator                InRotation                     (Parm)
// struct FVector                 OutPosition                    (Parm, OutParm)
// struct FRotator                OutRotation                    (Parm, OutParm)

void USkeletalMeshComponent::TransformFromBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.TransformFromBoneSpace"));

	USkeletalMeshComponent_TransformFromBoneSpace_Params params;
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;
}


// Function Engine.SkeletalMeshComponent.TransformToBoneSpace
// (Final, Iterator, Latent, Singular, Net, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   BoneName                       (Parm)
// struct FVector                 InPosition                     (Parm)
// struct FRotator                InRotation                     (Parm)
// struct FVector                 OutPosition                    (Parm, OutParm)
// struct FRotator                OutRotation                    (Parm, OutParm)

void USkeletalMeshComponent::TransformToBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.TransformToBoneSpace"));

	USkeletalMeshComponent_TransformToBoneSpace_Params params;
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;
}


// Function Engine.SkeletalMeshComponent.GetBoneAxis
// (Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// TEnumAsByte<EAxis>             Axis                           (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USkeletalMeshComponent::STATIC_GetBoneAxis(const struct FName& BoneName, TEnumAsByte<EAxis> Axis)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneAxis"));

	USkeletalMeshComponent_GetBoneAxis_Params params;
	params.BoneName = BoneName;
	params.Axis = Axis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetRefPosePosition
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            BoneIndex                      (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USkeletalMeshComponent::STATIC_GetRefPosePosition(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetRefPosePosition"));

	USkeletalMeshComponent_GetRefPosePosition_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.BoneIsChildOf
// (Singular, Simulated, Event, Operator)
// Parameters:
// struct FName                   BoneName                       (Parm)
// struct FName                   ParentBoneName                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::BoneIsChildOf(const struct FName& BoneName, const struct FName& ParentBoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.BoneIsChildOf"));

	USkeletalMeshComponent_BoneIsChildOf_Params params;
	params.BoneName = BoneName;
	params.ParentBoneName = ParentBoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneNames
// (Iterator, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<struct FName>           BoneNames                      (Parm, OutParm, NeedCtorLink)

void USkeletalMeshComponent::STATIC_GetBoneNames(TArray<struct FName>* BoneNames)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneNames"));

	USkeletalMeshComponent_GetBoneNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BoneNames != nullptr)
		*BoneNames = params.BoneNames;
}


// Function Engine.SkeletalMeshComponent.GetParentBone
// (Iterator, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USkeletalMeshComponent::STATIC_GetParentBone(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetParentBone"));

	USkeletalMeshComponent_GetParentBone_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneMatrix
// (Defined, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            BoneIndex                      (Parm)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FMatrix USkeletalMeshComponent::STATIC_GetBoneMatrix(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneMatrix"));

	USkeletalMeshComponent_GetBoneMatrix_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneName
// (Final, Defined, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            BoneIndex                      (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USkeletalMeshComponent::STATIC_GetBoneName(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneName"));

	USkeletalMeshComponent_GetBoneName_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.MatchRefBone
// (Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USkeletalMeshComponent::STATIC_MatchRefBone(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.MatchRefBone"));

	USkeletalMeshComponent_MatchRefBone_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneLocation
// (Final, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// int                            Space                          (OptionalParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USkeletalMeshComponent::STATIC_GetBoneLocation(const struct FName& BoneName, int Space)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneLocation"));

	USkeletalMeshComponent_GetBoneLocation_Params params;
	params.BoneName = BoneName;
	params.Space = Space;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneQuaternion
// (Final, Iterator, Latent, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   BoneName                       (Parm)
// int                            Space                          (OptionalParm, Parm)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FQuat USkeletalMeshComponent::STATIC_GetBoneQuaternion(const struct FName& BoneName, int Space)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetBoneQuaternion"));

	USkeletalMeshComponent_GetBoneQuaternion_Params params;
	params.BoneName = BoneName;
	params.Space = Space;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindMorphNode
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   InNodeName                     (Parm)
// class UMorphNodeBase*          ReturnValue                    (Parm, OutParm, ReturnParm)

class UMorphNodeBase* USkeletalMeshComponent::STATIC_FindMorphNode(const struct FName& InNodeName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindMorphNode"));

	USkeletalMeshComponent_FindMorphNode_Params params;
	params.InNodeName = InNodeName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindSkelControl
// (Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   InControlName                  (Parm)
// class USkelControlBase*        ReturnValue                    (Parm, OutParm, ReturnParm)

class USkelControlBase* USkeletalMeshComponent::STATIC_FindSkelControl(const struct FName& InControlName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindSkelControl"));

	USkeletalMeshComponent_FindSkelControl_Params params;
	params.InControlName = InControlName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.AllAnimNodes
// (Iterator, Latent, PreOperator, NetReliable, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class UAnimNode*               Node                           (Parm, OutParm)

void USkeletalMeshComponent::AllAnimNodes(class UClass* BaseClass, class UAnimNode** Node)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AllAnimNodes"));

	USkeletalMeshComponent_AllAnimNodes_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Node != nullptr)
		*Node = params.Node;
}


// Function Engine.SkeletalMeshComponent.FindAnimNode
// (Defined, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FName                   InNodeName                     (Parm)
// class UAnimNode*               ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimNode* USkeletalMeshComponent::STATIC_FindAnimNode(const struct FName& InNodeName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindAnimNode"));

	USkeletalMeshComponent_FindAnimNode_Params params;
	params.InNodeName = InNodeName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindMorphTarget
// (Singular, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   MorphTargetName                (Parm)
// class UMorphTarget*            ReturnValue                    (Parm, OutParm, ReturnParm)

class UMorphTarget* USkeletalMeshComponent::STATIC_FindMorphTarget(const struct FName& MorphTargetName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindMorphTarget"));

	USkeletalMeshComponent_FindMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimLength
// (Defined, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   AnimSeqName                    (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetAnimLength(const struct FName& AnimSeqName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetAnimLength"));

	USkeletalMeshComponent_GetAnimLength_Params params;
	params.AnimSeqName = AnimSeqName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimRateByDuration
// (Final, Iterator, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   AnimSeqName                    (Parm)
// float                          Duration                       (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetAnimRateByDuration(const struct FName& AnimSeqName, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetAnimRateByDuration"));

	USkeletalMeshComponent_GetAnimRateByDuration_Params params;
	params.AnimSeqName = AnimSeqName;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.RestoreSavedAnimSets
// (Latent, Singular, NetReliable, Native, HasOptionalParms)

void USkeletalMeshComponent::RestoreSavedAnimSets()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.RestoreSavedAnimSets"));

	USkeletalMeshComponent_RestoreSavedAnimSets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SaveAnimSets
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)

void USkeletalMeshComponent::SaveAnimSets()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SaveAnimSets"));

	USkeletalMeshComponent_SaveAnimSets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.FindAnimSequence
// (Final, Defined, Latent, PreOperator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FName                   AnimSeqName                    (Parm)
// class UAnimSequence*           ReturnValue                    (Parm, OutParm, ReturnParm)

class UAnimSequence* USkeletalMeshComponent::STATIC_FindAnimSequence(const struct FName& AnimSeqName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindAnimSequence"));

	USkeletalMeshComponent_FindAnimSequence_Params params;
	params.AnimSeqName = AnimSeqName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.WakeSoftBody
// (Final, Latent, PreOperator, Net, NetReliable, Operator, HasOptionalParms)

void USkeletalMeshComponent::WakeSoftBody()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.WakeSoftBody"));

	USkeletalMeshComponent_WakeSoftBody_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetSoftBodyFrozen
// (Defined, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bNewFrozen                     (Parm)

void USkeletalMeshComponent::SetSoftBodyFrozen(bool bNewFrozen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetSoftBodyFrozen"));

	USkeletalMeshComponent_SetSoftBodyFrozen_Params params;
	params.bNewFrozen = bNewFrozen;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateSoftBodyParams
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USkeletalMeshComponent::UpdateSoftBodyParams()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateSoftBodyParams"));

	USkeletalMeshComponent_UpdateSoftBodyParams_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothValidBounds
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ClothValidBoundsMin            (Parm)
// struct FVector                 ClothValidBoundsMax            (Parm)

void USkeletalMeshComponent::SetClothValidBounds(const struct FVector& ClothValidBoundsMin, const struct FVector& ClothValidBoundsMax)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothValidBounds"));

	USkeletalMeshComponent_SetClothValidBounds_Params params;
	params.ClothValidBoundsMin = ClothValidBoundsMin;
	params.ClothValidBoundsMax = ClothValidBoundsMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.EnableClothValidBounds
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Static)
// Parameters:
// bool                           IfEnableClothValidBounds       (Parm)

void USkeletalMeshComponent::STATIC_EnableClothValidBounds(bool IfEnableClothValidBounds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.EnableClothValidBounds"));

	USkeletalMeshComponent_EnableClothValidBounds_Params params;
	params.IfEnableClothValidBounds = IfEnableClothValidBounds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AttachClothToCollidingShapes
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// bool                           AttatchTwoWay                  (Parm)
// bool                           AttachTearable                 (Parm)

void USkeletalMeshComponent::AttachClothToCollidingShapes(bool AttatchTwoWay, bool AttachTearable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AttachClothToCollidingShapes"));

	USkeletalMeshComponent_AttachClothToCollidingShapes_Params params;
	params.AttatchTwoWay = AttatchTwoWay;
	params.AttachTearable = AttachTearable;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothVelocity
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 VelocityOffSet                 (Parm)

void USkeletalMeshComponent::SetClothVelocity(const struct FVector& VelocityOffSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothVelocity"));

	USkeletalMeshComponent_SetClothVelocity_Params params;
	params.VelocityOffSet = VelocityOffSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothPosition
// (Defined, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 ClothOffSet                    (Parm)

void USkeletalMeshComponent::SetClothPosition(const struct FVector& ClothOffSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothPosition"));

	USkeletalMeshComponent_SetClothPosition_Params params;
	params.ClothOffSet = ClothOffSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothSleep
// (Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           IfClothSleep                   (Parm)

void USkeletalMeshComponent::SetClothSleep(bool IfClothSleep)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothSleep"));

	USkeletalMeshComponent_SetClothSleep_Params params;
	params.IfClothSleep = IfClothSleep;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothThickness
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothThickness                 (Parm)

void USkeletalMeshComponent::SetClothThickness(float ClothThickness)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothThickness"));

	USkeletalMeshComponent_SetClothThickness_Params params;
	params.ClothThickness = ClothThickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothTearFactor
// (Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothTearFactor                (Parm)

void USkeletalMeshComponent::SetClothTearFactor(float ClothTearFactor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothTearFactor"));

	USkeletalMeshComponent_SetClothTearFactor_Params params;
	params.ClothTearFactor = ClothTearFactor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothStretchingStiffness
// (Final, Defined, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothStretchingStiffness       (Parm)

void USkeletalMeshComponent::SetClothStretchingStiffness(float ClothStretchingStiffness)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothStretchingStiffness"));

	USkeletalMeshComponent_SetClothStretchingStiffness_Params params;
	params.ClothStretchingStiffness = ClothStretchingStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothSolverIterations
// (Defined, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ClothSolverIterations          (Parm)

void USkeletalMeshComponent::SetClothSolverIterations(int ClothSolverIterations)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothSolverIterations"));

	USkeletalMeshComponent_SetClothSolverIterations_Params params;
	params.ClothSolverIterations = ClothSolverIterations;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothSleepLinearVelocity
// (Final, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothSleepLinearVelocity       (Parm)

void USkeletalMeshComponent::SetClothSleepLinearVelocity(float ClothSleepLinearVelocity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothSleepLinearVelocity"));

	USkeletalMeshComponent_SetClothSleepLinearVelocity_Params params;
	params.ClothSleepLinearVelocity = ClothSleepLinearVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothPressure
// (Final, Defined, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothPressure                  (Parm)

void USkeletalMeshComponent::SetClothPressure(float ClothPressure)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothPressure"));

	USkeletalMeshComponent_SetClothPressure_Params params;
	params.ClothPressure = ClothPressure;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothFriction
// (Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothFriction                  (Parm)

void USkeletalMeshComponent::SetClothFriction(float ClothFriction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothFriction"));

	USkeletalMeshComponent_SetClothFriction_Params params;
	params.ClothFriction = ClothFriction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothFlags
// (Final, Defined, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            ClothFlags                     (Parm)

void USkeletalMeshComponent::SetClothFlags(int ClothFlags)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothFlags"));

	USkeletalMeshComponent_SetClothFlags_Params params;
	params.ClothFlags = ClothFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothDampingCoefficient
// (Final, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothDampingCoefficient        (Parm)

void USkeletalMeshComponent::SetClothDampingCoefficient(float ClothDampingCoefficient)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothDampingCoefficient"));

	USkeletalMeshComponent_SetClothDampingCoefficient_Params params;
	params.ClothDampingCoefficient = ClothDampingCoefficient;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothCollisionResponseCoefficient
// (NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothCollisionResponseCoefficient (Parm)

void USkeletalMeshComponent::SetClothCollisionResponseCoefficient(float ClothCollisionResponseCoefficient)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothCollisionResponseCoefficient"));

	USkeletalMeshComponent_SetClothCollisionResponseCoefficient_Params params;
	params.ClothCollisionResponseCoefficient = ClothCollisionResponseCoefficient;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothBendingStiffness
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothBendingStiffness          (Parm)

void USkeletalMeshComponent::SetClothBendingStiffness(float ClothBendingStiffness)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothBendingStiffness"));

	USkeletalMeshComponent_SetClothBendingStiffness_Params params;
	params.ClothBendingStiffness = ClothBendingStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothAttachmentTearFactor
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothAttachTearFactor          (Parm)

void USkeletalMeshComponent::SetClothAttachmentTearFactor(float ClothAttachTearFactor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothAttachmentTearFactor"));

	USkeletalMeshComponent_SetClothAttachmentTearFactor_Params params;
	params.ClothAttachTearFactor = ClothAttachTearFactor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothAttachmentResponseCoefficient
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          ClothAttachmentResponseCoefficient (Parm)

void USkeletalMeshComponent::SetClothAttachmentResponseCoefficient(float ClothAttachmentResponseCoefficient)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothAttachmentResponseCoefficient"));

	USkeletalMeshComponent_SetClothAttachmentResponseCoefficient_Params params;
	params.ClothAttachmentResponseCoefficient = ClothAttachmentResponseCoefficient;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetClothThickness
// (Final, Defined, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothThickness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothThickness"));

	USkeletalMeshComponent_GetClothThickness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothTearFactor
// (Defined, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothTearFactor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothTearFactor"));

	USkeletalMeshComponent_GetClothTearFactor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothStretchingStiffness
// (Final, Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothStretchingStiffness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothStretchingStiffness"));

	USkeletalMeshComponent_GetClothStretchingStiffness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothSolverIterations
// (Latent, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USkeletalMeshComponent::STATIC_GetClothSolverIterations()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothSolverIterations"));

	USkeletalMeshComponent_GetClothSolverIterations_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothSleepLinearVelocity
// (Final, Defined, Iterator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothSleepLinearVelocity()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothSleepLinearVelocity"));

	USkeletalMeshComponent_GetClothSleepLinearVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothPressure
// (Defined, Iterator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothPressure()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothPressure"));

	USkeletalMeshComponent_GetClothPressure_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothFriction
// (Final, Iterator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothFriction()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothFriction"));

	USkeletalMeshComponent_GetClothFriction_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothFlags
// (Iterator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USkeletalMeshComponent::STATIC_GetClothFlags()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothFlags"));

	USkeletalMeshComponent_GetClothFlags_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothDampingCoefficient
// (Final, Defined, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothDampingCoefficient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothDampingCoefficient"));

	USkeletalMeshComponent_GetClothDampingCoefficient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothCollisionResponseCoefficient
// (Defined, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothCollisionResponseCoefficient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothCollisionResponseCoefficient"));

	USkeletalMeshComponent_GetClothCollisionResponseCoefficient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothBendingStiffness
// (Final, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothBendingStiffness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothBendingStiffness"));

	USkeletalMeshComponent_GetClothBendingStiffness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothAttachmentTearFactor
// (NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothAttachmentTearFactor()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothAttachmentTearFactor"));

	USkeletalMeshComponent_GetClothAttachmentTearFactor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothAttachmentResponseCoefficient
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetClothAttachmentResponseCoefficient()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetClothAttachmentResponseCoefficient"));

	USkeletalMeshComponent_GetClothAttachmentResponseCoefficient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.ForceApexClothingTeleport
// (Final, Singular, NetReliable, Simulated, Exec, Event, Static)

void USkeletalMeshComponent::STATIC_ForceApexClothingTeleport()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ForceApexClothingTeleport"));

	USkeletalMeshComponent_ForceApexClothingTeleport_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ForceApexClothingTeleportAndReset
// (Defined, Singular, NetReliable, Simulated, Exec, Event, Static)

void USkeletalMeshComponent::STATIC_ForceApexClothingTeleportAndReset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ForceApexClothingTeleportAndReset"));

	USkeletalMeshComponent_ForceApexClothingTeleportAndReset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResetClothVertsToRefPose
// (Final, Iterator, PreOperator, Singular, Net, Native, HasOptionalParms)

void USkeletalMeshComponent::ResetClothVertsToRefPose()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.ResetClothVertsToRefPose"));

	USkeletalMeshComponent_ResetClothVertsToRefPose_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAttachClothVertsToBaseBody
// (Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bAttachVerts                   (Parm)

void USkeletalMeshComponent::SetAttachClothVertsToBaseBody(bool bAttachVerts)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetAttachClothVertsToBaseBody"));

	USkeletalMeshComponent_SetAttachClothVertsToBaseBody_Params params;
	params.bAttachVerts = bAttachVerts;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothExternalForce
// (Defined, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 InForce                        (Parm)

void USkeletalMeshComponent::SetClothExternalForce(const struct FVector& InForce)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothExternalForce"));

	USkeletalMeshComponent_SetClothExternalForce_Params params;
	params.InForce = InForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UpdateClothParams
// (Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USkeletalMeshComponent::UpdateClothParams()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.UpdateClothParams"));

	USkeletalMeshComponent_UpdateClothParams_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetEnableClothingSimulation
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnable                      (Parm)

void USkeletalMeshComponent::SetEnableClothingSimulation(bool bInEnable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetEnableClothingSimulation"));

	USkeletalMeshComponent_SetEnableClothingSimulation_Params params;
	params.bInEnable = bInEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothFrozen
// (Final, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewFrozen                     (Parm)

void USkeletalMeshComponent::SetClothFrozen(bool bNewFrozen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetClothFrozen"));

	USkeletalMeshComponent_SetClothFrozen_Params params;
	params.bNewFrozen = bNewFrozen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetEnableClothSimulation
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bInEnable                      (Parm)

void USkeletalMeshComponent::SetEnableClothSimulation(bool bInEnable)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetEnableClothSimulation"));

	USkeletalMeshComponent_SetEnableClothSimulation_Params params;
	params.bInEnable = bInEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetForceRefPose
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bNewForceRefPose               (Parm)

void USkeletalMeshComponent::SetForceRefPose(bool bNewForceRefPose)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetForceRefPose"));

	USkeletalMeshComponent_SetForceRefPose_Params params;
	params.bNewForceRefPose = bNewForceRefPose;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetPhysicsAsset
// (Final, Defined, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class UPhysicsAsset*           NewPhysicsAsset                (Parm)
// bool                           bForceReInit                   (OptionalParm, Parm)

void USkeletalMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetPhysicsAsset"));

	USkeletalMeshComponent_SetPhysicsAsset_Params params;
	params.NewPhysicsAsset = NewPhysicsAsset;
	params.bForceReInit = bForceReInit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetSkeletalMesh
// (Final, Iterator, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// class USkeletalMesh*           NewMesh                        (Parm)
// bool                           bKeepSpaceBases                (OptionalParm, Parm)
// bool                           bTgCallInitAnimTree            (OptionalParm, Parm)

void USkeletalMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bKeepSpaceBases, bool bTgCallInitAnimTree)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetSkeletalMesh"));

	USkeletalMeshComponent_SetSkeletalMesh_Params params;
	params.NewMesh = NewMesh;
	params.bKeepSpaceBases = bKeepSpaceBases;
	params.bTgCallInitAnimTree = bTgCallInitAnimTree;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetTransformMatrix
// (Final, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FMatrix USkeletalMeshComponent::STATIC_GetTransformMatrix()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetTransformMatrix"));

	USkeletalMeshComponent_GetTransformMatrix_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.AttachedComponents
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UClass*                  BaseClass                      (Parm)
// class UActorComponent*         OutComponent                   (Parm, OutParm, EditInline)

void USkeletalMeshComponent::AttachedComponents(class UClass* BaseClass, class UActorComponent** OutComponent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AttachedComponents"));

	USkeletalMeshComponent_AttachedComponents_Params params;
	params.BaseClass = BaseClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponent != nullptr)
		*OutComponent = params.OutComponent;
}


// Function Engine.SkeletalMeshComponent.IsComponentAttached
// (Final, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// class UActorComponent*         Component                      (Parm, EditInline)
// struct FName                   BoneName                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::STATIC_IsComponentAttached(class UActorComponent* Component, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.IsComponentAttached"));

	USkeletalMeshComponent_IsComponentAttached_Params params;
	params.Component = Component;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.FindComponentAttachedToBone
// (Iterator, NetReliable, Exec, Event, Static)
// Parameters:
// struct FName                   InBoneName                     (Parm)
// class UActorComponent*         ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class UActorComponent* USkeletalMeshComponent::STATIC_FindComponentAttachedToBone(const struct FName& InBoneName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.FindComponentAttachedToBone"));

	USkeletalMeshComponent_FindComponentAttachedToBone_Params params;
	params.InBoneName = InBoneName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetSocketBoneName
// (Final, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InSocketName                   (Parm)
// struct FName                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FName USkeletalMeshComponent::STATIC_GetSocketBoneName(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetSocketBoneName"));

	USkeletalMeshComponent_GetSocketBoneName_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetSocketByName
// (Defined, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InSocketName                   (Parm)
// class USkeletalMeshSocket*     ReturnValue                    (Parm, OutParm, ReturnParm)

class USkeletalMeshSocket* USkeletalMeshComponent::STATIC_GetSocketByName(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetSocketByName"));

	USkeletalMeshComponent_GetSocketByName_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetSocketWorldLocationAndRotation
// (Final, Defined, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   InSocketName                   (Parm)
// struct FVector                 OutLocation                    (Parm, OutParm)
// struct FRotator                OutRotation                    (OptionalParm, Parm, OutParm)
// int                            Space                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USkeletalMeshComponent::STATIC_GetSocketWorldLocationAndRotation(const struct FName& InSocketName, int Space, struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetSocketWorldLocationAndRotation"));

	USkeletalMeshComponent_GetSocketWorldLocationAndRotation_Params params;
	params.InSocketName = InSocketName;
	params.Space = Space;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLocation != nullptr)
		*OutLocation = params.OutLocation;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.AttachComponentToSocket
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UActorComponent*         Component                      (Parm, EditInline)
// struct FName                   SocketName                     (Parm)

void USkeletalMeshComponent::AttachComponentToSocket(class UActorComponent* Component, const struct FName& SocketName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AttachComponentToSocket"));

	USkeletalMeshComponent_AttachComponentToSocket_Params params;
	params.Component = Component;
	params.SocketName = SocketName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.DetachComponent
// (Final, Iterator, Net, NetReliable, Native, Static)
// Parameters:
// class UActorComponent*         Component                      (Parm, EditInline)

void USkeletalMeshComponent::STATIC_DetachComponent(class UActorComponent* Component)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.DetachComponent"));

	USkeletalMeshComponent_DetachComponent_Params params;
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AttachComponent
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Operator)
// Parameters:
// class UActorComponent*         Component                      (Parm, EditInline)
// struct FName                   BoneName                       (Parm)
// struct FVector                 RelativeLocation               (OptionalParm, Parm)
// struct FRotator                RelativeRotation               (OptionalParm, Parm)
// struct FVector                 RelativeScale                  (OptionalParm, Parm)

void USkeletalMeshComponent::AttachComponent(class UActorComponent* Component, const struct FName& BoneName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const struct FVector& RelativeScale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.AttachComponent"));

	USkeletalMeshComponent_AttachComponent_Params params;
	params.Component = Component;
	params.BoneName = BoneName;
	params.RelativeLocation = RelativeLocation;
	params.RelativeRotation = RelativeRotation;
	params.RelativeScale = RelativeScale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.GetFOV
// (Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USkeletalMeshComponent::STATIC_GetFOV()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.GetFOV"));

	USkeletalMeshComponent_GetFOV_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.SetFOV
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewFOV                         (Parm)

void USkeletalMeshComponent::SetFOV(float NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SkeletalMeshComponent.SetFOV"));

	USkeletalMeshComponent_SetFOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.OnToggleHidden
// (Final, Latent, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_ToggleHidden*    Action                         (Parm)

void ASplineActor::STATIC_OnToggleHidden(class USeqAct_ToggleHidden* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.OnToggleHidden"));

	ASplineActor_OnToggleHidden_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ASplineActor::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.OnToggle"));

	ASplineActor_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.GetAllConnectedSplineActors
// (Final, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<class ASplineActor*>    OutSet                         (Parm, OutParm, NeedCtorLink)

void ASplineActor::STATIC_GetAllConnectedSplineActors(TArray<class ASplineActor*>* OutSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.GetAllConnectedSplineActors"));

	ASplineActor_GetAllConnectedSplineActors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSet != nullptr)
		*OutSet = params.OutSet;
}


// Function Engine.SplineActor.FindSplinePathTo
// (Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class ASplineActor*            Goal                           (Parm)
// TArray<class ASplineActor*>    OutRoute                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASplineActor::STATIC_FindSplinePathTo(class ASplineActor* Goal, TArray<class ASplineActor*>* OutRoute)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.FindSplinePathTo"));

	ASplineActor_FindSplinePathTo_Params params;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRoute != nullptr)
		*OutRoute = params.OutRoute;

	return params.ReturnValue;
}


// Function Engine.SplineActor.GetBestConnectionInDirection
// (Final, Defined, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 DesiredDir                     (Parm)
// bool                           bUseLinksFrom                  (OptionalParm, Parm)
// class ASplineActor*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ASplineActor* ASplineActor::STATIC_GetBestConnectionInDirection(const struct FVector& DesiredDir, bool bUseLinksFrom)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.GetBestConnectionInDirection"));

	ASplineActor_GetBestConnectionInDirection_Params params;
	params.DesiredDir = DesiredDir;
	params.bUseLinksFrom = bUseLinksFrom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineActor.GetRandomConnection
// (PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// bool                           bUseLinksFrom                  (OptionalParm, Parm)
// class ASplineActor*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ASplineActor* ASplineActor::STATIC_GetRandomConnection(bool bUseLinksFrom)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.GetRandomConnection"));

	ASplineActor_GetRandomConnection_Params params;
	params.bUseLinksFrom = bUseLinksFrom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineActor.BreakAllConnectionsFrom
// (NetReliable, Exec, Event, Operator)

void ASplineActor::BreakAllConnectionsFrom()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.BreakAllConnectionsFrom"));

	ASplineActor_BreakAllConnectionsFrom_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.BreakAllConnections
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Event, Operator)

void ASplineActor::BreakAllConnections()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.BreakAllConnections"));

	ASplineActor_BreakAllConnections_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.BreakConnectionTo
// (Final, NetReliable, Exec, Event, Operator)
// Parameters:
// class ASplineActor*            NextActor                      (Parm)

void ASplineActor::BreakConnectionTo(class ASplineActor* NextActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.BreakConnectionTo"));

	ASplineActor_BreakConnectionTo_Params params;
	params.NextActor = NextActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.FindTargetForComponent
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class USplineComponent*        SplineComp                     (Parm, EditInline)
// class ASplineActor*            ReturnValue                    (Parm, OutParm, ReturnParm)

class ASplineActor* ASplineActor::STATIC_FindTargetForComponent(class USplineComponent* SplineComp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.FindTargetForComponent"));

	ASplineActor_FindTargetForComponent_Params params;
	params.SplineComp = SplineComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineActor.FindSplineComponentTo
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class ASplineActor*            NextActor                      (Parm)
// class USplineComponent*        ReturnValue                    (Parm, OutParm, ReturnParm, EditInline)

class USplineComponent* ASplineActor::STATIC_FindSplineComponentTo(class ASplineActor* NextActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.FindSplineComponentTo"));

	ASplineActor_FindSplineComponentTo_Params params;
	params.NextActor = NextActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineActor.IsConnectedTo
// (Defined, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// class ASplineActor*            NextActor                      (Parm)
// bool                           bCheckForDisableDestination    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ASplineActor::STATIC_IsConnectedTo(class ASplineActor* NextActor, bool bCheckForDisableDestination)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.IsConnectedTo"));

	ASplineActor_IsConnectedTo_Params params;
	params.NextActor = NextActor;
	params.bCheckForDisableDestination = bCheckForDisableDestination;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineActor.AddConnectionTo
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// class ASplineActor*            NextActor                      (Parm)

void ASplineActor::AddConnectionTo(class ASplineActor* NextActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.AddConnectionTo"));

	ASplineActor_AddConnectionTo_Params params;
	params.NextActor = NextActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.UpdateConnectedSplineComponents
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// bool                           bFinish                        (Parm)

void ASplineActor::UpdateConnectedSplineComponents(bool bFinish)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.UpdateConnectedSplineComponents"));

	ASplineActor_UpdateConnectedSplineComponents_Params params;
	params.bFinish = bFinish;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.UpdateSplineComponents
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ASplineActor::UpdateSplineComponents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.UpdateSplineComponents"));

	ASplineActor_UpdateSplineComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineActor.GetWorldSpaceTangent
// (Latent, Net, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector ASplineActor::STATIC_GetWorldSpaceTangent()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineActor.GetWorldSpaceTangent"));

	ASplineActor_GetWorldSpaceTangent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineLoftActor.UpdateSplineParams
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ASplineLoftActor::UpdateSplineParams()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineLoftActor.UpdateSplineParams"));

	ASplineLoftActor_UpdateSplineParams_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineLoftActor.ClearLoftMesh
// (Defined, NetReliable, Simulated, Exec, Native, Event, Operator)

void ASplineLoftActor::ClearLoftMesh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineLoftActor.ClearLoftMesh"));

	ASplineLoftActor_ClearLoftMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
// (Final, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// float                          Distance                       (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USplineComponent::STATIC_GetTangentAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline"));

	USplineComponent_GetTangentAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
// (Iterator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          Distance                       (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector USplineComponent::STATIC_GetLocationAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline"));

	USplineComponent_GetLocationAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetSplineLength
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float USplineComponent::STATIC_GetSplineLength()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineComponent.GetSplineLength"));

	USplineComponent_GetSplineLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.UpdateSplineReparamTable
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USplineComponent::UpdateSplineReparamTable()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineComponent.UpdateSplineReparamTable"));

	USplineComponent_UpdateSplineReparamTable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.UpdateSplineCurviness
// (Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void USplineComponent::UpdateSplineCurviness()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SplineComponent.UpdateSplineCurviness"));

	USplineComponent_UpdateSplineCurviness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProcBuilding.FindEdgeForTopLevelScope
// (Final, Defined, Iterator, Latent, NetReliable, Exec, Event, Static)
// Parameters:
// int                            TopLevelScopeIndex             (Parm)
// TEnumAsByte<EScopeEdge>        Edge                           (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int AProcBuilding::STATIC_FindEdgeForTopLevelScope(int TopLevelScopeIndex, TEnumAsByte<EScopeEdge> Edge)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.FindEdgeForTopLevelScope"));

	AProcBuilding_FindEdgeForTopLevelScope_Params params;
	params.TopLevelScopeIndex = TopLevelScopeIndex;
	params.Edge = Edge;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ProcBuilding.BreakFractureComponent
// (Final, Defined, NetReliable, Exec, Event, Operator)
// Parameters:
// class UFracturedStaticMeshComponent* Comp                           (Parm, EditInline)
// struct FVector                 BoxMin                         (Parm)
// struct FVector                 BoxMax                         (Parm)

void AProcBuilding::BreakFractureComponent(class UFracturedStaticMeshComponent* Comp, const struct FVector& BoxMin, const struct FVector& BoxMax)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.BreakFractureComponent"));

	AProcBuilding_BreakFractureComponent_Params params;
	params.Comp = Comp;
	params.BoxMin = BoxMin;
	params.BoxMax = BoxMax;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProcBuilding.GetAllGroupedProcBuildings
// (Final, Defined, Latent, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<class AProcBuilding*>   OutSet                         (Parm, OutParm, NeedCtorLink)

void AProcBuilding::STATIC_GetAllGroupedProcBuildings(TArray<class AProcBuilding*>* OutSet)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.GetAllGroupedProcBuildings"));

	AProcBuilding_GetAllGroupedProcBuildings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSet != nullptr)
		*OutSet = params.OutSet;
}


// Function Engine.ProcBuilding.GetBaseMostBuilding
// (Final, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// class AProcBuilding*           ReturnValue                    (Parm, OutParm, ReturnParm)

class AProcBuilding* AProcBuilding::STATIC_GetBaseMostBuilding()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.GetBaseMostBuilding"));

	AProcBuilding_GetBaseMostBuilding_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ProcBuilding.FindComponentsForTopLevelScope
// (Final, Iterator, NetReliable, Exec, Event, Static)
// Parameters:
// int                            TopLevelScopeIndex             (Parm)
// TArray<class UStaticMeshComponent*> ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink, EditInline)

TArray<class UStaticMeshComponent*> AProcBuilding::STATIC_FindComponentsForTopLevelScope(int TopLevelScopeIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.FindComponentsForTopLevelScope"));

	AProcBuilding_FindComponentsForTopLevelScope_Params params;
	params.TopLevelScopeIndex = TopLevelScopeIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ProcBuilding.ClearBuildingMeshes
// (Final, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void AProcBuilding::ClearBuildingMeshes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ProcBuilding.ClearBuildingMeshes"));

	AProcBuilding_ClearBuildingMeshes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PBRuleNodeMesh.PickRandomBuildingMesh
// (Iterator, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UPBRuleNodeMesh::PickRandomBuildingMesh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PBRuleNodeMesh.PickRandomBuildingMesh"));

	UPBRuleNodeMesh_PickRandomBuildingMesh_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.GetMissionTime
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float AGameReplicationInfo::GetMissionTime()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.GetMissionTime"));

	AGameReplicationInfo_GetMissionTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.ShouldShowGore
// (Defined, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameReplicationInfo::ShouldShowGore()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.ShouldShowGore"));

	AGameReplicationInfo_ShouldShowGore_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.IsCoopMultiplayerGame
// (Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameReplicationInfo::STATIC_IsCoopMultiplayerGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.IsCoopMultiplayerGame"));

	AGameReplicationInfo_IsCoopMultiplayerGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.IsMultiplayerGame
// (Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameReplicationInfo::STATIC_IsMultiplayerGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.IsMultiplayerGame"));

	AGameReplicationInfo_IsMultiplayerGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.EndGame
// (Final, Latent, Event, Static)

void AGameReplicationInfo::STATIC_EndGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.EndGame"));

	AGameReplicationInfo_EndGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.StartMatch
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)

void AGameReplicationInfo::StartMatch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.StartMatch"));

	AGameReplicationInfo_StartMatch_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.SetTeam
// (Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// class ATeamInfo*               TI                             (Parm)

void AGameReplicationInfo::SetTeam(int Index, class ATeamInfo* TI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.SetTeam"));

	AGameReplicationInfo_SetTeam_Params params;
	params.Index = Index;
	params.TI = TI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.RemovePRI
// (Final, Defined, Iterator, Latent, PreOperator, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)

void AGameReplicationInfo::RemovePRI(class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.RemovePRI"));

	AGameReplicationInfo_RemovePRI_Params params;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.AddPRI
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)

void AGameReplicationInfo::AddPRI(class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.AddPRI"));

	AGameReplicationInfo_AddPRI_Params params;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.CheckIsEnemy
// (Defined, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// class AActor*                  A                              (Const, Parm)
// class AActor*                  B                              (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameReplicationInfo::CheckIsEnemy(class AActor* A, class AActor* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.CheckIsEnemy"));

	AGameReplicationInfo_CheckIsEnemy_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.OnSameTeam
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// class AActor*                  A                              (Parm)
// class AActor*                  B                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AGameReplicationInfo::STATIC_OnSameTeam(class AActor* A, class AActor* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.OnSameTeam"));

	AGameReplicationInfo_OnSameTeam_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameReplicationInfo.Timer
// (Defined, Latent, PreOperator, Singular, NetReliable, Native)

void AGameReplicationInfo::Timer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.Timer"));

	AGameReplicationInfo_Timer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void AGameReplicationInfo::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.Reset"));

	AGameReplicationInfo_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.ReceivedGameClass
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)

void AGameReplicationInfo::ReceivedGameClass()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.ReceivedGameClass"));

	AGameReplicationInfo_ReceivedGameClass_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AGameReplicationInfo::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.ReplicatedEvent"));

	AGameReplicationInfo_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameReplicationInfo.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AGameReplicationInfo::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameReplicationInfo.PostBeginPlay"));

	AGameReplicationInfo_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.IsPrimaryPlayer
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerReplicationInfo::STATIC_IsPrimaryPlayer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.IsPrimaryPlayer"));

	APlayerReplicationInfo_IsPrimaryPlayer_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.UnregisterPlayerFromSession
// (Latent, Simulated, Exec, Native, HasOptionalParms)

void APlayerReplicationInfo::UnregisterPlayerFromSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.UnregisterPlayerFromSession"));

	APlayerReplicationInfo_UnregisterPlayerFromSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.RegisterPlayerWithSession
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, HasOptionalParms)

void APlayerReplicationInfo::RegisterPlayerWithSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.RegisterPlayerWithSession"));

	APlayerReplicationInfo_RegisterPlayerWithSession_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.IsInvalidName
// (Final, Defined, Iterator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerReplicationInfo::STATIC_IsInvalidName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.IsInvalidName"));

	APlayerReplicationInfo_IsInvalidName_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char APlayerReplicationInfo::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.GetTeamNum"));

	APlayerReplicationInfo_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.SetUniqueId
// (Iterator, Latent, PreOperator, NetReliable, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerUniqueId                 (Parm)

void APlayerReplicationInfo::SetUniqueId(const struct FUniqueNetId& PlayerUniqueId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.SetUniqueId"));

	APlayerReplicationInfo_SetUniqueId_Params params;
	params.PlayerUniqueId = PlayerUniqueId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.SeamlessTravelTo
// (Final, Defined, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  NewPRI                         (Parm)

void APlayerReplicationInfo::SeamlessTravelTo(class APlayerReplicationInfo* NewPRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.SeamlessTravelTo"));

	APlayerReplicationInfo_SeamlessTravelTo_Params params;
	params.NewPRI = NewPRI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.IncrementDeaths
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Operator, Static)
// Parameters:
// int                            Amt                            (OptionalParm, Parm)

void APlayerReplicationInfo::STATIC_IncrementDeaths(int Amt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.IncrementDeaths"));

	APlayerReplicationInfo_IncrementDeaths_Params params;
	params.Amt = Amt;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.CopyProperties
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Static)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)

void APlayerReplicationInfo::STATIC_CopyProperties(class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.CopyProperties"));

	APlayerReplicationInfo_CopyProperties_Params params;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.OverrideWith
// (Final, PreOperator, Singular, Exec, Native, Event, Operator, Static)
// Parameters:
// class APlayerReplicationInfo*  PRI                            (Parm)

void APlayerReplicationInfo::STATIC_OverrideWith(class APlayerReplicationInfo* PRI)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.OverrideWith"));

	APlayerReplicationInfo_OverrideWith_Params params;
	params.PRI = PRI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.Duplicate
// (Final, Iterator, PreOperator, Singular, Net, Native, Operator, HasOptionalParms)
// Parameters:
// class APlayerReplicationInfo*  ReturnValue                    (Parm, OutParm, ReturnParm)

class APlayerReplicationInfo* APlayerReplicationInfo::Duplicate()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.Duplicate"));

	APlayerReplicationInfo_Duplicate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.SetWaitingPlayer
// (PreOperator, Singular, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           B                              (Parm)

void APlayerReplicationInfo::SetWaitingPlayer(bool B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.SetWaitingPlayer"));

	APlayerReplicationInfo_SetWaitingPlayer_Params params;
	params.B = B;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.SetPlayerName
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void APlayerReplicationInfo::SetPlayerName(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.SetPlayerName"));

	APlayerReplicationInfo_SetPlayerName_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          YL                             (Parm, OutParm)
// float                          YPos                           (Parm, OutParm)

void APlayerReplicationInfo::STATIC_DisplayDebug(class AHUD* HUD, float* YL, float* YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.DisplayDebug"));

	APlayerReplicationInfo_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (YL != nullptr)
		*YL = params.YL;
	if (YPos != nullptr)
		*YPos = params.YPos;
}


// Function Engine.PlayerReplicationInfo.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APlayerReplicationInfo::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.GetHumanReadableName"));

	APlayerReplicationInfo_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.Reset
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)

void APlayerReplicationInfo::Reset()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.Reset"));

	APlayerReplicationInfo_Reset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.Destroyed
// (Iterator, Latent, Singular, Simulated)

void APlayerReplicationInfo::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.Destroyed"));

	APlayerReplicationInfo_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ShouldBroadCastWelcomeMessage
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Event, HasOptionalParms)
// Parameters:
// bool                           bExiting                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerReplicationInfo::ShouldBroadCastWelcomeMessage(bool bExiting)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ShouldBroadCastWelcomeMessage"));

	APlayerReplicationInfo_ShouldBroadCastWelcomeMessage_Params params;
	params.bExiting = bExiting;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerReplicationInfo.UpdatePing
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// float                          TimeStamp                      (Parm)

void APlayerReplicationInfo::UpdatePing(float TimeStamp)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.UpdatePing"));

	APlayerReplicationInfo_UpdatePing_Params params;
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void APlayerReplicationInfo::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ReplicatedEvent"));

	APlayerReplicationInfo_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.RemoteUserDataReplicated
// (Defined, Native, HasOptionalParms)

void APlayerReplicationInfo::RemoteUserDataReplicated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.RemoteUserDataReplicated"));

	APlayerReplicationInfo_RemoteUserDataReplicated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.SetPlayerTeam
// (Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// class ATeamInfo*               NewTeam                        (Parm)

void APlayerReplicationInfo::SetPlayerTeam(class ATeamInfo* NewTeam)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.SetPlayerTeam"));

	APlayerReplicationInfo_SetPlayerTeam_Params params;
	params.NewTeam = NewTeam;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ClientInitialize
// (Defined, Latent, Static)
// Parameters:
// class AController*             C                              (Parm)

void APlayerReplicationInfo::STATIC_ClientInitialize(class AController* C)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ClientInitialize"));

	APlayerReplicationInfo_ClientInitialize_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.UpdateRemoteUserData
// (Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void APlayerReplicationInfo::UpdateRemoteUserData()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.UpdateRemoteUserData"));

	APlayerReplicationInfo_UpdateRemoteUserData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ServerUpdateRemoteUserData
// (Final, Singular, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FPRIAudioDeviceInfo     Device                         (Parm, NeedCtorLink)
// int                            Index                          (Parm)

void APlayerReplicationInfo::ServerUpdateRemoteUserData(const struct FPRIAudioDeviceInfo& Device, int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ServerUpdateRemoteUserData"));

	APlayerReplicationInfo_ServerUpdateRemoteUserData_Params params;
	params.Device = Device;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ServerFinalizeRemoteUserData
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bGuest                         (Parm)
// struct FString                 Id                             (Parm, NeedCtorLink)

void APlayerReplicationInfo::ServerFinalizeRemoteUserData(bool bGuest, const struct FString& Id)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ServerFinalizeRemoteUserData"));

	APlayerReplicationInfo_ServerFinalizeRemoteUserData_Params params;
	params.bGuest = bGuest;
	params.Id = Id;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.ClientFillRemoteUserData
// (Final, Defined, Iterator, Latent, Singular, Simulated, Native, HasOptionalParms)

void APlayerReplicationInfo::ClientFillRemoteUserData()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.ClientFillRemoteUserData"));

	APlayerReplicationInfo_ClientFillRemoteUserData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.PostBeginPlay
// (Final, Latent, Net, Simulated)

void APlayerReplicationInfo::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.PostBeginPlay"));

	APlayerReplicationInfo_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerReplicationInfo.IsBot
// (Iterator, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool APlayerReplicationInfo::STATIC_IsBot()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlayerReplicationInfo.IsBot"));

	APlayerReplicationInfo_IsBot_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TeamInfo.GetTeamNum
// (Final, Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  ReturnValue                    (Parm, OutParm, ReturnParm)

unsigned char ATeamInfo::STATIC_GetTeamNum()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.GetTeamNum"));

	ATeamInfo_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TeamInfo.GetHumanReadableName
// (Final, Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ATeamInfo::STATIC_GetHumanReadableName()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.GetHumanReadableName"));

	ATeamInfo_GetHumanReadableName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TeamInfo.RemoveFromTeam
// (Iterator, PreOperator, Native, HasOptionalParms)
// Parameters:
// class AController*             Other                          (Parm)

void ATeamInfo::RemoveFromTeam(class AController* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.RemoveFromTeam"));

	ATeamInfo_RemoveFromTeam_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TeamInfo.AddToTeam
// (Defined, Iterator, PreOperator, Singular, Operator)
// Parameters:
// class AController*             Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATeamInfo::AddToTeam(class AController* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.AddToTeam"));

	ATeamInfo_AddToTeam_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TeamInfo.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ATeamInfo::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.Destroyed"));

	ATeamInfo_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TeamInfo.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void ATeamInfo::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TeamInfo.ReplicatedEvent"));

	ATeamInfo_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.StopCameraAnim
// (Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UCameraAnimInst*         AnimInst                       (Parm)
// bool                           bImmediate                     (OptionalParm, Parm)

void ACamera::StopCameraAnim(class UCameraAnimInst* AnimInst, bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.StopCameraAnim"));

	ACamera_StopCameraAnim_Params params;
	params.AnimInst = AnimInst;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.StopAllCameraAnimsByType
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UCameraAnim*             Anim                           (Parm)
// bool                           bImmediate                     (OptionalParm, Parm)

void ACamera::StopAllCameraAnimsByType(class UCameraAnim* Anim, bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.StopAllCameraAnimsByType"));

	ACamera_StopAllCameraAnimsByType_Params params;
	params.Anim = Anim;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.StopAllCameraAnims
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           bImmediate                     (OptionalParm, Parm)

void ACamera::StopAllCameraAnims(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.StopAllCameraAnims"));

	ACamera_StopAllCameraAnims_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.PlayCameraAnim
// (Final, Latent, Net, HasOptionalParms)
// Parameters:
// class UCameraAnim*             Anim                           (Parm)
// float                          Rate                           (OptionalParm, Parm)
// float                          Scale                          (OptionalParm, Parm)
// float                          BlendInTime                    (OptionalParm, Parm)
// float                          BlendOutTime                   (OptionalParm, Parm)
// bool                           bLoop                          (OptionalParm, Parm)
// bool                           bRandomStartTime               (OptionalParm, Parm)
// float                          Duration                       (OptionalParm, Parm)
// bool                           bSingleInstance                (OptionalParm, Parm)
// class UCameraAnimInst*         ReturnValue                    (Parm, OutParm, ReturnParm)

class UCameraAnimInst* ACamera::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, bool bSingleInstance)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.PlayCameraAnim"));

	ACamera_PlayCameraAnim_Params params;
	params.Anim = Anim;
	params.Rate = Rate;
	params.Scale = Scale;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Duration = Duration;
	params.bSingleInstance = bSingleInstance;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Camera.ClearAllCameraShakes
// (Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Operator)

void ACamera::ClearAllCameraShakes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.ClearAllCameraShakes"));

	ACamera_ClearAllCameraShakes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.PlayWorldCameraShake
// (Final, Defined, Latent, Singular, NetReliable, HasOptionalParms)
// Parameters:
// class UCameraShake*            Shake                          (Parm)
// class AActor*                  ShakeInstigator                (Parm)
// struct FVector                 Epicenter                      (Parm)
// float                          InnerRadius                    (Parm)
// float                          OuterRadius                    (Parm)
// float                          Falloff                        (Parm)
// bool                           bTryForceFeedback              (Parm)
// bool                           bOrientShakeTowardsEpicenter   (OptionalParm, Parm)

void ACamera::PlayWorldCameraShake(class UCameraShake* Shake, class AActor* ShakeInstigator, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bTryForceFeedback, bool bOrientShakeTowardsEpicenter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.PlayWorldCameraShake"));

	ACamera_PlayWorldCameraShake_Params params;
	params.Shake = Shake;
	params.ShakeInstigator = ShakeInstigator;
	params.Epicenter = Epicenter;
	params.InnerRadius = InnerRadius;
	params.OuterRadius = OuterRadius;
	params.Falloff = Falloff;
	params.bTryForceFeedback = bTryForceFeedback;
	params.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.CalcRadialShakeScale
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// class ACamera*                 Cam                            (Parm)
// struct FVector                 Epicenter                      (Parm)
// float                          InnerRadius                    (Parm)
// float                          OuterRadius                    (Parm)
// float                          Falloff                        (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ACamera::CalcRadialShakeScale(class ACamera* Cam, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.CalcRadialShakeScale"));

	ACamera_CalcRadialShakeScale_Params params;
	params.Cam = Cam;
	params.Epicenter = Epicenter;
	params.InnerRadius = InnerRadius;
	params.OuterRadius = OuterRadius;
	params.Falloff = Falloff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Camera.StopCameraShake
// (Final, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UCameraShake*            Shake                          (Parm)

void ACamera::StopCameraShake(class UCameraShake* Shake)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.StopCameraShake"));

	ACamera_StopCameraShake_Params params;
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.PlayCameraShake
// (Defined, Latent, Net, HasOptionalParms)
// Parameters:
// class UCameraShake*            Shake                          (Parm)
// float                          Scale                          (Parm)
// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (OptionalParm, Parm)
// struct FRotator                UserPlaySpaceRot               (OptionalParm, Parm)

void ACamera::PlayCameraShake(class UCameraShake* Shake, float Scale, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.PlayCameraShake"));

	ACamera_PlayCameraShake_Params params;
	params.Shake = Shake;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.ClearCameraLensEffects
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)

void ACamera::ClearCameraLensEffects()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.ClearCameraLensEffects"));

	ACamera_ClearCameraLensEffects_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.RemoveCameraLensEffect
// (Final, Defined, Latent, Native, HasOptionalParms)
// Parameters:
// class AEmitterCameraLensEffectBase* Emitter                        (Parm)

void ACamera::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.RemoveCameraLensEffect"));

	ACamera_RemoveCameraLensEffect_Params params;
	params.Emitter = Emitter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.AddCameraLensEffect
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// class UClass*                  LensEffectEmitterClass         (Parm)

void ACamera::AddCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.AddCameraLensEffect"));

	ACamera_AddCameraLensEffect_Params params;
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.FindCameraLensEffect
// (Final, NetReliable, Exec, Event, Static)
// Parameters:
// class UClass*                  LensEffectEmitterClass         (Parm)
// class AEmitterCameraLensEffectBase* ReturnValue                    (Parm, OutParm, ReturnParm)

class AEmitterCameraLensEffectBase* ACamera::STATIC_FindCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.FindCameraLensEffect"));

	ACamera_FindCameraLensEffect_Params params;
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Camera.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void ACamera::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.DisplayDebug"));

	ACamera_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.Camera.SetViewTarget
// (Iterator, PreOperator, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm)
// struct FViewTargetTransitionParams TransitionParams               (OptionalParm, Parm)

void ACamera::SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.SetViewTarget"));

	ACamera_SetViewTarget_Params params;
	params.NewViewTarget = NewViewTarget;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.UpdateViewTarget
// (NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FTViewTarget            OutVT                          (Parm, OutParm)
// float                          DeltaTime                      (Parm)

void ACamera::UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.UpdateViewTarget"));

	ACamera_UpdateViewTarget_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutVT != nullptr)
		*OutVT = params.OutVT;
}


// Function Engine.Camera.CheckViewTarget
// (Iterator, Singular, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FTViewTarget            VT                             (Parm, OutParm)

void ACamera::CheckViewTarget(struct FTViewTarget* VT)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.CheckViewTarget"));

	ACamera_CheckViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (VT != nullptr)
		*VT = params.VT;
}


// Function Engine.Camera.FillCameraCache
// (Iterator, Singular, Net, Exec, Event, Static)
// Parameters:
// struct FTPOV                   NewPOV                         (Const, Parm, OutParm)

void ACamera::STATIC_FillCameraCache(struct FTPOV* NewPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.FillCameraCache"));

	ACamera_FillCameraCache_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewPOV != nullptr)
		*NewPOV = params.NewPOV;
}


// Function Engine.Camera.GetViewLocalToTarget
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// class AActor*                  InViewTarget                   (Const, Parm)
// struct FVector                 LocalViewLocation              (Parm, OutParm)
// struct FQuat                   LocalViewRotation              (Parm, OutParm)

void ACamera::STATIC_GetViewLocalToTarget(class AActor* InViewTarget, struct FVector* LocalViewLocation, struct FQuat* LocalViewRotation)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.GetViewLocalToTarget"));

	ACamera_GetViewLocalToTarget_Params params;
	params.InViewTarget = InViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LocalViewLocation != nullptr)
		*LocalViewLocation = params.LocalViewLocation;
	if (LocalViewRotation != nullptr)
		*LocalViewRotation = params.LocalViewRotation;
}


// Function Engine.Camera.BlendViewTargets
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Operator)
// Parameters:
// struct FTViewTarget            A                              (Const, Parm, OutParm)
// struct FTViewTarget            B                              (Const, Parm, OutParm)
// float                          Alpha                          (Parm)
// struct FTPOV                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTPOV ACamera::BlendViewTargets(float Alpha, struct FTViewTarget* A, struct FTViewTarget* B)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.BlendViewTargets"));

	ACamera_BlendViewTargets_Params params;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
	if (B != nullptr)
		*B = params.B;

	return params.ReturnValue;
}


// Function Engine.Camera.ApplyAudioFade
// (Defined, Latent, Singular, NetReliable, Simulated, Operator)

void ACamera::ApplyAudioFade()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.ApplyAudioFade"));

	ACamera_ApplyAudioFade_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.DoUpdateCamera
// (Final, Defined, Iterator, Latent, Exec, Native, Static)
// Parameters:
// float                          DeltaTime                      (Parm)

void ACamera::STATIC_DoUpdateCamera(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.DoUpdateCamera"));

	ACamera_DoUpdateCamera_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.UpdateCamera
// (Defined, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)

void ACamera::UpdateCamera(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.UpdateCamera"));

	ACamera_UpdateCamera_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.SetDesiredColorScale
// (Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 NewColorScale                  (Parm)
// float                          InterpTime                     (Parm)

void ACamera::SetDesiredColorScale(const struct FVector& NewColorScale, float InterpTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.SetDesiredColorScale"));

	ACamera_SetDesiredColorScale_Params params;
	params.NewColorScale = NewColorScale;
	params.InterpTime = InterpTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.GetCameraRotation
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRotator ACamera::STATIC_GetCameraRotation()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.GetCameraRotation"));

	ACamera_GetCameraRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Camera.GetCameraViewPoint
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 OutCamLoc                      (Parm, OutParm)
// struct FRotator                OutCamRot                      (Parm, OutParm)

void ACamera::STATIC_GetCameraViewPoint(struct FVector* OutCamLoc, struct FRotator* OutCamRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.GetCameraViewPoint"));

	ACamera_GetCameraViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutCamLoc != nullptr)
		*OutCamLoc = params.OutCamLoc;
	if (OutCamRot != nullptr)
		*OutCamRot = params.OutCamRot;
}


// Function Engine.Camera.SetFOV
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewFOV                         (Parm)

void ACamera::SetFOV(float NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.SetFOV"));

	ACamera_SetFOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.GetFOVAngle
// (Iterator, Latent, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ACamera::GetFOVAngle()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.GetFOVAngle"));

	ACamera_GetFOVAngle_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Camera.InitializeFor
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       PC                             (Parm)

void ACamera::InitializeFor(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.InitializeFor"));

	ACamera_InitializeFor_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.ApplyCameraModifiers
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Operator)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FTPOV                   OutPOV                         (Parm, OutParm)

void ACamera::ApplyCameraModifiers(float DeltaTime, struct FTPOV* OutPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.ApplyCameraModifiers"));

	ACamera_ApplyCameraModifiers_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPOV != nullptr)
		*OutPOV = params.OutPOV;
}


// Function Engine.Camera.Destroyed
// (Iterator, Latent, Singular, Simulated)

void ACamera::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.Destroyed"));

	ACamera_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ACamera::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.PostBeginPlay"));

	ACamera_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Camera.CreateCameraModifier
// (Final, Exec, Static)
// Parameters:
// class UClass*                  ModifierClass                  (Parm)
// class UCameraModifier*         ReturnValue                    (Parm, OutParm, ReturnParm)

class UCameraModifier* ACamera::STATIC_CreateCameraModifier(class UClass* ModifierClass)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Camera.CreateCameraModifier"));

	ACamera_CreateCameraModifier_Params params;
	params.ModifierClass = ModifierClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraActor.DisplayDebug
// (Final, Defined, Iterator, PreOperator, Simulated, Native, Static)
// Parameters:
// class AHUD*                    HUD                            (Parm)
// float                          out_YL                         (Parm, OutParm)
// float                          out_YPos                       (Parm, OutParm)

void ACameraActor::STATIC_DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraActor.DisplayDebug"));

	ACameraActor_DisplayDebug_Params params;
	params.HUD = HUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_YL != nullptr)
		*out_YL = params.out_YL;
	if (out_YPos != nullptr)
		*out_YPos = params.out_YPos;
}


// Function Engine.CameraActor.GetCameraView
// (Iterator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FTPOV                   OutPOV                         (Parm, OutParm)
// bool                           bOnlyFOV                       (OptionalParm, Parm)

void ACameraActor::GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraActor.GetCameraView"));

	ACameraActor_GetCameraView_Params params;
	params.DeltaTime = DeltaTime;
	params.bOnlyFOV = bOnlyFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPOV != nullptr)
		*OutPOV = params.OutPOV;
}


// Function Engine.CameraAnimInst.SetPlaySpace
// (Final, Latent, PreOperator, Singular, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ECameraAnimPlaySpace> NewSpace                       (Parm)
// struct FRotator                UserPlaySpace                  (OptionalParm, Parm)

void UCameraAnimInst::SetPlaySpace(TEnumAsByte<ECameraAnimPlaySpace> NewSpace, const struct FRotator& UserPlaySpace)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.SetPlaySpace"));

	UCameraAnimInst_SetPlaySpace_Params params;
	params.NewSpace = NewSpace;
	params.UserPlaySpace = UserPlaySpace;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.ApplyTransientScaling
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Operator)
// Parameters:
// float                          Scalar                         (Parm)

void UCameraAnimInst::ApplyTransientScaling(float Scalar)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.ApplyTransientScaling"));

	UCameraAnimInst_ApplyTransientScaling_Params params;
	params.Scalar = Scalar;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.Stop
// (Final, Defined, Iterator, Latent, Singular, Net, Exec)
// Parameters:
// bool                           bImmediate                     (OptionalParm, Parm)

void UCameraAnimInst::Stop(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.Stop"));

	UCameraAnimInst_Stop_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.AdvanceAnim
// (Final, Defined, Iterator, Singular, Net, Operator)
// Parameters:
// float                          DeltaTime                      (Parm)
// bool                           bJump                          (Parm)

void UCameraAnimInst::AdvanceAnim(float DeltaTime, bool bJump)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.AdvanceAnim"));

	UCameraAnimInst_AdvanceAnim_Params params;
	params.DeltaTime = DeltaTime;
	params.bJump = bJump;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.Update
// (Final, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          NewRate                        (Parm)
// float                          NewScale                       (Parm)
// float                          NewBlendInTime                 (Parm)
// float                          NewBlendOutTime                (Parm)
// float                          NewDuration                    (OptionalParm, Parm)

void UCameraAnimInst::Update(float NewRate, float NewScale, float NewBlendInTime, float NewBlendOutTime, float NewDuration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.Update"));

	UCameraAnimInst_Update_Params params;
	params.NewRate = NewRate;
	params.NewScale = NewScale;
	params.NewBlendInTime = NewBlendInTime;
	params.NewBlendOutTime = NewBlendOutTime;
	params.NewDuration = NewDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.Play
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// class UCameraAnim*             Anim                           (Parm)
// class AActor*                  CamActor                       (Parm)
// float                          InRate                         (Parm)
// float                          InScale                        (Parm)
// float                          InBlendInTime                  (Parm)
// float                          InBlendOutTime                 (Parm)
// bool                           bInLoop                        (Parm)
// bool                           bRandomStartTime               (Parm)
// float                          Duration                       (OptionalParm, Parm)

void UCameraAnimInst::Play(class UCameraAnim* Anim, class AActor* CamActor, float InRate, float InScale, float InBlendInTime, float InBlendOutTime, bool bInLoop, bool bRandomStartTime, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraAnimInst.Play"));

	UCameraAnimInst_Play_Params params;
	params.Anim = Anim;
	params.CamActor = CamActor;
	params.InRate = InRate;
	params.InScale = InScale;
	params.InBlendInTime = InBlendInTime;
	params.InBlendOutTime = InBlendOutTime;
	params.bInLoop = bInLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.UpdateAlpha
// (Final, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// class ACamera*                 Camera                         (Parm)
// float                          DeltaTime                      (Parm)

void UCameraModifier::UpdateAlpha(class ACamera* Camera, float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.UpdateAlpha"));

	UCameraModifier_UpdateAlpha_Params params;
	params.Camera = Camera;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.ToggleModifier
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, HasOptionalParms)

void UCameraModifier::ToggleModifier()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.ToggleModifier"));

	UCameraModifier_ToggleModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.EnableModifier
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void UCameraModifier::STATIC_EnableModifier()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.EnableModifier"));

	UCameraModifier_EnableModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.DisableModifier
// (Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bImmediate                     (OptionalParm, Parm)

void UCameraModifier::DisableModifier(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.DisableModifier"));

	UCameraModifier_DisableModifier_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.RemoveCameraModifier
// (Iterator, Latent, Native, HasOptionalParms)
// Parameters:
// class ACamera*                 Camera                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCameraModifier::RemoveCameraModifier(class ACamera* Camera)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.RemoveCameraModifier"));

	UCameraModifier_RemoveCameraModifier_Params params;
	params.Camera = Camera;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.AddCameraModifier
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// class ACamera*                 Camera                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCameraModifier::AddCameraModifier(class ACamera* Camera)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.AddCameraModifier"));

	UCameraModifier_AddCameraModifier_Params params;
	params.Camera = Camera;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.IsDisabled
// (Latent, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCameraModifier::STATIC_IsDisabled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.IsDisabled"));

	UCameraModifier_IsDisabled_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.ModifyCamera
// (Defined, Iterator, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// class ACamera*                 Camera                         (Parm)
// float                          DeltaTime                      (Parm)
// struct FTPOV                   OutPOV                         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCameraModifier::STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.ModifyCamera"));

	UCameraModifier_ModifyCamera_Params params;
	params.Camera = Camera;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPOV != nullptr)
		*OutPOV = params.OutPOV;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UCameraModifier::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier.Init"));

	UCameraModifier_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier_CameraShake.ModifyCamera
// (Defined, Iterator, Singular, NetReliable, Event, Operator, Static)
// Parameters:
// class ACamera*                 Camera                         (Parm)
// float                          DeltaTime                      (Parm)
// struct FTPOV                   OutPOV                         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCameraModifier_CameraShake::STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.ModifyCamera"));

	UCameraModifier_CameraShake_ModifyCamera_Params params;
	params.Camera = Camera;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPOV != nullptr)
		*OutPOV = params.OutPOV;

	return params.ReturnValue;
}


// Function Engine.CameraModifier_CameraShake.UpdateCameraShake
// (Final, Defined, Iterator, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// float                          DeltaTime                      (Parm)
// struct FCameraShakeInstance    Shake                          (Parm, OutParm)
// struct FTPOV                   OutPOV                         (Parm, OutParm)

void UCameraModifier_CameraShake::UpdateCameraShake(float DeltaTime, struct FCameraShakeInstance* Shake, struct FTPOV* OutPOV)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.UpdateCameraShake"));

	UCameraModifier_CameraShake_UpdateCameraShake_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Shake != nullptr)
		*Shake = params.Shake;
	if (OutPOV != nullptr)
		*OutPOV = params.OutPOV;
}


// Function Engine.CameraModifier_CameraShake.RemoveAllCameraShakes
// (Latent, Native, HasOptionalParms)

void UCameraModifier_CameraShake::RemoveAllCameraShakes()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.RemoveAllCameraShakes"));

	UCameraModifier_CameraShake_RemoveAllCameraShakes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier_CameraShake.RemoveCameraShake
// (Final, Iterator, Latent, Native, HasOptionalParms)
// Parameters:
// class UCameraShake*            Shake                          (Parm)

void UCameraModifier_CameraShake::RemoveCameraShake(class UCameraShake* Shake)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.RemoveCameraShake"));

	UCameraModifier_CameraShake_RemoveCameraShake_Params params;
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier_CameraShake.AddCameraShake
// (Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// class UCameraShake*            NewShake                       (Parm)
// float                          Scale                          (Parm)
// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (OptionalParm, Parm)
// struct FRotator                UserPlaySpaceRot               (OptionalParm, Parm)

void UCameraModifier_CameraShake::AddCameraShake(class UCameraShake* NewShake, float Scale, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.AddCameraShake"));

	UCameraModifier_CameraShake_AddCameraShake_Params params;
	params.NewShake = NewShake;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier_CameraShake.InitializeShake
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Operator, Static)
// Parameters:
// class UCameraShake*            NewShake                       (Parm)
// float                          Scale                          (Parm)
// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (Parm)
// struct FRotator                UserPlaySpaceRot               (OptionalParm, Parm)
// struct FCameraShakeInstance    ReturnValue                    (Parm, OutParm, ReturnParm)

struct FCameraShakeInstance UCameraModifier_CameraShake::STATIC_InitializeShake(class UCameraShake* NewShake, float Scale, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.InitializeShake"));

	UCameraModifier_CameraShake_InitializeShake_Params params;
	params.NewShake = NewShake;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier_CameraShake.ReinitShake
// (Iterator, PreOperator, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// int                            ActiveShakeIdx                 (Parm)
// float                          Scale                          (Parm)

void UCameraModifier_CameraShake::ReinitShake(int ActiveShakeIdx, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.ReinitShake"));

	UCameraModifier_CameraShake_ReinitShake_Params params;
	params.ActiveShakeIdx = ActiveShakeIdx;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier_CameraShake.InitializeOffset
// (Iterator, Latent, PreOperator, Net, Simulated, Operator, Static)
// Parameters:
// struct FFOscillator            Param                          (Const, Parm, OutParm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UCameraModifier_CameraShake::STATIC_InitializeOffset(struct FFOscillator* Param)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraModifier_CameraShake.InitializeOffset"));

	UCameraModifier_CameraShake_InitializeOffset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Param != nullptr)
		*Param = params.Param;

	return params.ReturnValue;
}


// Function Engine.CameraShake.GetHUDOscillationMagnitude
// (Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UCameraShake::STATIC_GetHUDOscillationMagnitude()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraShake.GetHUDOscillationMagnitude"));

	UCameraShake_GetHUDOscillationMagnitude_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraShake.GetLocOscillationMagnitude
// (Defined, Iterator, Singular, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UCameraShake::STATIC_GetLocOscillationMagnitude()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraShake.GetLocOscillationMagnitude"));

	UCameraShake_GetLocOscillationMagnitude_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraShake.GetRotOscillationMagnitude
// (Defined, Iterator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UCameraShake::STATIC_GetRotOscillationMagnitude()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CameraShake.GetRotOscillationMagnitude"));

	UCameraShake_GetRotOscillationMagnitude_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageUpgradeHelper.GetCloudUpgradeKeys
// (Defined, Iterator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<struct FString>         CloudKeys                      (Parm, OutParm, NeedCtorLink)

void UCloudStorageUpgradeHelper::GetCloudUpgradeKeys(TArray<struct FString>* CloudKeys)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageUpgradeHelper.GetCloudUpgradeKeys"));

	UCloudStorageUpgradeHelper_GetCloudUpgradeKeys_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CloudKeys != nullptr)
		*CloudKeys = params.CloudKeys;
}


// Function Engine.CloudStorageUpgradeHelper.HandleLocalKeyValue
// (Final, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 CloudKeyName                   (Parm, OutParm, NeedCtorLink)
// struct FPlatformInterfaceData  CloudValue                     (Parm, OutParm, NeedCtorLink)
// int                            bShouldMoveToCloud             (Parm, OutParm)
// int                            bShouldDeleteLocalKey          (Parm, OutParm)

void UCloudStorageUpgradeHelper::HandleLocalKeyValue(struct FString* CloudKeyName, struct FPlatformInterfaceData* CloudValue, int* bShouldMoveToCloud, int* bShouldDeleteLocalKey)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageUpgradeHelper.HandleLocalKeyValue"));

	UCloudStorageUpgradeHelper_HandleLocalKeyValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CloudKeyName != nullptr)
		*CloudKeyName = params.CloudKeyName;
	if (CloudValue != nullptr)
		*CloudValue = params.CloudValue;
	if (bShouldMoveToCloud != nullptr)
		*bShouldMoveToCloud = params.bShouldMoveToCloud;
	if (bShouldDeleteLocalKey != nullptr)
		*bShouldDeleteLocalKey = params.bShouldDeleteLocalKey;
}


// Function Engine.CloudStorageUpgradeHelper.HandleLocalDocument
// (PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 DocName                        (Parm, OutParm, NeedCtorLink)
// int                            bShouldMoveToCloud             (Parm, OutParm)
// int                            bShouldDeleteLocalFile         (Parm, OutParm)

void UCloudStorageUpgradeHelper::HandleLocalDocument(struct FString* DocName, int* bShouldMoveToCloud, int* bShouldDeleteLocalFile)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageUpgradeHelper.HandleLocalDocument"));

	UCloudStorageUpgradeHelper_HandleLocalDocument_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DocName != nullptr)
		*DocName = params.DocName;
	if (bShouldMoveToCloud != nullptr)
		*bShouldMoveToCloud = params.bShouldMoveToCloud;
	if (bShouldDeleteLocalFile != nullptr)
		*bShouldDeleteLocalFile = params.bShouldDeleteLocalFile;
}


// Function Engine.AnalyticEventsBase.SendCachedEvents
// (Final, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void UAnalyticEventsBase::SendCachedEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.SendCachedEvents"));

	UAnalyticEventsBase_SendCachedEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogCurrencyGivenEvent
// (Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)

void UAnalyticEventsBase::LogCurrencyGivenEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogCurrencyGivenEvent"));

	UAnalyticEventsBase_LogCurrencyGivenEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogCurrencyPurchaseEvent
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)
// struct FString                 RealCurrencyType               (Parm, NeedCtorLink)
// float                          RealMoneyCost                  (Parm)
// struct FString                 PaymentProvider                (Parm, NeedCtorLink)

void UAnalyticEventsBase::LogCurrencyPurchaseEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount, const struct FString& RealCurrencyType, float RealMoneyCost, const struct FString& PaymentProvider)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogCurrencyPurchaseEvent"));

	UAnalyticEventsBase_LogCurrencyPurchaseEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;
	params.RealCurrencyType = RealCurrencyType;
	params.RealMoneyCost = RealMoneyCost;
	params.PaymentProvider = PaymentProvider;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogItemPurchaseEvent
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ItemId                         (Parm, NeedCtorLink)
// struct FString                 Currency                       (Parm, NeedCtorLink)
// int                            PerItemCost                    (Parm)
// int                            ItemQuantity                   (Parm)

void UAnalyticEventsBase::LogItemPurchaseEvent(const struct FString& ItemId, const struct FString& Currency, int PerItemCost, int ItemQuantity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogItemPurchaseEvent"));

	UAnalyticEventsBase_LogItemPurchaseEvent_Params params;
	params.ItemId = ItemId;
	params.Currency = Currency;
	params.PerItemCost = PerItemCost;
	params.ItemQuantity = ItemQuantity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogUserAttributeUpdateArray
// (Final, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<struct FEventStringParam> AttributeArray                 (Parm, NeedCtorLink)

void UAnalyticEventsBase::LogUserAttributeUpdateArray(TArray<struct FEventStringParam> AttributeArray)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogUserAttributeUpdateArray"));

	UAnalyticEventsBase_LogUserAttributeUpdateArray_Params params;
	params.AttributeArray = AttributeArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogUserAttributeUpdate
// (Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 AttributeName                  (Parm, NeedCtorLink)
// struct FString                 AttributeValue                 (Parm, NeedCtorLink)

void UAnalyticEventsBase::LogUserAttributeUpdate(const struct FString& AttributeName, const struct FString& AttributeValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogUserAttributeUpdate"));

	UAnalyticEventsBase_LogUserAttributeUpdate_Params params;
	params.AttributeName = AttributeName;
	params.AttributeValue = AttributeValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogErrorMessage
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ErrorName                      (Parm, NeedCtorLink)
// struct FString                 ErrorMessage                   (Parm, NeedCtorLink)

void UAnalyticEventsBase::LogErrorMessage(const struct FString& ErrorName, const struct FString& ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogErrorMessage"));

	UAnalyticEventsBase_LogErrorMessage_Params params;
	params.ErrorName = ErrorName;
	params.ErrorMessage = ErrorMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.EndStringEventParamArray
// (Final, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// TArray<struct FEventStringParam> ParamArray                     (Parm, NeedCtorLink)

void UAnalyticEventsBase::EndStringEventParamArray(const struct FString& EventName, TArray<struct FEventStringParam> ParamArray)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.EndStringEventParamArray"));

	UAnalyticEventsBase_EndStringEventParamArray_Params params;
	params.EventName = EventName;
	params.ParamArray = ParamArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogStringEventParamArray
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// TArray<struct FEventStringParam> ParamArray                     (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UAnalyticEventsBase::LogStringEventParamArray(const struct FString& EventName, TArray<struct FEventStringParam> ParamArray, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogStringEventParamArray"));

	UAnalyticEventsBase_LogStringEventParamArray_Params params;
	params.EventName = EventName;
	params.ParamArray = ParamArray;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.EndStringEventParam
// (Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// struct FString                 ParamName                      (Parm, NeedCtorLink)
// struct FString                 ParamValue                     (Parm, NeedCtorLink)

void UAnalyticEventsBase::EndStringEventParam(const struct FString& EventName, const struct FString& ParamName, const struct FString& ParamValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.EndStringEventParam"));

	UAnalyticEventsBase_EndStringEventParam_Params params;
	params.EventName = EventName;
	params.ParamName = ParamName;
	params.ParamValue = ParamValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogStringEventParam
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// struct FString                 ParamName                      (Parm, NeedCtorLink)
// struct FString                 ParamValue                     (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UAnalyticEventsBase::LogStringEventParam(const struct FString& EventName, const struct FString& ParamName, const struct FString& ParamValue, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogStringEventParam"));

	UAnalyticEventsBase_LogStringEventParam_Params params;
	params.EventName = EventName;
	params.ParamName = ParamName;
	params.ParamValue = ParamValue;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.EndStringEvent
// (Final, Defined, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)

void UAnalyticEventsBase::EndStringEvent(const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.EndStringEvent"));

	UAnalyticEventsBase_EndStringEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.LogStringEvent
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UAnalyticEventsBase::LogStringEvent(const struct FString& EventName, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.LogStringEvent"));

	UAnalyticEventsBase_LogStringEvent_Params params;
	params.EventName = EventName;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.EndSession
// (Defined, Singular, Net, Simulated, Native, HasOptionalParms)

void UAnalyticEventsBase::EndSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.EndSession"));

	UAnalyticEventsBase_EndSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.StartSession
// (Final, Defined, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void UAnalyticEventsBase::StartSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.StartSession"));

	UAnalyticEventsBase_StartSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.SetUserId
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 NewUserId                      (Parm, NeedCtorLink)

void UAnalyticEventsBase::SetUserId(const struct FString& NewUserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.SetUserId"));

	UAnalyticEventsBase_SetUserId_Params params;
	params.NewUserId = NewUserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UAnalyticEventsBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.Init"));

	UAnalyticEventsBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnalyticEventsBase.IsSessionInProgress
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAnalyticEventsBase::STATIC_IsSessionInProgress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnalyticEventsBase.IsSessionInProgress"));

	UAnalyticEventsBase_IsSessionInProgress_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MultiProviderAnalytics.SendCachedEvents
// (Final, PreOperator, NetReliable, Exec, Native, HasOptionalParms)

void UMultiProviderAnalytics::SendCachedEvents()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.SendCachedEvents"));

	UMultiProviderAnalytics_SendCachedEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogCurrencyGivenEvent
// (Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)

void UMultiProviderAnalytics::LogCurrencyGivenEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogCurrencyGivenEvent"));

	UMultiProviderAnalytics_LogCurrencyGivenEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogCurrencyPurchaseEvent
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 GameCurrencyType               (Parm, NeedCtorLink)
// int                            GameCurrencyAmount             (Parm)
// struct FString                 RealCurrencyType               (Parm, NeedCtorLink)
// float                          RealMoneyCost                  (Parm)
// struct FString                 PaymentProvider                (Parm, NeedCtorLink)

void UMultiProviderAnalytics::LogCurrencyPurchaseEvent(const struct FString& GameCurrencyType, int GameCurrencyAmount, const struct FString& RealCurrencyType, float RealMoneyCost, const struct FString& PaymentProvider)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogCurrencyPurchaseEvent"));

	UMultiProviderAnalytics_LogCurrencyPurchaseEvent_Params params;
	params.GameCurrencyType = GameCurrencyType;
	params.GameCurrencyAmount = GameCurrencyAmount;
	params.RealCurrencyType = RealCurrencyType;
	params.RealMoneyCost = RealMoneyCost;
	params.PaymentProvider = PaymentProvider;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogItemPurchaseEvent
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ItemId                         (Parm, NeedCtorLink)
// struct FString                 Currency                       (Parm, NeedCtorLink)
// int                            PerItemCost                    (Parm)
// int                            ItemQuantity                   (Parm)

void UMultiProviderAnalytics::LogItemPurchaseEvent(const struct FString& ItemId, const struct FString& Currency, int PerItemCost, int ItemQuantity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogItemPurchaseEvent"));

	UMultiProviderAnalytics_LogItemPurchaseEvent_Params params;
	params.ItemId = ItemId;
	params.Currency = Currency;
	params.PerItemCost = PerItemCost;
	params.ItemQuantity = ItemQuantity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogUserAttributeUpdateArray
// (Final, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TArray<struct FEventStringParam> AttributeArray                 (Parm, NeedCtorLink)

void UMultiProviderAnalytics::LogUserAttributeUpdateArray(TArray<struct FEventStringParam> AttributeArray)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogUserAttributeUpdateArray"));

	UMultiProviderAnalytics_LogUserAttributeUpdateArray_Params params;
	params.AttributeArray = AttributeArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogUserAttributeUpdate
// (Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 AttributeName                  (Parm, NeedCtorLink)
// struct FString                 AttributeValue                 (Parm, NeedCtorLink)

void UMultiProviderAnalytics::LogUserAttributeUpdate(const struct FString& AttributeName, const struct FString& AttributeValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogUserAttributeUpdate"));

	UMultiProviderAnalytics_LogUserAttributeUpdate_Params params;
	params.AttributeName = AttributeName;
	params.AttributeValue = AttributeValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogErrorMessage
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ErrorName                      (Parm, NeedCtorLink)
// struct FString                 ErrorMessage                   (Parm, NeedCtorLink)

void UMultiProviderAnalytics::LogErrorMessage(const struct FString& ErrorName, const struct FString& ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogErrorMessage"));

	UMultiProviderAnalytics_LogErrorMessage_Params params;
	params.ErrorName = ErrorName;
	params.ErrorMessage = ErrorMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.EndStringEventParamArray
// (Final, Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// TArray<struct FEventStringParam> ParamArray                     (Parm, NeedCtorLink)

void UMultiProviderAnalytics::EndStringEventParamArray(const struct FString& EventName, TArray<struct FEventStringParam> ParamArray)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.EndStringEventParamArray"));

	UMultiProviderAnalytics_EndStringEventParamArray_Params params;
	params.EventName = EventName;
	params.ParamArray = ParamArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogStringEventParamArray
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// TArray<struct FEventStringParam> ParamArray                     (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UMultiProviderAnalytics::LogStringEventParamArray(const struct FString& EventName, TArray<struct FEventStringParam> ParamArray, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogStringEventParamArray"));

	UMultiProviderAnalytics_LogStringEventParamArray_Params params;
	params.EventName = EventName;
	params.ParamArray = ParamArray;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.EndStringEventParam
// (Iterator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// struct FString                 ParamName                      (Parm, NeedCtorLink)
// struct FString                 ParamValue                     (Parm, NeedCtorLink)

void UMultiProviderAnalytics::EndStringEventParam(const struct FString& EventName, const struct FString& ParamName, const struct FString& ParamValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.EndStringEventParam"));

	UMultiProviderAnalytics_EndStringEventParam_Params params;
	params.EventName = EventName;
	params.ParamName = ParamName;
	params.ParamValue = ParamValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogStringEventParam
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// struct FString                 ParamName                      (Parm, NeedCtorLink)
// struct FString                 ParamValue                     (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UMultiProviderAnalytics::LogStringEventParam(const struct FString& EventName, const struct FString& ParamName, const struct FString& ParamValue, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogStringEventParam"));

	UMultiProviderAnalytics_LogStringEventParam_Params params;
	params.EventName = EventName;
	params.ParamName = ParamName;
	params.ParamValue = ParamValue;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.EndStringEvent
// (Final, Defined, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)

void UMultiProviderAnalytics::EndStringEvent(const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.EndStringEvent"));

	UMultiProviderAnalytics_EndStringEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.LogStringEvent
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 EventName                      (Parm, NeedCtorLink)
// bool                           bTimed                         (Parm)

void UMultiProviderAnalytics::LogStringEvent(const struct FString& EventName, bool bTimed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.LogStringEvent"));

	UMultiProviderAnalytics_LogStringEvent_Params params;
	params.EventName = EventName;
	params.bTimed = bTimed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.EndSession
// (Defined, Singular, Net, Simulated, Native, HasOptionalParms)

void UMultiProviderAnalytics::EndSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.EndSession"));

	UMultiProviderAnalytics_EndSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.StartSession
// (Final, Defined, Latent, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)

void UMultiProviderAnalytics::StartSession()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.StartSession"));

	UMultiProviderAnalytics_StartSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.SetUserId
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 NewUserId                      (Parm, NeedCtorLink)

void UMultiProviderAnalytics::SetUserId(const struct FString& NewUserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.SetUserId"));

	UMultiProviderAnalytics_SetUserId_Params params;
	params.NewUserId = NewUserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MultiProviderAnalytics.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UMultiProviderAnalytics::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.MultiProviderAnalytics.Init"));

	UMultiProviderAnalytics_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AppNotificationsBase.DebugLogNotification
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Static)
// Parameters:
// struct FNotificationInfo       Notification                   (Const, Parm, OutParm, NeedCtorLink)

void UAppNotificationsBase::STATIC_DebugLogNotification(struct FNotificationInfo* Notification)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.DebugLogNotification"));

	UAppNotificationsBase_DebugLogNotification_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Notification != nullptr)
		*Notification = params.Notification;
}


// Function Engine.AppNotificationsBase.OnReceivedRemoteNotification
// (Defined, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// struct FNotificationInfo       Notification                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           bWasAppActive                  (Parm)

void UAppNotificationsBase::OnReceivedRemoteNotification(bool bWasAppActive, struct FNotificationInfo* Notification)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.OnReceivedRemoteNotification"));

	UAppNotificationsBase_OnReceivedRemoteNotification_Params params;
	params.bWasAppActive = bWasAppActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Notification != nullptr)
		*Notification = params.Notification;
}


// Function Engine.AppNotificationsBase.OnReceivedLocalNotification
// (Defined, Iterator, Latent, PreOperator, Exec, Native, HasOptionalParms)
// Parameters:
// struct FNotificationInfo       Notification                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           bWasAppActive                  (Parm)

void UAppNotificationsBase::OnReceivedLocalNotification(bool bWasAppActive, struct FNotificationInfo* Notification)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.OnReceivedLocalNotification"));

	UAppNotificationsBase_OnReceivedLocalNotification_Params params;
	params.bWasAppActive = bWasAppActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Notification != nullptr)
		*Notification = params.Notification;
}


// Function Engine.AppNotificationsBase.CancelAllScheduledLocalNotifications
// (Final, Defined, Iterator, PreOperator, Singular, Exec, Native, Event, Operator)

void UAppNotificationsBase::CancelAllScheduledLocalNotifications()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.CancelAllScheduledLocalNotifications"));

	UAppNotificationsBase_CancelAllScheduledLocalNotifications_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AppNotificationsBase.ScheduleLocalNotification
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FNotificationInfo       Notification                   (Const, Parm, OutParm, NeedCtorLink)
// int                            StartOffsetSeconds             (Parm)

void UAppNotificationsBase::ScheduleLocalNotification(int StartOffsetSeconds, struct FNotificationInfo* Notification)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.ScheduleLocalNotification"));

	UAppNotificationsBase_ScheduleLocalNotification_Params params;
	params.StartOffsetSeconds = StartOffsetSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Notification != nullptr)
		*Notification = params.Notification;
}


// Function Engine.AppNotificationsBase.WasLaunchedViaNotification
// (Final, Latent, Singular, Net, NetReliable, Operator, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UAppNotificationsBase::WasLaunchedViaNotification()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.WasLaunchedViaNotification"));

	UAppNotificationsBase_WasLaunchedViaNotification_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AppNotificationsBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UAppNotificationsBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AppNotificationsBase.Init"));

	UAppNotificationsBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudStorageBase.UpgradeLocalStorageToCloud
// (Final, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TScriptInterface<class UCloudStorageUpgradeHelper> UpgradeHelper                  (Parm)
// bool                           bForceSearchAgain              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::UpgradeLocalStorageToCloud(const TScriptInterface<class UCloudStorageUpgradeHelper>& UpgradeHelper, bool bForceSearchAgain)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.UpgradeLocalStorageToCloud"));

	UCloudStorageBase_UpgradeLocalStorageToCloud_Params params;
	params.UpgradeHelper = UpgradeHelper;
	params.bForceSearchAgain = bForceSearchAgain;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ResolveConflictWithVersionIndex
// (Iterator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::ResolveConflictWithVersionIndex(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ResolveConflictWithVersionIndex"));

	UCloudStorageBase_ResolveConflictWithVersionIndex_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ResolveConflictWithNewestDocument
// (Final, Defined, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::ResolveConflictWithNewestDocument()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ResolveConflictWithNewestDocument"));

	UCloudStorageBase_ResolveConflictWithNewestDocument_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.WaitForWritesToFinish
// (Final, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// float                          MaxTimeSeconds                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::WaitForWritesToFinish(float MaxTimeSeconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.WaitForWritesToFinish"));

	UCloudStorageBase_WaitForWritesToFinish_Params params;
	params.MaxTimeSeconds = MaxTimeSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.IsStillWritingFiles
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::IsStillWritingFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.IsStillWritingFiles"));

	UCloudStorageBase_IsStillWritingFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.SaveDocumentWithObject
// (Final, Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// class UObject*                 ObjectData                     (Parm)
// int                            SaveVersion                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::SaveDocumentWithObject(int Index, class UObject* ObjectData, int SaveVersion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.SaveDocumentWithObject"));

	UCloudStorageBase_SaveDocumentWithObject_Params params;
	params.Index = Index;
	params.ObjectData = ObjectData;
	params.SaveVersion = SaveVersion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.SaveDocumentWithBytes
// (Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// TArray<unsigned char>          ByteData                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::SaveDocumentWithBytes(int Index, TArray<unsigned char> ByteData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.SaveDocumentWithBytes"));

	UCloudStorageBase_SaveDocumentWithBytes_Params params;
	params.Index = Index;
	params.ByteData = ByteData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.SaveDocumentWithString
// (Defined, Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// struct FString                 StringData                     (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::SaveDocumentWithString(int Index, const struct FString& StringData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.SaveDocumentWithString"));

	UCloudStorageBase_SaveDocumentWithString_Params params;
	params.Index = Index;
	params.StringData = StringData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.WriteCloudDocument
// (Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::WriteCloudDocument(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.WriteCloudDocument"));

	UCloudStorageBase_WriteCloudDocument_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ParseDocumentAsObject
// (Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// class UClass*                  ObjectClass                    (Parm)
// int                            ExpectedVersion                (Parm)
// bool                           bIsForConflict                 (OptionalParm, Parm)
// class UObject*                 ReturnValue                    (Parm, OutParm, ReturnParm)

class UObject* UCloudStorageBase::ParseDocumentAsObject(int Index, class UClass* ObjectClass, int ExpectedVersion, bool bIsForConflict)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ParseDocumentAsObject"));

	UCloudStorageBase_ParseDocumentAsObject_Params params;
	params.Index = Index;
	params.ObjectClass = ObjectClass;
	params.ExpectedVersion = ExpectedVersion;
	params.bIsForConflict = bIsForConflict;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ParseDocumentAsBytes
// (Final, Defined, Iterator, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// TArray<unsigned char>          ByteData                       (Parm, OutParm, NeedCtorLink)
// bool                           bIsForConflict                 (OptionalParm, Parm)

void UCloudStorageBase::ParseDocumentAsBytes(int Index, bool bIsForConflict, TArray<unsigned char>* ByteData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ParseDocumentAsBytes"));

	UCloudStorageBase_ParseDocumentAsBytes_Params params;
	params.Index = Index;
	params.bIsForConflict = bIsForConflict;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ByteData != nullptr)
		*ByteData = params.ByteData;
}


// Function Engine.CloudStorageBase.ParseDocumentAsString
// (Final, Latent, PreOperator, Singular, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// bool                           bIsForConflict                 (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UCloudStorageBase::ParseDocumentAsString(int Index, bool bIsForConflict)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ParseDocumentAsString"));

	UCloudStorageBase_ParseDocumentAsString_Params params;
	params.Index = Index;
	params.bIsForConflict = bIsForConflict;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ReadCloudDocument
// (Defined, Iterator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// bool                           bIsForConflict                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::ReadCloudDocument(int Index, bool bIsForConflict)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ReadCloudDocument"));

	UCloudStorageBase_ReadCloudDocument_Params params;
	params.Index = Index;
	params.bIsForConflict = bIsForConflict;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.DeleteAllCloudDocuments
// (Defined, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)

void UCloudStorageBase::DeleteAllCloudDocuments()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.DeleteAllCloudDocuments"));

	UCloudStorageBase_DeleteAllCloudDocuments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudStorageBase.CreateCloudDocument
// (Final, PreOperator, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UCloudStorageBase::CreateCloudDocument(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.CreateCloudDocument"));

	UCloudStorageBase_CreateCloudDocument_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.GetCloudDocumentName
// (Final, Iterator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UCloudStorageBase::GetCloudDocumentName(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.GetCloudDocumentName"));

	UCloudStorageBase_GetCloudDocumentName_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.GetNumCloudDocuments
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           bIsForConflict                 (OptionalParm, Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UCloudStorageBase::GetNumCloudDocuments(bool bIsForConflict)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.GetNumCloudDocuments"));

	UCloudStorageBase_GetNumCloudDocuments_Params params;
	params.bIsForConflict = bIsForConflict;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.QueryForCloudDocuments
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::QueryForCloudDocuments()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.QueryForCloudDocuments"));

	UCloudStorageBase_QueryForCloudDocuments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.WriteKeyValue
// (Final, Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// struct FPlatformInterfaceData  Value                          (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::WriteKeyValue(const struct FString& KeyName, struct FPlatformInterfaceData* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.WriteKeyValue"));

	UCloudStorageBase_WriteKeyValue_Params params;
	params.KeyName = KeyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ReadKeyValueFromLocalStore
// (Latent, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// TEnumAsByte<EPlatformInterfaceDataType> Type                           (Parm)
// struct FPlatformInterfaceDelegateResult Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::ReadKeyValueFromLocalStore(const struct FString& KeyName, TEnumAsByte<EPlatformInterfaceDataType> Type, struct FPlatformInterfaceDelegateResult* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ReadKeyValueFromLocalStore"));

	UCloudStorageBase_ReadKeyValueFromLocalStore_Params params;
	params.KeyName = KeyName;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.ReadKeyValue
// (Final, Defined, Iterator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// TEnumAsByte<EPlatformInterfaceDataType> Type                           (Parm)
// struct FPlatformInterfaceDelegateResult Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::ReadKeyValue(const struct FString& KeyName, TEnumAsByte<EPlatformInterfaceDataType> Type, struct FPlatformInterfaceDelegateResult* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.ReadKeyValue"));

	UCloudStorageBase_ReadKeyValue_Params params;
	params.KeyName = KeyName;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.IsUsingLocalStorage
// (Final, Iterator, Latent, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBase::STATIC_IsUsingLocalStorage()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.IsUsingLocalStorage"));

	UCloudStorageBase_IsUsingLocalStorage_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UCloudStorageBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBase.Init"));

	UCloudStorageBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FacebookIntegration.Disconnect
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Native, HasOptionalParms)

void UFacebookIntegration::Disconnect()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.Disconnect"));

	UFacebookIntegration_Disconnect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FacebookIntegration.FacebookDialog
// (Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Action                         (Parm, NeedCtorLink)
// TArray<struct FString>         ParamKeysAndValues             (Parm, NeedCtorLink)

void UFacebookIntegration::FacebookDialog(const struct FString& Action, TArray<struct FString> ParamKeysAndValues)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.FacebookDialog"));

	UFacebookIntegration_FacebookDialog_Params params;
	params.Action = Action;
	params.ParamKeysAndValues = ParamKeysAndValues;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FacebookIntegration.FacebookRequest
// (Final, Latent, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 GraphRequest                   (Parm, NeedCtorLink)

void UFacebookIntegration::FacebookRequest(const struct FString& GraphRequest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.FacebookRequest"));

	UFacebookIntegration_FacebookRequest_Params params;
	params.GraphRequest = GraphRequest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FacebookIntegration.IsAuthorized
// (Defined, Iterator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFacebookIntegration::IsAuthorized()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.IsAuthorized"));

	UFacebookIntegration_IsAuthorized_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FacebookIntegration.Authorize
// (Defined, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFacebookIntegration::Authorize()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.Authorize"));

	UFacebookIntegration_Authorize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FacebookIntegration.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UFacebookIntegration::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FacebookIntegration.Init"));

	UFacebookIntegration_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InAppMessageBase.ShowInAppEmailUI
// (Final, Iterator, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 InitialSubject                 (OptionalParm, Parm, NeedCtorLink)
// struct FString                 InitialMessage                 (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInAppMessageBase::ShowInAppEmailUI(const struct FString& InitialSubject, const struct FString& InitialMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InAppMessageBase.ShowInAppEmailUI"));

	UInAppMessageBase_ShowInAppEmailUI_Params params;
	params.InitialSubject = InitialSubject;
	params.InitialMessage = InitialMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InAppMessageBase.ShowInAppSMSUI
// (Defined, Iterator, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 InitialMessage                 (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UInAppMessageBase::ShowInAppSMSUI(const struct FString& InitialMessage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InAppMessageBase.ShowInAppSMSUI"));

	UInAppMessageBase_ShowInAppSMSUI_Params params;
	params.InitialMessage = InitialMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InAppMessageBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UInAppMessageBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InAppMessageBase.Init"));

	UInAppMessageBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InGameAdManager.SetPauseWhileAdOpen
// (Defined, Iterator, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// bool                           bShouldPause                   (Parm)

void UInGameAdManager::SetPauseWhileAdOpen(bool bShouldPause)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InGameAdManager.SetPauseWhileAdOpen"));

	UInGameAdManager_SetPauseWhileAdOpen_Params params;
	params.bShouldPause = bShouldPause;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InGameAdManager.ForceCloseAd
// (Iterator, Singular, NetReliable, Simulated, Exec, Event, Static)

void UInGameAdManager::STATIC_ForceCloseAd()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InGameAdManager.ForceCloseAd"));

	UInGameAdManager_ForceCloseAd_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InGameAdManager.HideBanner
// (Iterator, PreOperator, Operator, Static)

void UInGameAdManager::STATIC_HideBanner()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InGameAdManager.HideBanner"));

	UInGameAdManager_HideBanner_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InGameAdManager.ShowBanner
// (Iterator, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// bool                           bShowBottomOfScreen            (Parm)

void UInGameAdManager::ShowBanner(bool bShowBottomOfScreen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InGameAdManager.ShowBanner"));

	UInGameAdManager_ShowBanner_Params params;
	params.bShowBottomOfScreen = bShowBottomOfScreen;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InGameAdManager.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UInGameAdManager::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.InGameAdManager.Init"));

	UInGameAdManager_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TwitterIntegrationBase.TwitterRequest
// (Final, Defined, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// TArray<struct FString>         ParamKeysAndValues             (Parm, NeedCtorLink)
// TEnumAsByte<ETwitterRequestMethod> RequestMethod                  (Parm)
// int                            AccountIndex                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTwitterIntegrationBase::TwitterRequest(const struct FString& URL, TArray<struct FString> ParamKeysAndValues, TEnumAsByte<ETwitterRequestMethod> RequestMethod, int AccountIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.TwitterRequest"));

	UTwitterIntegrationBase_TwitterRequest_Params params;
	params.URL = URL;
	params.ParamKeysAndValues = ParamKeysAndValues;
	params.RequestMethod = RequestMethod;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetAccountId
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            AccountIndex                   (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UTwitterIntegrationBase::GetAccountId(int AccountIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.GetAccountId"));

	UTwitterIntegrationBase_GetAccountId_Params params;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetAccountName
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            AccountIndex                   (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UTwitterIntegrationBase::GetAccountName(int AccountIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.GetAccountName"));

	UTwitterIntegrationBase_GetAccountName_Params params;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetNumAccounts
// (Final, Defined, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UTwitterIntegrationBase::GetNumAccounts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.GetNumAccounts"));

	UTwitterIntegrationBase_GetNumAccounts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
// (Final, Defined, Latent, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTwitterIntegrationBase::AuthorizeAccounts()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.AuthorizeAccounts"));

	UTwitterIntegrationBase_AuthorizeAccounts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.ShowTweetUI
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 InitialMessage                 (OptionalParm, Parm, NeedCtorLink)
// struct FString                 URL                            (OptionalParm, Parm, NeedCtorLink)
// struct FString                 Picture                        (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTwitterIntegrationBase::ShowTweetUI(const struct FString& InitialMessage, const struct FString& URL, const struct FString& Picture)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.ShowTweetUI"));

	UTwitterIntegrationBase_ShowTweetUI_Params params;
	params.InitialMessage = InitialMessage;
	params.URL = URL;
	params.Picture = Picture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.CanShowTweetUI
// (Final, Defined, Singular, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UTwitterIntegrationBase::CanShowTweetUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.CanShowTweetUI"));

	UTwitterIntegrationBase_CanShowTweetUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UTwitterIntegrationBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TwitterIntegrationBase.Init"));

	UTwitterIntegrationBase_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
// (Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 HeaderName                     (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UPlatformInterfaceWebResponse::STATIC_GetHeaderValue(const struct FString& HeaderName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue"));

	UPlatformInterfaceWebResponse_GetHeaderValue_Params params;
	params.HeaderName = HeaderName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetHeader
// (Defined, Exec, Native, Event, Static)
// Parameters:
// int                            HeaderIndex                    (Parm)
// struct FString                 Header                         (Parm, OutParm, NeedCtorLink)
// struct FString                 Value                          (Parm, OutParm, NeedCtorLink)

void UPlatformInterfaceWebResponse::STATIC_GetHeader(int HeaderIndex, struct FString* Header, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceWebResponse.GetHeader"));

	UPlatformInterfaceWebResponse_GetHeader_Params params;
	params.HeaderIndex = HeaderIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Header != nullptr)
		*Header = params.Header;
	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
// (Latent, PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UPlatformInterfaceWebResponse::STATIC_GetNumHeaders()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders"));

	UPlatformInterfaceWebResponse_GetNumHeaders_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokCustomTraversalAnnotation.GetDestinationEdge
// (Iterator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FVector                 EdgeStart                      (Parm, OutParm)
// struct FVector                 EdgeEnd                        (Parm, OutParm)

void AHavokCustomTraversalAnnotation::STATIC_GetDestinationEdge(struct FVector* EdgeStart, struct FVector* EdgeEnd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokCustomTraversalAnnotation.GetDestinationEdge"));

	AHavokCustomTraversalAnnotation_GetDestinationEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EdgeStart != nullptr)
		*EdgeStart = params.EdgeStart;
	if (EdgeEnd != nullptr)
		*EdgeEnd = params.EdgeEnd;
}


// Function Engine.HavokCustomTraversalAnnotation.GetSourceEdge
// (Final, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 EdgeStart                      (Parm, OutParm)
// struct FVector                 EdgeEnd                        (Parm, OutParm)

void AHavokCustomTraversalAnnotation::STATIC_GetSourceEdge(struct FVector* EdgeStart, struct FVector* EdgeEnd)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokCustomTraversalAnnotation.GetSourceEdge"));

	AHavokCustomTraversalAnnotation_GetSourceEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (EdgeStart != nullptr)
		*EdgeStart = params.EdgeStart;
	if (EdgeEnd != nullptr)
		*EdgeEnd = params.EdgeEnd;
}


// Function Engine.HavokTraversalAnnotationPortal.IsValidPortal
// (Final, Defined, PreOperator, Simulated, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AHavokTraversalAnnotationPortal::STATIC_IsValidPortal()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokTraversalAnnotationPortal.IsValidPortal"));

	AHavokTraversalAnnotationPortal_IsValidPortal_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokNavMeshActor.CleanupNavMesh
// (Iterator, Singular, Simulated, Exec, Native, Event, Operator)

void AHavokNavMeshActor::CleanupNavMesh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshActor.CleanupNavMesh"));

	AHavokNavMeshActor_CleanupNavMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HavokNavMeshActor.InitializeNavMesh
// (Final, Defined, Latent, PreOperator, Net, Simulated, Operator, Static)

void AHavokNavMeshActor::STATIC_InitializeNavMesh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshActor.InitializeNavMesh"));

	AHavokNavMeshActor_InitializeNavMesh_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HavokNavMeshGrid.WorldToTangent
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FVector                 InPos                          (Const, Parm, OutParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector2D UHavokNavMeshGrid::WorldToTangent(struct FVector* InPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshGrid.WorldToTangent"));

	UHavokNavMeshGrid_WorldToTangent_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InPos != nullptr)
		*InPos = params.InPos;

	return params.ReturnValue;
}


// Function Engine.HavokNavMeshGrid.WorldToTexel
// (Defined, Iterator, Latent, PreOperator, Singular, Net, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FVector                 InPos                          (Const, Parm, OutParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector2D UHavokNavMeshGrid::WorldToTexel(struct FVector* InPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshGrid.WorldToTexel"));

	UHavokNavMeshGrid_WorldToTexel_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InPos != nullptr)
		*InPos = params.InPos;

	return params.ReturnValue;
}


// Function Engine.HavokNavMeshGrid.TexelToWorld
// (Final, PreOperator, Singular, Simulated, Native, Event, HasOptionalParms)
// Parameters:
// struct FVector2D               InPos                          (Const, Parm, OutParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVector UHavokNavMeshGrid::TexelToWorld(struct FVector2D* InPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshGrid.TexelToWorld"));

	UHavokNavMeshGrid_TexelToWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InPos != nullptr)
		*InPos = params.InPos;

	return params.ReturnValue;
}


// Function Engine.HavokNavMeshGrid.InitGrid
// (Final, Iterator, PreOperator, Net, Simulated, Operator, Static)

void UHavokNavMeshGrid::STATIC_InitGrid()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavMeshGrid.InitGrid"));

	UHavokNavMeshGrid_InitGrid_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HavokNavigationHandle.PathCache_RemoveIndex
// (Singular, Net, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// int                            Index                          (Parm)
// int                            Count                          (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::STATIC_PathCache_RemoveIndex(int Index, int Count)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.PathCache_RemoveIndex"));

	UHavokNavigationHandle_PathCache_RemoveIndex_Params params;
	params.Index = Index;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.CopyMovePointsFromPathCache
// (Final, PreOperator, Net, NetReliable, Simulated, Static)
// Parameters:
// struct FVector                 FinalDest                      (Parm)
// TArray<struct FVector>         MovePoints                     (Parm, OutParm, NeedCtorLink)

void UHavokNavigationHandle::STATIC_CopyMovePointsFromPathCache(const struct FVector& FinalDest, TArray<struct FVector>* MovePoints)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.CopyMovePointsFromPathCache"));

	UHavokNavigationHandle_CopyMovePointsFromPathCache_Params params;
	params.FinalDest = FinalDest;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MovePoints != nullptr)
		*MovePoints = params.MovePoints;
}


// Function Engine.HavokNavigationHandle.GetCurrentEdgeType
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<ENavMeshEdgeType>  ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENavMeshEdgeType> UHavokNavigationHandle::STATIC_GetCurrentEdgeType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.GetCurrentEdgeType"));

	UHavokNavigationHandle_GetCurrentEdgeType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.ClearCurrentEdge
// (Final, Defined, PreOperator, Net, Simulated, Exec, Native, Event, Operator)

void UHavokNavigationHandle::ClearCurrentEdge()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.ClearCurrentEdge"));

	UHavokNavigationHandle_ClearCurrentEdge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HavokNavigationHandle.GetPackedKeyForPosition
// (Defined, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 pos                            (Parm, OutParm)
// struct FVector                 PrevPos                        (Const, Parm, OutParm)
// int                            PreviousKey                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UHavokNavigationHandle::STATIC_GetPackedKeyForPosition(int PreviousKey, struct FVector* pos, struct FVector* PrevPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.GetPackedKeyForPosition"));

	UHavokNavigationHandle_GetPackedKeyForPosition_Params params;
	params.PreviousKey = PreviousKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (pos != nullptr)
		*pos = params.pos;
	if (PrevPos != nullptr)
		*PrevPos = params.PrevPos;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.LineCheck
// (Defined, Iterator, PreOperator, Net, NetReliable, Native, Operator, Static)
// Parameters:
// struct FVector                 Start                          (Parm)
// struct FVector                 Direction                      (Parm)
// struct FVector                 Extent                         (Parm)
// struct FVector                 out_HitLocation                (OptionalParm, Parm, OutParm)
// struct FVector                 out_HitNormal                  (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::STATIC_LineCheck(const struct FVector& Start, const struct FVector& Direction, const struct FVector& Extent, struct FVector* out_HitLocation, struct FVector* out_HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.LineCheck"));

	UHavokNavigationHandle_LineCheck_Params params;
	params.Start = Start;
	params.Direction = Direction;
	params.Extent = Extent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_HitLocation != nullptr)
		*out_HitLocation = params.out_HitLocation;
	if (out_HitNormal != nullptr)
		*out_HitNormal = params.out_HitNormal;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.ActorReachable
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, Event)
// Parameters:
// class AActor*                  GoalActor                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::ActorReachable(class AActor* GoalActor)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.ActorReachable"));

	UHavokNavigationHandle_ActorReachable_Params params;
	params.GoalActor = GoalActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.PointReachable
// (Final, PreOperator, Net, NetReliable, HasOptionalParms)
// Parameters:
// struct FVector                 Point                          (Parm)
// struct FVector                 OverrideStartPoint             (OptionalParm, Parm)
// bool                           bAllowHitsInEndCollisionBox    (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::PointReachable(const struct FVector& Point, const struct FVector& OverrideStartPoint, bool bAllowHitsInEndCollisionBox)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.PointReachable"));

	UHavokNavigationHandle_PointReachable_Params params;
	params.Point = Point;
	params.OverrideStartPoint = OverrideStartPoint;
	params.bAllowHitsInEndCollisionBox = bAllowHitsInEndCollisionBox;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FVector                 MovePt                         (Parm, OutParm)
// class AController*             C                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::SuggestMovePreparation(class AController* C, struct FVector* MovePt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.SuggestMovePreparation"));

	UHavokNavigationHandle_SuggestMovePreparation_Params params;
	params.C = C;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MovePt != nullptr)
		*MovePt = params.MovePt;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.FindPath
// (Iterator, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// class AActor*                  out_DestActor                  (OptionalParm, Parm, OutParm)
// int                            out_DestItem                   (OptionalParm, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::STATIC_FindPath(class AActor** out_DestActor, int* out_DestItem)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.FindPath"));

	UHavokNavigationHandle_FindPath_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_DestActor != nullptr)
		*out_DestActor = params.out_DestActor;
	if (out_DestItem != nullptr)
		*out_DestItem = params.out_DestItem;

	return params.ReturnValue;
}


// Function Engine.HavokNavigationHandle.GetNextMoveLocation
// (Final, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// struct FVector                 out_MoveDest                   (Parm, OutParm)
// float                          ArrivalDistance                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UHavokNavigationHandle::STATIC_GetNextMoveLocation(float ArrivalDistance, struct FVector* out_MoveDest)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HavokNavigationHandle.GetNextMoveLocation"));

	UHavokNavigationHandle_GetNextMoveLocation_Params params;
	params.ArrivalDistance = ArrivalDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (out_MoveDest != nullptr)
		*out_MoveDest = params.out_MoveDest;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.PartiallyDuplicates
// (Final, Iterator, PreOperator, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// int                            Switch1                        (Parm)
// int                            Switch2                        (Parm)
// class UObject*                 OptionalObject1                (Parm)
// class UObject*                 OptionalObject2                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalMessage::STATIC_PartiallyDuplicates(int Switch1, int Switch2, class UObject* OptionalObject1, class UObject* OptionalObject2)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.PartiallyDuplicates"));

	ULocalMessage_PartiallyDuplicates_Params params;
	params.Switch1 = Switch1;
	params.Switch2 = Switch2;
	params.OptionalObject1 = OptionalObject1;
	params.OptionalObject2 = OptionalObject2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.IsConsoleMessage
// (Final, Iterator, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            Switch                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ULocalMessage::STATIC_IsConsoleMessage(int Switch)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.IsConsoleMessage"));

	ULocalMessage_IsConsoleMessage_Params params;
	params.Switch = Switch;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetLifeTime
// (Defined, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ULocalMessage::STATIC_GetLifeTime(int Switch)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetLifeTime"));

	ULocalMessage_GetLifeTime_Params params;
	params.Switch = Switch;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetFontSize
// (Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            Switch                         (Parm)
// class APlayerReplicationInfo*  RelatedPRI1                    (Parm)
// class APlayerReplicationInfo*  RelatedPRI2                    (Parm)
// class APlayerReplicationInfo*  LocalPlayer                    (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int ULocalMessage::STATIC_GetFontSize(int Switch, class APlayerReplicationInfo* RelatedPRI1, class APlayerReplicationInfo* RelatedPRI2, class APlayerReplicationInfo* LocalPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetFontSize"));

	ULocalMessage_GetFontSize_Params params;
	params.Switch = Switch;
	params.RelatedPRI1 = RelatedPRI1;
	params.RelatedPRI2 = RelatedPRI2;
	params.LocalPlayer = LocalPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetPos
// (Final, Iterator, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (Parm)
// class AHUD*                    myHUD                          (Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float ULocalMessage::STATIC_GetPos(int Switch, class AHUD* myHUD)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetPos"));

	ULocalMessage_GetPos_Params params;
	params.Switch = Switch;
	params.myHUD = myHUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetColor
// (Final, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)
// struct FColor                  ReturnValue                    (Parm, OutParm, ReturnParm)

struct FColor ULocalMessage::STATIC_GetColor(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetColor"));

	ULocalMessage_GetColor_Params params;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetConsoleColor
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class APlayerReplicationInfo*  RelatedPRI_2                   (Parm)
// struct FColor                  ReturnValue                    (Parm, OutParm, ReturnParm)

struct FColor ULocalMessage::STATIC_GetConsoleColor(class APlayerReplicationInfo* RelatedPRI_2)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetConsoleColor"));

	ULocalMessage_GetConsoleColor_Params params;
	params.RelatedPRI_2 = RelatedPRI_2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.GetString
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// bool                           bPRI1HUD                       (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString ULocalMessage::STATIC_GetString(int Switch, bool bPRI1HUD, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.GetString"));

	ULocalMessage_GetString_Params params;
	params.Switch = Switch;
	params.bPRI1HUD = bPRI1HUD;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LocalMessage.ClientReceive
// (Iterator, PreOperator, Static)
// Parameters:
// class APlayerController*       P                              (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void ULocalMessage::STATIC_ClientReceive(class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.LocalMessage.ClientReceive"));

	ULocalMessage_ClientReceive_Params params;
	params.P = P;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_Teleport.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_Teleport::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Teleport.GetObjClassVersion"));

	USeqAct_Teleport_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_Teleport.ShouldTeleport
// (Defined, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// class AActor*                  TestActor                      (Parm)
// struct FVector                 TeleportLocation               (Parm)
// float                          TeleportDist                   (OptionalParm, Parm)
// TArray<class AVolume*>         Volumes                        (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USeqAct_Teleport::ShouldTeleport(class AActor* TestActor, const struct FVector& TeleportLocation, float TeleportDist, TArray<class AVolume*> Volumes)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_Teleport.ShouldTeleport"));

	USeqAct_Teleport_ShouldTeleport_Params params;
	params.TestActor = TestActor;
	params.TeleportLocation = TeleportLocation;
	params.TeleportDist = TeleportDist;
	params.Volumes = Volumes;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetVelocity.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetVelocity::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetVelocity.GetObjClassVersion"));

	USeqAct_SetVelocity_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_AttachToActor.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_AttachToActor::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_AttachToActor.GetObjClassVersion"));

	USeqAct_AttachToActor_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearCustomOnlineDelegates
// (Final, Iterator, PreOperator, Net, Simulated, Exec, Native, Event, Operator)

void UOnlinePlayerInterface::ClearCustomOnlineDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearCustomOnlineDelegates"));

	UOnlinePlayerInterface_ClearCustomOnlineDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearAchievements
// (Defined, Latent, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (OptionalParm, Parm)

void UOnlinePlayerInterface::ClearAchievements(unsigned char LocalUserNum, int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearAchievements"));

	UOnlinePlayerInterface_ClearAchievements_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.GetAchievements
// (Iterator, PreOperator, Singular, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FAchievementDetails> Achievements                   (Parm, OutParm, NeedCtorLink)
// int                            TitleId                        (OptionalParm, Parm)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlinePlayerInterface::STATIC_GetAchievements(unsigned char LocalUserNum, int TitleId, TArray<struct FAchievementDetails>* Achievements)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetAchievements"));

	UOnlinePlayerInterface_GetAchievements_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Achievements != nullptr)
		*Achievements = params.Achievements;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearReadAchievementsCompleteDelegate
// (Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAchievementsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReadAchievementsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAchievementsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReadAchievementsCompleteDelegate"));

	UOnlinePlayerInterface_ClearReadAchievementsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAchievementsCompleteDelegate = ReadAchievementsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReadAchievementsCompleteDelegate
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAchievementsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReadAchievementsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAchievementsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReadAchievementsCompleteDelegate"));

	UOnlinePlayerInterface_AddReadAchievementsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAchievementsCompleteDelegate = ReadAchievementsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReadAchievementsComplete
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            TitleId                        (Parm)

void UOnlinePlayerInterface::STATIC_OnReadAchievementsComplete(int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReadAchievementsComplete"));

	UOnlinePlayerInterface_OnReadAchievementsComplete_Params params;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ReadAchievements
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (OptionalParm, Parm)
// bool                           bShouldReadText                (OptionalParm, Parm)
// bool                           bShouldReadImages              (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ReadAchievements(unsigned char LocalUserNum, int TitleId, bool bShouldReadText, bool bShouldReadImages)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ReadAchievements"));

	UOnlinePlayerInterface_ReadAchievements_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;
	params.bShouldReadText = bShouldReadText;
	params.bShouldReadImages = bShouldReadImages;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearUnlockAchievementCompleteDelegate
// (Final, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         UnlockAchievementCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearUnlockAchievementCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& UnlockAchievementCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearUnlockAchievementCompleteDelegate"));

	UOnlinePlayerInterface_ClearUnlockAchievementCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.UnlockAchievementCompleteDelegate = UnlockAchievementCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddUnlockAchievementCompleteDelegate
// (Final, Defined, Iterator, PreOperator, Singular, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         UnlockAchievementCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddUnlockAchievementCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& UnlockAchievementCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddUnlockAchievementCompleteDelegate"));

	UOnlinePlayerInterface_AddUnlockAchievementCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.UnlockAchievementCompleteDelegate = UnlockAchievementCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnUnlockAchievementComplete
// (Defined, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnUnlockAchievementComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnUnlockAchievementComplete"));

	UOnlinePlayerInterface_OnUnlockAchievementComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.UnlockAchievement
// (Latent, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            AchievementId                  (Parm)
// float                          PercentComplete                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::UnlockAchievement(unsigned char LocalUserNum, int AchievementId, float PercentComplete)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.UnlockAchievement"));

	UOnlinePlayerInterface_UnlockAchievement_Params params;
	params.LocalUserNum = LocalUserNum;
	params.AchievementId = AchievementId;
	params.PercentComplete = PercentComplete;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.DeleteMessage
// (PreOperator, Singular, Net, Native, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            MessageIndex                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_DeleteMessage(unsigned char LocalUserNum, int MessageIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.DeleteMessage"));

	UOnlinePlayerInterface_DeleteMessage_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MessageIndex = MessageIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearFriendMessageReceivedDelegate
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         MessageDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearFriendMessageReceivedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& MessageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearFriendMessageReceivedDelegate"));

	UOnlinePlayerInterface_ClearFriendMessageReceivedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MessageDelegate = MessageDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddFriendMessageReceivedDelegate
// (Final, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         MessageDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddFriendMessageReceivedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& MessageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFriendMessageReceivedDelegate"));

	UOnlinePlayerInterface_AddFriendMessageReceivedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MessageDelegate = MessageDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnFriendMessageReceived
// (Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            SendingPlayer                  (Parm)
// struct FString                 SendingNick                    (Parm, NeedCtorLink)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnFriendMessageReceived(unsigned char LocalUserNum, const struct FUniqueNetId& SendingPlayer, const struct FString& SendingNick, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnFriendMessageReceived"));

	UOnlinePlayerInterface_OnFriendMessageReceived_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SendingPlayer = SendingPlayer;
	params.SendingNick = SendingNick;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.GetFriendMessages
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FOnlineFriendMessage> FriendMessages                 (Parm, OutParm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_GetFriendMessages(unsigned char LocalUserNum, TArray<struct FOnlineFriendMessage>* FriendMessages)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetFriendMessages"));

	UOnlinePlayerInterface_GetFriendMessages_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FriendMessages != nullptr)
		*FriendMessages = params.FriendMessages;
}


// Function Engine.OnlinePlayerInterface.ClearJoinFriendGameCompleteDelegate
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         JoinFriendGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearJoinFriendGameCompleteDelegate(const struct FScriptDelegate& JoinFriendGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearJoinFriendGameCompleteDelegate"));

	UOnlinePlayerInterface_ClearJoinFriendGameCompleteDelegate_Params params;
	params.JoinFriendGameCompleteDelegate = JoinFriendGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddJoinFriendGameCompleteDelegate
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         JoinFriendGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddJoinFriendGameCompleteDelegate(const struct FScriptDelegate& JoinFriendGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddJoinFriendGameCompleteDelegate"));

	UOnlinePlayerInterface_AddJoinFriendGameCompleteDelegate_Params params;
	params.JoinFriendGameCompleteDelegate = JoinFriendGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnJoinFriendGameComplete
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnJoinFriendGameComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnJoinFriendGameComplete"));

	UOnlinePlayerInterface_OnJoinFriendGameComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.JoinFriendGame
// (Defined, Latent, Singular, Simulated, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            Friend                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_JoinFriendGame(unsigned char LocalUserNum, const struct FUniqueNetId& Friend)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.JoinFriendGame"));

	UOnlinePlayerInterface_JoinFriendGame_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Friend = Friend;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CheckForGameInviteOnLaunch
// (Final, Iterator, Latent, Net, NetReliable, Exec, Native, Event, Operator)

void UOnlinePlayerInterface::CheckForGameInviteOnLaunch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CheckForGameInviteOnLaunch"));

	UOnlinePlayerInterface_CheckForGameInviteOnLaunch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearReceivedGameInviteDelegate
// (Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReceivedGameInviteDelegate     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReceivedGameInviteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReceivedGameInviteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReceivedGameInviteDelegate"));

	UOnlinePlayerInterface_ClearReceivedGameInviteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReceivedGameInviteDelegate = ReceivedGameInviteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReceivedGameInviteDelegate
// (Final, Defined, Iterator, Latent, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReceivedGameInviteDelegate     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReceivedGameInviteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReceivedGameInviteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReceivedGameInviteDelegate"));

	UOnlinePlayerInterface_AddReceivedGameInviteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReceivedGameInviteDelegate = ReceivedGameInviteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReceivedGameInvite
// (Defined, Iterator, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 InviterName                    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnReceivedGameInvite(unsigned char LocalUserNum, const struct FString& InviterName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReceivedGameInvite"));

	UOnlinePlayerInterface_OnReceivedGameInvite_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InviterName = InviterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.SendGameInviteToFriends
// (Final, Iterator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Friends                        (Parm, NeedCtorLink)
// struct FString                 Text                           (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::SendGameInviteToFriends(unsigned char LocalUserNum, const struct FName& SessionName, TArray<struct FUniqueNetId> Friends, const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.SendGameInviteToFriends"));

	UOnlinePlayerInterface_SendGameInviteToFriends_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SessionName = SessionName;
	params.Friends = Friends;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.SendGameInviteToFriend
// (Iterator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            Friend                         (Parm)
// struct FString                 Text                           (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::SendGameInviteToFriend(unsigned char LocalUserNum, const struct FName& SessionName, const struct FUniqueNetId& Friend, const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.SendGameInviteToFriend"));

	UOnlinePlayerInterface_SendGameInviteToFriend_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SessionName = SessionName;
	params.Friend = Friend;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.SendMessageToFriend
// (Final, Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            Friend                         (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::SendMessageToFriend(unsigned char LocalUserNum, const struct FUniqueNetId& Friend, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.SendMessageToFriend"));

	UOnlinePlayerInterface_SendMessageToFriend_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Friend = Friend;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearFriendInviteReceivedDelegate
// (Final, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InviteDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearFriendInviteReceivedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InviteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearFriendInviteReceivedDelegate"));

	UOnlinePlayerInterface_ClearFriendInviteReceivedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InviteDelegate = InviteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddFriendInviteReceivedDelegate
// (Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InviteDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddFriendInviteReceivedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InviteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFriendInviteReceivedDelegate"));

	UOnlinePlayerInterface_AddFriendInviteReceivedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InviteDelegate = InviteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnFriendInviteReceived
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            RequestingPlayer               (Parm)
// struct FString                 RequestingNick                 (Parm, NeedCtorLink)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnFriendInviteReceived(unsigned char LocalUserNum, const struct FUniqueNetId& RequestingPlayer, const struct FString& RequestingNick, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnFriendInviteReceived"));

	UOnlinePlayerInterface_OnFriendInviteReceived_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RequestingPlayer = RequestingPlayer;
	params.RequestingNick = RequestingNick;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.RemoveFriend
// (Defined, PreOperator, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            FormerFriend                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::RemoveFriend(unsigned char LocalUserNum, const struct FUniqueNetId& FormerFriend)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.RemoveFriend"));

	UOnlinePlayerInterface_RemoveFriend_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FormerFriend = FormerFriend;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.DenyFriendInvite
// (NetReliable, Native, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            RequestingPlayer               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_DenyFriendInvite(unsigned char LocalUserNum, const struct FUniqueNetId& RequestingPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.DenyFriendInvite"));

	UOnlinePlayerInterface_DenyFriendInvite_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RequestingPlayer = RequestingPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.AcceptFriendInvite
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            RequestingPlayer               (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::AcceptFriendInvite(unsigned char LocalUserNum, const struct FUniqueNetId& RequestingPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AcceptFriendInvite"));

	UOnlinePlayerInterface_AcceptFriendInvite_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RequestingPlayer = RequestingPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearAddFriendByNameCompleteDelegate
// (Iterator, Latent, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         FriendDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearAddFriendByNameCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& FriendDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearAddFriendByNameCompleteDelegate"));

	UOnlinePlayerInterface_ClearAddFriendByNameCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FriendDelegate = FriendDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddAddFriendByNameCompleteDelegate
// (Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         FriendDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddAddFriendByNameCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& FriendDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddAddFriendByNameCompleteDelegate"));

	UOnlinePlayerInterface_AddAddFriendByNameCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FriendDelegate = FriendDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnAddFriendByNameComplete
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnAddFriendByNameComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnAddFriendByNameComplete"));

	UOnlinePlayerInterface_OnAddFriendByNameComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddFriendByName
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 FriendName                     (Parm, NeedCtorLink)
// struct FString                 Message                        (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::AddFriendByName(unsigned char LocalUserNum, const struct FString& FriendName, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFriendByName"));

	UOnlinePlayerInterface_AddFriendByName_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FriendName = FriendName;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.AddFriend
// (Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            NewFriend                      (Parm)
// struct FString                 Message                        (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::AddFriend(unsigned char LocalUserNum, const struct FUniqueNetId& NewFriend, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFriend"));

	UOnlinePlayerInterface_AddFriend_Params params;
	params.LocalUserNum = LocalUserNum;
	params.NewFriend = NewFriend;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetKeyboardInputResults
// (Defined, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  bWasCanceled                   (Parm, OutParm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlinePlayerInterface::STATIC_GetKeyboardInputResults(unsigned char* bWasCanceled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetKeyboardInputResults"));

	UOnlinePlayerInterface_GetKeyboardInputResults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bWasCanceled != nullptr)
		*bWasCanceled = params.bWasCanceled;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearKeyboardInputDoneDelegate
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InputDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearKeyboardInputDoneDelegate(const struct FScriptDelegate& InputDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearKeyboardInputDoneDelegate"));

	UOnlinePlayerInterface_ClearKeyboardInputDoneDelegate_Params params;
	params.InputDelegate = InputDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddKeyboardInputDoneDelegate
// (Final, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InputDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddKeyboardInputDoneDelegate(const struct FScriptDelegate& InputDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddKeyboardInputDoneDelegate"));

	UOnlinePlayerInterface_AddKeyboardInputDoneDelegate_Params params;
	params.InputDelegate = InputDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnKeyboardInputComplete
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnKeyboardInputComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnKeyboardInputComplete"));

	UOnlinePlayerInterface_OnKeyboardInputComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.HideKeyboardUI
// (Latent, PreOperator, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_HideKeyboardUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.HideKeyboardUI"));

	UOnlinePlayerInterface_HideKeyboardUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ShowKeyboardUI
// (Final, Iterator, Latent, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 TitleText                      (Parm, NeedCtorLink)
// struct FString                 DescriptionText                (Parm, NeedCtorLink)
// bool                           bIsPassword                    (OptionalParm, Parm)
// bool                           bShouldValidate                (OptionalParm, Parm)
// struct FString                 DefaultText                    (OptionalParm, Parm, NeedCtorLink)
// int                            MaxResultLength                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ShowKeyboardUI(unsigned char LocalUserNum, const struct FString& TitleText, const struct FString& DescriptionText, bool bIsPassword, bool bShouldValidate, const struct FString& DefaultText, int MaxResultLength)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ShowKeyboardUI"));

	UOnlinePlayerInterface_ShowKeyboardUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleText = TitleText;
	params.DescriptionText = DescriptionText;
	params.bIsPassword = bIsPassword;
	params.bShouldValidate = bShouldValidate;
	params.DefaultText = DefaultText;
	params.MaxResultLength = MaxResultLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.SetOnlineStatus
// (Iterator, Latent, PreOperator, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 StatusString                   (Parm, NeedCtorLink)
// bool                           PlayerActive                   (OptionalParm, Parm)

void UOnlinePlayerInterface::SetOnlineStatus(unsigned char LocalUserNum, const struct FString& StatusString, bool PlayerActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.SetOnlineStatus"));

	UOnlinePlayerInterface_SetOnlineStatus_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatusString = StatusString;
	params.PlayerActive = PlayerActive;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.GetFriendsList
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FOnlineFriend>   Friends                        (Parm, OutParm, NeedCtorLink)
// int                            Count                          (OptionalParm, Parm)
// int                            StartingAt                     (OptionalParm, Parm)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlinePlayerInterface::STATIC_GetFriendsList(unsigned char LocalUserNum, int Count, int StartingAt, TArray<struct FOnlineFriend>* Friends)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetFriendsList"));

	UOnlinePlayerInterface_GetFriendsList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Count = Count;
	params.StartingAt = StartingAt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Friends != nullptr)
		*Friends = params.Friends;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearReadFriendsCompleteDelegate
// (Final, Defined, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadFriendsCompleteDelegate    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReadFriendsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadFriendsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReadFriendsCompleteDelegate"));

	UOnlinePlayerInterface_ClearReadFriendsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadFriendsCompleteDelegate = ReadFriendsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReadFriendsCompleteDelegate
// (Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadFriendsCompleteDelegate    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReadFriendsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadFriendsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReadFriendsCompleteDelegate"));

	UOnlinePlayerInterface_AddReadFriendsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadFriendsCompleteDelegate = ReadFriendsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReadFriendsComplete
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnReadFriendsComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReadFriendsComplete"));

	UOnlinePlayerInterface_OnReadFriendsComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ReadFriendsList
// (Final, Defined, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            Count                          (OptionalParm, Parm)
// int                            StartingAt                     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ReadFriendsList(unsigned char LocalUserNum, int Count, int StartingAt)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ReadFriendsList"));

	UOnlinePlayerInterface_ReadFriendsList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Count = Count;
	params.StartingAt = StartingAt;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearWritePlayerStorageCompleteDelegate
// (Final, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WritePlayerStorageCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearWritePlayerStorageCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WritePlayerStorageCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearWritePlayerStorageCompleteDelegate"));

	UOnlinePlayerInterface_ClearWritePlayerStorageCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WritePlayerStorageCompleteDelegate = WritePlayerStorageCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddWritePlayerStorageCompleteDelegate
// (Net, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WritePlayerStorageCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddWritePlayerStorageCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WritePlayerStorageCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddWritePlayerStorageCompleteDelegate"));

	UOnlinePlayerInterface_AddWritePlayerStorageCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WritePlayerStorageCompleteDelegate = WritePlayerStorageCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnWritePlayerStorageComplete
// (Defined, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnWritePlayerStorageComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnWritePlayerStorageComplete"));

	UOnlinePlayerInterface_OnWritePlayerStorageComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.WritePlayerStorage
// (Final, Defined, Iterator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// int                            DeviceID                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::WritePlayerStorage(unsigned char LocalUserNum, class UOnlinePlayerStorage* PlayerStorage, int DeviceID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.WritePlayerStorage"));

	UOnlinePlayerInterface_WritePlayerStorage_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerStorage = PlayerStorage;
	params.DeviceID = DeviceID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetPlayerStorage
// (Final, Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlinePlayerStorage*    ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlinePlayerStorage* UOnlinePlayerInterface::STATIC_GetPlayerStorage(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetPlayerStorage"));

	UOnlinePlayerInterface_GetPlayerStorage_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearReadPlayerStorageForNetIdCompleteDelegate
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FUniqueNetId            NetId                          (Parm)
// struct FScriptDelegate         ReadPlayerStorageForNetIdCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReadPlayerStorageForNetIdCompleteDelegate(const struct FUniqueNetId& NetId, const struct FScriptDelegate& ReadPlayerStorageForNetIdCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReadPlayerStorageForNetIdCompleteDelegate"));

	UOnlinePlayerInterface_ClearReadPlayerStorageForNetIdCompleteDelegate_Params params;
	params.NetId = NetId;
	params.ReadPlayerStorageForNetIdCompleteDelegate = ReadPlayerStorageForNetIdCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReadPlayerStorageForNetIdCompleteDelegate
// (Final, Defined, Iterator, Operator)
// Parameters:
// struct FUniqueNetId            NetId                          (Parm)
// struct FScriptDelegate         ReadPlayerStorageForNetIdCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReadPlayerStorageForNetIdCompleteDelegate(const struct FUniqueNetId& NetId, const struct FScriptDelegate& ReadPlayerStorageForNetIdCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReadPlayerStorageForNetIdCompleteDelegate"));

	UOnlinePlayerInterface_AddReadPlayerStorageForNetIdCompleteDelegate_Params params;
	params.NetId = NetId;
	params.ReadPlayerStorageForNetIdCompleteDelegate = ReadPlayerStorageForNetIdCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReadPlayerStorageForNetIdComplete
// (Final, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            NetId                          (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnReadPlayerStorageForNetIdComplete(const struct FUniqueNetId& NetId, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReadPlayerStorageForNetIdComplete"));

	UOnlinePlayerInterface_OnReadPlayerStorageForNetIdComplete_Params params;
	params.NetId = NetId;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ReadPlayerStorageForNetId
// (Final, Iterator, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            NetId                          (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ReadPlayerStorageForNetId(unsigned char LocalUserNum, const struct FUniqueNetId& NetId, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ReadPlayerStorageForNetId"));

	UOnlinePlayerInterface_ReadPlayerStorageForNetId_Params params;
	params.LocalUserNum = LocalUserNum;
	params.NetId = NetId;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearReadPlayerStorageCompleteDelegate
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadPlayerStorageCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReadPlayerStorageCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadPlayerStorageCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReadPlayerStorageCompleteDelegate"));

	UOnlinePlayerInterface_ClearReadPlayerStorageCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadPlayerStorageCompleteDelegate = ReadPlayerStorageCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReadPlayerStorageCompleteDelegate
// (Defined, Iterator, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadPlayerStorageCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReadPlayerStorageCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadPlayerStorageCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReadPlayerStorageCompleteDelegate"));

	UOnlinePlayerInterface_AddReadPlayerStorageCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadPlayerStorageCompleteDelegate = ReadPlayerStorageCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReadPlayerStorageComplete
// (Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnReadPlayerStorageComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReadPlayerStorageComplete"));

	UOnlinePlayerInterface_OnReadPlayerStorageComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ReadPlayerStorage
// (Final, Defined, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// int                            DeviceID                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ReadPlayerStorage(unsigned char LocalUserNum, class UOnlinePlayerStorage* PlayerStorage, int DeviceID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ReadPlayerStorage"));

	UOnlinePlayerInterface_ReadPlayerStorage_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerStorage = PlayerStorage;
	params.DeviceID = DeviceID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearWriteProfileSettingsCompleteDelegate
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WriteProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearWriteProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WriteProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearWriteProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterface_ClearWriteProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WriteProfileSettingsCompleteDelegate = WriteProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddWriteProfileSettingsCompleteDelegate
// (Final, Net, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WriteProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddWriteProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WriteProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddWriteProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterface_AddWriteProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WriteProfileSettingsCompleteDelegate = WriteProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnWriteProfileSettingsComplete
// (Final, Defined, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnWriteProfileSettingsComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnWriteProfileSettingsComplete"));

	UOnlinePlayerInterface_OnWriteProfileSettingsComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.WriteProfileSettings
// (Final, Latent, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineProfileSettings*  ProfileSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::WriteProfileSettings(unsigned char LocalUserNum, class UOnlineProfileSettings* ProfileSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.WriteProfileSettings"));

	UOnlinePlayerInterface_WriteProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProfileSettings = ProfileSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetProfileSettings
// (Defined, Latent, PreOperator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineProfileSettings*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineProfileSettings* UOnlinePlayerInterface::STATIC_GetProfileSettings(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetProfileSettings"));

	UOnlinePlayerInterface_GetProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearReadProfileSettingsCompleteDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearReadProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearReadProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterface_ClearReadProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadProfileSettingsCompleteDelegate = ReadProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddReadProfileSettingsCompleteDelegate
// (Latent, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddReadProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddReadProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterface_AddReadProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadProfileSettingsCompleteDelegate = ReadProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnReadProfileSettingsComplete
// (Defined, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnReadProfileSettingsComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnReadProfileSettingsComplete"));

	UOnlinePlayerInterface_OnReadProfileSettingsComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ReadProfileSettings
// (Final, Defined, Iterator, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineProfileSettings*  ProfileSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ReadProfileSettings(unsigned char LocalUserNum, class UOnlineProfileSettings* ProfileSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ReadProfileSettings"));

	UOnlinePlayerInterface_ReadProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProfileSettings = ProfileSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearFriendsChangeDelegate
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         FriendsDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearFriendsChangeDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& FriendsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearFriendsChangeDelegate"));

	UOnlinePlayerInterface_ClearFriendsChangeDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FriendsDelegate = FriendsDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddFriendsChangeDelegate
// (Defined, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         FriendsDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddFriendsChangeDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& FriendsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFriendsChangeDelegate"));

	UOnlinePlayerInterface_AddFriendsChangeDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FriendsDelegate = FriendsDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearMutingChangeDelegate
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MutingDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearMutingChangeDelegate(const struct FScriptDelegate& MutingDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearMutingChangeDelegate"));

	UOnlinePlayerInterface_ClearMutingChangeDelegate_Params params;
	params.MutingDelegate = MutingDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddMutingChangeDelegate
// (Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         MutingDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddMutingChangeDelegate(const struct FScriptDelegate& MutingDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddMutingChangeDelegate"));

	UOnlinePlayerInterface_AddMutingChangeDelegate_Params params;
	params.MutingDelegate = MutingDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearCurrentUserChangedDelegate
// (Iterator, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         CurrentUserDelegate            (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearCurrentUserChangedDelegate(const struct FScriptDelegate& CurrentUserDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearCurrentUserChangedDelegate"));

	UOnlinePlayerInterface_ClearCurrentUserChangedDelegate_Params params;
	params.CurrentUserDelegate = CurrentUserDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddCurrentUserChangedDelegate
// (Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         CurrentUserDelegate            (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddCurrentUserChangedDelegate(const struct FScriptDelegate& CurrentUserDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddCurrentUserChangedDelegate"));

	UOnlinePlayerInterface_AddCurrentUserChangedDelegate_Params params;
	params.CurrentUserDelegate = CurrentUserDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearLoginCancelledDelegate
// (Final, Defined, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         CancelledDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearLoginCancelledDelegate(const struct FScriptDelegate& CancelledDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearLoginCancelledDelegate"));

	UOnlinePlayerInterface_ClearLoginCancelledDelegate_Params params;
	params.CancelledDelegate = CancelledDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddLoginCancelledDelegate
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         CancelledDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddLoginCancelledDelegate(const struct FScriptDelegate& CancelledDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddLoginCancelledDelegate"));

	UOnlinePlayerInterface_AddLoginCancelledDelegate_Params params;
	params.CancelledDelegate = CancelledDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearLoginStatusChangeDelegate
// (Defined, Iterator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         LoginStatusDelegate            (Parm, NeedCtorLink)
// unsigned char                  LocalUserNum                   (Parm)

void UOnlinePlayerInterface::ClearLoginStatusChangeDelegate(const struct FScriptDelegate& LoginStatusDelegate, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearLoginStatusChangeDelegate"));

	UOnlinePlayerInterface_ClearLoginStatusChangeDelegate_Params params;
	params.LoginStatusDelegate = LoginStatusDelegate;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddLoginStatusChangeDelegate
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         LoginStatusDelegate            (Parm, NeedCtorLink)
// unsigned char                  LocalUserNum                   (Parm)

void UOnlinePlayerInterface::AddLoginStatusChangeDelegate(const struct FScriptDelegate& LoginStatusDelegate, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddLoginStatusChangeDelegate"));

	UOnlinePlayerInterface_AddLoginStatusChangeDelegate_Params params;
	params.LoginStatusDelegate = LoginStatusDelegate;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnLoginStatusChange
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<ELoginStatus>      NewStatus                      (Parm)
// struct FUniqueNetId            NewId                          (Parm)

void UOnlinePlayerInterface::STATIC_OnLoginStatusChange(TEnumAsByte<ELoginStatus> NewStatus, const struct FUniqueNetId& NewId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnLoginStatusChange"));

	UOnlinePlayerInterface_OnLoginStatusChange_Params params;
	params.NewStatus = NewStatus;
	params.NewId = NewId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearLoginChangeDelegate
// (Iterator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         LoginDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearLoginChangeDelegate(const struct FScriptDelegate& LoginDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearLoginChangeDelegate"));

	UOnlinePlayerInterface_ClearLoginChangeDelegate_Params params;
	params.LoginDelegate = LoginDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddLoginChangeDelegate
// (Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         LoginDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddLoginChangeDelegate(const struct FScriptDelegate& LoginDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddLoginChangeDelegate"));

	UOnlinePlayerInterface_AddLoginChangeDelegate_Params params;
	params.LoginDelegate = LoginDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ShowFriendsUI
// (Final, Iterator, Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ShowFriendsUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ShowFriendsUI"));

	UOnlinePlayerInterface_ShowFriendsUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.IsMuted
// (Final, Latent, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_IsMuted(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.IsMuted"));

	UOnlinePlayerInterface_IsMuted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.AreAnyFriends
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FFriendsQuery>   Query                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::AreAnyFriends(unsigned char LocalUserNum, TArray<struct FFriendsQuery>* Query)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AreAnyFriends"));

	UOnlinePlayerInterface_AreAnyFriends_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Query != nullptr)
		*Query = params.Query;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.IsFriend
// (Final, Iterator, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_IsFriend(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.IsFriend"));

	UOnlinePlayerInterface_IsFriend_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanUploadFitnessData
// (Final, Defined, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanUploadFitnessData(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanUploadFitnessData"));

	UOnlinePlayerInterface_CanUploadFitnessData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanShareKinectContent
// (PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanShareKinectContent(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanShareKinectContent"));

	UOnlinePlayerInterface_CanShareKinectContent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanShareWithSocialNetwork
// (Defined, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanShareWithSocialNetwork(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanShareWithSocialNetwork"));

	UOnlinePlayerInterface_CanShareWithSocialNetwork_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanBrowseInternet
// (Defined, Iterator, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanBrowseInternet(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanBrowseInternet"));

	UOnlinePlayerInterface_CanBrowseInternet_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanAccessPremiumVideoContent
// (Final, Iterator, Latent, Singular, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanAccessPremiumVideoContent(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanAccessPremiumVideoContent"));

	UOnlinePlayerInterface_CanAccessPremiumVideoContent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanAccessPremiumContent
// (Iterator, Latent, Singular, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanAccessPremiumContent(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanAccessPremiumContent"));

	UOnlinePlayerInterface_CanAccessPremiumContent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanUseCloudStorage
// (Singular, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanUseCloudStorage(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanUseCloudStorage"));

	UOnlinePlayerInterface_CanUseCloudStorage_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanRecordDVRClips
// (Iterator, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanRecordDVRClips(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanRecordDVRClips"));

	UOnlinePlayerInterface_CanRecordDVRClips_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanShowPresenceInformation
// (Final, Defined, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanShowPresenceInformation(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanShowPresenceInformation"));

	UOnlinePlayerInterface_CanShowPresenceInformation_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanViewPlayerProfiles
// (Iterator, Singular, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanViewPlayerProfiles(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanViewPlayerProfiles"));

	UOnlinePlayerInterface_CanViewPlayerProfiles_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanPurchaseContent
// (Defined, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanPurchaseContent(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanPurchaseContent"));

	UOnlinePlayerInterface_CanPurchaseContent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanShareUserCreatedContent
// (Final, PreOperator, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanShareUserCreatedContent(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanShareUserCreatedContent"));

	UOnlinePlayerInterface_CanShareUserCreatedContent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateTextWithUsersByUniqueNetIds
// (Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    Users                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanCommunicateTextWithUsersByUniqueNetIds(unsigned char LocalUserNum, TArray<struct FUniqueNetId> Users)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateTextWithUsersByUniqueNetIds"));

	UOnlinePlayerInterface_CanCommunicateTextWithUsersByUniqueNetIds_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Users = Users;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateTextWithUsers
// (Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FSessionMemberInfo> Users                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanCommunicateTextWithUsers(unsigned char LocalUserNum, TArray<struct FSessionMemberInfo> Users)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateTextWithUsers"));

	UOnlinePlayerInterface_CanCommunicateTextWithUsers_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Users = Users;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateVoiceWithUsersByUniqueNetIds
// (Defined, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    Users                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_CanCommunicateVoiceWithUsersByUniqueNetIds(unsigned char LocalUserNum, TArray<struct FUniqueNetId> Users)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateVoiceWithUsersByUniqueNetIds"));

	UOnlinePlayerInterface_CanCommunicateVoiceWithUsersByUniqueNetIds_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Users = Users;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateVoiceWithUsers
// (Defined, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FSessionMemberInfo> Users                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanCommunicateVoiceWithUsers(unsigned char LocalUserNum, TArray<struct FSessionMemberInfo> Users)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateVoiceWithUsers"));

	UOnlinePlayerInterface_CanCommunicateVoiceWithUsers_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Users = Users;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanMultiplayerCrossPlay
// (Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanMultiplayerCrossPlay(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanMultiplayerCrossPlay"));

	UOnlinePlayerInterface_CanMultiplayerCrossPlay_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateVoice
// (Final, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_CanCommunicateVoice(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateVoice"));

	UOnlinePlayerInterface_CanCommunicateVoice_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateVideo
// (Final, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanCommunicateVideo(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateVideo"));

	UOnlinePlayerInterface_CanCommunicateVideo_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanCommunicateText
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanCommunicateText(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanCommunicateText"));

	UOnlinePlayerInterface_CanCommunicateText_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CanPlayOnline
// (Final, Latent, Net, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevelHint             (Parm, OutParm)
// bool                           bAttemptToResolve              (OptionalParm, Parm)
// struct FString                 Reason                         (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CanPlayOnline(unsigned char LocalUserNum, bool bAttemptToResolve, const struct FString& Reason, TEnumAsByte<EFeaturePrivilegeLevel>* PrivilegeLevelHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CanPlayOnline"));

	UOnlinePlayerInterface_CanPlayOnline_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAttemptToResolve = bAttemptToResolve;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PrivilegeLevelHint != nullptr)
		*PrivilegeLevelHint = params.PrivilegeLevelHint;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearFilterTextDelegate
// (Final, Defined, Iterator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         FilterTextDelegate             (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearFilterTextDelegate(const struct FScriptDelegate& FilterTextDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearFilterTextDelegate"));

	UOnlinePlayerInterface_ClearFilterTextDelegate_Params params;
	params.FilterTextDelegate = FilterTextDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddFilterTextDelegate
// (Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         FilterTextDelegate             (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddFilterTextDelegate(const struct FScriptDelegate& FilterTextDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddFilterTextDelegate"));

	UOnlinePlayerInterface_AddFilterTextDelegate_Params params;
	params.FilterTextDelegate = FilterTextDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnFilterText
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 OriginalText                   (Parm, NeedCtorLink)
// struct FString                 FilteredText                   (Parm, NeedCtorLink)
// bool                           bCensorCompletely              (Parm)

void UOnlinePlayerInterface::STATIC_OnFilterText(const struct FString& OriginalText, const struct FString& FilteredText, bool bCensorCompletely)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnFilterText"));

	UOnlinePlayerInterface_OnFilterText_Params params;
	params.OriginalText = OriginalText;
	params.FilteredText = FilteredText;
	params.bCensorCompletely = bCensorCompletely;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.CheckFilterText
// (Final, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Text                           (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::CheckFilterText(const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CheckFilterText"));

	UOnlinePlayerInterface_CheckFilterText_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearPrivilegeCheckedForUsersByUniqueNetIdsDelegate
// (Defined, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearPrivilegeCheckedForUsersByUniqueNetIdsDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearPrivilegeCheckedForUsersByUniqueNetIdsDelegate"));

	UOnlinePlayerInterface_ClearPrivilegeCheckedForUsersByUniqueNetIdsDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddPrivilegeCheckedForUsersByUniqueNetIdsDelegate
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddPrivilegeCheckedForUsersByUniqueNetIdsDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddPrivilegeCheckedForUsersByUniqueNetIdsDelegate"));

	UOnlinePlayerInterface_AddPrivilegeCheckedForUsersByUniqueNetIdsDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnPrivilegeCheckedForUsersByUniqueNetIds
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilege> Privilege                      (Parm)
// TArray<struct FPermissionsResultByUniqueNetId> Results                        (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnPrivilegeCheckedForUsersByUniqueNetIds(unsigned char LocalUserNum, TEnumAsByte<EFeaturePrivilege> Privilege, TArray<struct FPermissionsResultByUniqueNetId> Results)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnPrivilegeCheckedForUsersByUniqueNetIds"));

	UOnlinePlayerInterface_OnPrivilegeCheckedForUsersByUniqueNetIds_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Privilege = Privilege;
	params.Results = Results;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearPrivilegeCheckedForUsersDelegate
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearPrivilegeCheckedForUsersDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearPrivilegeCheckedForUsersDelegate"));

	UOnlinePlayerInterface_ClearPrivilegeCheckedForUsersDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddPrivilegeCheckedForUsersDelegate
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddPrivilegeCheckedForUsersDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddPrivilegeCheckedForUsersDelegate"));

	UOnlinePlayerInterface_AddPrivilegeCheckedForUsersDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnPrivilegeCheckedForUsers
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilege> Privilege                      (Parm)
// TArray<struct FPermissionsResult> Results                        (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnPrivilegeCheckedForUsers(unsigned char LocalUserNum, TEnumAsByte<EFeaturePrivilege> Privilege, TArray<struct FPermissionsResult> Results)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnPrivilegeCheckedForUsers"));

	UOnlinePlayerInterface_OnPrivilegeCheckedForUsers_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Privilege = Privilege;
	params.Results = Results;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearPrivilegeLevelCheckedDelegate
// (Iterator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearPrivilegeLevelCheckedDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearPrivilegeLevelCheckedDelegate"));

	UOnlinePlayerInterface_ClearPrivilegeLevelCheckedDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddPrivilegeLevelCheckedDelegate
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         PrivilegeDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddPrivilegeLevelCheckedDelegate(const struct FScriptDelegate& PrivilegeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddPrivilegeLevelCheckedDelegate"));

	UOnlinePlayerInterface_AddPrivilegeLevelCheckedDelegate_Params params;
	params.PrivilegeDelegate = PrivilegeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnPrivilegeLevelChecked
// (Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EFeaturePrivilege> Privilege                      (Parm)
// TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevel                 (Parm)
// bool                           bDiffersFromHint               (Parm)

void UOnlinePlayerInterface::STATIC_OnPrivilegeLevelChecked(unsigned char LocalUserNum, TEnumAsByte<EFeaturePrivilege> Privilege, TEnumAsByte<EFeaturePrivilegeLevel> PrivilegeLevel, bool bDiffersFromHint)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnPrivilegeLevelChecked"));

	UOnlinePlayerInterface_OnPrivilegeLevelChecked_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Privilege = Privilege;
	params.PrivilegeLevel = PrivilegeLevel;
	params.bDiffersFromHint = bDiffersFromHint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.IsLocalLogin
// (Defined, Iterator, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_IsLocalLogin(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.IsLocalLogin"));

	UOnlinePlayerInterface_IsLocalLogin_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.IsGuestLogin
// (Defined, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_IsGuestLogin(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.IsGuestLogin"));

	UOnlinePlayerInterface_IsGuestLogin_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetPlayerNickname
// (Iterator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlinePlayerInterface::STATIC_GetPlayerNickname(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetPlayerNickname"));

	UOnlinePlayerInterface_GetPlayerNickname_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetControllerIdFromNetId
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// int                            ControllerId                   (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::GetControllerIdFromNetId(const struct FUniqueNetId& PlayerID, int* ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetControllerIdFromNetId"));

	UOnlinePlayerInterface_GetControllerIdFromNetId_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ControllerId != nullptr)
		*ControllerId = params.ControllerId;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetUniquePlayerId
// (Final, Latent, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_GetUniquePlayerId(unsigned char LocalUserNum, struct FUniqueNetId* PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetUniquePlayerId"));

	UOnlinePlayerInterface_GetUniquePlayerId_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlayerID != nullptr)
		*PlayerID = params.PlayerID;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.GetLoginStatus
// (Final, Iterator, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<ELoginStatus>      ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ELoginStatus> UOnlinePlayerInterface::GetLoginStatus(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetLoginStatus"));

	UOnlinePlayerInterface_GetLoginStatus_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.CacheLoggedInGamepad
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)

void UOnlinePlayerInterface::CacheLoggedInGamepad()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.CacheLoggedInGamepad"));

	UOnlinePlayerInterface_CacheLoggedInGamepad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.PairUserAndControllerAtIndex
// (Final, Iterator, Latent, PreOperator, Net, Exec, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  PlayerIndex                    (Parm)
// unsigned char                  ControllerIndex                (Parm)
// int                            PairIndex                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_PairUserAndControllerAtIndex(unsigned char PlayerIndex, unsigned char ControllerIndex, int PairIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.PairUserAndControllerAtIndex"));

	UOnlinePlayerInterface_PairUserAndControllerAtIndex_Params params;
	params.PlayerIndex = PlayerIndex;
	params.ControllerIndex = ControllerIndex;
	params.PairIndex = PairIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearSystemUserContrllerPairingChangedDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         PairingChangeDelegate          (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearSystemUserContrllerPairingChangedDelegate(const struct FScriptDelegate& PairingChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearSystemUserContrllerPairingChangedDelegate"));

	UOnlinePlayerInterface_ClearSystemUserContrllerPairingChangedDelegate_Params params;
	params.PairingChangeDelegate = PairingChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddSystemUserContrllerPairingChangedDelegate
// (Final, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         PairingChangeDelegate          (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddSystemUserContrllerPairingChangedDelegate(const struct FScriptDelegate& PairingChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddSystemUserContrllerPairingChangedDelegate"));

	UOnlinePlayerInterface_AddSystemUserContrllerPairingChangedDelegate_Params params;
	params.PairingChangeDelegate = PairingChangeDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnSystemUserControllerPairingChanged
// (PreOperator, Exec, Native, Event, Static)
// Parameters:
// int                            NewLocalUserNum                (Parm)
// int                            PreviousLocalUserNum           (Parm)

void UOnlinePlayerInterface::STATIC_OnSystemUserControllerPairingChanged(int NewLocalUserNum, int PreviousLocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnSystemUserControllerPairingChanged"));

	UOnlinePlayerInterface_OnSystemUserControllerPairingChanged_Params params;
	params.NewLocalUserNum = NewLocalUserNum;
	params.PreviousLocalUserNum = PreviousLocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearLogoutCompletedDelegate
// (Final, Defined, Iterator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         LogoutDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearLogoutCompletedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& LogoutDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearLogoutCompletedDelegate"));

	UOnlinePlayerInterface_ClearLogoutCompletedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.LogoutDelegate = LogoutDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddLogoutCompletedDelegate
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         LogoutDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddLogoutCompletedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& LogoutDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddLogoutCompletedDelegate"));

	UOnlinePlayerInterface_AddLogoutCompletedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.LogoutDelegate = LogoutDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnLogoutCompleted
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterface::STATIC_OnLogoutCompleted(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnLogoutCompleted"));

	UOnlinePlayerInterface_OnLogoutCompleted_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.Logout
// (Defined, Latent, NetReliable, Simulated, Native, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_Logout(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.Logout"));

	UOnlinePlayerInterface_Logout_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ClearLoginFailedDelegate
// (Final, Iterator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         LoginDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearLoginFailedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& LoginDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearLoginFailedDelegate"));

	UOnlinePlayerInterface_ClearLoginFailedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.LoginDelegate = LoginDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddLoginFailedDelegate
// (Final, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         LoginDelegate                  (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddLoginFailedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& LoginDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddLoginFailedDelegate"));

	UOnlinePlayerInterface_AddLoginFailedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.LoginDelegate = LoginDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnLoginFailed
// (PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EOnlineServerConnectionStatus> ErrorCode                      (Parm)

void UOnlinePlayerInterface::STATIC_OnLoginFailed(unsigned char LocalUserNum, TEnumAsByte<EOnlineServerConnectionStatus> ErrorCode)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnLoginFailed"));

	UOnlinePlayerInterface_OnLoginFailed_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ErrorCode = ErrorCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AutoLogin
// (Iterator, Latent, Net, Exec, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::AutoLogin()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AutoLogin"));

	UOnlinePlayerInterface_AutoLogin_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.Login
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 LoginName                      (Parm, NeedCtorLink)
// struct FString                 Password                       (Parm, NeedCtorLink)
// bool                           bWantsLocalOnly                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::Login(unsigned char LocalUserNum, const struct FString& LoginName, const struct FString& Password, bool bWantsLocalOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.Login"));

	UOnlinePlayerInterface_Login_Params params;
	params.LocalUserNum = LocalUserNum;
	params.LoginName = LoginName;
	params.Password = Password;
	params.bWantsLocalOnly = bWantsLocalOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.IsAccountPickerOpen
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::IsAccountPickerOpen()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.IsAccountPickerOpen"));

	UOnlinePlayerInterface_IsAccountPickerOpen_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.ShowLoginUI
// (Final, Defined, Iterator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bForceLogin                    (OptionalParm, Parm)
// bool                           bShowOnlineOnly                (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::ShowLoginUI(unsigned char LocalUserNum, bool bForceLogin, bool bShowOnlineOnly)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ShowLoginUI"));

	UOnlinePlayerInterface_ShowLoginUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bForceLogin = bForceLogin;
	params.bShowOnlineOnly = bShowOnlineOnly;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.RemoveAccountPickerCompleteDelegate
// (Final, Defined, Iterator, Native, HasOptionalParms)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::RemoveAccountPickerCompleteDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.RemoveAccountPickerCompleteDelegate"));

	UOnlinePlayerInterface_RemoveAccountPickerCompleteDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddAccountPickerCompleteDelegate
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddAccountPickerCompleteDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddAccountPickerCompleteDelegate"));

	UOnlinePlayerInterface_AddAccountPickerCompleteDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnAccountPickerComplete
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bForceLogin                    (Parm)

void UOnlinePlayerInterface::STATIC_OnAccountPickerComplete(bool bForceLogin)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnAccountPickerComplete"));

	UOnlinePlayerInterface_OnAccountPickerComplete_Params params;
	params.bForceLogin = bForceLogin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnFriendsChange
// (Final, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePlayerInterface::STATIC_OnFriendsChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnFriendsChange"));

	UOnlinePlayerInterface_OnFriendsChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnMutingChange
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePlayerInterface::STATIC_OnMutingChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnMutingChange"));

	UOnlinePlayerInterface_OnMutingChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearGetUserAccountInfoDelegate
// (Final, Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearGetUserAccountInfoDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearGetUserAccountInfoDelegate"));

	UOnlinePlayerInterface_ClearGetUserAccountInfoDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddGetUserAccountInfoDelegate
// (Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddGetUserAccountInfoDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddGetUserAccountInfoDelegate"));

	UOnlinePlayerInterface_AddGetUserAccountInfoDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.GetUserAccountInfo
// (Final, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_GetUserAccountInfo(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetUserAccountInfo"));

	UOnlinePlayerInterface_GetUserAccountInfo_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.OnUserAccountInfoRetrieved
// (Final, Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bSuccessful                    (Parm)
// struct FUserAccountInfo        AccountInfo                    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnUserAccountInfoRetrieved(bool bSuccessful, const struct FUserAccountInfo& AccountInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnUserAccountInfoRetrieved"));

	UOnlinePlayerInterface_OnUserAccountInfoRetrieved_Params params;
	params.bSuccessful = bSuccessful;
	params.AccountInfo = AccountInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.ClearURLTokenRetrievedDelegate
// (Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         tsrDelegate                    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::ClearURLTokenRetrievedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& tsrDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.ClearURLTokenRetrievedDelegate"));

	UOnlinePlayerInterface_ClearURLTokenRetrievedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.tsrDelegate = tsrDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.AddURLTokenRetrievedDelegate
// (Defined, Iterator, Latent, PreOperator, Singular, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         tsrDelegate                    (Parm, NeedCtorLink)

void UOnlinePlayerInterface::AddURLTokenRetrievedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& tsrDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.AddURLTokenRetrievedDelegate"));

	UOnlinePlayerInterface_AddURLTokenRetrievedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.tsrDelegate = tsrDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.GetTokenAndSignatureForURL
// (Defined, Iterator, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterface::STATIC_GetTokenAndSignatureForURL(unsigned char LocalUserNum, const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.GetTokenAndSignatureForURL"));

	UOnlinePlayerInterface_GetTokenAndSignatureForURL_Params params;
	params.LocalUserNum = LocalUserNum;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterface.OnTokenAndSignatureRetrieved
// (Final, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bSuccess                       (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 URL                            (Parm, NeedCtorLink)
// struct FString                 Token                          (Parm, NeedCtorLink)
// struct FString                 AuthToken                      (Parm, NeedCtorLink)
// struct FString                 Signature                      (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnTokenAndSignatureRetrieved(bool bSuccess, unsigned char LocalUserNum, const struct FString& URL, const struct FString& Token, const struct FString& AuthToken, const struct FString& Signature)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnTokenAndSignatureRetrieved"));

	UOnlinePlayerInterface_OnTokenAndSignatureRetrieved_Params params;
	params.bSuccess = bSuccess;
	params.LocalUserNum = LocalUserNum;
	params.URL = URL;
	params.Token = Token;
	params.AuthToken = AuthToken;
	params.Signature = Signature;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnCurrentUserChanged
// (Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  CurrentUserLocalNum            (Parm)
// struct FString                 CurrentUser                    (Parm, NeedCtorLink)
// struct FString                 LoggedInUser                   (Parm, NeedCtorLink)

void UOnlinePlayerInterface::STATIC_OnCurrentUserChanged(unsigned char CurrentUserLocalNum, const struct FString& CurrentUser, const struct FString& LoggedInUser)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnCurrentUserChanged"));

	UOnlinePlayerInterface_OnCurrentUserChanged_Params params;
	params.CurrentUserLocalNum = CurrentUserLocalNum;
	params.CurrentUser = CurrentUser;
	params.LoggedInUser = LoggedInUser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnLoginCancelled
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePlayerInterface::STATIC_OnLoginCancelled()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnLoginCancelled"));

	UOnlinePlayerInterface_OnLoginCancelled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterface.OnLoginChange
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlinePlayerInterface::STATIC_OnLoginChange(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterface.OnLoginChange"));

	UOnlinePlayerInterface_OnLoginChange_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.RateContent
// (Final, Defined, Iterator, Latent, Net, NetReliable, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FCommunityContentFile   FileToRate                     (Const, Parm, OutParm, NeedCtorLink)
// int                            NewRating                      (Parm)

void UOnlineCommunityContentInterface::RateContent(unsigned char PlayerNum, int NewRating, struct FCommunityContentFile* FileToRate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.RateContent"));

	UOnlineCommunityContentInterface_RateContent_Params params;
	params.PlayerNum = PlayerNum;
	params.NewRating = NewRating;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileToRate != nullptr)
		*FileToRate = params.FileToRate;
}


// Function Engine.OnlineCommunityContentInterface.ClearDeleteContentCompleteDelegate
// (Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         DeleteContentCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::ClearDeleteContentCompleteDelegate(const struct FScriptDelegate& DeleteContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ClearDeleteContentCompleteDelegate"));

	UOnlineCommunityContentInterface_ClearDeleteContentCompleteDelegate_Params params;
	params.DeleteContentCompleteDelegate = DeleteContentCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.AddDeleteContentCompleteDelegate
// (Defined, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         DeleteContentCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::AddDeleteContentCompleteDelegate(const struct FScriptDelegate& DeleteContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.AddDeleteContentCompleteDelegate"));

	UOnlineCommunityContentInterface_AddDeleteContentCompleteDelegate_Params params;
	params.DeleteContentCompleteDelegate = DeleteContentCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.OnDeleteContentComplete
// (Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineCommunityContentInterface::STATIC_OnDeleteContentComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.OnDeleteContentComplete"));

	UOnlineCommunityContentInterface_OnDeleteContentComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.DeleteContent
// (Final, Defined, Iterator, Singular, Net, Native, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FCommunityContentMetadata MetaData                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::STATIC_DeleteContent(unsigned char PlayerNum, struct FCommunityContentMetadata* MetaData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.DeleteContent"));

	UOnlineCommunityContentInterface_DeleteContent_Params params;
	params.PlayerNum = PlayerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MetaData != nullptr)
		*MetaData = params.MetaData;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.ClearDownloadContentCompleteDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         DownloadContentCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::ClearDownloadContentCompleteDelegate(const struct FScriptDelegate& DownloadContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ClearDownloadContentCompleteDelegate"));

	UOnlineCommunityContentInterface_ClearDownloadContentCompleteDelegate_Params params;
	params.DownloadContentCompleteDelegate = DownloadContentCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.AddDownloadContentCompleteDelegate
// (Final, Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         DownloadContentCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::AddDownloadContentCompleteDelegate(const struct FScriptDelegate& DownloadContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.AddDownloadContentCompleteDelegate"));

	UOnlineCommunityContentInterface_AddDownloadContentCompleteDelegate_Params params;
	params.DownloadContentCompleteDelegate = DownloadContentCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.OnDownloadContentComplete
// (Defined, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FCommunityContentFile   FileDownloaded                 (Parm, NeedCtorLink)
// TArray<unsigned char>          Payload                        (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::STATIC_OnDownloadContentComplete(bool bWasSuccessful, const struct FCommunityContentFile& FileDownloaded, TArray<unsigned char> Payload)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.OnDownloadContentComplete"));

	UOnlineCommunityContentInterface_OnDownloadContentComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.FileDownloaded = FileDownloaded;
	params.Payload = Payload;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.DownloadContent
// (Defined, PreOperator, Exec, Native, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FCommunityContentFile   FileToDownload                 (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::STATIC_DownloadContent(unsigned char PlayerNum, struct FCommunityContentFile* FileToDownload)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.DownloadContent"));

	UOnlineCommunityContentInterface_DownloadContent_Params params;
	params.PlayerNum = PlayerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileToDownload != nullptr)
		*FileToDownload = params.FileToDownload;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.ClearUploadContentCompleteDelegate
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UploadContentCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::ClearUploadContentCompleteDelegate(const struct FScriptDelegate& UploadContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ClearUploadContentCompleteDelegate"));

	UOnlineCommunityContentInterface_ClearUploadContentCompleteDelegate_Params params;
	params.UploadContentCompleteDelegate = UploadContentCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.AddUploadContentCompleteDelegate
// (Final, Iterator, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UploadContentCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::AddUploadContentCompleteDelegate(const struct FScriptDelegate& UploadContentCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.AddUploadContentCompleteDelegate"));

	UOnlineCommunityContentInterface_AddUploadContentCompleteDelegate_Params params;
	params.UploadContentCompleteDelegate = UploadContentCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.OnUploadContentComplete
// (Final, Defined, Iterator, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FCommunityContentFile   UploadedFile                   (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::STATIC_OnUploadContentComplete(bool bWasSuccessful, const struct FCommunityContentFile& UploadedFile)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.OnUploadContentComplete"));

	UOnlineCommunityContentInterface_OnUploadContentComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UploadedFile = UploadedFile;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.UploadContent
// (Defined, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// TArray<unsigned char>          Payload                        (Const, Parm, OutParm, NeedCtorLink)
// struct FCommunityContentMetadata MetaData                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::UploadContent(unsigned char PlayerNum, TArray<unsigned char>* Payload, struct FCommunityContentMetadata* MetaData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.UploadContent"));

	UOnlineCommunityContentInterface_UploadContent_Params params;
	params.PlayerNum = PlayerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Payload != nullptr)
		*Payload = params.Payload;
	if (MetaData != nullptr)
		*MetaData = params.MetaData;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.GetFriendsContentList
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FOnlineFriend           Friend                         (Const, Parm, OutParm, NeedCtorLink)
// TArray<struct FCommunityContentFile> ContentFiles                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::STATIC_GetFriendsContentList(unsigned char PlayerNum, struct FOnlineFriend* Friend, TArray<struct FCommunityContentFile>* ContentFiles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.GetFriendsContentList"));

	UOnlineCommunityContentInterface_GetFriendsContentList_Params params;
	params.PlayerNum = PlayerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Friend != nullptr)
		*Friend = params.Friend;
	if (ContentFiles != nullptr)
		*ContentFiles = params.ContentFiles;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.ClearReadFriendsContentListCompleteDelegate
// (Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadFriendsContentListCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::ClearReadFriendsContentListCompleteDelegate(const struct FScriptDelegate& ReadFriendsContentListCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ClearReadFriendsContentListCompleteDelegate"));

	UOnlineCommunityContentInterface_ClearReadFriendsContentListCompleteDelegate_Params params;
	params.ReadFriendsContentListCompleteDelegate = ReadFriendsContentListCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.AddReadFriendsContentListCompleteDelegate
// (Final, Operator)
// Parameters:
// struct FScriptDelegate         ReadFriendsContentListCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::AddReadFriendsContentListCompleteDelegate(const struct FScriptDelegate& ReadFriendsContentListCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.AddReadFriendsContentListCompleteDelegate"));

	UOnlineCommunityContentInterface_AddReadFriendsContentListCompleteDelegate_Params params;
	params.ReadFriendsContentListCompleteDelegate = ReadFriendsContentListCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.OnReadFriendsContentListComplete
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineCommunityContentInterface::STATIC_OnReadFriendsContentListComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.OnReadFriendsContentListComplete"));

	UOnlineCommunityContentInterface_OnReadFriendsContentListComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.ReadFriendsContentList
// (Final, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// TArray<struct FOnlineFriend>   Friends                        (Const, Parm, OutParm, NeedCtorLink)
// int                            StartAt                        (OptionalParm, Parm)
// int                            NumToRead                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::ReadFriendsContentList(unsigned char PlayerNum, int StartAt, int NumToRead, TArray<struct FOnlineFriend>* Friends)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ReadFriendsContentList"));

	UOnlineCommunityContentInterface_ReadFriendsContentList_Params params;
	params.PlayerNum = PlayerNum;
	params.StartAt = StartAt;
	params.NumToRead = NumToRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Friends != nullptr)
		*Friends = params.Friends;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.GetContentList
// (Defined, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// TArray<struct FCommunityContentFile> ContentFiles                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::STATIC_GetContentList(unsigned char PlayerNum, TArray<struct FCommunityContentFile>* ContentFiles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.GetContentList"));

	UOnlineCommunityContentInterface_GetContentList_Params params;
	params.PlayerNum = PlayerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ContentFiles != nullptr)
		*ContentFiles = params.ContentFiles;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.ClearReadContentListCompleteDelegate
// (PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadContentListCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::ClearReadContentListCompleteDelegate(const struct FScriptDelegate& ReadContentListCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ClearReadContentListCompleteDelegate"));

	UOnlineCommunityContentInterface_ClearReadContentListCompleteDelegate_Params params;
	params.ReadContentListCompleteDelegate = ReadContentListCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.AddReadContentListCompleteDelegate
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ReadContentListCompleteDelegate (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::AddReadContentListCompleteDelegate(const struct FScriptDelegate& ReadContentListCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.AddReadContentListCompleteDelegate"));

	UOnlineCommunityContentInterface_AddReadContentListCompleteDelegate_Params params;
	params.ReadContentListCompleteDelegate = ReadContentListCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.OnReadContentListComplete
// (Defined, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TArray<struct FCommunityContentFile> ContentFiles                   (Parm, NeedCtorLink)

void UOnlineCommunityContentInterface::STATIC_OnReadContentListComplete(bool bWasSuccessful, TArray<struct FCommunityContentFile> ContentFiles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.OnReadContentListComplete"));

	UOnlineCommunityContentInterface_OnReadContentListComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.ContentFiles = ContentFiles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.ReadContentList
// (Final, Iterator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FUniqueNetId            NetId                          (Parm)
// struct FString                 Path                           (OptionalParm, Parm, NeedCtorLink)
// int                            StartAt                        (OptionalParm, Parm)
// int                            NumToRead                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::ReadContentList(unsigned char PlayerNum, const struct FUniqueNetId& NetId, const struct FString& Path, int StartAt, int NumToRead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.ReadContentList"));

	UOnlineCommunityContentInterface_ReadContentList_Params params;
	params.PlayerNum = PlayerNum;
	params.NetId = NetId;
	params.Path = Path;
	params.StartAt = StartAt;
	params.NumToRead = NumToRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineCommunityContentInterface.Exit
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)

void UOnlineCommunityContentInterface::Exit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.Exit"));

	UOnlineCommunityContentInterface_Exit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineCommunityContentInterface.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineCommunityContentInterface::Init()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineCommunityContentInterface.Init"));

	UOnlineCommunityContentInterface_Init_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.CancelRecordingEvent
// (Final, Iterator, Latent, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 EventName                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDVRInterface::CancelRecordingEvent(unsigned char LocalUserNum, const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.CancelRecordingEvent"));

	UOnlineGameDVRInterface_CancelRecordingEvent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.RecordPreviousTimespan
// (PreOperator, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 EventName                      (Parm, NeedCtorLink)
// float                          Duration                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDVRInterface::RecordPreviousTimespan(unsigned char LocalUserNum, const struct FString& EventName, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.RecordPreviousTimespan"));

	UOnlineGameDVRInterface_RecordPreviousTimespan_Params params;
	params.LocalUserNum = LocalUserNum;
	params.EventName = EventName;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.EndRecordingEvent
// (Iterator, Latent, PreOperator, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 EventName                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDVRInterface::STATIC_EndRecordingEvent(unsigned char LocalUserNum, const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.EndRecordingEvent"));

	UOnlineGameDVRInterface_EndRecordingEvent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.ClearRecordEventCompleteDelegate
// (Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         RecordEventCompleteDelegate    (Parm, NeedCtorLink)

void UOnlineGameDVRInterface::ClearRecordEventCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& RecordEventCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.ClearRecordEventCompleteDelegate"));

	UOnlineGameDVRInterface_ClearRecordEventCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RecordEventCompleteDelegate = RecordEventCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.AddRecordEventCompleteDelegate
// (Final, PreOperator, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         RecordEventCompleteDelegate    (Parm, NeedCtorLink)

void UOnlineGameDVRInterface::AddRecordEventCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& RecordEventCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.AddRecordEventCompleteDelegate"));

	UOnlineGameDVRInterface_AddRecordEventCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RecordEventCompleteDelegate = RecordEventCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.OnRecordEventComplete
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 EventName                      (Parm, NeedCtorLink)

void UOnlineGameDVRInterface::STATIC_OnRecordEventComplete(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.OnRecordEventComplete"));

	UOnlineGameDVRInterface_OnRecordEventComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.BeginRecordingEvent
// (Final, Defined, PreOperator, Simulated, Native, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 EventName                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDVRInterface::BeginRecordingEvent(unsigned char LocalUserNum, const struct FString& EventName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.BeginRecordingEvent"));

	UOnlineGameDVRInterface_BeginRecordingEvent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.ClearReadRecordedClipsCompleteDelegate
// (Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadRecordedClipsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameDVRInterface::ClearReadRecordedClipsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadRecordedClipsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.ClearReadRecordedClipsCompleteDelegate"));

	UOnlineGameDVRInterface_ClearReadRecordedClipsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadRecordedClipsCompleteDelegate = ReadRecordedClipsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.AddReadRecordedClipsCompleteDelegate
// (Final, Latent, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadRecordedClipsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameDVRInterface::AddReadRecordedClipsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadRecordedClipsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.AddReadRecordedClipsCompleteDelegate"));

	UOnlineGameDVRInterface_AddReadRecordedClipsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadRecordedClipsCompleteDelegate = ReadRecordedClipsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.ClearCachedRecordedClips
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineGameDVRInterface::ClearCachedRecordedClips(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.ClearCachedRecordedClips"));

	UOnlineGameDVRInterface_ClearCachedRecordedClips_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.OnReadRecordedClipsComplete
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineGameDVRInterface::STATIC_OnReadRecordedClipsComplete(bool bWasSuccessful, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.OnReadRecordedClipsComplete"));

	UOnlineGameDVRInterface_OnReadRecordedClipsComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.ReadRecordedClips
// (Final, Latent, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDVRInterface::ReadRecordedClips(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.ReadRecordedClips"));

	UOnlineGameDVRInterface_ReadRecordedClips_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDVRInterface.DisableRecording
// (Final, Iterator, Latent, Simulated, Native, Static)

void UOnlineGameDVRInterface::STATIC_DisableRecording()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.DisableRecording"));

	UOnlineGameDVRInterface_DisableRecording_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDVRInterface.EnableRecording
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Static)

void UOnlineGameDVRInterface::STATIC_EnableRecording()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDVRInterface.EnableRecording"));

	UOnlineGameDVRInterface_EnableRecording_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.ClearWriteSharedFileCompleteDelegate
// (Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         WriteSharedFileCompleteDelegate (Parm, NeedCtorLink)

void USharedCloudFileInterface::ClearWriteSharedFileCompleteDelegate(const struct FScriptDelegate& WriteSharedFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.ClearWriteSharedFileCompleteDelegate"));

	USharedCloudFileInterface_ClearWriteSharedFileCompleteDelegate_Params params;
	params.WriteSharedFileCompleteDelegate = WriteSharedFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.AddWriteSharedFileCompleteDelegate
// (Final, Defined, Net, Operator)
// Parameters:
// struct FScriptDelegate         WriteSharedFileCompleteDelegate (Parm, NeedCtorLink)

void USharedCloudFileInterface::AddWriteSharedFileCompleteDelegate(const struct FScriptDelegate& WriteSharedFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.AddWriteSharedFileCompleteDelegate"));

	USharedCloudFileInterface_AddWriteSharedFileCompleteDelegate_Params params;
	params.WriteSharedFileCompleteDelegate = WriteSharedFileCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.WriteSharedFile
// (Defined, Iterator, Latent, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TArray<unsigned char>          Contents                       (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USharedCloudFileInterface::WriteSharedFile(const struct FString& UserId, const struct FString& Filename, TArray<unsigned char>* Contents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.WriteSharedFile"));

	USharedCloudFileInterface_WriteSharedFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Contents != nullptr)
		*Contents = params.Contents;

	return params.ReturnValue;
}


// Function Engine.SharedCloudFileInterface.OnWriteSharedFileComplete
// (Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 SharedHandle                   (Parm, NeedCtorLink)

void USharedCloudFileInterface::STATIC_OnWriteSharedFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename, const struct FString& SharedHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.OnWriteSharedFileComplete"));

	USharedCloudFileInterface_OnWriteSharedFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;
	params.SharedHandle = SharedHandle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.ClearReadSharedFileCompleteDelegate
// (Defined, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadSharedFileCompleteDelegate (Parm, NeedCtorLink)

void USharedCloudFileInterface::ClearReadSharedFileCompleteDelegate(const struct FScriptDelegate& ReadSharedFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.ClearReadSharedFileCompleteDelegate"));

	USharedCloudFileInterface_ClearReadSharedFileCompleteDelegate_Params params;
	params.ReadSharedFileCompleteDelegate = ReadSharedFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.AddReadSharedFileCompleteDelegate
// (Final, Defined, Latent, Operator)
// Parameters:
// struct FScriptDelegate         ReadSharedFileCompleteDelegate (Parm, NeedCtorLink)

void USharedCloudFileInterface::AddReadSharedFileCompleteDelegate(const struct FScriptDelegate& ReadSharedFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.AddReadSharedFileCompleteDelegate"));

	USharedCloudFileInterface_AddReadSharedFileCompleteDelegate_Params params;
	params.ReadSharedFileCompleteDelegate = ReadSharedFileCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.ReadSharedFile
// (Final, Iterator, Latent, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FString                 SharedHandle                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USharedCloudFileInterface::ReadSharedFile(const struct FString& SharedHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.ReadSharedFile"));

	USharedCloudFileInterface_ReadSharedFile_Params params;
	params.SharedHandle = SharedHandle;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SharedCloudFileInterface.OnReadSharedFileComplete
// (Final, Defined, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 SharedHandle                   (Parm, NeedCtorLink)

void USharedCloudFileInterface::STATIC_OnReadSharedFileComplete(bool bWasSuccessful, const struct FString& SharedHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.OnReadSharedFileComplete"));

	USharedCloudFileInterface_OnReadSharedFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.SharedHandle = SharedHandle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SharedCloudFileInterface.ClearSharedFile
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 SharedHandle                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USharedCloudFileInterface::ClearSharedFile(const struct FString& SharedHandle)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.ClearSharedFile"));

	USharedCloudFileInterface_ClearSharedFile_Params params;
	params.SharedHandle = SharedHandle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SharedCloudFileInterface.ClearSharedFiles
// (Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USharedCloudFileInterface::ClearSharedFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.ClearSharedFiles"));

	USharedCloudFileInterface_ClearSharedFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SharedCloudFileInterface.GetSharedFileContents
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 SharedHandle                   (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool USharedCloudFileInterface::STATIC_GetSharedFileContents(const struct FString& SharedHandle, TArray<unsigned char>* FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SharedCloudFileInterface.GetSharedFileContents"));

	USharedCloudFileInterface_GetSharedFileContents_Params params;
	params.SharedHandle = SharedHandle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileContents != nullptr)
		*FileContents = params.FileContents;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.ClearAllDelegates
// (Final, Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Operator)

void UUserCloudFileInterface::ClearAllDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearAllDelegates"));

	UUserCloudFileInterface_ClearAllDelegates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.ClearDeleteUserFileCompleteDelegate
// (Defined, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         DeleteUserFileCompleteDelegate (Parm, NeedCtorLink)

void UUserCloudFileInterface::ClearDeleteUserFileCompleteDelegate(const struct FScriptDelegate& DeleteUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearDeleteUserFileCompleteDelegate"));

	UUserCloudFileInterface_ClearDeleteUserFileCompleteDelegate_Params params;
	params.DeleteUserFileCompleteDelegate = DeleteUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.AddDeleteUserFileCompleteDelegate
// (Iterator, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         DeleteUserFileCompleteDelegate (Parm, NeedCtorLink)

void UUserCloudFileInterface::AddDeleteUserFileCompleteDelegate(const struct FScriptDelegate& DeleteUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.AddDeleteUserFileCompleteDelegate"));

	UUserCloudFileInterface_AddDeleteUserFileCompleteDelegate_Params params;
	params.DeleteUserFileCompleteDelegate = DeleteUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.DeleteUserFile
// (Final, Defined, Iterator, PreOperator, Singular, Net, Native, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           bShouldCloudDelete             (Parm)
// bool                           bShouldLocallyDelete           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::STATIC_DeleteUserFile(const struct FString& UserId, const struct FString& Filename, bool bShouldCloudDelete, bool bShouldLocallyDelete)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.DeleteUserFile"));

	UUserCloudFileInterface_DeleteUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;
	params.bShouldCloudDelete = bShouldCloudDelete;
	params.bShouldLocallyDelete = bShouldLocallyDelete;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.OnDeleteUserFileComplete
// (Final, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_OnDeleteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.OnDeleteUserFileComplete"));

	UUserCloudFileInterface_OnDeleteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.ClearWriteUserFileCompleteDelegate
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         WriteUserFileCompleteDelegate  (Parm, NeedCtorLink)

void UUserCloudFileInterface::ClearWriteUserFileCompleteDelegate(const struct FScriptDelegate& WriteUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearWriteUserFileCompleteDelegate"));

	UUserCloudFileInterface_ClearWriteUserFileCompleteDelegate_Params params;
	params.WriteUserFileCompleteDelegate = WriteUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.AddWriteUserFileCompleteDelegate
// (Iterator, Net, Operator)
// Parameters:
// struct FScriptDelegate         WriteUserFileCompleteDelegate  (Parm, NeedCtorLink)

void UUserCloudFileInterface::AddWriteUserFileCompleteDelegate(const struct FScriptDelegate& WriteUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.AddWriteUserFileCompleteDelegate"));

	UUserCloudFileInterface_AddWriteUserFileCompleteDelegate_Params params;
	params.WriteUserFileCompleteDelegate = WriteUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.WriteUserFile
// (Final, PreOperator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::WriteUserFile(const struct FString& UserId, const struct FString& Filename, TArray<unsigned char>* FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.WriteUserFile"));

	UUserCloudFileInterface_WriteUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileContents != nullptr)
		*FileContents = params.FileContents;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.OnWriteUserFileComplete
// (Final, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_OnWriteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.OnWriteUserFileComplete"));

	UUserCloudFileInterface_OnWriteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.ClearReadUserFileCompleteDelegate
// (Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadUserFileCompleteDelegate   (Parm, NeedCtorLink)

void UUserCloudFileInterface::ClearReadUserFileCompleteDelegate(const struct FScriptDelegate& ReadUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearReadUserFileCompleteDelegate"));

	UUserCloudFileInterface_ClearReadUserFileCompleteDelegate_Params params;
	params.ReadUserFileCompleteDelegate = ReadUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.AddReadUserFileCompleteDelegate
// (Final, Iterator, Latent, Operator)
// Parameters:
// struct FScriptDelegate         ReadUserFileCompleteDelegate   (Parm, NeedCtorLink)

void UUserCloudFileInterface::AddReadUserFileCompleteDelegate(const struct FScriptDelegate& ReadUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.AddReadUserFileCompleteDelegate"));

	UUserCloudFileInterface_AddReadUserFileCompleteDelegate_Params params;
	params.ReadUserFileCompleteDelegate = ReadUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.ReadUserFile
// (Final, Defined, PreOperator, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::ReadUserFile(const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ReadUserFile"));

	UUserCloudFileInterface_ReadUserFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.OnReadUserFileComplete
// (Final, Iterator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_OnReadUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.OnReadUserFileComplete"));

	UUserCloudFileInterface_OnReadUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.GetUserFileList
// (Final, Defined, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// TArray<struct FEmsFile>        UserFiles                      (Parm, OutParm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_GetUserFileList(const struct FString& UserId, TArray<struct FEmsFile>* UserFiles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.GetUserFileList"));

	UUserCloudFileInterface_GetUserFileList_Params params;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (UserFiles != nullptr)
		*UserFiles = params.UserFiles;
}


// Function Engine.UserCloudFileInterface.ClearEnumerateUserFileCompleteDelegate
// (Final, Defined, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         EnumerateUserFileCompleteDelegate (Parm, NeedCtorLink)

void UUserCloudFileInterface::ClearEnumerateUserFileCompleteDelegate(const struct FScriptDelegate& EnumerateUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearEnumerateUserFileCompleteDelegate"));

	UUserCloudFileInterface_ClearEnumerateUserFileCompleteDelegate_Params params;
	params.EnumerateUserFileCompleteDelegate = EnumerateUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.AddEnumerateUserFileCompleteDelegate
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         EnumerateUserFileCompleteDelegate (Parm, NeedCtorLink)

void UUserCloudFileInterface::AddEnumerateUserFileCompleteDelegate(const struct FScriptDelegate& EnumerateUserFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.AddEnumerateUserFileCompleteDelegate"));

	UUserCloudFileInterface_AddEnumerateUserFileCompleteDelegate_Params params;
	params.EnumerateUserFileCompleteDelegate = EnumerateUserFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.EnumerateUserFiles
// (Latent, Net, Event, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_EnumerateUserFiles(const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.EnumerateUserFiles"));

	UUserCloudFileInterface_EnumerateUserFiles_Params params;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.OnEnumerateUserFilesComplete
// (Final, Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)

void UUserCloudFileInterface::STATIC_OnEnumerateUserFilesComplete(bool bWasSuccessful, const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.OnEnumerateUserFilesComplete"));

	UUserCloudFileInterface_OnEnumerateUserFilesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileInterface.ClearFile
// (Final, Iterator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::ClearFile(const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearFile"));

	UUserCloudFileInterface_ClearFile_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.ClearFiles
// (Defined, Iterator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::ClearFiles(const struct FString& UserId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.ClearFiles"));

	UUserCloudFileInterface_ClearFiles_Params params;
	params.UserId = UserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileInterface.GetFileContents
// (Final, Defined, Iterator, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileInterface::STATIC_GetFileContents(const struct FString& UserId, const struct FString& Filename, TArray<unsigned char>* FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileInterface.GetFileContents"));

	UUserCloudFileInterface_GetFileContents_Params params;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileContents != nullptr)
		*FileContents = params.FileContents;

	return params.ReturnValue;
}


// Function Engine.OnlineSocialInterface.ClearPostLinkCompleted
// (Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PostLinkDelegate               (Parm, NeedCtorLink)

void UOnlineSocialInterface::ClearPostLinkCompleted(unsigned char LocalUserNum, const struct FScriptDelegate& PostLinkDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.ClearPostLinkCompleted"));

	UOnlineSocialInterface_ClearPostLinkCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PostLinkDelegate = PostLinkDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.AddPostLinkCompleted
// (Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PostLinkDelegate               (Parm, NeedCtorLink)

void UOnlineSocialInterface::AddPostLinkCompleted(unsigned char LocalUserNum, const struct FScriptDelegate& PostLinkDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.AddPostLinkCompleted"));

	UOnlineSocialInterface_AddPostLinkCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PostLinkDelegate = PostLinkDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.OnPostLinkCompleted
// (Iterator, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineSocialInterface::STATIC_OnPostLinkCompleted(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.OnPostLinkCompleted"));

	UOnlineSocialInterface_OnPostLinkCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.PostLink
// (Defined, Simulated, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FSocialPostLinkInfo     PostLinkInfo                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSocialInterface::PostLink(unsigned char LocalUserNum, struct FSocialPostLinkInfo* PostLinkInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.PostLink"));

	UOnlineSocialInterface_PostLink_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PostLinkInfo != nullptr)
		*PostLinkInfo = params.PostLinkInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineSocialInterface.ClearPostImageCompleted
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PostImageDelegate              (Parm, NeedCtorLink)

void UOnlineSocialInterface::ClearPostImageCompleted(unsigned char LocalUserNum, const struct FScriptDelegate& PostImageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.ClearPostImageCompleted"));

	UOnlineSocialInterface_ClearPostImageCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PostImageDelegate = PostImageDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.AddPostImageCompleted
// (Final, Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PostImageDelegate              (Parm, NeedCtorLink)

void UOnlineSocialInterface::AddPostImageCompleted(unsigned char LocalUserNum, const struct FScriptDelegate& PostImageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.AddPostImageCompleted"));

	UOnlineSocialInterface_AddPostImageCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PostImageDelegate = PostImageDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.OnPostImageCompleted
// (Final, Defined, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineSocialInterface::STATIC_OnPostImageCompleted(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.OnPostImageCompleted"));

	UOnlineSocialInterface_OnPostImageCompleted_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.PostImage
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FSocialPostImageInfo    PostImageInfo                  (Const, Parm, OutParm, NeedCtorLink)
// TArray<unsigned char>          FullImage                      (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSocialInterface::PostImage(unsigned char LocalUserNum, TArray<unsigned char> FullImage, struct FSocialPostImageInfo* PostImageInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.PostImage"));

	UOnlineSocialInterface_PostImage_Params params;
	params.LocalUserNum = LocalUserNum;
	params.FullImage = FullImage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PostImageInfo != nullptr)
		*PostImageInfo = params.PostImageInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineSocialInterface.ClearQuerySocialPostPrivilegesCompleted
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         PostPrivilegesDelegate         (Parm, NeedCtorLink)

void UOnlineSocialInterface::ClearQuerySocialPostPrivilegesCompleted(const struct FScriptDelegate& PostPrivilegesDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.ClearQuerySocialPostPrivilegesCompleted"));

	UOnlineSocialInterface_ClearQuerySocialPostPrivilegesCompleted_Params params;
	params.PostPrivilegesDelegate = PostPrivilegesDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.AddQuerySocialPostPrivilegesCompleted
// (Defined, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         PostPrivilegesDelegate         (Parm, NeedCtorLink)

void UOnlineSocialInterface::AddQuerySocialPostPrivilegesCompleted(const struct FScriptDelegate& PostPrivilegesDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.AddQuerySocialPostPrivilegesCompleted"));

	UOnlineSocialInterface_AddQuerySocialPostPrivilegesCompleted_Params params;
	params.PostPrivilegesDelegate = PostPrivilegesDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.OnQuerySocialPostPrivilegesCompleted
// (PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FSocialPostPrivileges   PostPrivileges                 (Parm)

void UOnlineSocialInterface::STATIC_OnQuerySocialPostPrivilegesCompleted(bool bWasSuccessful, const struct FSocialPostPrivileges& PostPrivileges)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.OnQuerySocialPostPrivilegesCompleted"));

	UOnlineSocialInterface_OnQuerySocialPostPrivilegesCompleted_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.PostPrivileges = PostPrivileges;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSocialInterface.QuerySocialPostPrivileges
// (Latent, NetReliable, Exec, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSocialInterface::QuerySocialPostPrivileges()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSocialInterface.QuerySocialPostPrivileges"));

	UOnlineSocialInterface_QuerySocialPostPrivileges_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.DeleteTitleFile
// (Final, Iterator, PreOperator, Singular, Net, Native, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::STATIC_DeleteTitleFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.DeleteTitleFile"));

	UOnlineTitleFileCacheInterface_DeleteTitleFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.DeleteTitleFiles
// (Defined, Iterator, PreOperator, Singular, Net, Native, Static)
// Parameters:
// float                          MaxAgeSeconds                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::STATIC_DeleteTitleFiles(float MaxAgeSeconds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.DeleteTitleFiles"));

	UOnlineTitleFileCacheInterface_DeleteTitleFiles_Params params;
	params.MaxAgeSeconds = MaxAgeSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.ClearCachedFile
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::ClearCachedFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.ClearCachedFile"));

	UOnlineTitleFileCacheInterface_ClearCachedFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.ClearCachedFiles
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::ClearCachedFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.ClearCachedFiles"));

	UOnlineTitleFileCacheInterface_ClearCachedFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.GetTitleFileLogicalName
// (Defined, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineTitleFileCacheInterface::STATIC_GetTitleFileLogicalName(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.GetTitleFileLogicalName"));

	UOnlineTitleFileCacheInterface_GetTitleFileLogicalName_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.GetTitleFileHash
// (Final, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineTitleFileCacheInterface::STATIC_GetTitleFileHash(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.GetTitleFileHash"));

	UOnlineTitleFileCacheInterface_GetTitleFileHash_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.GetTitleFileState
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineTitleFileCacheInterface::STATIC_GetTitleFileState(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.GetTitleFileState"));

	UOnlineTitleFileCacheInterface_GetTitleFileState_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.GetTitleFileContents
// (Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::STATIC_GetTitleFileContents(const struct FString& Filename, TArray<unsigned char>* FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.GetTitleFileContents"));

	UOnlineTitleFileCacheInterface_GetTitleFileContents_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileContents != nullptr)
		*FileContents = params.FileContents;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.ClearSaveTitleFileCompleteDelegate
// (PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         SaveCompleteDelegate           (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::ClearSaveTitleFileCompleteDelegate(const struct FScriptDelegate& SaveCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.ClearSaveTitleFileCompleteDelegate"));

	UOnlineTitleFileCacheInterface_ClearSaveTitleFileCompleteDelegate_Params params;
	params.SaveCompleteDelegate = SaveCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.AddSaveTitleFileCompleteDelegate
// (Defined, Latent, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         SaveCompleteDelegate           (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::AddSaveTitleFileCompleteDelegate(const struct FScriptDelegate& SaveCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.AddSaveTitleFileCompleteDelegate"));

	UOnlineTitleFileCacheInterface_AddSaveTitleFileCompleteDelegate_Params params;
	params.SaveCompleteDelegate = SaveCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.OnSaveTitleFileComplete
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::OnSaveTitleFileComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.OnSaveTitleFileComplete"));

	UOnlineTitleFileCacheInterface_OnSaveTitleFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.SaveTitleFile
// (Final, Latent, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 LogicalName                    (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::SaveTitleFile(const struct FString& Filename, const struct FString& LogicalName, TArray<unsigned char> FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.SaveTitleFile"));

	UOnlineTitleFileCacheInterface_SaveTitleFile_Params params;
	params.Filename = Filename;
	params.LogicalName = LogicalName;
	params.FileContents = FileContents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileCacheInterface.ClearLoadTitleFileCompleteDelegate
// (Final, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         LoadCompleteDelegate           (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::ClearLoadTitleFileCompleteDelegate(const struct FScriptDelegate& LoadCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.ClearLoadTitleFileCompleteDelegate"));

	UOnlineTitleFileCacheInterface_ClearLoadTitleFileCompleteDelegate_Params params;
	params.LoadCompleteDelegate = LoadCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.AddLoadTitleFileCompleteDelegate
// (Iterator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         LoadCompleteDelegate           (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::AddLoadTitleFileCompleteDelegate(const struct FScriptDelegate& LoadCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.AddLoadTitleFileCompleteDelegate"));

	UOnlineTitleFileCacheInterface_AddLoadTitleFileCompleteDelegate_Params params;
	params.LoadCompleteDelegate = LoadCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.OnLoadTitleFileComplete
// (Final, Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UOnlineTitleFileCacheInterface::OnLoadTitleFileComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.OnLoadTitleFileComplete"));

	UOnlineTitleFileCacheInterface_OnLoadTitleFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileCacheInterface.LoadTitleFile
// (PreOperator, Simulated, Native, Operator, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileCacheInterface::STATIC_LoadTitleFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileCacheInterface.LoadTitleFile"));

	UOnlineTitleFileCacheInterface_LoadTitleFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineChatInterface.NotifyTeamChange
// (Final, Singular, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// struct FQWord                  PlayerUID                      (Parm)
// unsigned char                  TeamID                         (Parm)

void UOnlineChatInterface::STATIC_NotifyTeamChange(const struct FQWord& PlayerUID, unsigned char TeamID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineChatInterface.NotifyTeamChange"));

	UOnlineChatInterface_NotifyTeamChange_Params params;
	params.PlayerUID = PlayerUID;
	params.TeamID = TeamID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineChatInterface.SendChatMessage
// (Final, Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Channel                        (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UOnlineChatInterface::SendChatMessage(int Channel, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineChatInterface.SendChatMessage"));

	UOnlineChatInterface_SendChatMessage_Params params;
	params.Channel = Channel;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineChatInterface.ClearChatMessageDelegate
// (Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ChatDelegate                   (Parm, NeedCtorLink)

void UOnlineChatInterface::ClearChatMessageDelegate(const struct FScriptDelegate& ChatDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineChatInterface.ClearChatMessageDelegate"));

	UOnlineChatInterface_ClearChatMessageDelegate_Params params;
	params.ChatDelegate = ChatDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineChatInterface.AddChatMessageDelegate
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ChatDelegate                   (Parm, NeedCtorLink)

void UOnlineChatInterface::AddChatMessageDelegate(const struct FScriptDelegate& ChatDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineChatInterface.AddChatMessageDelegate"));

	UOnlineChatInterface_AddChatMessageDelegate_Params params;
	params.ChatDelegate = ChatDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineChatInterface.OnChatMessage
// (Final, Defined, Iterator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// int                            Channel                        (Parm)
// struct FString                 Sender                         (Parm, NeedCtorLink)
// struct FString                 Message                        (Parm, NeedCtorLink)

void UOnlineChatInterface::STATIC_OnChatMessage(int Channel, const struct FString& Sender, const struct FString& Message)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineChatInterface.OnChatMessage"));

	UOnlineChatInterface_OnChatMessage_Params params;
	params.Channel = Channel;
	params.Sender = Sender;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.ClearRequestTitleFileListCompleteDelegate
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RequestTitleFileListDelegate   (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::ClearRequestTitleFileListCompleteDelegate(const struct FScriptDelegate& RequestTitleFileListDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.ClearRequestTitleFileListCompleteDelegate"));

	UOnlineTitleFileInterface_ClearRequestTitleFileListCompleteDelegate_Params params;
	params.RequestTitleFileListDelegate = RequestTitleFileListDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.AddRequestTitleFileListCompleteDelegate
// (Final, Iterator, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         RequestTitleFileListDelegate   (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::AddRequestTitleFileListCompleteDelegate(const struct FScriptDelegate& RequestTitleFileListDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.AddRequestTitleFileListCompleteDelegate"));

	UOnlineTitleFileInterface_AddRequestTitleFileListCompleteDelegate_Params params;
	params.RequestTitleFileListDelegate = RequestTitleFileListDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.OnRequestTitleFileListComplete
// (Final, Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TArray<struct FString>         FilePaths                      (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::OnRequestTitleFileListComplete(bool bWasSuccessful, TArray<struct FString> FilePaths)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.OnRequestTitleFileListComplete"));

	UOnlineTitleFileInterface_OnRequestTitleFileListComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.FilePaths = FilePaths;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.RequestTitleFileList
// (Final, Defined, Iterator, Latent, PreOperator, Net, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileInterface::RequestTitleFileList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.RequestTitleFileList"));

	UOnlineTitleFileInterface_RequestTitleFileList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.ClearDownloadedFile
// (Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileInterface::ClearDownloadedFile(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.ClearDownloadedFile"));

	UOnlineTitleFileInterface_ClearDownloadedFile_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.ClearDownloadedFiles
// (Final, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileInterface::ClearDownloadedFiles()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.ClearDownloadedFiles"));

	UOnlineTitleFileInterface_ClearDownloadedFiles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.GetTitleFileState
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineTitleFileInterface::STATIC_GetTitleFileState(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.GetTitleFileState"));

	UOnlineTitleFileInterface_GetTitleFileState_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.GetTitleFileContents
// (Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FString                 Filename                       (Parm, NeedCtorLink)
// TArray<unsigned char>          FileContents                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileInterface::STATIC_GetTitleFileContents(const struct FString& Filename, TArray<unsigned char>* FileContents)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.GetTitleFileContents"));

	UOnlineTitleFileInterface_GetTitleFileContents_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FileContents != nullptr)
		*FileContents = params.FileContents;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.ClearReadTitleFileCompleteDelegate
// (Final, Defined, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadTitleFileCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::ClearReadTitleFileCompleteDelegate(const struct FScriptDelegate& ReadTitleFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.ClearReadTitleFileCompleteDelegate"));

	UOnlineTitleFileInterface_ClearReadTitleFileCompleteDelegate_Params params;
	params.ReadTitleFileCompleteDelegate = ReadTitleFileCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.AddReadTitleFileCompleteDelegate
// (Iterator, Latent, Operator)
// Parameters:
// struct FScriptDelegate         ReadTitleFileCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::AddReadTitleFileCompleteDelegate(const struct FScriptDelegate& ReadTitleFileCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.AddReadTitleFileCompleteDelegate"));

	UOnlineTitleFileInterface_AddReadTitleFileCompleteDelegate_Params params;
	params.ReadTitleFileCompleteDelegate = ReadTitleFileCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineTitleFileInterface.ReadTitleFile
// (PreOperator, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FString                 FileToRead                     (Parm, NeedCtorLink)
// TEnumAsByte<EOnlineFileType>   FileType                       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineTitleFileInterface::ReadTitleFile(const struct FString& FileToRead, TEnumAsByte<EOnlineFileType> FileType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.ReadTitleFile"));

	UOnlineTitleFileInterface_ReadTitleFile_Params params;
	params.FileToRead = FileToRead;
	params.FileType = FileType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineTitleFileInterface.OnReadTitleFileComplete
// (Iterator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UOnlineTitleFileInterface::STATIC_OnReadTitleFileComplete(bool bWasSuccessful, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineTitleFileInterface.OnReadTitleFileComplete"));

	UOnlineTitleFileInterface_OnReadTitleFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.IsGameChatBlocked
// (Final, Defined, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::STATIC_IsGameChatBlocked(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.IsGameChatBlocked"));

	UOnlinePartyChatInterface_IsGameChatBlocked_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.SignalGameChatStopping
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePartyChatInterface::STATIC_SignalGameChatStopping()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.SignalGameChatStopping"));

	UOnlinePartyChatInterface_SignalGameChatStopping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.SignalGameChatAttempting
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePartyChatInterface::STATIC_SignalGameChatAttempting()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.SignalGameChatAttempting"));

	UOnlinePartyChatInterface_SignalGameChatAttempting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.ClearGameChatBlockedChangedDelegate
// (PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearGameChatBlockedChangedDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearGameChatBlockedChangedDelegate"));

	UOnlinePartyChatInterface_ClearGameChatBlockedChangedDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddGameChatBlockedChangedDelegate
// (Final, Defined, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddGameChatBlockedChangedDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddGameChatBlockedChangedDelegate"));

	UOnlinePartyChatInterface_AddGameChatBlockedChangedDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnGameChatBlockedChanged
// (Iterator, Latent, PreOperator, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bIsActive                      (Parm)

void UOnlinePartyChatInterface::STATIC_OnGameChatBlockedChanged(bool bIsActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnGameChatBlockedChanged"));

	UOnlinePartyChatInterface_OnGameChatBlockedChanged_Params params;
	params.bIsActive = bIsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.IsInPartyChat
// (Defined, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::STATIC_IsInPartyChat(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.IsInPartyChat"));

	UOnlinePartyChatInterface_IsInPartyChat_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.ClearPartyChatActiveChangedDelegate
// (Final, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearPartyChatActiveChangedDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearPartyChatActiveChangedDelegate"));

	UOnlinePartyChatInterface_ClearPartyChatActiveChangedDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddPartyChatActiveChangedDelegate
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddPartyChatActiveChangedDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddPartyChatActiveChangedDelegate"));

	UOnlinePartyChatInterface_AddPartyChatActiveChangedDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnPartyChatActiveChanged
// (Final, Defined, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bIsActive                      (Parm)

void UOnlinePartyChatInterface::STATIC_OnPartyChatActiveChanged(bool bIsActive)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnPartyChatActiveChanged"));

	UOnlinePartyChatInterface_OnPartyChatActiveChanged_Params params;
	params.bIsActive = bIsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.ShowCommunitySessionsUI
// (Final, Iterator, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::ShowCommunitySessionsUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ShowCommunitySessionsUI"));

	UOnlinePartyChatInterface_ShowCommunitySessionsUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.ShowVoiceChannelUI
// (Final, Latent, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::ShowVoiceChannelUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ShowVoiceChannelUI"));

	UOnlinePartyChatInterface_ShowVoiceChannelUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.ShowPartyUI
// (PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::ShowPartyUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ShowPartyUI"));

	UOnlinePartyChatInterface_ShowPartyUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.GetPartyBandwidth
// (Final, Defined, Iterator, Latent, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePartyChatInterface::STATIC_GetPartyBandwidth()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.GetPartyBandwidth"));

	UOnlinePartyChatInterface_GetPartyBandwidth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.SetPartyMemberCustomData
// (Final, Iterator, Latent, Singular, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            Data1                          (Parm)
// int                            Data2                          (Parm)
// int                            Data3                          (Parm)
// int                            Data4                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::SetPartyMemberCustomData(unsigned char LocalUserNum, int Data1, int Data2, int Data3, int Data4)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.SetPartyMemberCustomData"));

	UOnlinePartyChatInterface_SetPartyMemberCustomData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Data1 = Data1;
	params.Data2 = Data2;
	params.Data3 = Data3;
	params.Data4 = Data4;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.ClearPartyMembersInfoChangedDelegate
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PartyMembersInfoChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearPartyMembersInfoChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& PartyMembersInfoChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearPartyMembersInfoChangedDelegate"));

	UOnlinePartyChatInterface_ClearPartyMembersInfoChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PartyMembersInfoChangedDelegate = PartyMembersInfoChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddPartyMembersInfoChangedDelegate
// (Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PartyMembersInfoChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddPartyMembersInfoChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& PartyMembersInfoChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddPartyMembersInfoChangedDelegate"));

	UOnlinePartyChatInterface_AddPartyMembersInfoChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PartyMembersInfoChangedDelegate = PartyMembersInfoChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnPartyMembersInfoChanged
// (Final, Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// int                            CustomData1                    (Parm)
// int                            CustomData2                    (Parm)
// int                            CustomData3                    (Parm)
// int                            CustomData4                    (Parm)

void UOnlinePartyChatInterface::STATIC_OnPartyMembersInfoChanged(const struct FString& PlayerName, const struct FUniqueNetId& PlayerID, int CustomData1, int CustomData2, int CustomData3, int CustomData4)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnPartyMembersInfoChanged"));

	UOnlinePartyChatInterface_OnPartyMembersInfoChanged_Params params;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;
	params.CustomData1 = CustomData1;
	params.CustomData2 = CustomData2;
	params.CustomData3 = CustomData3;
	params.CustomData4 = CustomData4;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.ClearReservedPartyMemberListChangedDelegate
// (Final, Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReservedPartyMemberListChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearReservedPartyMemberListChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReservedPartyMemberListChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearReservedPartyMemberListChangedDelegate"));

	UOnlinePartyChatInterface_ClearReservedPartyMemberListChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReservedPartyMemberListChangedDelegate = ReservedPartyMemberListChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddReservedPartyMemberListChangedDelegate
// (Defined, Iterator, PreOperator, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReservedPartyMemberListChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddReservedPartyMemberListChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReservedPartyMemberListChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddReservedPartyMemberListChangedDelegate"));

	UOnlinePartyChatInterface_AddReservedPartyMemberListChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReservedPartyMemberListChangedDelegate = ReservedPartyMemberListChangedDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnReservedPartyMemberListChanged
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bJoinedOrLeft                  (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)

void UOnlinePartyChatInterface::STATIC_OnReservedPartyMemberListChanged(bool bJoinedOrLeft, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnReservedPartyMemberListChanged"));

	UOnlinePartyChatInterface_OnReservedPartyMemberListChanged_Params params;
	params.bJoinedOrLeft = bJoinedOrLeft;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.ClearPartyMemberListChangedDelegate
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PartyMemberListChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearPartyMemberListChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& PartyMemberListChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearPartyMemberListChangedDelegate"));

	UOnlinePartyChatInterface_ClearPartyMemberListChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PartyMemberListChangedDelegate = PartyMemberListChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddPartyMemberListChangedDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         PartyMemberListChangedDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddPartyMemberListChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& PartyMemberListChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddPartyMemberListChangedDelegate"));

	UOnlinePartyChatInterface_AddPartyMemberListChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PartyMemberListChangedDelegate = PartyMemberListChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnPartyMemberListChanged
// (Iterator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bJoinedOrLeft                  (Parm)
// struct FString                 PlayerName                     (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)

void UOnlinePartyChatInterface::STATIC_OnPartyMemberListChanged(bool bJoinedOrLeft, const struct FString& PlayerName, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnPartyMemberListChanged"));

	UOnlinePartyChatInterface_OnPartyMemberListChanged_Params params;
	params.bJoinedOrLeft = bJoinedOrLeft;
	params.PlayerName = PlayerName;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.GetPartyMemberInformation
// (Defined, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            MemberId                       (Parm)
// struct FOnlinePartyMember      PartyMember                    (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::STATIC_GetPartyMemberInformation(const struct FUniqueNetId& MemberId, struct FOnlinePartyMember* PartyMember)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.GetPartyMemberInformation"));

	UOnlinePartyChatInterface_GetPartyMemberInformation_Params params;
	params.MemberId = MemberId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PartyMember != nullptr)
		*PartyMember = params.PartyMember;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.GetPartyMembersInformation
// (Final, Defined, PreOperator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FOnlinePartyMember> PartyMembers                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::STATIC_GetPartyMembersInformation(TArray<struct FOnlinePartyMember>* PartyMembers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.GetPartyMembersInformation"));

	UOnlinePartyChatInterface_GetPartyMembersInformation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PartyMembers != nullptr)
		*PartyMembers = params.PartyMembers;

	return params.ReturnValue;
}


// Function Engine.OnlinePartyChatInterface.ClearSendPartyGameInvitesCompleteDelegate
// (Final, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         SendPartyGameInvitesCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::ClearSendPartyGameInvitesCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& SendPartyGameInvitesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.ClearSendPartyGameInvitesCompleteDelegate"));

	UOnlinePartyChatInterface_ClearSendPartyGameInvitesCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SendPartyGameInvitesCompleteDelegate = SendPartyGameInvitesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.AddSendPartyGameInvitesCompleteDelegate
// (Iterator, Latent, PreOperator, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         SendPartyGameInvitesCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePartyChatInterface::AddSendPartyGameInvitesCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& SendPartyGameInvitesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.AddSendPartyGameInvitesCompleteDelegate"));

	UOnlinePartyChatInterface_AddSendPartyGameInvitesCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SendPartyGameInvitesCompleteDelegate = SendPartyGameInvitesCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.OnSendPartyGameInvitesComplete
// (Final, Simulated, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePartyChatInterface::STATIC_OnSendPartyGameInvitesComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.OnSendPartyGameInvitesComplete"));

	UOnlinePartyChatInterface_OnSendPartyGameInvitesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePartyChatInterface.SendPartyGameInvites
// (Defined, Iterator, Latent, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePartyChatInterface::SendPartyGameInvites(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePartyChatInterface.SendPartyGameInvites"));

	UOnlinePartyChatInterface_SendPartyGameInvites_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineNewsInterface.GetNews
// (Final, Iterator, Net, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EOnlineNewsType>   NewsType                       (Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineNewsInterface::STATIC_GetNews(unsigned char LocalUserNum, TEnumAsByte<EOnlineNewsType> NewsType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineNewsInterface.GetNews"));

	UOnlineNewsInterface_GetNews_Params params;
	params.LocalUserNum = LocalUserNum;
	params.NewsType = NewsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineNewsInterface.ClearReadNewsCompletedDelegate
// (Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadNewsDelegate               (Parm, NeedCtorLink)

void UOnlineNewsInterface::ClearReadNewsCompletedDelegate(const struct FScriptDelegate& ReadNewsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineNewsInterface.ClearReadNewsCompletedDelegate"));

	UOnlineNewsInterface_ClearReadNewsCompletedDelegate_Params params;
	params.ReadNewsDelegate = ReadNewsDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineNewsInterface.AddReadNewsCompletedDelegate
// (Final, Defined, Operator)
// Parameters:
// struct FScriptDelegate         ReadNewsDelegate               (Parm, NeedCtorLink)

void UOnlineNewsInterface::AddReadNewsCompletedDelegate(const struct FScriptDelegate& ReadNewsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineNewsInterface.AddReadNewsCompletedDelegate"));

	UOnlineNewsInterface_AddReadNewsCompletedDelegate_Params params;
	params.ReadNewsDelegate = ReadNewsDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineNewsInterface.OnReadNewsCompleted
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TEnumAsByte<EOnlineNewsType>   NewsType                       (Parm)

void UOnlineNewsInterface::OnReadNewsCompleted(bool bWasSuccessful, TEnumAsByte<EOnlineNewsType> NewsType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineNewsInterface.OnReadNewsCompleted"));

	UOnlineNewsInterface_OnReadNewsCompleted_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.NewsType = NewsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineNewsInterface.ReadNews
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EOnlineNewsType>   NewsType                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineNewsInterface::ReadNews(unsigned char LocalUserNum, TEnumAsByte<EOnlineNewsType> NewsType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineNewsInterface.ReadNews"));

	UOnlineNewsInterface_ReadNews_Params params;
	params.LocalUserNum = LocalUserNum;
	params.NewsType = NewsType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.SendPlayerSessionResume
// (Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 MultiplayerCorrelationId       (Parm, NeedCtorLink)
// int                            GameplayModeId                 (Parm)
// int                            DifficultyLevelId              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::SendPlayerSessionResume(unsigned char LocalUserNum, const struct FString& MultiplayerCorrelationId, int GameplayModeId, int DifficultyLevelId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.SendPlayerSessionResume"));

	UOnlineStatsInterface_SendPlayerSessionResume_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MultiplayerCorrelationId = MultiplayerCorrelationId;
	params.GameplayModeId = GameplayModeId;
	params.DifficultyLevelId = DifficultyLevelId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.SendPlayerSessionPause
// (Final, Defined, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 MultiplayerCorrelationId       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::SendPlayerSessionPause(unsigned char LocalUserNum, const struct FString& MultiplayerCorrelationId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.SendPlayerSessionPause"));

	UOnlineStatsInterface_SendPlayerSessionPause_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MultiplayerCorrelationId = MultiplayerCorrelationId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.SendPlayerSessionEnd
// (Defined, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 MultiplayerCorrelationId       (Parm, NeedCtorLink)
// int                            GameplayModeId                 (Parm)
// int                            DifficultyLevelId              (Parm)
// int                            ExitStatusId                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::SendPlayerSessionEnd(unsigned char LocalUserNum, const struct FString& MultiplayerCorrelationId, int GameplayModeId, int DifficultyLevelId, int ExitStatusId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.SendPlayerSessionEnd"));

	UOnlineStatsInterface_SendPlayerSessionEnd_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MultiplayerCorrelationId = MultiplayerCorrelationId;
	params.GameplayModeId = GameplayModeId;
	params.DifficultyLevelId = DifficultyLevelId;
	params.ExitStatusId = ExitStatusId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.SendPlayerSessionStart
// (Final, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 MultiplayerCorrelationId       (Parm, NeedCtorLink)
// int                            GameplayModeId                 (Parm)
// int                            DifficultyLevelId              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::SendPlayerSessionStart(unsigned char LocalUserNum, const struct FString& MultiplayerCorrelationId, int GameplayModeId, int DifficultyLevelId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.SendPlayerSessionStart"));

	UOnlineStatsInterface_SendPlayerSessionStart_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MultiplayerCorrelationId = MultiplayerCorrelationId;
	params.GameplayModeId = GameplayModeId;
	params.DifficultyLevelId = DifficultyLevelId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.UnsubscribeToStatisticEvent
// (Final, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerNetId                    (Parm)
// struct FName                   StatName                       (Parm)

void UOnlineStatsInterface::UnsubscribeToStatisticEvent(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerNetId, const struct FName& StatName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.UnsubscribeToStatisticEvent"));

	UOnlineStatsInterface_UnsubscribeToStatisticEvent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerNetId = PlayerNetId;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.SubscribeToStatisticEvent
// (Iterator, Singular, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerNetId                    (Parm)
// struct FName                   StatName                       (Parm)
// struct FScriptDelegate         EventDelegate                  (Parm, NeedCtorLink)

void UOnlineStatsInterface::SubscribeToStatisticEvent(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerNetId, const struct FName& StatName, const struct FScriptDelegate& EventDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.SubscribeToStatisticEvent"));

	UOnlineStatsInterface_SubscribeToStatisticEvent_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerNetId = PlayerNetId;
	params.StatName = StatName;
	params.EventDelegate = EventDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.OnStatisticChanged
// (Defined, Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            PlayerNetId                    (Parm)
// struct FName                   StatName                       (Parm)
// struct FString                 NewStatValue                   (Parm, NeedCtorLink)

void UOnlineStatsInterface::STATIC_OnStatisticChanged(const struct FUniqueNetId& PlayerNetId, const struct FName& StatName, const struct FString& NewStatValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.OnStatisticChanged"));

	UOnlineStatsInterface_OnStatisticChanged_Params params;
	params.PlayerNetId = PlayerNetId;
	params.StatName = StatName;
	params.NewStatValue = NewStatValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.CalcAggregateSkill
// (PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Operator)
// Parameters:
// TArray<struct FDouble>         Mus                            (Parm, NeedCtorLink)
// TArray<struct FDouble>         Sigmas                         (Parm, NeedCtorLink)
// struct FDouble                 OutAggregateMu                 (Parm, OutParm)
// struct FDouble                 OutAggregateSigma              (Parm, OutParm)

void UOnlineStatsInterface::CalcAggregateSkill(TArray<struct FDouble> Mus, TArray<struct FDouble> Sigmas, struct FDouble* OutAggregateMu, struct FDouble* OutAggregateSigma)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.CalcAggregateSkill"));

	UOnlineStatsInterface_CalcAggregateSkill_Params params;
	params.Mus = Mus;
	params.Sigmas = Sigmas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAggregateMu != nullptr)
		*OutAggregateMu = params.OutAggregateMu;
	if (OutAggregateSigma != nullptr)
		*OutAggregateSigma = params.OutAggregateSigma;
}


// Function Engine.OnlineStatsInterface.RegisterStatGuid
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// struct FString                 ClientStatGuid                 (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::RegisterStatGuid(const struct FUniqueNetId& PlayerID, struct FString* ClientStatGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.RegisterStatGuid"));

	UOnlineStatsInterface_RegisterStatGuid_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ClientStatGuid != nullptr)
		*ClientStatGuid = params.ClientStatGuid;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.GetClientStatGuid
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineStatsInterface::STATIC_GetClientStatGuid()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.GetClientStatGuid"));

	UOnlineStatsInterface_GetClientStatGuid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ClearRegisterHostStatGuidCompleteDelegateDelegate
// (Final, Defined, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RegisterHostStatGuidCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::ClearRegisterHostStatGuidCompleteDelegateDelegate(const struct FScriptDelegate& RegisterHostStatGuidCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ClearRegisterHostStatGuidCompleteDelegateDelegate"));

	UOnlineStatsInterface_ClearRegisterHostStatGuidCompleteDelegateDelegate_Params params;
	params.RegisterHostStatGuidCompleteDelegate = RegisterHostStatGuidCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.AddRegisterHostStatGuidCompleteDelegate
// (Defined, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         RegisterHostStatGuidCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::AddRegisterHostStatGuidCompleteDelegate(const struct FScriptDelegate& RegisterHostStatGuidCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.AddRegisterHostStatGuidCompleteDelegate"));

	UOnlineStatsInterface_AddRegisterHostStatGuidCompleteDelegate_Params params;
	params.RegisterHostStatGuidCompleteDelegate = RegisterHostStatGuidCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.OnRegisterHostStatGuidComplete
// (Latent, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineStatsInterface::STATIC_OnRegisterHostStatGuidComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.OnRegisterHostStatGuidComplete"));

	UOnlineStatsInterface_OnRegisterHostStatGuidComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.RegisterHostStatGuid
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FString                 HostStatGuid                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::RegisterHostStatGuid(struct FString* HostStatGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.RegisterHostStatGuid"));

	UOnlineStatsInterface_RegisterHostStatGuid_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HostStatGuid != nullptr)
		*HostStatGuid = params.HostStatGuid;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.GetHostStatGuid
// (Final, Iterator, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineStatsInterface::STATIC_GetHostStatGuid()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.GetHostStatGuid"));

	UOnlineStatsInterface_GetHostStatGuid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.WriteOnlinePlayerScores
// (Final, Iterator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// int                            LeaderboardId                  (Parm)
// TArray<struct FOnlinePlayerScore> PlayerScores                   (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::WriteOnlinePlayerScores(const struct FName& SessionName, int LeaderboardId, TArray<struct FOnlinePlayerScore>* PlayerScores)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.WriteOnlinePlayerScores"));

	UOnlineStatsInterface_WriteOnlinePlayerScores_Params params;
	params.SessionName = SessionName;
	params.LeaderboardId = LeaderboardId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlayerScores != nullptr)
		*PlayerScores = params.PlayerScores;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ClearFlushOnlineStatsCompleteDelegate
// (Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         FlushOnlineStatsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::ClearFlushOnlineStatsCompleteDelegate(const struct FScriptDelegate& FlushOnlineStatsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ClearFlushOnlineStatsCompleteDelegate"));

	UOnlineStatsInterface_ClearFlushOnlineStatsCompleteDelegate_Params params;
	params.FlushOnlineStatsCompleteDelegate = FlushOnlineStatsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.AddFlushOnlineStatsCompleteDelegate
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         FlushOnlineStatsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::AddFlushOnlineStatsCompleteDelegate(const struct FScriptDelegate& FlushOnlineStatsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.AddFlushOnlineStatsCompleteDelegate"));

	UOnlineStatsInterface_AddFlushOnlineStatsCompleteDelegate_Params params;
	params.FlushOnlineStatsCompleteDelegate = FlushOnlineStatsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.OnFlushOnlineStatsComplete
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineStatsInterface::STATIC_OnFlushOnlineStatsComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.OnFlushOnlineStatsComplete"));

	UOnlineStatsInterface_OnFlushOnlineStatsComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.FlushOnlineStats
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::STATIC_FlushOnlineStats(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.FlushOnlineStats"));

	UOnlineStatsInterface_FlushOnlineStats_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.WriteOnlineStats
// (Defined, Iterator, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            Player                         (Parm)
// class UOnlineStatsWrite*       StatsWrite                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::WriteOnlineStats(const struct FName& SessionName, const struct FUniqueNetId& Player, class UOnlineStatsWrite* StatsWrite)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.WriteOnlineStats"));

	UOnlineStatsInterface_WriteOnlineStats_Params params;
	params.SessionName = SessionName;
	params.Player = Player;
	params.StatsWrite = StatsWrite;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.FreeStats
// (Final, Iterator, Latent, PreOperator, Singular, Native, Event, Static)
// Parameters:
// class UOnlineStatsRead*        StatsRead                      (Parm)

void UOnlineStatsInterface::STATIC_FreeStats(class UOnlineStatsRead* StatsRead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.FreeStats"));

	UOnlineStatsInterface_FreeStats_Params params;
	params.StatsRead = StatsRead;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.ClearReadOnlineStatsCompleteDelegate
// (Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadOnlineStatsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::ClearReadOnlineStatsCompleteDelegate(const struct FScriptDelegate& ReadOnlineStatsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ClearReadOnlineStatsCompleteDelegate"));

	UOnlineStatsInterface_ClearReadOnlineStatsCompleteDelegate_Params params;
	params.ReadOnlineStatsCompleteDelegate = ReadOnlineStatsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.AddReadOnlineStatsCompleteDelegate
// (Final, Iterator, Operator)
// Parameters:
// struct FScriptDelegate         ReadOnlineStatsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineStatsInterface::AddReadOnlineStatsCompleteDelegate(const struct FScriptDelegate& ReadOnlineStatsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.AddReadOnlineStatsCompleteDelegate"));

	UOnlineStatsInterface_AddReadOnlineStatsCompleteDelegate_Params params;
	params.ReadOnlineStatsCompleteDelegate = ReadOnlineStatsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.OnReadOnlineStatsComplete
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineStatsInterface::STATIC_OnReadOnlineStatsComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.OnReadOnlineStatsComplete"));

	UOnlineStatsInterface_OnReadOnlineStatsComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineStatsInterface.ReadOnlineStatsByRankAroundPlayer
// (Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// int                            NumRows                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::ReadOnlineStatsByRankAroundPlayer(unsigned char LocalUserNum, class UOnlineStatsRead* StatsRead, int NumRows)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ReadOnlineStatsByRankAroundPlayer"));

	UOnlineStatsInterface_ReadOnlineStatsByRankAroundPlayer_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatsRead = StatsRead;
	params.NumRows = NumRows;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ReadOnlineStatsByRank
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// int                            StartIndex                     (OptionalParm, Parm)
// int                            NumToRead                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::ReadOnlineStatsByRank(unsigned char LocalUserNum, class UOnlineStatsRead* StatsRead, int StartIndex, int NumToRead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ReadOnlineStatsByRank"));

	UOnlineStatsInterface_ReadOnlineStatsByRank_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatsRead = StatsRead;
	params.StartIndex = StartIndex;
	params.NumToRead = NumToRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ReadOnlineStatForFriends
// (Final, Defined, Latent, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// bool                           FavoriteFriendsOnly            (OptionalParm, Parm)
// int                            NumToRead                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::ReadOnlineStatForFriends(unsigned char LocalUserNum, class UOnlineStatsRead* StatsRead, bool FavoriteFriendsOnly, int NumToRead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ReadOnlineStatForFriends"));

	UOnlineStatsInterface_ReadOnlineStatForFriends_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatsRead = StatsRead;
	params.FavoriteFriendsOnly = FavoriteFriendsOnly;
	params.NumToRead = NumToRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ReadOnlineStats
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::ReadOnlineStats(unsigned char LocalUserNum, class UOnlineStatsRead* StatsRead, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ReadOnlineStats"));

	UOnlineStatsInterface_ReadOnlineStats_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatsRead = StatsRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlineStatsInterface.ReadOnlineStatsForPlayer
// (Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineStatsInterface::ReadOnlineStatsForPlayer(unsigned char LocalUserNum, class UOnlineStatsRead* StatsRead)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineStatsInterface.ReadOnlineStatsForPlayer"));

	UOnlineStatsInterface_ReadOnlineStatsForPlayer_Params params;
	params.LocalUserNum = LocalUserNum;
	params.StatsRead = StatsRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.UnmuteAll
// (Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::UnmuteAll(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.UnmuteAll"));

	UOnlineVoiceInterface_UnmuteAll_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.MuteAll
// (Iterator, PreOperator, Singular, Simulated, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bAllowFriends                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_MuteAll(unsigned char LocalUserNum, bool bAllowFriends)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.MuteAll"));

	UOnlineVoiceInterface_MuteAll_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bAllowFriends = bAllowFriends;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.SetSpeechRecognitionObject
// (Final, Iterator, Latent, PreOperator, Singular, Net, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// class USpeechRecognition*      SpeechRecogObj                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::SetSpeechRecognitionObject(unsigned char LocalUserNum, class USpeechRecognition* SpeechRecogObj)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.SetSpeechRecognitionObject"));

	UOnlineVoiceInterface_SetSpeechRecognitionObject_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SpeechRecogObj = SpeechRecogObj;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.SelectVocabulary
// (Final, Iterator, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            VocabularyId                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::SelectVocabulary(unsigned char LocalUserNum, int VocabularyId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.SelectVocabulary"));

	UOnlineVoiceInterface_SelectVocabulary_Params params;
	params.LocalUserNum = LocalUserNum;
	params.VocabularyId = VocabularyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.ClearRecognitionCompleteDelegate
// (Final, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         RecognitionDelegate            (Parm, NeedCtorLink)

void UOnlineVoiceInterface::ClearRecognitionCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& RecognitionDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.ClearRecognitionCompleteDelegate"));

	UOnlineVoiceInterface_ClearRecognitionCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RecognitionDelegate = RecognitionDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.AddRecognitionCompleteDelegate
// (PreOperator, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         RecognitionDelegate            (Parm, NeedCtorLink)

void UOnlineVoiceInterface::AddRecognitionCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& RecognitionDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.AddRecognitionCompleteDelegate"));

	UOnlineVoiceInterface_AddRecognitionCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.RecognitionDelegate = RecognitionDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.OnRecognitionComplete
// (Final, Defined, Iterator, Exec, Native, Event, Static)

void UOnlineVoiceInterface::STATIC_OnRecognitionComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.OnRecognitionComplete"));

	UOnlineVoiceInterface_OnRecognitionComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.GetRecognitionResults
// (Defined, Iterator, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FSpeechRecognizedWord> Words                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_GetRecognitionResults(unsigned char LocalUserNum, TArray<struct FSpeechRecognizedWord>* Words)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.GetRecognitionResults"));

	UOnlineVoiceInterface_GetRecognitionResults_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Words != nullptr)
		*Words = params.Words;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.StopSpeechRecognition
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::StopSpeechRecognition(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.StopSpeechRecognition"));

	UOnlineVoiceInterface_StopSpeechRecognition_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.StartSpeechRecognition
// (PreOperator, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::StartSpeechRecognition(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.StartSpeechRecognition"));

	UOnlineVoiceInterface_StartSpeechRecognition_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.StopNetworkedVoice
// (Latent, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineVoiceInterface::StopNetworkedVoice(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.StopNetworkedVoice"));

	UOnlineVoiceInterface_StopNetworkedVoice_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.StartNetworkedVoice
// (Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineVoiceInterface::StartNetworkedVoice(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.StartNetworkedVoice"));

	UOnlineVoiceInterface_StartNetworkedVoice_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.ClearPlayerTalkingDelegate
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         TalkerDelegate                 (Parm, NeedCtorLink)

void UOnlineVoiceInterface::ClearPlayerTalkingDelegate(const struct FScriptDelegate& TalkerDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.ClearPlayerTalkingDelegate"));

	UOnlineVoiceInterface_ClearPlayerTalkingDelegate_Params params;
	params.TalkerDelegate = TalkerDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.AddPlayerTalkingDelegate
// (Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         TalkerDelegate                 (Parm, NeedCtorLink)

void UOnlineVoiceInterface::AddPlayerTalkingDelegate(const struct FScriptDelegate& TalkerDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.AddPlayerTalkingDelegate"));

	UOnlineVoiceInterface_AddPlayerTalkingDelegate_Params params;
	params.TalkerDelegate = TalkerDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.OnPlayerTalkingStateChange
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            Player                         (Parm)
// bool                           bIsTalking                     (Parm)

void UOnlineVoiceInterface::STATIC_OnPlayerTalkingStateChange(const struct FUniqueNetId& Player, bool bIsTalking)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.OnPlayerTalkingStateChange"));

	UOnlineVoiceInterface_OnPlayerTalkingStateChange_Params params;
	params.Player = Player;
	params.bIsTalking = bIsTalking;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineVoiceInterface.IsTalkerMuted
// (Final, Iterator, Simulated, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            ConsoleId                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_IsTalkerMuted(const struct FUniqueNetId& ConsoleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.IsTalkerMuted"));

	UOnlineVoiceInterface_IsTalkerMuted_Params params;
	params.ConsoleId = ConsoleId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.UnmuteRemoteTalker
// (Final, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bIsSystemWide                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::UnmuteRemoteTalker(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID, bool bIsSystemWide)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.UnmuteRemoteTalker"));

	UOnlineVoiceInterface_UnmuteRemoteTalker_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;
	params.bIsSystemWide = bIsSystemWide;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.MuteRemoteTalker
// (Defined, Iterator, PreOperator, Singular, Simulated, Event, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bIsSystemWide                  (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_MuteRemoteTalker(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID, bool bIsSystemWide)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.MuteRemoteTalker"));

	UOnlineVoiceInterface_MuteRemoteTalker_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;
	params.bIsSystemWide = bIsSystemWide;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.UpdatePlayerMuteSetting
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           PlayerMuteSetting              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::UpdatePlayerMuteSetting(bool PlayerMuteSetting)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.UpdatePlayerMuteSetting"));

	UOnlineVoiceInterface_UpdatePlayerMuteSetting_Params params;
	params.PlayerMuteSetting = PlayerMuteSetting;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.SetRemoteTalkerPriority
// (Iterator, PreOperator, Net, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// int                            Priority                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::SetRemoteTalkerPriority(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID, int Priority)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.SetRemoteTalkerPriority"));

	UOnlineVoiceInterface_SetRemoteTalkerPriority_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;
	params.Priority = Priority;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.IsHeadsetPresent
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_IsHeadsetPresent(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.IsHeadsetPresent"));

	UOnlineVoiceInterface_IsHeadsetPresent_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.IsRemotePlayerTalking
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_IsRemotePlayerTalking(const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.IsRemotePlayerTalking"));

	UOnlineVoiceInterface_IsRemotePlayerTalking_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.IsLocalPlayerTalking
// (Final, PreOperator, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::STATIC_IsLocalPlayerTalking(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.IsLocalPlayerTalking"));

	UOnlineVoiceInterface_IsLocalPlayerTalking_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.UnregisterRemoteTalker
// (PreOperator, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::UnregisterRemoteTalker(const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.UnregisterRemoteTalker"));

	UOnlineVoiceInterface_UnregisterRemoteTalker_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.RegisterRemoteTalker
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::RegisterRemoteTalker(const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.RegisterRemoteTalker"));

	UOnlineVoiceInterface_RegisterRemoteTalker_Params params;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.UnregisterLocalTalker
// (Defined, Iterator, Latent, PreOperator, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// unsigned char                  ChannelIndex                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::UnregisterLocalTalker(unsigned char LocalUserNum, unsigned char ChannelIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.UnregisterLocalTalker"));

	UOnlineVoiceInterface_UnregisterLocalTalker_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ChannelIndex = ChannelIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineVoiceInterface.RegisterLocalTalker
// (Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// unsigned char                  ChannelIndex                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineVoiceInterface::RegisterLocalTalker(unsigned char LocalUserNum, unsigned char ChannelIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineVoiceInterface.RegisterLocalTalker"));

	UOnlineVoiceInterface_RegisterLocalTalker_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ChannelIndex = ChannelIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearCachedSaveGames
// (Final, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ClearCachedSaveGames(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearCachedSaveGames"));

	UOnlineContentInterface_ClearCachedSaveGames_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearDeleteSaveGameDataCompleteDelegate
// (Final, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         DeleteSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearDeleteSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& DeleteSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearDeleteSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_ClearDeleteSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeleteSaveGameDataCompleteDelegate = DeleteSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddDeleteSaveGameDataCompleteDelegate
// (Final, Defined, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         DeleteSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::AddDeleteSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& DeleteSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddDeleteSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_AddDeleteSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeleteSaveGameDataCompleteDelegate = DeleteSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnDeleteSaveGameDataComplete
// (Defined, Iterator, Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)

void UOnlineContentInterface::STATIC_OnDeleteSaveGameDataComplete(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnDeleteSaveGameDataComplete"));

	UOnlineContentInterface_OnDeleteSaveGameDataComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.DeleteSaveGameData
// (Final, Defined, PreOperator, Singular, Net, Native, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::STATIC_DeleteSaveGameData(unsigned char LocalUserNum, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.DeleteSaveGameData"));

	UOnlineContentInterface_DeleteSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearWriteSaveGameDataCompleteDelegate
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WriteSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearWriteSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WriteSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearWriteSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_ClearWriteSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WriteSaveGameDataCompleteDelegate = WriteSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddWriteSaveGameDataCompleteDelegate
// (Defined, Net, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         WriteSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::AddWriteSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& WriteSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddWriteSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_AddWriteSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.WriteSaveGameDataCompleteDelegate = WriteSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnWriteSaveGameDataComplete
// (Final, Latent, Singular, Simulated, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)

void UOnlineContentInterface::STATIC_OnWriteSaveGameDataComplete(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnWriteSaveGameDataComplete"));

	UOnlineContentInterface_OnWriteSaveGameDataComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.WriteSaveGameData
// (Iterator, Latent, NetReliable, Simulated, Operator, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// TArray<unsigned char>          SaveGameData                   (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 Title                          (OptionalParm, Parm, NeedCtorLink)
// struct FString                 SubTitle                       (OptionalParm, Parm, NeedCtorLink)
// struct FString                 Description                    (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::WriteSaveGameData(unsigned char LocalUserNum, const struct FString& SaveFileName, const struct FString& Title, const struct FString& SubTitle, const struct FString& Description, TArray<unsigned char>* SaveGameData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.WriteSaveGameData"));

	UOnlineContentInterface_WriteSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;
	params.Title = Title;
	params.SubTitle = SubTitle;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SaveGameData != nullptr)
		*SaveGameData = params.SaveGameData;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearReadSaveGameDataCompleteDelegate
// (Final, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearReadSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearReadSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_ClearReadSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadSaveGameDataCompleteDelegate = ReadSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddReadSaveGameDataCompleteDelegate
// (Defined, Latent, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::AddReadSaveGameDataCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddReadSaveGameDataCompleteDelegate"));

	UOnlineContentInterface_AddReadSaveGameDataCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadSaveGameDataCompleteDelegate = ReadSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnReadSaveGameDataComplete
// (Latent, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)

void UOnlineContentInterface::STATIC_OnReadSaveGameDataComplete(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnReadSaveGameDataComplete"));

	UOnlineContentInterface_OnReadSaveGameDataComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.GetSaveGameData
// (Defined, Latent, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// unsigned char                  bIsValid                       (Parm, OutParm)
// TArray<unsigned char>          SaveGameData                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::STATIC_GetSaveGameData(unsigned char LocalUserNum, const struct FString& SaveFileName, unsigned char* bIsValid, TArray<unsigned char>* SaveGameData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.GetSaveGameData"));

	UOnlineContentInterface_GetSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bIsValid != nullptr)
		*bIsValid = params.bIsValid;
	if (SaveGameData != nullptr)
		*SaveGameData = params.SaveGameData;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ReadSaveGameData
// (Final, Defined, Latent, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ReadSaveGameData(unsigned char LocalUserNum, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ReadSaveGameData"));

	UOnlineContentInterface_ReadSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.GetAvailableDownloadCounts
// (Iterator, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            NewDownloads                   (Parm, OutParm)
// int                            TotalDownloads                 (Parm, OutParm)

void UOnlineContentInterface::STATIC_GetAvailableDownloadCounts(unsigned char LocalUserNum, int* NewDownloads, int* TotalDownloads)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.GetAvailableDownloadCounts"));

	UOnlineContentInterface_GetAvailableDownloadCounts_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewDownloads != nullptr)
		*NewDownloads = params.NewDownloads;
	if (TotalDownloads != nullptr)
		*TotalDownloads = params.TotalDownloads;
}


// Function Engine.OnlineContentInterface.ClearQueryAvailableDownloadsComplete
// (Final, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         QueryDownloadsDelegate         (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearQueryAvailableDownloadsComplete(unsigned char LocalUserNum, const struct FScriptDelegate& QueryDownloadsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearQueryAvailableDownloadsComplete"));

	UOnlineContentInterface_ClearQueryAvailableDownloadsComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.QueryDownloadsDelegate = QueryDownloadsDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddQueryAvailableDownloadsComplete
// (PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         QueryDownloadsDelegate         (Parm, NeedCtorLink)

void UOnlineContentInterface::AddQueryAvailableDownloadsComplete(unsigned char LocalUserNum, const struct FScriptDelegate& QueryDownloadsDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddQueryAvailableDownloadsComplete"));

	UOnlineContentInterface_AddQueryAvailableDownloadsComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.QueryDownloadsDelegate = QueryDownloadsDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnQueryAvailableDownloadsComplete
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineContentInterface::STATIC_OnQueryAvailableDownloadsComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnQueryAvailableDownloadsComplete"));

	UOnlineContentInterface_OnQueryAvailableDownloadsComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.QueryAvailableDownloads
// (Defined, NetReliable, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            CategoryMask                   (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::QueryAvailableDownloads(unsigned char LocalUserNum, int CategoryMask)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.QueryAvailableDownloads"));

	UOnlineContentInterface_QueryAvailableDownloads_Params params;
	params.LocalUserNum = LocalUserNum;
	params.CategoryMask = CategoryMask;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearCrossTitleSaveGames
// (Defined, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ClearCrossTitleSaveGames(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearCrossTitleSaveGames"));

	UOnlineContentInterface_ClearCrossTitleSaveGames_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearReadCrossTitleSaveGameDataComplete
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearReadCrossTitleSaveGameDataComplete(unsigned char LocalUserNum, const struct FScriptDelegate& ReadSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearReadCrossTitleSaveGameDataComplete"));

	UOnlineContentInterface_ClearReadCrossTitleSaveGameDataComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadSaveGameDataCompleteDelegate = ReadSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddReadCrossTitleSaveGameDataComplete
// (Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadSaveGameDataCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::AddReadCrossTitleSaveGameDataComplete(unsigned char LocalUserNum, const struct FScriptDelegate& ReadSaveGameDataCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddReadCrossTitleSaveGameDataComplete"));

	UOnlineContentInterface_AddReadCrossTitleSaveGameDataComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadSaveGameDataCompleteDelegate = ReadSaveGameDataCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnReadCrossTitleSaveGameDataComplete
// (Iterator, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// int                            TitleId                        (Parm)
// struct FString                 FriendlyName                   (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)

void UOnlineContentInterface::STATIC_OnReadCrossTitleSaveGameDataComplete(bool bWasSuccessful, unsigned char LocalUserNum, int DeviceID, int TitleId, const struct FString& FriendlyName, const struct FString& Filename, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnReadCrossTitleSaveGameDataComplete"));

	UOnlineContentInterface_OnReadCrossTitleSaveGameDataComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.TitleId = TitleId;
	params.FriendlyName = FriendlyName;
	params.Filename = Filename;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.GetCrossTitleSaveGameData
// (Final, Defined, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// int                            TitleId                        (Parm)
// struct FString                 FriendlyName                   (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// unsigned char                  bIsValid                       (Parm, OutParm)
// TArray<unsigned char>          SaveGameData                   (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::STATIC_GetCrossTitleSaveGameData(unsigned char LocalUserNum, int DeviceID, int TitleId, const struct FString& FriendlyName, const struct FString& Filename, const struct FString& SaveFileName, unsigned char* bIsValid, TArray<unsigned char>* SaveGameData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.GetCrossTitleSaveGameData"));

	UOnlineContentInterface_GetCrossTitleSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.TitleId = TitleId;
	params.FriendlyName = FriendlyName;
	params.Filename = Filename;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bIsValid != nullptr)
		*bIsValid = params.bIsValid;
	if (SaveGameData != nullptr)
		*SaveGameData = params.SaveGameData;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ReadCrossTitleSaveGameData
// (Defined, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            DeviceID                       (Parm)
// int                            TitleId                        (Parm)
// struct FString                 FriendlyName                   (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)
// struct FString                 SaveFileName                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ReadCrossTitleSaveGameData(unsigned char LocalUserNum, int DeviceID, int TitleId, const struct FString& FriendlyName, const struct FString& Filename, const struct FString& SaveFileName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ReadCrossTitleSaveGameData"));

	UOnlineContentInterface_ReadCrossTitleSaveGameData_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeviceID = DeviceID;
	params.TitleId = TitleId;
	params.FriendlyName = FriendlyName;
	params.Filename = Filename;
	params.SaveFileName = SaveFileName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearReadCrossTitleDownloadableContentCompleteDelegate
// (Final, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadCrossTitleDLCCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearReadCrossTitleDownloadableContentCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadCrossTitleDLCCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearReadCrossTitleDownloadableContentCompleteDelegate"));

	UOnlineContentInterface_ClearReadCrossTitleDownloadableContentCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadCrossTitleDLCCompleteDelegate = ReadCrossTitleDLCCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddReadCrossTitleDownloadableContentCompleteDelegate
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadCrossTitleDLCCompleteDelegate (Parm, NeedCtorLink)

void UOnlineContentInterface::AddReadCrossTitleDownloadableContentCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadCrossTitleDLCCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddReadCrossTitleDownloadableContentCompleteDelegate"));

	UOnlineContentInterface_AddReadCrossTitleDownloadableContentCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadCrossTitleDLCCompleteDelegate = ReadCrossTitleDLCCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnReadCrossTitleDownloadableContentComplete
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineContentInterface::STATIC_OnReadCrossTitleDownloadableContentComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnReadCrossTitleDownloadableContentComplete"));

	UOnlineContentInterface_OnReadCrossTitleDownloadableContentComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.GetCrossTitleDownloadableContentList
// (Final, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FOnlineCrossTitleContent> ContentList                    (Parm, OutParm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineContentInterface::STATIC_GetCrossTitleDownloadableContentList(unsigned char LocalUserNum, TArray<struct FOnlineCrossTitleContent>* ContentList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.GetCrossTitleDownloadableContentList"));

	UOnlineContentInterface_GetCrossTitleDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ContentList != nullptr)
		*ContentList = params.ContentList;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearCrossTitleDownloadableContentList
// (PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineContentInterface::ClearCrossTitleDownloadableContentList(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearCrossTitleDownloadableContentList"));

	UOnlineContentInterface_ClearCrossTitleDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.ReadCrossTitleDownloadableContentList
// (Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ReadCrossTitleDownloadableContentList(unsigned char LocalUserNum, int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ReadCrossTitleDownloadableContentList"));

	UOnlineContentInterface_ReadCrossTitleDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.GetDownloadableContentList
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FOnlineContent>  ContentList                    (Parm, OutParm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineContentInterface::STATIC_GetDownloadableContentList(unsigned char LocalUserNum, TArray<struct FOnlineContent>* ContentList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.GetDownloadableContentList"));

	UOnlineContentInterface_GetDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ContentList != nullptr)
		*ContentList = params.ContentList;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearDownloadableContentList
// (Defined, Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineContentInterface::ClearDownloadableContentList(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearDownloadableContentList"));

	UOnlineContentInterface_ClearDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.ReadDownloadableContentList
// (Defined, Iterator, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineContentInterface::ReadDownloadableContentList(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ReadDownloadableContentList"));

	UOnlineContentInterface_ReadDownloadableContentList_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineContentInterface.ClearReadDownloadableContentComplete
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadDLCCompleteDelegate        (Parm, NeedCtorLink)

void UOnlineContentInterface::ClearReadDownloadableContentComplete(unsigned char LocalUserNum, const struct FScriptDelegate& ReadDLCCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearReadDownloadableContentComplete"));

	UOnlineContentInterface_ClearReadDownloadableContentComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadDLCCompleteDelegate = ReadDLCCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddReadDownloadableContentComplete
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadDLCCompleteDelegate        (Parm, NeedCtorLink)

void UOnlineContentInterface::AddReadDownloadableContentComplete(unsigned char LocalUserNum, const struct FScriptDelegate& ReadDLCCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddReadDownloadableContentComplete"));

	UOnlineContentInterface_AddReadDownloadableContentComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadDLCCompleteDelegate = ReadDLCCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnReadDownloadableContentComplete
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Native, Event, Operator, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineContentInterface::STATIC_OnReadDownloadableContentComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnReadDownloadableContentComplete"));

	UOnlineContentInterface_OnReadDownloadableContentComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.ClearContentChangeDelegate
// (Defined, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ContentDelegate                (Parm, NeedCtorLink)
// unsigned char                  LocalUserNum                   (OptionalParm, Parm)

void UOnlineContentInterface::ClearContentChangeDelegate(const struct FScriptDelegate& ContentDelegate, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.ClearContentChangeDelegate"));

	UOnlineContentInterface_ClearContentChangeDelegate_Params params;
	params.ContentDelegate = ContentDelegate;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.AddContentChangeDelegate
// (Final, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ContentDelegate                (Parm, NeedCtorLink)
// unsigned char                  LocalUserNum                   (OptionalParm, Parm)

void UOnlineContentInterface::AddContentChangeDelegate(const struct FScriptDelegate& ContentDelegate, unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.AddContentChangeDelegate"));

	UOnlineContentInterface_AddContentChangeDelegate_Params params;
	params.ContentDelegate = ContentDelegate;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineContentInterface.OnContentChange
// (Defined, Latent, NetReliable, Native, Event, Operator, Static)

void UOnlineContentInterface::STATIC_OnContentChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineContentInterface.OnContentChange"));

	UOnlineContentInterface_OnContentChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearGetUserConnectionInfoCompleteDelegate
// (Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GetGetUserConnectionInfoCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGetUserConnectionInfoCompleteDelegate(const struct FScriptDelegate& GetGetUserConnectionInfoCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGetUserConnectionInfoCompleteDelegate"));

	UOnlineGameInterface_ClearGetUserConnectionInfoCompleteDelegate_Params params;
	params.GetGetUserConnectionInfoCompleteDelegate = GetGetUserConnectionInfoCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGetUserConnectionInfoCompleteDelegate
// (Final, Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         GetGetUserConnectionInfoCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGetUserConnectionInfoCompleteDelegate(const struct FScriptDelegate& GetGetUserConnectionInfoCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGetUserConnectionInfoCompleteDelegate"));

	UOnlineGameInterface_AddGetUserConnectionInfoCompleteDelegate_Params params;
	params.GetGetUserConnectionInfoCompleteDelegate = GetGetUserConnectionInfoCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGetUserConnectionInfoComplete
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<struct FSessionMemberInfo> OutMemberInfo                  (Parm, NeedCtorLink)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnGetUserConnectionInfoComplete(TArray<struct FSessionMemberInfo> OutMemberInfo, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGetUserConnectionInfoComplete"));

	UOnlineGameInterface_OnGetUserConnectionInfoComplete_Params params;
	params.OutMemberInfo = OutMemberInfo;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetUserConnectionInfoAsync
// (Defined, PreOperator, Singular, Simulated, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FString>         UserNames                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_GetUserConnectionInfoAsync(TArray<struct FString> UserNames)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetUserConnectionInfoAsync"));

	UOnlineGameInterface_GetUserConnectionInfoAsync_Params params;
	params.UserNames = UserNames;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearGetSessionMemberInfoCompleteDelegate
// (Defined, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GetSessionMemberInfoCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGetSessionMemberInfoCompleteDelegate(const struct FScriptDelegate& GetSessionMemberInfoCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGetSessionMemberInfoCompleteDelegate"));

	UOnlineGameInterface_ClearGetSessionMemberInfoCompleteDelegate_Params params;
	params.GetSessionMemberInfoCompleteDelegate = GetSessionMemberInfoCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGetSessionMemberInfoCompleteDelegate
// (Final, Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         GetSessionMemberInfoCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGetSessionMemberInfoCompleteDelegate(const struct FScriptDelegate& GetSessionMemberInfoCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGetSessionMemberInfoCompleteDelegate"));

	UOnlineGameInterface_AddGetSessionMemberInfoCompleteDelegate_Params params;
	params.GetSessionMemberInfoCompleteDelegate = GetSessionMemberInfoCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGetSessionMemberInfoComplete
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<struct FSessionMemberInfo> OutMemberInfo                  (Parm, NeedCtorLink)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnGetSessionMemberInfoComplete(TArray<struct FSessionMemberInfo> OutMemberInfo, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGetSessionMemberInfoComplete"));

	UOnlineGameInterface_OnGetSessionMemberInfoComplete_Params params;
	params.OutMemberInfo = OutMemberInfo;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetCurrentSessionMemberInfo
// (Iterator, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FSessionMemberInfo> OutMemberInfo                  (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_GetCurrentSessionMemberInfo(const struct FName& SessionName, TArray<struct FSessionMemberInfo>* OutMemberInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetCurrentSessionMemberInfo"));

	UOnlineGameInterface_GetCurrentSessionMemberInfo_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMemberInfo != nullptr)
		*OutMemberInfo = params.OutMemberInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.GetCurrentSessionMemberInfoAsync
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_GetCurrentSessionMemberInfoAsync(unsigned char LocalUserNum, const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetCurrentSessionMemberInfoAsync"));

	UOnlineGameInterface_GetCurrentSessionMemberInfoAsync_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.RunBandwidthTest
// (Final, Defined, Iterator, Latent, Singular, Net, Simulated, Native, HasOptionalParms)

void UOnlineGameInterface::RunBandwidthTest()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RunBandwidthTest"));

	UOnlineGameInterface_RunBandwidthTest_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.IsAllowedToNetworkHost
// (Iterator, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_IsAllowedToNetworkHost()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.IsAllowedToNetworkHost"));

	UOnlineGameInterface_IsAllowedToNetworkHost_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearGetRoomIdFromTitleServiceDelegate
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGetRoomIdFromTitleServiceDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGetRoomIdFromTitleServiceDelegate"));

	UOnlineGameInterface_ClearGetRoomIdFromTitleServiceDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGetRoomIdFromTitleServiceDelegate
// (Latent, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGetRoomIdFromTitleServiceDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGetRoomIdFromTitleServiceDelegate"));

	UOnlineGameInterface_AddGetRoomIdFromTitleServiceDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetRoomIdFromSessionId
// (Defined, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 SessionId                      (Parm, NeedCtorLink)

void UOnlineGameInterface::STATIC_GetRoomIdFromSessionId(const struct FString& SessionId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetRoomIdFromSessionId"));

	UOnlineGameInterface_GetRoomIdFromSessionId_Params params;
	params.SessionId = SessionId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetRoomIdFromTitleService
// (Final, Defined, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FQWord                  DataId                         (Parm)

void UOnlineGameInterface::STATIC_GetRoomIdFromTitleService(const struct FQWord& DataId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetRoomIdFromTitleService"));

	UOnlineGameInterface_GetRoomIdFromTitleService_Params params;
	params.DataId = DataId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGetRoomIdFromTitleService
// (Iterator, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FQWord                  RoomId                         (Parm)

void UOnlineGameInterface::OnGetRoomIdFromTitleService(const struct FQWord& RoomId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGetRoomIdFromTitleService"));

	UOnlineGameInterface_OnGetRoomIdFromTitleService_Params params;
	params.RoomId = RoomId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetRoomId
// (Final, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UOnlineGameInterface::STATIC_GetRoomId()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetRoomId"));

	UOnlineGameInterface_GetRoomId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearGetNumberOfCurrentPlayersCompleteDelegate
// (Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GetNumberOfCurrentPlayersCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGetNumberOfCurrentPlayersCompleteDelegate(const struct FScriptDelegate& GetNumberOfCurrentPlayersCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGetNumberOfCurrentPlayersCompleteDelegate"));

	UOnlineGameInterface_ClearGetNumberOfCurrentPlayersCompleteDelegate_Params params;
	params.GetNumberOfCurrentPlayersCompleteDelegate = GetNumberOfCurrentPlayersCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGetNumberOfCurrentPlayersCompleteDelegate
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         GetNumberOfCurrentPlayersCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGetNumberOfCurrentPlayersCompleteDelegate(const struct FScriptDelegate& GetNumberOfCurrentPlayersCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGetNumberOfCurrentPlayersCompleteDelegate"));

	UOnlineGameInterface_AddGetNumberOfCurrentPlayersCompleteDelegate_Params params;
	params.GetNumberOfCurrentPlayersCompleteDelegate = GetNumberOfCurrentPlayersCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGetNumberOfCurrentPlayersComplete
// (Defined, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            TotalPlayers                   (Parm)

void UOnlineGameInterface::STATIC_OnGetNumberOfCurrentPlayersComplete(int TotalPlayers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGetNumberOfCurrentPlayersComplete"));

	UOnlineGameInterface_OnGetNumberOfCurrentPlayersComplete_Params params;
	params.TotalPlayers = TotalPlayers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.GetNumberOfCurrentPlayersCached
// (PreOperator, Net, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineGameInterface::STATIC_GetNumberOfCurrentPlayersCached()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetNumberOfCurrentPlayersCached"));

	UOnlineGameInterface_GetNumberOfCurrentPlayersCached_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.SendPlayerList
// (Final, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<class APlayerReplicationInfo*> Players                        (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::SendPlayerList(TArray<class APlayerReplicationInfo*> Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.SendPlayerList"));

	UOnlineGameInterface_SendPlayerList_Params params;
	params.Players = Players;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.RetrieveGameSettingsForIP
// (Defined, Iterator, Latent, Singular, NetReliable, Native, HasOptionalParms)
// Parameters:
// struct FString                 IPAddress                      (Parm, NeedCtorLink)

void UOnlineGameInterface::RetrieveGameSettingsForIP(const struct FString& IPAddress)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RetrieveGameSettingsForIP"));

	UOnlineGameInterface_RetrieveGameSettingsForIP_Params params;
	params.IPAddress = IPAddress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearOnRetrieveGameSettingsForIPDelegate
// (Final, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RetrieveIPDelegate             (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearOnRetrieveGameSettingsForIPDelegate(const struct FScriptDelegate& RetrieveIPDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearOnRetrieveGameSettingsForIPDelegate"));

	UOnlineGameInterface_ClearOnRetrieveGameSettingsForIPDelegate_Params params;
	params.RetrieveIPDelegate = RetrieveIPDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddOnRetrieveGameSettingsForIPDelegate
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         NewRetrieveIPDelegate          (Parm, NeedCtorLink)

void UOnlineGameInterface::AddOnRetrieveGameSettingsForIPDelegate(const struct FScriptDelegate& NewRetrieveIPDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddOnRetrieveGameSettingsForIPDelegate"));

	UOnlineGameInterface_AddOnRetrieveGameSettingsForIPDelegate_Params params;
	params.NewRetrieveIPDelegate = NewRetrieveIPDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnRetrievedGameSettingsForIP
// (Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSuccessful                    (Parm)
// struct FOnlineGameSearchResult ConnectResult                  (Const, Parm, OutParm)

void UOnlineGameInterface::OnRetrievedGameSettingsForIP(bool bSuccessful, struct FOnlineGameSearchResult* ConnectResult)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnRetrievedGameSettingsForIP"));

	UOnlineGameInterface_OnRetrievedGameSettingsForIP_Params params;
	params.bSuccessful = bSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ConnectResult != nullptr)
		*ConnectResult = params.ConnectResult;
}


// Function Engine.OnlineGameInterface.GetNumberOfCurrentPlayers
// (Final, Defined, Iterator, Latent, Net, Exec, Native, Event, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_GetNumberOfCurrentPlayers()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetNumberOfCurrentPlayers"));

	UOnlineGameInterface_GetNumberOfCurrentPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearJoinMigratedOnlineGameCompleteDelegate
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         JoinMigratedOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearJoinMigratedOnlineGameCompleteDelegate(const struct FScriptDelegate& JoinMigratedOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearJoinMigratedOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearJoinMigratedOnlineGameCompleteDelegate_Params params;
	params.JoinMigratedOnlineGameCompleteDelegate = JoinMigratedOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddJoinMigratedOnlineGameCompleteDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         JoinMigratedOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddJoinMigratedOnlineGameCompleteDelegate(const struct FScriptDelegate& JoinMigratedOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddJoinMigratedOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddJoinMigratedOnlineGameCompleteDelegate_Params params;
	params.JoinMigratedOnlineGameCompleteDelegate = JoinMigratedOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnJoinMigratedOnlineGameComplete
// (Final, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnJoinMigratedOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnJoinMigratedOnlineGameComplete"));

	UOnlineGameInterface_OnJoinMigratedOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.JoinMigratedOnlineGame
// (Final, Iterator, Latent, Singular, Simulated, Exec, Operator, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FName                   SessionName                    (Parm)
// struct FOnlineGameSearchResult DesiredGame                    (Const, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_JoinMigratedOnlineGame(unsigned char PlayerNum, const struct FName& SessionName, struct FOnlineGameSearchResult* DesiredGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.JoinMigratedOnlineGame"));

	UOnlineGameInterface_JoinMigratedOnlineGame_Params params;
	params.PlayerNum = PlayerNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DesiredGame != nullptr)
		*DesiredGame = params.DesiredGame;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearMigrateOnlineGameCompleteDelegate
// (Iterator, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MigrateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearMigrateOnlineGameCompleteDelegate(const struct FScriptDelegate& MigrateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearMigrateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearMigrateOnlineGameCompleteDelegate_Params params;
	params.MigrateOnlineGameCompleteDelegate = MigrateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddMigrateOnlineGameCompleteDelegate
// (PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         MigrateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddMigrateOnlineGameCompleteDelegate(const struct FScriptDelegate& MigrateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddMigrateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddMigrateOnlineGameCompleteDelegate_Params params;
	params.MigrateOnlineGameCompleteDelegate = MigrateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnMigrateOnlineGameComplete
// (Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnMigrateOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMigrateOnlineGameComplete"));

	UOnlineGameInterface_OnMigrateOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.MigrateOnlineGame
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Operator, Static)
// Parameters:
// unsigned char                  HostingPlayerNum               (Parm)
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_MigrateOnlineGame(unsigned char HostingPlayerNum, const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.MigrateOnlineGame"));

	UOnlineGameInterface_MigrateOnlineGame_Params params;
	params.HostingPlayerNum = HostingPlayerNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearRecalculateSkillRatingCompleteDelegate
// (Final, Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RecalculateSkillRatingGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearRecalculateSkillRatingCompleteDelegate(const struct FScriptDelegate& RecalculateSkillRatingGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearRecalculateSkillRatingCompleteDelegate"));

	UOnlineGameInterface_ClearRecalculateSkillRatingCompleteDelegate_Params params;
	params.RecalculateSkillRatingGameCompleteDelegate = RecalculateSkillRatingGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddRecalculateSkillRatingCompleteDelegate
// (Defined, Iterator, Latent, Operator)
// Parameters:
// struct FScriptDelegate         RecalculateSkillRatingCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddRecalculateSkillRatingCompleteDelegate(const struct FScriptDelegate& RecalculateSkillRatingCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddRecalculateSkillRatingCompleteDelegate"));

	UOnlineGameInterface_AddRecalculateSkillRatingCompleteDelegate_Params params;
	params.RecalculateSkillRatingCompleteDelegate = RecalculateSkillRatingCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnRecalculateSkillRatingComplete
// (Final, Defined, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnRecalculateSkillRatingComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnRecalculateSkillRatingComplete"));

	UOnlineGameInterface_OnRecalculateSkillRatingComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.RecalculateSkillRating
// (Defined, PreOperator, Singular, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::RecalculateSkillRating(const struct FName& SessionName, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RecalculateSkillRating"));

	UOnlineGameInterface_RecalculateSkillRating_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.AcceptGameInvite
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::AcceptGameInvite(unsigned char LocalUserNum, const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AcceptGameInvite"));

	UOnlineGameInterface_AcceptGameInvite_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearGameInviteAcceptedDelegate
// (Final, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         GameInviteAcceptedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGameInviteAcceptedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& GameInviteAcceptedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGameInviteAcceptedDelegate"));

	UOnlineGameInterface_ClearGameInviteAcceptedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.GameInviteAcceptedDelegate = GameInviteAcceptedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGameInviteAcceptedDelegate
// (Iterator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         GameInviteAcceptedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGameInviteAcceptedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& GameInviteAcceptedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGameInviteAcceptedDelegate"));

	UOnlineGameInterface_AddGameInviteAcceptedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.GameInviteAcceptedDelegate = GameInviteAcceptedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGameInviteAccepted
// (Final, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FOnlineGameSearchResult InviteResult                   (Const, Parm, OutParm)

void UOnlineGameInterface::OnGameInviteAccepted(struct FOnlineGameSearchResult* InviteResult)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGameInviteAccepted"));

	UOnlineGameInterface_OnGameInviteAccepted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InviteResult != nullptr)
		*InviteResult = params.InviteResult;
}


// Function Engine.OnlineGameInterface.GetArbitratedPlayers
// (Final, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FOnlineArbitrationRegistrant> ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<struct FOnlineArbitrationRegistrant> UOnlineGameInterface::STATIC_GetArbitratedPlayers(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetArbitratedPlayers"));

	UOnlineGameInterface_GetArbitratedPlayers_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearArbitrationRegistrationCompleteDelegate
// (Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ArbitrationRegistrationCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearArbitrationRegistrationCompleteDelegate(const struct FScriptDelegate& ArbitrationRegistrationCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearArbitrationRegistrationCompleteDelegate"));

	UOnlineGameInterface_ClearArbitrationRegistrationCompleteDelegate_Params params;
	params.ArbitrationRegistrationCompleteDelegate = ArbitrationRegistrationCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddArbitrationRegistrationCompleteDelegate
// (PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ArbitrationRegistrationCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddArbitrationRegistrationCompleteDelegate(const struct FScriptDelegate& ArbitrationRegistrationCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddArbitrationRegistrationCompleteDelegate"));

	UOnlineGameInterface_AddArbitrationRegistrationCompleteDelegate_Params params;
	params.ArbitrationRegistrationCompleteDelegate = ArbitrationRegistrationCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnArbitrationRegistrationComplete
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnArbitrationRegistrationComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnArbitrationRegistrationComplete"));

	UOnlineGameInterface_OnArbitrationRegistrationComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.RegisterForArbitration
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::RegisterForArbitration(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RegisterForArbitration"));

	UOnlineGameInterface_RegisterForArbitration_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearEndOnlineGameCompleteDelegate
// (Defined, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         EndOnlineGameCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearEndOnlineGameCompleteDelegate(const struct FScriptDelegate& EndOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearEndOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearEndOnlineGameCompleteDelegate_Params params;
	params.EndOnlineGameCompleteDelegate = EndOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddEndOnlineGameCompleteDelegate
// (Final, Defined, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         EndOnlineGameCompleteDelegate  (Parm, NeedCtorLink)

void UOnlineGameInterface::AddEndOnlineGameCompleteDelegate(const struct FScriptDelegate& EndOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddEndOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddEndOnlineGameCompleteDelegate_Params params;
	params.EndOnlineGameCompleteDelegate = EndOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnEndOnlineGameComplete
// (Defined, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnEndOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnEndOnlineGameComplete"));

	UOnlineGameInterface_OnEndOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.EndOnlineGame
// (Final, PreOperator, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_EndOnlineGame(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.EndOnlineGame"));

	UOnlineGameInterface_EndOnlineGame_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearStartOnlineGameCompleteDelegate
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         StartOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearStartOnlineGameCompleteDelegate(const struct FScriptDelegate& StartOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearStartOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearStartOnlineGameCompleteDelegate_Params params;
	params.StartOnlineGameCompleteDelegate = StartOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddStartOnlineGameCompleteDelegate
// (Final, Iterator, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         StartOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddStartOnlineGameCompleteDelegate(const struct FScriptDelegate& StartOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddStartOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddStartOnlineGameCompleteDelegate_Params params;
	params.StartOnlineGameCompleteDelegate = StartOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnStartOnlineGameComplete
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnStartOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnStartOnlineGameComplete"));

	UOnlineGameInterface_OnStartOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.StartOnlineGame
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::StartOnlineGame(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.StartOnlineGame"));

	UOnlineGameInterface_StartOnlineGame_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearUnregisterPlayerCompleteDelegate
// (Final, Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterPlayerCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearUnregisterPlayerCompleteDelegate(const struct FScriptDelegate& UnregisterPlayerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearUnregisterPlayerCompleteDelegate"));

	UOnlineGameInterface_ClearUnregisterPlayerCompleteDelegate_Params params;
	params.UnregisterPlayerCompleteDelegate = UnregisterPlayerCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddUnregisterPlayerCompleteDelegate
// (Final, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterPlayerCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddUnregisterPlayerCompleteDelegate(const struct FScriptDelegate& UnregisterPlayerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddUnregisterPlayerCompleteDelegate"));

	UOnlineGameInterface_AddUnregisterPlayerCompleteDelegate_Params params;
	params.UnregisterPlayerCompleteDelegate = UnregisterPlayerCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnUnregisterPlayerComplete
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnUnregisterPlayerComplete(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnUnregisterPlayerComplete"));

	UOnlineGameInterface_OnUnregisterPlayerComplete_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.UnregisterPlayers
// (Final, Defined, Iterator, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::UnregisterPlayers(const struct FName& SessionName, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.UnregisterPlayers"));

	UOnlineGameInterface_UnregisterPlayers_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.UnregisterPlayer
// (Iterator, Latent, Singular, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::UnregisterPlayer(const struct FName& SessionName, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.UnregisterPlayer"));

	UOnlineGameInterface_UnregisterPlayer_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearRegisterPlayerCompleteDelegate
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RegisterPlayerCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearRegisterPlayerCompleteDelegate(const struct FScriptDelegate& RegisterPlayerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearRegisterPlayerCompleteDelegate"));

	UOnlineGameInterface_ClearRegisterPlayerCompleteDelegate_Params params;
	params.RegisterPlayerCompleteDelegate = RegisterPlayerCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddRegisterPlayerCompleteDelegate
// (Iterator, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         RegisterPlayerCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddRegisterPlayerCompleteDelegate(const struct FScriptDelegate& RegisterPlayerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddRegisterPlayerCompleteDelegate"));

	UOnlineGameInterface_AddRegisterPlayerCompleteDelegate_Params params;
	params.RegisterPlayerCompleteDelegate = RegisterPlayerCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnRegisterPlayerComplete
// (Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnRegisterPlayerComplete(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnRegisterPlayerComplete"));

	UOnlineGameInterface_OnRegisterPlayerComplete_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.RegisterPlayers
// (Final, Iterator, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::RegisterPlayers(const struct FName& SessionName, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RegisterPlayers"));

	UOnlineGameInterface_RegisterPlayers_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.RegisterPlayer
// (Defined, Net, NetReliable, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           bWasInvited                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::RegisterPlayer(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasInvited)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.RegisterPlayer"));

	UOnlineGameInterface_RegisterPlayer_Params params;
	params.SessionName = SessionName;
	params.PlayerID = PlayerID;
	params.bWasInvited = bWasInvited;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.GetResolvedConnectString
// (Final, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FString                 ConnectInfo                    (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_GetResolvedConnectString(const struct FName& SessionName, struct FString* ConnectInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetResolvedConnectString"));

	UOnlineGameInterface_GetResolvedConnectString_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ConnectInfo != nullptr)
		*ConnectInfo = params.ConnectInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearQuerySessionsForUserCompleteDelegate
// (Defined, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         QuerySessionsForUserCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearQuerySessionsForUserCompleteDelegate(const struct FScriptDelegate& QuerySessionsForUserCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearQuerySessionsForUserCompleteDelegate"));

	UOnlineGameInterface_ClearQuerySessionsForUserCompleteDelegate_Params params;
	params.QuerySessionsForUserCompleteDelegate = QuerySessionsForUserCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddQuerySessionsForUserCompleteDelegate
// (Final, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         QuerySessionsForUserCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddQuerySessionsForUserCompleteDelegate(const struct FScriptDelegate& QuerySessionsForUserCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddQuerySessionsForUserCompleteDelegate"));

	UOnlineGameInterface_AddQuerySessionsForUserCompleteDelegate_Params params;
	params.QuerySessionsForUserCompleteDelegate = QuerySessionsForUserCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnQuerySessionsForUserComplete
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalPlayerNum                 (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnQuerySessionsForUserComplete(unsigned char LocalPlayerNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnQuerySessionsForUserComplete"));

	UOnlineGameInterface_OnQuerySessionsForUserComplete_Params params;
	params.LocalPlayerNum = LocalPlayerNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.QuerySessionsByKeyword
// (Final, Iterator, NetReliable, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalPlayerNum                 (Parm)
// struct FString                 Keyword                        (Parm, NeedCtorLink)
// class UOnlineGameSearch*       SearchSettings                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::QuerySessionsByKeyword(unsigned char LocalPlayerNum, const struct FString& Keyword, class UOnlineGameSearch* SearchSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.QuerySessionsByKeyword"));

	UOnlineGameInterface_QuerySessionsByKeyword_Params params;
	params.LocalPlayerNum = LocalPlayerNum;
	params.Keyword = Keyword;
	params.SearchSettings = SearchSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.QuerySessionsForUser
// (Defined, Iterator, NetReliable, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalPlayerNum                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::QuerySessionsForUser(unsigned char LocalPlayerNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.QuerySessionsForUser"));

	UOnlineGameInterface_QuerySessionsForUser_Params params;
	params.LocalPlayerNum = LocalPlayerNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.LeaveAllOnlineSessions
// (Final, Defined, Iterator, Latent, Singular, Native, Operator, Static)
// Parameters:
// bool                           bClearSessionIfHost            (OptionalParm, Parm)

void UOnlineGameInterface::STATIC_LeaveAllOnlineSessions(bool bClearSessionIfHost)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.LeaveAllOnlineSessions"));

	UOnlineGameInterface_LeaveAllOnlineSessions_Params params;
	params.bClearSessionIfHost = bClearSessionIfHost;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.LeaveOnlineSession
// (PreOperator, Singular, Native, Operator, Static)
// Parameters:
// unsigned char                  LocalPlayerNum                 (Parm)
// struct FName                   SessionName                    (Parm)
// bool                           bClearSessionIfHost            (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_LeaveOnlineSession(unsigned char LocalPlayerNum, const struct FName& SessionName, bool bClearSessionIfHost)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.LeaveOnlineSession"));

	UOnlineGameInterface_LeaveOnlineSession_Params params;
	params.LocalPlayerNum = LocalPlayerNum;
	params.SessionName = SessionName;
	params.bClearSessionIfHost = bClearSessionIfHost;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearMatchStatusChangedDelegate
// (Defined, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MatchStatusChangedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearMatchStatusChangedDelegate(const struct FScriptDelegate& MatchStatusChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearMatchStatusChangedDelegate"));

	UOnlineGameInterface_ClearMatchStatusChangedDelegate_Params params;
	params.MatchStatusChangedDelegate = MatchStatusChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddMatchStatusChangedDelegate
// (Defined, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         MatchStatusChangedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::AddMatchStatusChangedDelegate(const struct FScriptDelegate& MatchStatusChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddMatchStatusChangedDelegate"));

	UOnlineGameInterface_AddMatchStatusChangedDelegate_Params params;
	params.MatchStatusChangedDelegate = MatchStatusChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnMatchStatusChanged
// (Final, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// unsigned char                  Status                         (Parm)

void UOnlineGameInterface::OnMatchStatusChanged(const struct FName& SessionName, unsigned char Status)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMatchStatusChanged"));

	UOnlineGameInterface_OnMatchStatusChanged_Params params;
	params.SessionName = SessionName;
	params.Status = Status;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearGamePlayersChangedDelegate
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GamePlayersChangedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGamePlayersChangedDelegate(const struct FScriptDelegate& GamePlayersChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGamePlayersChangedDelegate"));

	UOnlineGameInterface_ClearGamePlayersChangedDelegate_Params params;
	params.GamePlayersChangedDelegate = GamePlayersChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGamePlayersChangedDelegate
// (Final, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         GamePlayersChangedDelegate     (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGamePlayersChangedDelegate(const struct FScriptDelegate& GamePlayersChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGamePlayersChangedDelegate"));

	UOnlineGameInterface_AddGamePlayersChangedDelegate_Params params;
	params.GamePlayersChangedDelegate = GamePlayersChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGamePlayersChanged
// (Defined, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Players                        (Parm, NeedCtorLink)

void UOnlineGameInterface::OnGamePlayersChanged(const struct FName& SessionName, TArray<struct FUniqueNetId> Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGamePlayersChanged"));

	UOnlineGameInterface_OnGamePlayersChanged_Params params;
	params.SessionName = SessionName;
	params.Players = Players;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearAcceptPendingGameSessionCompleteDelegate
// (Latent, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         AcceptPendingGameSessionCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearAcceptPendingGameSessionCompleteDelegate(const struct FScriptDelegate& AcceptPendingGameSessionCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearAcceptPendingGameSessionCompleteDelegate"));

	UOnlineGameInterface_ClearAcceptPendingGameSessionCompleteDelegate_Params params;
	params.AcceptPendingGameSessionCompleteDelegate = AcceptPendingGameSessionCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddAcceptPendingGameSessionCompleteDelegate
// (Final, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         AcceptPendingGameSessionCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddAcceptPendingGameSessionCompleteDelegate(const struct FScriptDelegate& AcceptPendingGameSessionCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddAcceptPendingGameSessionCompleteDelegate"));

	UOnlineGameInterface_AddAcceptPendingGameSessionCompleteDelegate_Params params;
	params.AcceptPendingGameSessionCompleteDelegate = AcceptPendingGameSessionCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnAcceptPendingGameSessionComplete
// (Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnAcceptPendingGameSessionComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnAcceptPendingGameSessionComplete"));

	UOnlineGameInterface_OnAcceptPendingGameSessionComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AcceptPendingGameSession
// (PreOperator, Singular, Net, NetReliable, Exec, Native, Event)
// Parameters:
// struct FName                   SessionName                    (Parm)

void UOnlineGameInterface::AcceptPendingGameSession(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AcceptPendingGameSession"));

	UOnlineGameInterface_AcceptPendingGameSession_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearGameSessionReadyDelegate
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GameSessionReadyDelegate       (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearGameSessionReadyDelegate(const struct FScriptDelegate& GameSessionReadyDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearGameSessionReadyDelegate"));

	UOnlineGameInterface_ClearGameSessionReadyDelegate_Params params;
	params.GameSessionReadyDelegate = GameSessionReadyDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddGameSessionReadyDelegate
// (Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         GameSessionReadyDelegate       (Parm, NeedCtorLink)

void UOnlineGameInterface::AddGameSessionReadyDelegate(const struct FScriptDelegate& GameSessionReadyDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddGameSessionReadyDelegate"));

	UOnlineGameInterface_AddGameSessionReadyDelegate_Params params;
	params.GameSessionReadyDelegate = GameSessionReadyDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnGameSessionReady
// (Final, Defined, Latent, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)

void UOnlineGameInterface::OnGameSessionReady(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnGameSessionReady"));

	UOnlineGameInterface_OnGameSessionReady_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearUpdateSessionPropertiesCompleteDelegate
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UpdateSessionPropertiesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearUpdateSessionPropertiesCompleteDelegate(const struct FScriptDelegate& UpdateSessionPropertiesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearUpdateSessionPropertiesCompleteDelegate"));

	UOnlineGameInterface_ClearUpdateSessionPropertiesCompleteDelegate_Params params;
	params.UpdateSessionPropertiesCompleteDelegate = UpdateSessionPropertiesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddUpdateSessionPropertiesCompleteDelegate
// (Iterator, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UpdateSessionPropertiesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddUpdateSessionPropertiesCompleteDelegate(const struct FScriptDelegate& UpdateSessionPropertiesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddUpdateSessionPropertiesCompleteDelegate"));

	UOnlineGameInterface_AddUpdateSessionPropertiesCompleteDelegate_Params params;
	params.UpdateSessionPropertiesCompleteDelegate = UpdateSessionPropertiesCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnUpdateSessionPropertiesComplete
// (Final, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnUpdateSessionPropertiesComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnUpdateSessionPropertiesComplete"));

	UOnlineGameInterface_OnUpdateSessionPropertiesComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.UpdateSessionProperties
// (Final, Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  ScoutingUserNum                (Parm)
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::UpdateSessionProperties(unsigned char ScoutingUserNum, const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.UpdateSessionProperties"));

	UOnlineGameInterface_UpdateSessionProperties_Params params;
	params.ScoutingUserNum = ScoutingUserNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.DeleteCustomMemberProperty
// (Final, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FString                 PropertyName                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_DeleteCustomMemberProperty(const struct FName& SessionName, const struct FString& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.DeleteCustomMemberProperty"));

	UOnlineGameInterface_DeleteCustomMemberProperty_Params params;
	params.SessionName = SessionName;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.SetCustomMemberProperty
// (Final, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FString                 PropertyName                   (Parm, NeedCtorLink)
// struct FString                 PropertyValue                  (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::SetCustomMemberProperty(const struct FName& SessionName, const struct FString& PropertyName, const struct FString& PropertyValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.SetCustomMemberProperty"));

	UOnlineGameInterface_SetCustomMemberProperty_Params params;
	params.SessionName = SessionName;
	params.PropertyName = PropertyName;
	params.PropertyValue = PropertyValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.DeleteCustomSessionProperty
// (Defined, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FString                 PropertyName                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_DeleteCustomSessionProperty(const struct FName& SessionName, const struct FString& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.DeleteCustomSessionProperty"));

	UOnlineGameInterface_DeleteCustomSessionProperty_Params params;
	params.SessionName = SessionName;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.SetCustomSessionProperty
// (Defined, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FString                 PropertyName                   (Parm, NeedCtorLink)
// struct FString                 PropertyValue                  (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::SetCustomSessionProperty(const struct FName& SessionName, const struct FString& PropertyName, const struct FString& PropertyValue)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.SetCustomSessionProperty"));

	UOnlineGameInterface_SetCustomSessionProperty_Params params;
	params.SessionName = SessionName;
	params.PropertyName = PropertyName;
	params.PropertyValue = PropertyValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearMultiplayerSessionChangeDelegate
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MultiplayerSessionChangeDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearMultiplayerSessionChangeDelegate(const struct FScriptDelegate& MultiplayerSessionChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearMultiplayerSessionChangeDelegate"));

	UOnlineGameInterface_ClearMultiplayerSessionChangeDelegate_Params params;
	params.MultiplayerSessionChangeDelegate = MultiplayerSessionChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddMultiplayerSessionChangeDelegate
// (Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         MultiplayerSessionChangeDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddMultiplayerSessionChangeDelegate(const struct FScriptDelegate& MultiplayerSessionChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddMultiplayerSessionChangeDelegate"));

	UOnlineGameInterface_AddMultiplayerSessionChangeDelegate_Params params;
	params.MultiplayerSessionChangeDelegate = MultiplayerSessionChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnMultiplayerSessionChange
// (Final, Defined, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// struct FSessionUpdateInfo      SessionChanges                 (Parm, NeedCtorLink)

void UOnlineGameInterface::OnMultiplayerSessionChange(const struct FName& SessionName, const struct FSessionUpdateInfo& SessionChanges)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMultiplayerSessionChange"));

	UOnlineGameInterface_OnMultiplayerSessionChange_Params params;
	params.SessionName = SessionName;
	params.SessionChanges = SessionChanges;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearAddSessionMemberCompleteDelegate
// (Final, Iterator, Latent, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         AddSessionMemberCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearAddSessionMemberCompleteDelegate(const struct FScriptDelegate& AddSessionMemberCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearAddSessionMemberCompleteDelegate"));

	UOnlineGameInterface_ClearAddSessionMemberCompleteDelegate_Params params;
	params.AddSessionMemberCompleteDelegate = AddSessionMemberCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddAddSessionMemberCompleteDelegate
// (Final, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         AddSessionMemberCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddAddSessionMemberCompleteDelegate(const struct FScriptDelegate& AddSessionMemberCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddAddSessionMemberCompleteDelegate"));

	UOnlineGameInterface_AddAddSessionMemberCompleteDelegate_Params params;
	params.AddSessionMemberCompleteDelegate = AddSessionMemberCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnAddSessionMemberComplete
// (Final, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnAddSessionMemberComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnAddSessionMemberComplete"));

	UOnlineGameInterface_OnAddSessionMemberComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddSessionMembers
// (Defined, Iterator, Singular, Operator)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// TArray<struct FUniqueNetId>    Members                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::AddSessionMembers(unsigned char ScoutingPlayerNum, const struct FName& SessionName, TArray<struct FUniqueNetId> Members)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddSessionMembers"));

	UOnlineGameInterface_AddSessionMembers_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.Members = Members;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.AddSessionMember
// (Final, Defined, Singular, Operator)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// struct FUniqueNetId            Member                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::AddSessionMember(unsigned char ScoutingPlayerNum, const struct FName& SessionName, const struct FUniqueNetId& Member)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddSessionMember"));

	UOnlineGameInterface_AddSessionMember_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.Member = Member;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.AddSessionMemberByString
// (Iterator, Singular, Operator)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// struct FString                 Member                         (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::AddSessionMemberByString(unsigned char ScoutingPlayerNum, const struct FName& SessionName, const struct FString& Member)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddSessionMemberByString"));

	UOnlineGameInterface_AddSessionMemberByString_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.Member = Member;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.CreateOnlineSessionWithTemplate
// (PreOperator, Exec, Static)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     NewGameSettings                (Parm)
// struct FString                 TemplateName                   (Parm, NeedCtorLink)
// struct FString                 SessionKeyword                 (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_CreateOnlineSessionWithTemplate(unsigned char ScoutingPlayerNum, const struct FName& SessionName, class UOnlineGameSettings* NewGameSettings, const struct FString& TemplateName, const struct FString& SessionKeyword)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.CreateOnlineSessionWithTemplate"));

	UOnlineGameInterface_CreateOnlineSessionWithTemplate_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.NewGameSettings = NewGameSettings;
	params.TemplateName = TemplateName;
	params.SessionKeyword = SessionKeyword;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.InitiatedSessionSearch
// (Defined, Iterator, Latent, Singular, Net, Simulated, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_InitiatedSessionSearch(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.InitiatedSessionSearch"));

	UOnlineGameInterface_InitiatedSessionSearch_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.IsHostOfSession
// (Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_IsHostOfSession(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.IsHostOfSession"));

	UOnlineGameInterface_IsHostOfSession_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearMatchmakeOnlineGameWithPartyCompleteDelegate
// (Final, Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MatchmakeOnlineGameWithPartyCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearMatchmakeOnlineGameWithPartyCompleteDelegate(const struct FScriptDelegate& MatchmakeOnlineGameWithPartyCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearMatchmakeOnlineGameWithPartyCompleteDelegate"));

	UOnlineGameInterface_ClearMatchmakeOnlineGameWithPartyCompleteDelegate_Params params;
	params.MatchmakeOnlineGameWithPartyCompleteDelegate = MatchmakeOnlineGameWithPartyCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddMatchmakeOnlineGameWithPartyCompleteDelegate
// (Final, Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         MatchmakeOnlineGameWithPartyCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddMatchmakeOnlineGameWithPartyCompleteDelegate(const struct FScriptDelegate& MatchmakeOnlineGameWithPartyCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddMatchmakeOnlineGameWithPartyCompleteDelegate"));

	UOnlineGameInterface_AddMatchmakeOnlineGameWithPartyCompleteDelegate_Params params;
	params.MatchmakeOnlineGameWithPartyCompleteDelegate = MatchmakeOnlineGameWithPartyCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnMatchmakeOnlineGameWithPartyComplete
// (Iterator, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnMatchmakeOnlineGameWithPartyComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMatchmakeOnlineGameWithPartyComplete"));

	UOnlineGameInterface_OnMatchmakeOnlineGameWithPartyComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.MatchmakeOnlineGameWithParty
// (Final, Defined, Latent, PreOperator, NetReliable, Exec, Native, Operator, Static)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     NewGameSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_MatchmakeOnlineGameWithParty(unsigned char ScoutingPlayerNum, const struct FName& SessionName, class UOnlineGameSettings* NewGameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.MatchmakeOnlineGameWithParty"));

	UOnlineGameInterface_MatchmakeOnlineGameWithParty_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.NewGameSettings = NewGameSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearCreateOnlineGameWithPartyCompleteDelegate
// (Final, Defined, Iterator, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         CreateOnlineGameWithPartyCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearCreateOnlineGameWithPartyCompleteDelegate(const struct FScriptDelegate& CreateOnlineGameWithPartyCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearCreateOnlineGameWithPartyCompleteDelegate"));

	UOnlineGameInterface_ClearCreateOnlineGameWithPartyCompleteDelegate_Params params;
	params.CreateOnlineGameWithPartyCompleteDelegate = CreateOnlineGameWithPartyCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddCreateOnlineGameWithPartyCompleteDelegate
// (Final, Defined, Iterator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         CreateOnlineGameWithPartyCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddCreateOnlineGameWithPartyCompleteDelegate(const struct FScriptDelegate& CreateOnlineGameWithPartyCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddCreateOnlineGameWithPartyCompleteDelegate"));

	UOnlineGameInterface_AddCreateOnlineGameWithPartyCompleteDelegate_Params params;
	params.CreateOnlineGameWithPartyCompleteDelegate = CreateOnlineGameWithPartyCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnCreateOnlineGameWithPartyComplete
// (Defined, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnCreateOnlineGameWithPartyComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnCreateOnlineGameWithPartyComplete"));

	UOnlineGameInterface_OnCreateOnlineGameWithPartyComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.CreateOnlineGameWithParty
// (Defined, Iterator, Latent, Exec, Static)
// Parameters:
// unsigned char                  ScoutingPlayerNum              (Parm)
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     NewGameSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_CreateOnlineGameWithParty(unsigned char ScoutingPlayerNum, const struct FName& SessionName, class UOnlineGameSettings* NewGameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.CreateOnlineGameWithParty"));

	UOnlineGameInterface_CreateOnlineGameWithParty_Params params;
	params.ScoutingPlayerNum = ScoutingPlayerNum;
	params.SessionName = SessionName;
	params.NewGameSettings = NewGameSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearJoinOnlineGameCompleteDelegate
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         JoinOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearJoinOnlineGameCompleteDelegate(const struct FScriptDelegate& JoinOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearJoinOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearJoinOnlineGameCompleteDelegate_Params params;
	params.JoinOnlineGameCompleteDelegate = JoinOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddJoinOnlineGameCompleteDelegate
// (Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         JoinOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddJoinOnlineGameCompleteDelegate(const struct FScriptDelegate& JoinOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddJoinOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddJoinOnlineGameCompleteDelegate_Params params;
	params.JoinOnlineGameCompleteDelegate = JoinOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnJoinOnlineGameComplete
// (Defined, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnJoinOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnJoinOnlineGameComplete"));

	UOnlineGameInterface_OnJoinOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.IsCurrentRoomOwner
// (Final, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_IsCurrentRoomOwner()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.IsCurrentRoomOwner"));

	UOnlineGameInterface_IsCurrentRoomOwner_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.SetRankedReadyStatus
// (Latent, Net, Event, HasOptionalParms)
// Parameters:
// bool                           bReady                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::SetRankedReadyStatus(bool bReady)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.SetRankedReadyStatus"));

	UOnlineGameInterface_SetRankedReadyStatus_Params params;
	params.bReady = bReady;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.IsJoinOperationInProgress
// (Final, Latent, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_IsJoinOperationInProgress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.IsJoinOperationInProgress"));

	UOnlineGameInterface_IsJoinOperationInProgress_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.JoinOnlineGameByMatchingParams
// (PreOperator, Singular, Simulated, Exec, Operator, Static)
// Parameters:
// struct FQWord                  RoomId                         (Parm)
// class UOnlineGameSettings*     JoinedGameSettings             (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_JoinOnlineGameByMatchingParams(const struct FQWord& RoomId, class UOnlineGameSettings** JoinedGameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.JoinOnlineGameByMatchingParams"));

	UOnlineGameInterface_JoinOnlineGameByMatchingParams_Params params;
	params.RoomId = RoomId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (JoinedGameSettings != nullptr)
		*JoinedGameSettings = params.JoinedGameSettings;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.OnMapChangeComplete
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Native, Event, Operator, Static)

void UOnlineGameInterface::STATIC_OnMapChangeComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMapChangeComplete"));

	UOnlineGameInterface_OnMapChangeComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnMapChangePending
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Native, Event, Operator, Static)

void UOnlineGameInterface::STATIC_OnMapChangePending()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnMapChangePending"));

	UOnlineGameInterface_OnMapChangePending_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.JoinOnlineGameBySessionHandle
// (Final, PreOperator, Singular, Simulated, Exec, Operator, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FName                   SessionName                    (Parm)
// struct FString                 InSessionGuid                  (Const, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_JoinOnlineGameBySessionHandle(unsigned char PlayerNum, const struct FName& SessionName, const struct FString& InSessionGuid)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.JoinOnlineGameBySessionHandle"));

	UOnlineGameInterface_JoinOnlineGameBySessionHandle_Params params;
	params.PlayerNum = PlayerNum;
	params.SessionName = SessionName;
	params.InSessionGuid = InSessionGuid;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.JoinOnlineGame
// (Final, Defined, Iterator, Latent, Singular, Simulated, Exec, Operator, Static)
// Parameters:
// unsigned char                  PlayerNum                      (Parm)
// struct FName                   SessionName                    (Parm)
// struct FOnlineGameSearchResult DesiredGame                    (Const, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_JoinOnlineGame(unsigned char PlayerNum, const struct FName& SessionName, struct FOnlineGameSearchResult* DesiredGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.JoinOnlineGame"));

	UOnlineGameInterface_JoinOnlineGame_Params params;
	params.PlayerNum = PlayerNum;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DesiredGame != nullptr)
		*DesiredGame = params.DesiredGame;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.QueryNonAdvertisedData
// (Iterator, NetReliable, Exec, HasOptionalParms)
// Parameters:
// int                            StartAt                        (Parm)
// int                            NumberToQuery                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::QueryNonAdvertisedData(int StartAt, int NumberToQuery)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.QueryNonAdvertisedData"));

	UOnlineGameInterface_QueryNonAdvertisedData_Params params;
	params.StartAt = StartAt;
	params.NumberToQuery = NumberToQuery;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.FreeSearchResults
// (Final, Latent, PreOperator, Singular, Native, Event, Static)
// Parameters:
// class UOnlineGameSearch*       Search                         (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_FreeSearchResults(class UOnlineGameSearch* Search)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.FreeSearchResults"));

	UOnlineGameInterface_FreeSearchResults_Params params;
	params.Search = Search;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.GetGameSearch
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// class UOnlineGameSearch*       ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineGameSearch* UOnlineGameInterface::STATIC_GetGameSearch()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetGameSearch"));

	UOnlineGameInterface_GetGameSearch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.BindPlatformSpecificSessionToSearch
// (Final, Singular, Net, NetReliable, Exec, Native, Operator)
// Parameters:
// unsigned char                  SearchingPlayerNum             (Parm)
// class UOnlineGameSearch*       SearchSettings                 (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::BindPlatformSpecificSessionToSearch(unsigned char SearchingPlayerNum, class UOnlineGameSearch* SearchSettings, unsigned char PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.BindPlatformSpecificSessionToSearch"));

	UOnlineGameInterface_BindPlatformSpecificSessionToSearch_Params params;
	params.SearchingPlayerNum = SearchingPlayerNum;
	params.SearchSettings = SearchSettings;
	params.PlatformSpecificInfo = PlatformSpecificInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ReadPlatformSpecificSessionInfoBySessionName
// (Defined, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// unsigned char                  PlatformSpecificInfo           (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::ReadPlatformSpecificSessionInfoBySessionName(const struct FName& SessionName, unsigned char* PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ReadPlatformSpecificSessionInfoBySessionName"));

	UOnlineGameInterface_ReadPlatformSpecificSessionInfoBySessionName_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlatformSpecificInfo != nullptr)
		*PlatformSpecificInfo = params.PlatformSpecificInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ReadPlatformSpecificSessionInfo
// (Final, Net, Simulated, Exec, HasOptionalParms)
// Parameters:
// struct FOnlineGameSearchResult DesiredGame                    (Const, Parm, OutParm)
// unsigned char                  PlatformSpecificInfo           (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::ReadPlatformSpecificSessionInfo(struct FOnlineGameSearchResult* DesiredGame, unsigned char* PlatformSpecificInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ReadPlatformSpecificSessionInfo"));

	UOnlineGameInterface_ReadPlatformSpecificSessionInfo_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DesiredGame != nullptr)
		*DesiredGame = params.DesiredGame;
	if (PlatformSpecificInfo != nullptr)
		*PlatformSpecificInfo = params.PlatformSpecificInfo;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearQosStatusChangedDelegate
// (Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         QosStatusChangedDelegate       (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearQosStatusChangedDelegate(const struct FScriptDelegate& QosStatusChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearQosStatusChangedDelegate"));

	UOnlineGameInterface_ClearQosStatusChangedDelegate_Params params;
	params.QosStatusChangedDelegate = QosStatusChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddQosStatusChangedDelegate
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         QosStatusChangedDelegate       (Parm, NeedCtorLink)

void UOnlineGameInterface::AddQosStatusChangedDelegate(const struct FScriptDelegate& QosStatusChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddQosStatusChangedDelegate"));

	UOnlineGameInterface_AddQosStatusChangedDelegate_Params params;
	params.QosStatusChangedDelegate = QosStatusChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnQosStatusChanged
// (Final, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            NumComplete                    (Parm)
// int                            NumTotal                       (Parm)

void UOnlineGameInterface::OnQosStatusChanged(int NumComplete, int NumTotal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnQosStatusChanged"));

	UOnlineGameInterface_OnQosStatusChanged_Params params;
	params.NumComplete = NumComplete;
	params.NumTotal = NumTotal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.ClearCancelFindOnlineGamesCompleteDelegate
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         CancelFindOnlineGamesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearCancelFindOnlineGamesCompleteDelegate(const struct FScriptDelegate& CancelFindOnlineGamesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearCancelFindOnlineGamesCompleteDelegate"));

	UOnlineGameInterface_ClearCancelFindOnlineGamesCompleteDelegate_Params params;
	params.CancelFindOnlineGamesCompleteDelegate = CancelFindOnlineGamesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddCancelFindOnlineGamesCompleteDelegate
// (Final, Iterator, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         CancelFindOnlineGamesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddCancelFindOnlineGamesCompleteDelegate(const struct FScriptDelegate& CancelFindOnlineGamesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddCancelFindOnlineGamesCompleteDelegate"));

	UOnlineGameInterface_AddCancelFindOnlineGamesCompleteDelegate_Params params;
	params.CancelFindOnlineGamesCompleteDelegate = CancelFindOnlineGamesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnCancelFindOnlineGamesComplete
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnCancelFindOnlineGamesComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnCancelFindOnlineGamesComplete"));

	UOnlineGameInterface_OnCancelFindOnlineGamesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.CancelFindOnlineGames
// (Latent, PreOperator, Singular, Exec, Native, Event, Operator)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::CancelFindOnlineGames()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.CancelFindOnlineGames"));

	UOnlineGameInterface_CancelFindOnlineGames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearFindOnlineGamesCompleteDelegate
// (Final, Latent, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         FindOnlineGamesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearFindOnlineGamesCompleteDelegate(const struct FScriptDelegate& FindOnlineGamesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearFindOnlineGamesCompleteDelegate"));

	UOnlineGameInterface_ClearFindOnlineGamesCompleteDelegate_Params params;
	params.FindOnlineGamesCompleteDelegate = FindOnlineGamesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddFindOnlineGamesCompleteDelegate
// (Defined, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         FindOnlineGamesCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddFindOnlineGamesCompleteDelegate(const struct FScriptDelegate& FindOnlineGamesCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddFindOnlineGamesCompleteDelegate"));

	UOnlineGameInterface_AddFindOnlineGamesCompleteDelegate_Params params;
	params.FindOnlineGamesCompleteDelegate = FindOnlineGamesCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnFindOnlineGamesComplete
// (Final, Defined, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnFindOnlineGamesComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnFindOnlineGamesComplete"));

	UOnlineGameInterface_OnFindOnlineGamesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.FindOnlineGames
// (Defined, Singular, NetReliable, Exec, Event, Static)
// Parameters:
// unsigned char                  SearchingPlayerNum             (Parm)
// class UOnlineGameSearch*       SearchSettings                 (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_FindOnlineGames(unsigned char SearchingPlayerNum, class UOnlineGameSearch* SearchSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.FindOnlineGames"));

	UOnlineGameInterface_FindOnlineGames_Params params;
	params.SearchingPlayerNum = SearchingPlayerNum;
	params.SearchSettings = SearchSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearDestroyOnlineGameCompleteDelegate
// (Final, Defined, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         DestroyOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearDestroyOnlineGameCompleteDelegate(const struct FScriptDelegate& DestroyOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearDestroyOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearDestroyOnlineGameCompleteDelegate_Params params;
	params.DestroyOnlineGameCompleteDelegate = DestroyOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddDestroyOnlineGameCompleteDelegate
// (Final, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         DestroyOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddDestroyOnlineGameCompleteDelegate(const struct FScriptDelegate& DestroyOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddDestroyOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddDestroyOnlineGameCompleteDelegate_Params params;
	params.DestroyOnlineGameCompleteDelegate = DestroyOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnDestroyOnlineGameComplete
// (Final, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnDestroyOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnDestroyOnlineGameComplete"));

	UOnlineGameInterface_OnDestroyOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.DestroyOnlineGame
// (Defined, Latent, PreOperator, Singular, NetReliable, Native, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_DestroyOnlineGame(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.DestroyOnlineGame"));

	UOnlineGameInterface_DestroyOnlineGame_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.GetGameSettings
// (Final, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineGameSettings* UOnlineGameInterface::STATIC_GetGameSettings(const struct FName& SessionName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.GetGameSettings"));

	UOnlineGameInterface_GetGameSettings_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearUpdateOnlineGameCompleteDelegate
// (Final, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UpdateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearUpdateOnlineGameCompleteDelegate(const struct FScriptDelegate& UpdateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearUpdateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearUpdateOnlineGameCompleteDelegate_Params params;
	params.UpdateOnlineGameCompleteDelegate = UpdateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddUpdateOnlineGameCompleteDelegate
// (Final, Defined, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UpdateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddUpdateOnlineGameCompleteDelegate(const struct FScriptDelegate& UpdateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddUpdateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddUpdateOnlineGameCompleteDelegate_Params params;
	params.UpdateOnlineGameCompleteDelegate = UpdateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnUpdateOnlineGameComplete
// (PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnUpdateOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnUpdateOnlineGameComplete"));

	UOnlineGameInterface_OnUpdateOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.UpdateOnlineGame
// (Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     UpdatedGameSettings            (Parm)
// bool                           bShouldRefreshOnlineData       (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::UpdateOnlineGame(const struct FName& SessionName, class UOnlineGameSettings* UpdatedGameSettings, bool bShouldRefreshOnlineData)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.UpdateOnlineGame"));

	UOnlineGameInterface_UpdateOnlineGame_Params params;
	params.SessionName = SessionName;
	params.UpdatedGameSettings = UpdatedGameSettings;
	params.bShouldRefreshOnlineData = bShouldRefreshOnlineData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameInterface.ClearCreateOnlineGameCompleteDelegate
// (Defined, Iterator, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         CreateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::ClearCreateOnlineGameCompleteDelegate(const struct FScriptDelegate& CreateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.ClearCreateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_ClearCreateOnlineGameCompleteDelegate_Params params;
	params.CreateOnlineGameCompleteDelegate = CreateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.AddCreateOnlineGameCompleteDelegate
// (Defined, Iterator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         CreateOnlineGameCompleteDelegate (Parm, NeedCtorLink)

void UOnlineGameInterface::AddCreateOnlineGameCompleteDelegate(const struct FScriptDelegate& CreateOnlineGameCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.AddCreateOnlineGameCompleteDelegate"));

	UOnlineGameInterface_AddCreateOnlineGameCompleteDelegate_Params params;
	params.CreateOnlineGameCompleteDelegate = CreateOnlineGameCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.OnCreateOnlineGameComplete
// (Final, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlineGameInterface::OnCreateOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.OnCreateOnlineGameComplete"));

	UOnlineGameInterface_OnCreateOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameInterface.CreateOnlineGame
// (Iterator, Latent, Exec, Static)
// Parameters:
// unsigned char                  HostingPlayerNum               (Parm)
// struct FName                   SessionName                    (Parm)
// class UOnlineGameSettings*     NewGameSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameInterface::STATIC_CreateOnlineGame(unsigned char HostingPlayerNum, const struct FName& SessionName, class UOnlineGameSettings* NewGameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameInterface.CreateOnlineGame"));

	UOnlineGameInterface_CreateOnlineGame_Params params;
	params.HostingPlayerNum = HostingPlayerNum;
	params.SessionName = SessionName;
	params.NewGameSettings = NewGameSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.GetLocale
// (Final, Defined, Iterator, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineSystemInterface::STATIC_GetLocale()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.GetLocale"));

	UOnlineSystemInterface_GetLocale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.ClearStorageDeviceChangeDelegate
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         StorageDeviceChangeDelegate    (Parm, NeedCtorLink)

void UOnlineSystemInterface::ClearStorageDeviceChangeDelegate(const struct FScriptDelegate& StorageDeviceChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.ClearStorageDeviceChangeDelegate"));

	UOnlineSystemInterface_ClearStorageDeviceChangeDelegate_Params params;
	params.StorageDeviceChangeDelegate = StorageDeviceChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.AddStorageDeviceChangeDelegate
// (Defined, Iterator, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         StorageDeviceChangeDelegate    (Parm, NeedCtorLink)

void UOnlineSystemInterface::AddStorageDeviceChangeDelegate(const struct FScriptDelegate& StorageDeviceChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.AddStorageDeviceChangeDelegate"));

	UOnlineSystemInterface_AddStorageDeviceChangeDelegate_Params params;
	params.StorageDeviceChangeDelegate = StorageDeviceChangeDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.OnStorageDeviceChange
// (Final, Defined, Iterator, Latent, Exec, Native, Event, Static)

void UOnlineSystemInterface::STATIC_OnStorageDeviceChange()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.OnStorageDeviceChange"));

	UOnlineSystemInterface_OnStorageDeviceChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.GetNATType
// (Final, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<ENATType>          ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENATType> UOnlineSystemInterface::GetNATType()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.GetNATType"));

	UOnlineSystemInterface_GetNATType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.ClearConnectionStatusChangeDelegate
// (Final, Defined, Iterator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ConnectionStatusDelegate       (Parm, NeedCtorLink)

void UOnlineSystemInterface::ClearConnectionStatusChangeDelegate(const struct FScriptDelegate& ConnectionStatusDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.ClearConnectionStatusChangeDelegate"));

	UOnlineSystemInterface_ClearConnectionStatusChangeDelegate_Params params;
	params.ConnectionStatusDelegate = ConnectionStatusDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.AddConnectionStatusChangeDelegate
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ConnectionStatusDelegate       (Parm, NeedCtorLink)

void UOnlineSystemInterface::AddConnectionStatusChangeDelegate(const struct FScriptDelegate& ConnectionStatusDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.AddConnectionStatusChangeDelegate"));

	UOnlineSystemInterface_AddConnectionStatusChangeDelegate_Params params;
	params.ConnectionStatusDelegate = ConnectionStatusDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.OnConnectionStatusChange
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EOnlineServerConnectionStatus> ConnectionStatus               (Parm)

void UOnlineSystemInterface::STATIC_OnConnectionStatusChange(TEnumAsByte<EOnlineServerConnectionStatus> ConnectionStatus)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.OnConnectionStatusChange"));

	UOnlineSystemInterface_OnConnectionStatusChange_Params params;
	params.ConnectionStatus = ConnectionStatus;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.GetCurrentConnectionStatus
// (Final, Iterator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EOnlineServerConnectionStatus> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineServerConnectionStatus> UOnlineSystemInterface::STATIC_GetCurrentConnectionStatus()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.GetCurrentConnectionStatus"));

	UOnlineSystemInterface_GetCurrentConnectionStatus_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.IsControllerConnected
// (Defined, Iterator, Latent, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSystemInterface::STATIC_IsControllerConnected(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.IsControllerConnected"));

	UOnlineSystemInterface_IsControllerConnected_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.ClearControllerChangeDelegate
// (Iterator, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ControllerChangeDelegate       (Parm, NeedCtorLink)

void UOnlineSystemInterface::ClearControllerChangeDelegate(const struct FScriptDelegate& ControllerChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.ClearControllerChangeDelegate"));

	UOnlineSystemInterface_ClearControllerChangeDelegate_Params params;
	params.ControllerChangeDelegate = ControllerChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.AddControllerChangeDelegate
// (Final, Defined, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ControllerChangeDelegate       (Parm, NeedCtorLink)

void UOnlineSystemInterface::AddControllerChangeDelegate(const struct FScriptDelegate& ControllerChangeDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.AddControllerChangeDelegate"));

	UOnlineSystemInterface_AddControllerChangeDelegate_Params params;
	params.ControllerChangeDelegate = ControllerChangeDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.OnControllerChange
// (Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ControllerId                   (Parm)
// bool                           bIsConnected                   (Parm)
// bool                           bPauseGame                     (Parm)

void UOnlineSystemInterface::STATIC_OnControllerChange(int ControllerId, bool bIsConnected, bool bPauseGame)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.OnControllerChange"));

	UOnlineSystemInterface_OnControllerChange_Params params;
	params.ControllerId = ControllerId;
	params.bIsConnected = bIsConnected;
	params.bPauseGame = bPauseGame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.SetNetworkNotificationPosition
// (Defined, Iterator, PreOperator, Event, HasOptionalParms)
// Parameters:
// TEnumAsByte<ENetworkNotificationPosition> NewPos                         (Parm)

void UOnlineSystemInterface::SetNetworkNotificationPosition(TEnumAsByte<ENetworkNotificationPosition> NewPos)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.SetNetworkNotificationPosition"));

	UOnlineSystemInterface_SetNetworkNotificationPosition_Params params;
	params.NewPos = NewPos;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.GetNetworkNotificationPosition
// (Defined, Net, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<ENetworkNotificationPosition> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<ENetworkNotificationPosition> UOnlineSystemInterface::STATIC_GetNetworkNotificationPosition()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.GetNetworkNotificationPosition"));

	UOnlineSystemInterface_GetNetworkNotificationPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSystemInterface.ClearExternalUIChangeDelegate
// (Iterator, Singular, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ExternalUIDelegate             (Parm, NeedCtorLink)

void UOnlineSystemInterface::ClearExternalUIChangeDelegate(const struct FScriptDelegate& ExternalUIDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.ClearExternalUIChangeDelegate"));

	UOnlineSystemInterface_ClearExternalUIChangeDelegate_Params params;
	params.ExternalUIDelegate = ExternalUIDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.AddExternalUIChangeDelegate
// (Final, Iterator, PreOperator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         ExternalUIDelegate             (Parm, NeedCtorLink)

void UOnlineSystemInterface::AddExternalUIChangeDelegate(const struct FScriptDelegate& ExternalUIDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.AddExternalUIChangeDelegate"));

	UOnlineSystemInterface_AddExternalUIChangeDelegate_Params params;
	params.ExternalUIDelegate = ExternalUIDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.OnExternalUIChange
// (Iterator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bIsOpening                     (Parm)

void UOnlineSystemInterface::STATIC_OnExternalUIChange(bool bIsOpening)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.OnExternalUIChange"));

	UOnlineSystemInterface_OnExternalUIChange_Params params;
	params.bIsOpening = bIsOpening;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.ClearLinkStatusChangeDelegate
// (NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         LinkStatusDelegate             (Parm, NeedCtorLink)

void UOnlineSystemInterface::ClearLinkStatusChangeDelegate(const struct FScriptDelegate& LinkStatusDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.ClearLinkStatusChangeDelegate"));

	UOnlineSystemInterface_ClearLinkStatusChangeDelegate_Params params;
	params.LinkStatusDelegate = LinkStatusDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.AddLinkStatusChangeDelegate
// (Final, Defined, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         LinkStatusDelegate             (Parm, NeedCtorLink)

void UOnlineSystemInterface::AddLinkStatusChangeDelegate(const struct FScriptDelegate& LinkStatusDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.AddLinkStatusChangeDelegate"));

	UOnlineSystemInterface_AddLinkStatusChangeDelegate_Params params;
	params.LinkStatusDelegate = LinkStatusDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.OnLinkStatusChange
// (Final, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bIsConnected                   (Parm)

void UOnlineSystemInterface::STATIC_OnLinkStatusChange(bool bIsConnected)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.OnLinkStatusChange"));

	UOnlineSystemInterface_OnLinkStatusChange_Params params;
	params.bIsConnected = bIsConnected;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSystemInterface.HasLinkConnection
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSystemInterface::HasLinkConnection()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSystemInterface.HasLinkConnection"));

	UOnlineSystemInterface_HasLinkConnection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.SetMarketplaceVisibility
// (Final, Defined, Iterator, Native, Event, HasOptionalParms)
// Parameters:
// bool                           Visible                        (Parm)
// unsigned char                  IconPosition                   (Parm)

void UOnlineMarketplaceInterface::SetMarketplaceVisibility(bool Visible, unsigned char IconPosition)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.SetMarketplaceVisibility"));

	UOnlineMarketplaceInterface_SetMarketplaceVisibility_Params params;
	params.Visible = Visible;
	params.IconPosition = IconPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ClearMarketplaceItemPurchasedDelegate
// (Latent, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearMarketplaceItemPurchasedDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearMarketplaceItemPurchasedDelegate"));

	UOnlineMarketplaceInterface_ClearMarketplaceItemPurchasedDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddMarketplaceItemPurchasedDelegate
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddMarketplaceItemPurchasedDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddMarketplaceItemPurchasedDelegate"));

	UOnlineMarketplaceInterface_AddMarketplaceItemPurchasedDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.OnMarketplaceItemPurchased
// (Final, Singular, Exec, Native, Event, Static)

void UOnlineMarketplaceInterface::STATIC_OnMarketplaceItemPurchased()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnMarketplaceItemPurchased"));

	UOnlineMarketplaceInterface_OnMarketplaceItemPurchased_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ClearConsumeInventoryItemCompleteDelegate
// (Final, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ConsumeInventoryItemCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearConsumeInventoryItemCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ConsumeInventoryItemCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearConsumeInventoryItemCompleteDelegate"));

	UOnlineMarketplaceInterface_ClearConsumeInventoryItemCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ConsumeInventoryItemCompleteDelegate = ConsumeInventoryItemCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddConsumeInventoryItemCompleteDelegate
// (NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ConsumeInventoryItemCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddConsumeInventoryItemCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ConsumeInventoryItemCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddConsumeInventoryItemCompleteDelegate"));

	UOnlineMarketplaceInterface_AddConsumeInventoryItemCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ConsumeInventoryItemCompleteDelegate = ConsumeInventoryItemCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.OnConsumeInventoryItemComplete
// (Singular, Exec, Native, Event, Static)
// Parameters:
// struct FString                 ProductID                      (Parm, NeedCtorLink)
// bool                           bDidSucceed                    (Parm)
// int                            NewQuantity                    (Parm)

void UOnlineMarketplaceInterface::STATIC_OnConsumeInventoryItemComplete(const struct FString& ProductID, bool bDidSucceed, int NewQuantity)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnConsumeInventoryItemComplete"));

	UOnlineMarketplaceInterface_OnConsumeInventoryItemComplete_Params params;
	params.ProductID = ProductID;
	params.bDidSucceed = bDidSucceed;
	params.NewQuantity = NewQuantity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ConsumeInventoryItem
// (Defined, Iterator, Latent, NetReliable, Simulated, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 ProductID                      (Parm, NeedCtorLink)
// int                            Quantity                       (Parm)
// struct FString                 TransactionId                  (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineMarketplaceInterface::STATIC_ConsumeInventoryItem(unsigned char LocalUserNum, const struct FString& ProductID, int Quantity, const struct FString& TransactionId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ConsumeInventoryItem"));

	UOnlineMarketplaceInterface_ConsumeInventoryItem_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProductID = ProductID;
	params.Quantity = Quantity;
	params.TransactionId = TransactionId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.ResetInventoryItems
// (Final, Defined, Iterator, Latent, PreOperator, Singular, Net, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)

void UOnlineMarketplaceInterface::ResetInventoryItems(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ResetInventoryItems"));

	UOnlineMarketplaceInterface_ResetInventoryItems_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.GetInventoryItems
// (Final, Defined, Latent, Singular, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FMarketplaceInventoryItem> InventoryItems                 (Parm, OutParm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineMarketplaceInterface::GetInventoryItems(unsigned char LocalUserNum, TArray<struct FMarketplaceInventoryItem>* InventoryItems)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.GetInventoryItems"));

	UOnlineMarketplaceInterface_GetInventoryItems_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InventoryItems != nullptr)
		*InventoryItems = params.InventoryItems;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.ClearReadInventoryItemsCompleteDelegate
// (Final, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadInventoryItemsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearReadInventoryItemsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadInventoryItemsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearReadInventoryItemsCompleteDelegate"));

	UOnlineMarketplaceInterface_ClearReadInventoryItemsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadInventoryItemsCompleteDelegate = ReadInventoryItemsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddReadInventoryItemsCompleteDelegate
// (Defined, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadInventoryItemsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddReadInventoryItemsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadInventoryItemsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddReadInventoryItemsCompleteDelegate"));

	UOnlineMarketplaceInterface_AddReadInventoryItemsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadInventoryItemsCompleteDelegate = ReadInventoryItemsCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.OnReadInventoryItemsComplete
// (Final, Iterator, Singular, Exec, Native, Event, Static)

void UOnlineMarketplaceInterface::STATIC_OnReadInventoryItemsComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnReadInventoryItemsComplete"));

	UOnlineMarketplaceInterface_OnReadInventoryItemsComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ReadInventoryItems
// (Iterator, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineMarketplaceInterface::ReadInventoryItems(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ReadInventoryItems"));

	UOnlineMarketplaceInterface_ReadInventoryItems_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.ClearReadDetailsForProductIdListCompleteDelegate
// (Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearReadDetailsForProductIdListCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearReadDetailsForProductIdListCompleteDelegate"));

	UOnlineMarketplaceInterface_ClearReadDetailsForProductIdListCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddReadDetailsForProductIdListCompleteDelegate
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddReadDetailsForProductIdListCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddReadDetailsForProductIdListCompleteDelegate"));

	UOnlineMarketplaceInterface_AddReadDetailsForProductIdListCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ReadDetailsForProductIdList
// (Iterator, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FString>         ProductIds                     (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineMarketplaceInterface::ReadDetailsForProductIdList(unsigned char LocalUserNum, TArray<struct FString> ProductIds)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ReadDetailsForProductIdList"));

	UOnlineMarketplaceInterface_ReadDetailsForProductIdList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProductIds = ProductIds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.OnReadDetailsForProductIdList
// (Iterator, Singular, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FMarketplaceProductDetails> ProductList                    (Parm, OutParm, NeedCtorLink)

void UOnlineMarketplaceInterface::STATIC_OnReadDetailsForProductIdList(TArray<struct FMarketplaceProductDetails>* ProductList)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnReadDetailsForProductIdList"));

	UOnlineMarketplaceInterface_OnReadDetailsForProductIdList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ProductList != nullptr)
		*ProductList = params.ProductList;
}


// Function Engine.OnlineMarketplaceInterface.ClearReadAdditionalProductDetailsCompleteDelegate
// (Final, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAdditionalProductDetailsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearReadAdditionalProductDetailsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAdditionalProductDetailsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearReadAdditionalProductDetailsCompleteDelegate"));

	UOnlineMarketplaceInterface_ClearReadAdditionalProductDetailsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAdditionalProductDetailsCompleteDelegate = ReadAdditionalProductDetailsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddReadAdditionalProductDetailsCompleteDelegate
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAdditionalProductDetailsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddReadAdditionalProductDetailsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAdditionalProductDetailsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddReadAdditionalProductDetailsCompleteDelegate"));

	UOnlineMarketplaceInterface_AddReadAdditionalProductDetailsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAdditionalProductDetailsCompleteDelegate = ReadAdditionalProductDetailsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.OnReadAdditionalProductDetailsComplete
// (Defined, Singular, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<EMediaItemType>    MediaType                      (Parm)

void UOnlineMarketplaceInterface::STATIC_OnReadAdditionalProductDetailsComplete(TEnumAsByte<EMediaItemType> MediaType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnReadAdditionalProductDetailsComplete"));

	UOnlineMarketplaceInterface_OnReadAdditionalProductDetailsComplete_Params params;
	params.MediaType = MediaType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ReadAdditionalDetailsForProducts
// (Final, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EMediaItemType>    MediaType                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineMarketplaceInterface::ReadAdditionalDetailsForProducts(unsigned char LocalUserNum, TEnumAsByte<EMediaItemType> MediaType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ReadAdditionalDetailsForProducts"));

	UOnlineMarketplaceInterface_ReadAdditionalDetailsForProducts_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MediaType = MediaType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.ResetAvailableProducts
// (Final, Defined, PreOperator, Singular, Net, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EMediaItemType>    MediaType                      (Parm)

void UOnlineMarketplaceInterface::ResetAvailableProducts(unsigned char LocalUserNum, TEnumAsByte<EMediaItemType> MediaType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ResetAvailableProducts"));

	UOnlineMarketplaceInterface_ResetAvailableProducts_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MediaType = MediaType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.GetAvailableProducts
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TEnumAsByte<EMediaItemType>    MediaType                      (Parm)
// TArray<struct FMarketplaceProductDetails> AvailableProducts              (Parm, OutParm, NeedCtorLink)
// TEnumAsByte<EOnlineEnumerationReadState> ReturnValue                    (Parm, OutParm, ReturnParm)

TEnumAsByte<EOnlineEnumerationReadState> UOnlineMarketplaceInterface::STATIC_GetAvailableProducts(unsigned char LocalUserNum, TEnumAsByte<EMediaItemType> MediaType, TArray<struct FMarketplaceProductDetails>* AvailableProducts)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.GetAvailableProducts"));

	UOnlineMarketplaceInterface_GetAvailableProducts_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MediaType = MediaType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (AvailableProducts != nullptr)
		*AvailableProducts = params.AvailableProducts;

	return params.ReturnValue;
}


// Function Engine.OnlineMarketplaceInterface.ClearReadAvailableProductsCompleteDelegate
// (Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAvailableProductsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::ClearReadAvailableProductsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAvailableProductsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ClearReadAvailableProductsCompleteDelegate"));

	UOnlineMarketplaceInterface_ClearReadAvailableProductsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAvailableProductsCompleteDelegate = ReadAvailableProductsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.AddReadAvailableProductsCompleteDelegate
// (Final, Defined, Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadAvailableProductsCompleteDelegate (Parm, NeedCtorLink)

void UOnlineMarketplaceInterface::AddReadAvailableProductsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadAvailableProductsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.AddReadAvailableProductsCompleteDelegate"));

	UOnlineMarketplaceInterface_AddReadAvailableProductsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadAvailableProductsCompleteDelegate = ReadAvailableProductsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.OnReadAvailableProductsComplete
// (Final, Defined, Singular, Exec, Native, Event, Static)
// Parameters:
// TEnumAsByte<EMediaItemType>    MediaType                      (Parm)

void UOnlineMarketplaceInterface::STATIC_OnReadAvailableProductsComplete(TEnumAsByte<EMediaItemType> MediaType)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.OnReadAvailableProductsComplete"));

	UOnlineMarketplaceInterface_OnReadAvailableProductsComplete_Params params;
	params.MediaType = MediaType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineMarketplaceInterface.ReadAvailableProducts
// (Final, Defined, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 ParentId                       (Parm, NeedCtorLink)
// TEnumAsByte<EMediaItemType>    ParentMediaType                (OptionalParm, Parm)
// TEnumAsByte<EMediaItemType>    ChildMediaType                 (OptionalParm, Parm)
// TEnumAsByte<ECatalogSortOrder> SortOrder                      (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineMarketplaceInterface::ReadAvailableProducts(unsigned char LocalUserNum, const struct FString& ParentId, TEnumAsByte<EMediaItemType> ParentMediaType, TEnumAsByte<EMediaItemType> ChildMediaType, TEnumAsByte<ECatalogSortOrder> SortOrder)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineMarketplaceInterface.ReadAvailableProducts"));

	UOnlineMarketplaceInterface_ReadAvailableProducts_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ParentId = ParentId;
	params.ParentMediaType = ParentMediaType;
	params.ChildMediaType = ChildMediaType;
	params.SortOrder = SortOrder;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.SendReputationFeedback
// (Defined, Iterator, PreOperator, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  SenderLocalUserNum             (Parm)
// struct FUniqueNetId            ReputeeNetId                   (Parm)
// TEnumAsByte<EReputationFeedbackType> FeedbackType                   (Parm)
// struct FString                 ReportText                     (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::SendReputationFeedback(unsigned char SenderLocalUserNum, const struct FUniqueNetId& ReputeeNetId, TEnumAsByte<EReputationFeedbackType> FeedbackType, const struct FString& ReportText)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.SendReputationFeedback"));

	UOnlinePlayerInterfaceEx_SendReputationFeedback_Params params;
	params.SenderLocalUserNum = SenderLocalUserNum;
	params.ReputeeNetId = ReputeeNetId;
	params.FeedbackType = FeedbackType;
	params.ReportText = ReportText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearUnregisterRemoteTalkerCompleteDelegate
// (Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterRemoteTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearUnregisterRemoteTalkerCompleteDelegate(const struct FScriptDelegate& UnregisterRemoteTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearUnregisterRemoteTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearUnregisterRemoteTalkerCompleteDelegate_Params params;
	params.UnregisterRemoteTalkerCompleteDelegate = UnregisterRemoteTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddUnregisterRemoteTalkerCompleteDelegate
// (Defined, Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterRemoteTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddUnregisterRemoteTalkerCompleteDelegate(const struct FScriptDelegate& UnregisterRemoteTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddUnregisterRemoteTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddUnregisterRemoteTalkerCompleteDelegate_Params params;
	params.UnregisterRemoteTalkerCompleteDelegate = UnregisterRemoteTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnUnregisterRemoteTalkerComplete
// (Iterator, PreOperator, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            RemoteNetId                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnUnregisterRemoteTalkerComplete(const struct FUniqueNetId& RemoteNetId, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnUnregisterRemoteTalkerComplete"));

	UOnlinePlayerInterfaceEx_OnUnregisterRemoteTalkerComplete_Params params;
	params.RemoteNetId = RemoteNetId;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearUnregisterLocalTalkerCompleteDelegate
// (Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterLocalTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearUnregisterLocalTalkerCompleteDelegate(const struct FScriptDelegate& UnregisterLocalTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearUnregisterLocalTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearUnregisterLocalTalkerCompleteDelegate_Params params;
	params.UnregisterLocalTalkerCompleteDelegate = UnregisterLocalTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddUnregisterLocalTalkerCompleteDelegate
// (Latent, PreOperator, Singular, Operator)
// Parameters:
// struct FScriptDelegate         UnregisterLocalTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddUnregisterLocalTalkerCompleteDelegate(const struct FScriptDelegate& UnregisterLocalTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddUnregisterLocalTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddUnregisterLocalTalkerCompleteDelegate_Params params;
	params.UnregisterLocalTalkerCompleteDelegate = UnregisterLocalTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnUnregisterLocalTalkerComplete
// (Final, Defined, PreOperator, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnUnregisterLocalTalkerComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnUnregisterLocalTalkerComplete"));

	UOnlinePlayerInterfaceEx_OnUnregisterLocalTalkerComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearRegisterLocalTalkerCompleteDelegate
// (Iterator, Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         RegisterLocalTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearRegisterLocalTalkerCompleteDelegate(const struct FScriptDelegate& RegisterLocalTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearRegisterLocalTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearRegisterLocalTalkerCompleteDelegate_Params params;
	params.RegisterLocalTalkerCompleteDelegate = RegisterLocalTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddRegisterLocalTalkerCompleteDelegate
// (Final, Defined, PreOperator, Operator)
// Parameters:
// struct FScriptDelegate         RegisterLocalTalkerCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddRegisterLocalTalkerCompleteDelegate(const struct FScriptDelegate& RegisterLocalTalkerCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddRegisterLocalTalkerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddRegisterLocalTalkerCompleteDelegate_Params params;
	params.RegisterLocalTalkerCompleteDelegate = RegisterLocalTalkerCompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnRegisterLocalTalkerComplete
// (Final, Latent, Exec, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnRegisterLocalTalkerComplete(unsigned char LocalUserNum, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnRegisterLocalTalkerComplete"));

	UOnlinePlayerInterfaceEx_OnRegisterLocalTalkerComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearReadOnlineProfilesCompleteDelegate
// (Final, Defined, Latent, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ReadOnlineProfileDelegate      (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearReadOnlineProfilesCompleteDelegate(const struct FScriptDelegate& ReadOnlineProfileDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearReadOnlineProfilesCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearReadOnlineProfilesCompleteDelegate_Params params;
	params.ReadOnlineProfileDelegate = ReadOnlineProfileDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddReadOnlineProfilesCompleteDelegate
// (Iterator, Operator)
// Parameters:
// struct FScriptDelegate         ReadOnlineProfileDelegate      (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddReadOnlineProfilesCompleteDelegate(const struct FScriptDelegate& ReadOnlineProfileDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddReadOnlineProfilesCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddReadOnlineProfilesCompleteDelegate_Params params;
	params.ReadOnlineProfileDelegate = ReadOnlineProfileDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnReadOnlineProfilesComplete
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TArray<struct FString>         PlayerIDs                      (Parm, NeedCtorLink)
// TArray<struct FOnlineProfile>  OnlineProfiles                 (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::STATIC_OnReadOnlineProfilesComplete(bool bWasSuccessful, TArray<struct FString> PlayerIDs, TArray<struct FOnlineProfile> OnlineProfiles)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnReadOnlineProfilesComplete"));

	UOnlinePlayerInterfaceEx_OnReadOnlineProfilesComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.PlayerIDs = PlayerIDs;
	params.OnlineProfiles = OnlineProfiles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ReadOnlineProfilesForPlayers
// (Defined, Latent, PreOperator, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// TArray<struct FString>         PlayerIDs                      (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ReadOnlineProfilesForPlayers(TArray<struct FString> PlayerIDs)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ReadOnlineProfilesForPlayers"));

	UOnlinePlayerInterfaceEx_ReadOnlineProfilesForPlayers_Params params;
	params.PlayerIDs = PlayerIDs;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.GetPlayerIDForPlayerNickname
// (Final, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FString                 InPlayerNickname               (Parm, NeedCtorLink)
// struct FUniqueNetId            OutPlayerId                    (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::STATIC_GetPlayerIDForPlayerNickname(const struct FString& InPlayerNickname, struct FUniqueNetId* OutPlayerId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.GetPlayerIDForPlayerNickname"));

	UOnlinePlayerInterfaceEx_GetPlayerIDForPlayerNickname_Params params;
	params.InPlayerNickname = InPlayerNickname;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlayerId != nullptr)
		*OutPlayerId = params.OutPlayerId;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.GetPlayerNicknameForPlayerId
// (Final, Iterator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            InPlayerId                     (Parm)
// struct FString                 OutPlayerNickname              (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::STATIC_GetPlayerNicknameForPlayerId(const struct FUniqueNetId& InPlayerId, struct FString* OutPlayerNickname)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.GetPlayerNicknameForPlayerId"));

	UOnlinePlayerInterfaceEx_GetPlayerNicknameForPlayerId_Params params;
	params.InPlayerId = InPlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlayerNickname != nullptr)
		*OutPlayerNickname = params.OutPlayerNickname;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowCustomErrorUI
// (Defined, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            ErrorCode                      (Parm)
// struct FString                 ErrorContext                   (Parm, NeedCtorLink)
// struct FString                 DialogTitle                    (Parm, NeedCtorLink)
// struct FString                 DialogContent                  (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowCustomErrorUI(int ErrorCode, const struct FString& ErrorContext, const struct FString& DialogTitle, const struct FString& DialogContent)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowCustomErrorUI"));

	UOnlinePlayerInterfaceEx_ShowCustomErrorUI_Params params;
	params.ErrorCode = ErrorCode;
	params.ErrorContext = ErrorContext;
	params.DialogTitle = DialogTitle;
	params.DialogContent = DialogContent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowSystemErrorUI
// (Final, Defined, Iterator, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// int                            ErrorCode                      (Parm)
// struct FString                 ErrorContext                   (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowSystemErrorUI(int ErrorCode, const struct FString& ErrorContext)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowSystemErrorUI"));

	UOnlinePlayerInterfaceEx_ShowSystemErrorUI_Params params;
	params.ErrorCode = ErrorCode;
	params.ErrorContext = ErrorContext;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowCustomMessageUI
// (Final, Defined, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    Recipients                     (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 MessageTitle                   (Parm, NeedCtorLink)
// struct FString                 NonEditableMessage             (Parm, NeedCtorLink)
// struct FString                 EditableMessage                (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowCustomMessageUI(unsigned char LocalUserNum, const struct FString& MessageTitle, const struct FString& NonEditableMessage, const struct FString& EditableMessage, TArray<struct FUniqueNetId>* Recipients)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowCustomMessageUI"));

	UOnlinePlayerInterfaceEx_ShowCustomMessageUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.MessageTitle = MessageTitle;
	params.NonEditableMessage = NonEditableMessage;
	params.EditableMessage = EditableMessage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Recipients != nullptr)
		*Recipients = params.Recipients;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearCrossTitleProfileSettings
// (Final, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (Parm)

void UOnlinePlayerInterfaceEx::ClearCrossTitleProfileSettings(unsigned char LocalUserNum, int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearCrossTitleProfileSettings"));

	UOnlinePlayerInterfaceEx_ClearCrossTitleProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.GetCrossTitleProfileSettings
// (Defined, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (Parm)
// class UOnlineProfileSettings*  ReturnValue                    (Parm, OutParm, ReturnParm)

class UOnlineProfileSettings* UOnlinePlayerInterfaceEx::STATIC_GetCrossTitleProfileSettings(unsigned char LocalUserNum, int TitleId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.GetCrossTitleProfileSettings"));

	UOnlinePlayerInterfaceEx_GetCrossTitleProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearReadCrossTitleProfileSettingsCompleteDelegate
// (Defined, PreOperator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearReadCrossTitleProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearReadCrossTitleProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearReadCrossTitleProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadProfileSettingsCompleteDelegate = ReadProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddReadCrossTitleProfileSettingsCompleteDelegate
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ReadProfileSettingsCompleteDelegate (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddReadCrossTitleProfileSettingsCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ReadProfileSettingsCompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddReadCrossTitleProfileSettingsCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddReadCrossTitleProfileSettingsCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ReadProfileSettingsCompleteDelegate = ReadProfileSettingsCompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnReadCrossTitleProfileSettingsComplete
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (Parm)
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnReadCrossTitleProfileSettingsComplete(unsigned char LocalUserNum, int TitleId, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnReadCrossTitleProfileSettingsComplete"));

	UOnlinePlayerInterfaceEx_OnReadCrossTitleProfileSettingsComplete_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ReadCrossTitleProfileSettings
// (Final, Latent, Singular, Simulated, Exec, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            TitleId                        (Parm)
// class UOnlineProfileSettings*  ProfileSettings                (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ReadCrossTitleProfileSettings(unsigned char LocalUserNum, int TitleId, class UOnlineProfileSettings* ProfileSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ReadCrossTitleProfileSettings"));

	UOnlinePlayerInterfaceEx_ReadCrossTitleProfileSettings_Params params;
	params.LocalUserNum = LocalUserNum;
	params.TitleId = TitleId;
	params.ProfileSettings = ProfileSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.UnlockAvatarAward
// (Defined, Latent, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            AvatarItemId                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::UnlockAvatarAward(unsigned char LocalUserNum, int AvatarItemId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.UnlockAvatarAward"));

	UOnlinePlayerInterfaceEx_UnlockAvatarAward_Params params;
	params.LocalUserNum = LocalUserNum;
	params.AvatarItemId = AvatarItemId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowCustomPlayersUI
// (Iterator, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 Title                          (Parm, NeedCtorLink)
// struct FString                 Description                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowCustomPlayersUI(unsigned char LocalUserNum, const struct FString& Title, const struct FString& Description, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowCustomPlayersUI"));

	UOnlinePlayerInterfaceEx_ShowCustomPlayersUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Title = Title;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowPlayersUI
// (Defined, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowPlayersUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowPlayersUI"));

	UOnlinePlayerInterfaceEx_ShowPlayersUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowFriendsInviteUI
// (Iterator, Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowFriendsInviteUI(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowFriendsInviteUI"));

	UOnlinePlayerInterfaceEx_ShowFriendsInviteUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearProfileDataChangedDelegate
// (Final, Iterator, Singular, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ProfileDataChangedDelegate     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearProfileDataChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ProfileDataChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearProfileDataChangedDelegate"));

	UOnlinePlayerInterfaceEx_ClearProfileDataChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProfileDataChangedDelegate = ProfileDataChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddProfileDataChangedDelegate
// (Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         ProfileDataChangedDelegate     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddProfileDataChangedDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& ProfileDataChangedDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddProfileDataChangedDelegate"));

	UOnlinePlayerInterfaceEx_AddProfileDataChangedDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ProfileDataChangedDelegate = ProfileDataChangedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnProfileDataChanged
// (Final, Latent, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)

void UOnlinePlayerInterfaceEx::STATIC_OnProfileDataChanged()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnProfileDataChanged"));

	UOnlinePlayerInterfaceEx_OnProfileDataChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.UnlockGamerPicture
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            PictureId                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::UnlockGamerPicture(unsigned char LocalUserNum, int PictureId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.UnlockGamerPicture"));

	UOnlinePlayerInterfaceEx_UnlockGamerPicture_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PictureId = PictureId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.IsDeviceValid
// (Final, Defined, Iterator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            DeviceID                       (Parm)
// int                            SizeNeeded                     (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::STATIC_IsDeviceValid(int DeviceID, int SizeNeeded)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.IsDeviceValid"));

	UOnlinePlayerInterfaceEx_IsDeviceValid_Params params;
	params.DeviceID = DeviceID;
	params.SizeNeeded = SizeNeeded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.GetDeviceSelectionResults
// (Latent, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 DeviceName                     (Parm, OutParm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlinePlayerInterfaceEx::STATIC_GetDeviceSelectionResults(unsigned char LocalUserNum, struct FString* DeviceName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.GetDeviceSelectionResults"));

	UOnlinePlayerInterfaceEx_GetDeviceSelectionResults_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DeviceName != nullptr)
		*DeviceName = params.DeviceName;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearDeviceSelectionDoneDelegate
// (Iterator, Latent, PreOperator, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         DeviceDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearDeviceSelectionDoneDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& DeviceDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearDeviceSelectionDoneDelegate"));

	UOnlinePlayerInterfaceEx_ClearDeviceSelectionDoneDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeviceDelegate = DeviceDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddDeviceSelectionDoneDelegate
// (Defined, Iterator, Latent, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         DeviceDelegate                 (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddDeviceSelectionDoneDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& DeviceDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddDeviceSelectionDoneDelegate"));

	UOnlinePlayerInterfaceEx_AddDeviceSelectionDoneDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.DeviceDelegate = DeviceDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnDeviceSelectionComplete
// (Defined, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnDeviceSelectionComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnDeviceSelectionComplete"));

	UOnlinePlayerInterfaceEx_OnDeviceSelectionComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowDeviceSelectionUI
// (Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            SizeNeeded                     (Parm)
// bool                           bManageStorage                 (OptionalParm, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowDeviceSelectionUI(unsigned char LocalUserNum, int SizeNeeded, bool bManageStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowDeviceSelectionUI"));

	UOnlinePlayerInterfaceEx_ShowDeviceSelectionUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.SizeNeeded = SizeNeeded;
	params.bManageStorage = bManageStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowMembershipMarketplaceUI
// (Defined, Latent, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowMembershipMarketplaceUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowMembershipMarketplaceUI"));

	UOnlinePlayerInterfaceEx_ShowMembershipMarketplaceUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.CloseCurrentContentUI
// (Final, Latent, Net, Static)

void UOnlinePlayerInterfaceEx::STATIC_CloseCurrentContentUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.CloseCurrentContentUI"));

	UOnlinePlayerInterfaceEx_CloseCurrentContentUI_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowContentRedeemCodeUI
// (PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Offer                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowContentRedeemCodeUI(unsigned char LocalUserNum, const struct FString& Offer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowContentRedeemCodeUI"));

	UOnlinePlayerInterfaceEx_ShowContentRedeemCodeUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Offer = Offer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowContentPurchaseUI
// (Final, Defined, Latent, Native, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Offer                          (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowContentPurchaseUI(unsigned char LocalUserNum, const struct FString& Offer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowContentPurchaseUI"));

	UOnlinePlayerInterfaceEx_ShowContentPurchaseUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Offer = Offer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowContentMarketplaceUI
// (Final, Defined, Iterator, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// int                            ParentProductType              (Parm)
// int                            RequestedProductTypes          (Parm)
// struct FString                 ParentProductId                (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowContentMarketplaceUI(unsigned char LocalUserNum, int ParentProductType, int RequestedProductTypes, const struct FString& ParentProductId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowContentMarketplaceUI"));

	UOnlinePlayerInterfaceEx_ShowContentMarketplaceUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ParentProductType = ParentProductType;
	params.RequestedProductTypes = RequestedProductTypes;
	params.ParentProductId = ParentProductId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearContentPurchaseResponse
// (Final, Defined, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         HelpDelegate                   (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearContentPurchaseResponse(const struct FScriptDelegate& HelpDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearContentPurchaseResponse"));

	UOnlinePlayerInterfaceEx_ClearContentPurchaseResponse_Params params;
	params.HelpDelegate = HelpDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddContentPurchaseResponse
// (Defined, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         HelpDelegate                   (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddContentPurchaseResponse(const struct FScriptDelegate& HelpDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddContentPurchaseResponse"));

	UOnlinePlayerInterfaceEx_AddContentPurchaseResponse_Params params;
	params.HelpDelegate = HelpDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnContentPurchaseResponse
// (Final, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bAccepted                      (Parm)
// struct FQWord                  qwOrderId                      (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnContentPurchaseResponse(bool bAccepted, const struct FQWord& qwOrderId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnContentPurchaseResponse"));

	UOnlinePlayerInterfaceEx_OnContentPurchaseResponse_Params params;
	params.bAccepted = bAccepted;
	params.qwOrderId = qwOrderId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.CanShowContentPurchaseUI
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::CanShowContentPurchaseUI()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.CanShowContentPurchaseUI"));

	UOnlinePlayerInterfaceEx_CanShowContentPurchaseUI_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowProductDetailsUI
// (Final, Defined, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 ParentProductId                (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowProductDetailsUI(unsigned char LocalUserNum, const struct FString& ParentProductId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowProductDetailsUI"));

	UOnlinePlayerInterfaceEx_ShowProductDetailsUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.ParentProductId = ParentProductId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearAcceptReceivedDataDelegate
// (Final, Latent, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearAcceptReceivedDataDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearAcceptReceivedDataDelegate"));

	UOnlinePlayerInterfaceEx_ClearAcceptReceivedDataDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddAcceptReceivedDataDelegate
// (Defined, Latent, Singular, Net, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddAcceptReceivedDataDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddAcceptReceivedDataDelegate"));

	UOnlinePlayerInterfaceEx_AddAcceptReceivedDataDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnAcceptReceivedData
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 Data                           (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::STATIC_OnAcceptReceivedData(const struct FString& Data)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnAcceptReceivedData"));

	UOnlinePlayerInterfaceEx_OnAcceptReceivedData_Params params;
	params.Data = Data;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowDataSendingUI
// (Final, Iterator, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Message                        (Parm, NeedCtorLink)
// struct FString                 DataName                       (Parm, NeedCtorLink)
// struct FString                 DataDescription                (Parm, NeedCtorLink)
// TArray<unsigned char>          Data                           (Parm, NeedCtorLink)
// int                            MaxSelectableUsers             (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowDataSendingUI(unsigned char LocalUserNum, const struct FString& Message, const struct FString& DataName, const struct FString& DataDescription, TArray<unsigned char> Data, int MaxSelectableUsers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowDataSendingUI"));

	UOnlinePlayerInterfaceEx_ShowDataSendingUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Message = Message;
	params.DataName = DataName;
	params.DataDescription = DataDescription;
	params.Data = Data;
	params.MaxSelectableUsers = MaxSelectableUsers;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearPeoplePickerCompleteDelegate
// (Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearPeoplePickerCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearPeoplePickerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearPeoplePickerCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddPeoplePickerCompleteDelegate
// (Final, Defined, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddPeoplePickerCompleteDelegate(unsigned char LocalUserNum, const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddPeoplePickerCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddPeoplePickerCompleteDelegate_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnPeoplePickerComplete
// (Iterator, PreOperator, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// TArray<struct FOnlineFriend>   PeoplePicked                   (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::STATIC_OnPeoplePickerComplete(bool bWasSuccessful, TArray<struct FOnlineFriend> PeoplePicked)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnPeoplePickerComplete"));

	UOnlinePlayerInterfaceEx_OnPeoplePickerComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.PeoplePicked = PeoplePicked;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowPeoplePickerUI
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FOnlineFriend>   People                         (Parm, NeedCtorLink)
// int                            MaxSelectable                  (Parm)
// struct FString                 Text                           (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowPeoplePickerUI(unsigned char LocalUserNum, TArray<struct FOnlineFriend> People, int MaxSelectable, const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowPeoplePickerUI"));

	UOnlinePlayerInterfaceEx_ShowPeoplePickerUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.People = People;
	params.MaxSelectable = MaxSelectable;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowInviteUI
// (Final, Iterator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 InviteText                     (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowInviteUI(unsigned char LocalUserNum, const struct FString& InviteText)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowInviteUI"));

	UOnlinePlayerInterfaceEx_ShowInviteUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.InviteText = InviteText;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowAchievementsUI
// (Final, Defined, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowAchievementsUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowAchievementsUI"));

	UOnlinePlayerInterfaceEx_ShowAchievementsUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowMessagesUI
// (Final, Defined, Latent, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowMessagesUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowMessagesUI"));

	UOnlinePlayerInterfaceEx_ShowMessagesUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowComposeMessageUI
// (Defined, Iterator, Latent, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// TArray<struct FUniqueNetId>    People                         (OptionalParm, Parm, NeedCtorLink)
// struct FString                 Text                           (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowComposeMessageUI(unsigned char LocalUserNum, TArray<struct FUniqueNetId> People, const struct FString& Text)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowComposeMessageUI"));

	UOnlinePlayerInterfaceEx_ShowComposeMessageUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.People = People;
	params.Text = Text;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearShowComposeMessageUICompleteDelegate
// (Final, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         MessageDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearShowComposeMessageUICompleteDelegate(const struct FScriptDelegate& MessageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearShowComposeMessageUICompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearShowComposeMessageUICompleteDelegate_Params params;
	params.MessageDelegate = MessageDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddShowComposeMessageUICompleteDelegate
// (Final, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         MessageDelegate                (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddShowComposeMessageUICompleteDelegate(const struct FScriptDelegate& MessageDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddShowComposeMessageUICompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddShowComposeMessageUICompleteDelegate_Params params;
	params.MessageDelegate = MessageDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnShowComposeMessageUIComplete
// (Final, Defined, Latent, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnShowComposeMessageUIComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnShowComposeMessageUIComplete"));

	UOnlinePlayerInterfaceEx_OnShowComposeMessageUIComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowGamerCardUIByUsername
// (Final, Defined, Iterator, Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 UserName                       (Parm, NeedCtorLink)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowGamerCardUIByUsername(unsigned char LocalUserNum, const struct FString& UserName, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowGamerCardUIByUsername"));

	UOnlinePlayerInterfaceEx_ShowGamerCardUIByUsername_Params params;
	params.LocalUserNum = LocalUserNum;
	params.UserName = UserName;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowGamerCardUI
// (Defined, Iterator, Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowGamerCardUI(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowGamerCardUI"));

	UOnlinePlayerInterfaceEx_ShowGamerCardUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearShowGamerCardCompleteDelegate
// (Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         GamerCardDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearShowGamerCardCompleteDelegate(const struct FScriptDelegate& GamerCardDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearShowGamerCardCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearShowGamerCardCompleteDelegate_Params params;
	params.GamerCardDelegate = GamerCardDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddShowGamerCardCompleteDelegate
// (Defined, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         GamerCardDelegate              (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddShowGamerCardCompleteDelegate(const struct FScriptDelegate& GamerCardDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddShowGamerCardCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddShowGamerCardCompleteDelegate_Params params;
	params.GamerCardDelegate = GamerCardDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnShowGamerCardComplete
// (Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnShowGamerCardComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnShowGamerCardComplete"));

	UOnlinePlayerInterfaceEx_OnShowGamerCardComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowVideo
// (Latent, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowVideo(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowVideo"));

	UOnlinePlayerInterfaceEx_ShowVideo_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ClearShowHelpCompleteDelegate
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         HelpDelegate                   (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::ClearShowHelpCompleteDelegate(const struct FScriptDelegate& HelpDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ClearShowHelpCompleteDelegate"));

	UOnlinePlayerInterfaceEx_ClearShowHelpCompleteDelegate_Params params;
	params.HelpDelegate = HelpDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.AddShowHelpCompleteDelegate
// (Final, Defined, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         HelpDelegate                   (Parm, NeedCtorLink)

void UOnlinePlayerInterfaceEx::AddShowHelpCompleteDelegate(const struct FScriptDelegate& HelpDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.AddShowHelpCompleteDelegate"));

	UOnlinePlayerInterfaceEx_AddShowHelpCompleteDelegate_Params params;
	params.HelpDelegate = HelpDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.OnShowHelpComplete
// (Final, Iterator, Latent, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)

void UOnlinePlayerInterfaceEx::STATIC_OnShowHelpComplete(bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.OnShowHelpComplete"));

	UOnlinePlayerInterfaceEx_OnShowHelpComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowHelpForErrorUI
// (Final, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// struct FString                 ContextId                      (Parm, NeedCtorLink)
// struct FString                 ErrorString                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowHelpForErrorUI(const struct FString& ContextId, const struct FString& ErrorString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowHelpForErrorUI"));

	UOnlinePlayerInterfaceEx_ShowHelpForErrorUI_Params params;
	params.ContextId = ContextId;
	params.ErrorString = ErrorString;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowHelpUI
// (Defined, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowHelpUI(unsigned char LocalUserNum)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowHelpUI"));

	UOnlinePlayerInterfaceEx_ShowHelpUI_Params params;
	params.LocalUserNum = LocalUserNum;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlinePlayerInterfaceEx.ShowFeedbackUI
// (Final, Latent, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FUniqueNetId            PlayerID                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlinePlayerInterfaceEx::ShowFeedbackUI(unsigned char LocalUserNum, const struct FUniqueNetId& PlayerID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlinePlayerInterfaceEx.ShowFeedbackUI"));

	UOnlinePlayerInterfaceEx_ShowFeedbackUI_Params params;
	params.LocalUserNum = LocalUserNum;
	params.PlayerID = PlayerID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAccountInterface.GetLocalAccountNames
// (Defined, Iterator, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FString>         Accounts                       (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAccountInterface::STATIC_GetLocalAccountNames(TArray<struct FString>* Accounts)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.GetLocalAccountNames"));

	UOnlineAccountInterface_GetLocalAccountNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Accounts != nullptr)
		*Accounts = params.Accounts;

	return params.ReturnValue;
}


// Function Engine.OnlineAccountInterface.DeleteLocalAccount
// (Final, Defined, Iterator, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FString                 UserName                       (Parm, NeedCtorLink)
// struct FString                 Password                       (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAccountInterface::STATIC_DeleteLocalAccount(const struct FString& UserName, const struct FString& Password)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.DeleteLocalAccount"));

	UOnlineAccountInterface_DeleteLocalAccount_Params params;
	params.UserName = UserName;
	params.Password = Password;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAccountInterface.RenameLocalAccount
// (Final, Singular, Native, HasOptionalParms)
// Parameters:
// struct FString                 NewUserName                    (Parm, NeedCtorLink)
// struct FString                 OldUserName                    (Parm, NeedCtorLink)
// struct FString                 Password                       (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAccountInterface::RenameLocalAccount(const struct FString& NewUserName, const struct FString& OldUserName, const struct FString& Password)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.RenameLocalAccount"));

	UOnlineAccountInterface_RenameLocalAccount_Params params;
	params.NewUserName = NewUserName;
	params.OldUserName = OldUserName;
	params.Password = Password;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAccountInterface.CreateLocalAccount
// (Final, Latent, Exec, Static)
// Parameters:
// struct FString                 UserName                       (Parm, NeedCtorLink)
// struct FString                 Password                       (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAccountInterface::STATIC_CreateLocalAccount(const struct FString& UserName, const struct FString& Password)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.CreateLocalAccount"));

	UOnlineAccountInterface_CreateLocalAccount_Params params;
	params.UserName = UserName;
	params.Password = Password;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineAccountInterface.ClearCreateOnlineAccountCompletedDelegate
// (Final, Iterator, Latent, Net, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         AccountCreateDelegate          (Parm, NeedCtorLink)

void UOnlineAccountInterface::ClearCreateOnlineAccountCompletedDelegate(const struct FScriptDelegate& AccountCreateDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.ClearCreateOnlineAccountCompletedDelegate"));

	UOnlineAccountInterface_ClearCreateOnlineAccountCompletedDelegate_Params params;
	params.AccountCreateDelegate = AccountCreateDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAccountInterface.AddCreateOnlineAccountCompletedDelegate
// (Final, Iterator, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         AccountCreateDelegate          (Parm, NeedCtorLink)

void UOnlineAccountInterface::AddCreateOnlineAccountCompletedDelegate(const struct FScriptDelegate& AccountCreateDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.AddCreateOnlineAccountCompletedDelegate"));

	UOnlineAccountInterface_AddCreateOnlineAccountCompletedDelegate_Params params;
	params.AccountCreateDelegate = AccountCreateDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAccountInterface.OnCreateOnlineAccountCompleted
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// TEnumAsByte<EOnlineAccountCreateStatus> ErrorStatus                    (Parm)

void UOnlineAccountInterface::STATIC_OnCreateOnlineAccountCompleted(TEnumAsByte<EOnlineAccountCreateStatus> ErrorStatus)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.OnCreateOnlineAccountCompleted"));

	UOnlineAccountInterface_OnCreateOnlineAccountCompleted_Params params;
	params.ErrorStatus = ErrorStatus;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineAccountInterface.CreateOnlineAccount
// (Final, Defined, Latent, Exec, Static)
// Parameters:
// struct FString                 UserName                       (Parm, NeedCtorLink)
// struct FString                 Password                       (Parm, NeedCtorLink)
// struct FString                 EmailAddress                   (Parm, NeedCtorLink)
// struct FString                 ProductKey                     (OptionalParm, Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineAccountInterface::STATIC_CreateOnlineAccount(const struct FString& UserName, const struct FString& Password, const struct FString& EmailAddress, const struct FString& ProductKey)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineAccountInterface.CreateOnlineAccount"));

	UOnlineAccountInterface_CreateOnlineAccount_Params params;
	params.UserName = UserName;
	params.Password = Password;
	params.EmailAddress = EmailAddress;
	params.ProductKey = ProductKey;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.IsPendingAuth
// (Final, Singular, Net, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            PlayerUID                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::STATIC_IsPendingAuth(const struct FUniqueNetId& PlayerUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.IsPendingAuth"));

	AAccessControl_IsPendingAuth_Params params;
	params.PlayerUID = PlayerUID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.Cleanup
// (Final, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           bExit                          (OptionalParm, Parm)

void AAccessControl::Cleanup(bool bExit)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.Cleanup"));

	AAccessControl_Cleanup_Params params;
	params.bExit = bExit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.NotifyExit
// (Defined, Iterator, Net, Simulated, Exec, Event, Operator, Static)

void AAccessControl::STATIC_NotifyExit()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.NotifyExit"));

	AAccessControl_NotifyExit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.NotifyGameEnding
// (Latent, Net, Simulated, Exec, Event, Operator, Static)

void AAccessControl::STATIC_NotifyGameEnding()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.NotifyGameEnding"));

	AAccessControl_NotifyGameEnding_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.NotifyServerTravel
// (Iterator, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// bool                           bSeamless                      (Parm)

void AAccessControl::STATIC_NotifyServerTravel(bool bSeamless)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.NotifyServerTravel"));

	AAccessControl_NotifyServerTravel_Params params;
	params.bSeamless = bSeamless;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.OnDestroyOnlineGameComplete
// (Final, Iterator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   SessionName                    (Parm)
// bool                           bWasSuccessful                 (Parm)

void AAccessControl::OnDestroyOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.OnDestroyOnlineGameComplete"));

	AAccessControl_OnDestroyOnlineGameComplete_Params params;
	params.SessionName = SessionName;
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.StaticOnClientConnectionClose
// (Final, Iterator, Latent, PreOperator, Singular, Net, Simulated, Exec, Event, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)

void AAccessControl::StaticOnClientConnectionClose(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.StaticOnClientConnectionClose"));

	AAccessControl_StaticOnClientConnectionClose_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.OnClientConnectionClose
// (Final, Defined, Iterator, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)

void AAccessControl::OnClientConnectionClose(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.OnClientConnectionClose"));

	AAccessControl_OnClientConnectionClose_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.ListenHostAuthTimeout
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Native, Operator, Static)

void AAccessControl::STATIC_ListenHostAuthTimeout()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ListenHostAuthTimeout"));

	AAccessControl_ListenHostAuthTimeout_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.EndListenHostAuth
// (Final, Defined, Latent, Event, Static)

void AAccessControl::STATIC_EndListenHostAuth()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.EndListenHostAuth"));

	AAccessControl_EndListenHostAuth_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.ContinueListenHostAuth
// (Final, Latent, Singular, NetReliable, Simulated, Static)

void AAccessControl::STATIC_ContinueListenHostAuth()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ContinueListenHostAuth"));

	AAccessControl_ContinueListenHostAuth_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.BeginListenHostAuth
// (Defined, PreOperator, Simulated, Native, Operator)
// Parameters:
// bool                           bRetry                         (OptionalParm, Parm)

void AAccessControl::BeginListenHostAuth(bool bRetry)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.BeginListenHostAuth"));

	AAccessControl_BeginListenHostAuth_Params params;
	params.bRetry = bRetry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.ProcessServerAuthRetryRequest
// (Defined, PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)

void AAccessControl::ProcessServerAuthRetryRequest(class UPlayer* ClientConnection)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ProcessServerAuthRetryRequest"));

	AAccessControl_ProcessServerAuthRetryRequest_Params params;
	params.ClientConnection = ClientConnection;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.ProcessServerAuthRequest
// (PreOperator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// class UPlayer*                 ClientConnection               (Parm)
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            ClientPort                     (Parm)

void AAccessControl::ProcessServerAuthRequest(class UPlayer* ClientConnection, const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int ClientPort)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ProcessServerAuthRequest"));

	AAccessControl_ProcessServerAuthRequest_Params params;
	params.ClientConnection = ClientConnection;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.ClientPort = ClientPort;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.OnClientAuthComplete
// (Final, Defined, Latent, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bSuccess                       (Parm)
// struct FUniqueNetId            ClientUID                      (Parm)
// class UPlayer*                 ClientConnection               (Parm)
// struct FString                 ExtraInfo                      (Parm, NeedCtorLink)

void AAccessControl::OnClientAuthComplete(bool bSuccess, const struct FUniqueNetId& ClientUID, class UPlayer* ClientConnection, const struct FString& ExtraInfo)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.OnClientAuthComplete"));

	AAccessControl_OnClientAuthComplete_Params params;
	params.bSuccess = bSuccess;
	params.ClientUID = ClientUID;
	params.ClientConnection = ClientConnection;
	params.ExtraInfo = ExtraInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.ProcessClientAuthResponse
// (Final, Defined, Iterator, Singular, NetReliable, Simulated, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            ClientUID                      (Parm)
// struct FIpAddr                 ClientIP                       (Parm)
// int                            AuthTicketUID                  (Parm)

void AAccessControl::ProcessClientAuthResponse(const struct FUniqueNetId& ClientUID, const struct FIpAddr& ClientIP, int AuthTicketUID)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ProcessClientAuthResponse"));

	AAccessControl_ProcessClientAuthResponse_Params params;
	params.ClientUID = ClientUID;
	params.ClientIP = ClientIP;
	params.AuthTicketUID = AuthTicketUID;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.OnAuthReady
// (Latent, Exec, Native, HasOptionalParms)

void AAccessControl::OnAuthReady()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.OnAuthReady"));

	AAccessControl_OnAuthReady_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.PendingAuthTimer
// (Defined, Iterator, Singular, Net, Simulated, Exec, Native, Event, Operator, Static)

void AAccessControl::STATIC_PendingAuthTimer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.PendingAuthTimer"));

	AAccessControl_PendingAuthTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.PostLogin
// (Final, Iterator, Latent, Net, Exec, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       NewPlayer                      (Parm)

void AAccessControl::PostLogin(class APlayerController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.PostLogin"));

	AAccessControl_PostLogin_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.PreLogin
// (Latent, PreOperator, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// struct FString                 Address                        (Parm, NeedCtorLink)
// struct FUniqueNetId            UniqueId                       (Const, Parm)
// bool                           bSupportsAuth                  (Parm)
// struct FString                 OutError                       (Parm, OutParm, NeedCtorLink)
// bool                           bSpectator                     (Parm)

void AAccessControl::PreLogin(const struct FString& Options, const struct FString& Address, const struct FUniqueNetId& UniqueId, bool bSupportsAuth, bool bSpectator, struct FString* OutError)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.PreLogin"));

	AAccessControl_PreLogin_Params params;
	params.Options = Options;
	params.Address = Address;
	params.UniqueId = UniqueId;
	params.bSupportsAuth = bSupportsAuth;
	params.bSpectator = bSpectator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutError != nullptr)
		*OutError = params.OutError;
}


// Function Engine.AccessControl.ClearAuthDelegates
// (Final, Iterator, PreOperator, Singular, Simulated, Exec, Native, Event, Operator)
// Parameters:
// bool                           bExiting                       (Parm)

void AAccessControl::ClearAuthDelegates(bool bExiting)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ClearAuthDelegates"));

	AAccessControl_ClearAuthDelegates_Params params;
	params.bExiting = bExiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.RegisterAuthDelegates
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void AAccessControl::RegisterAuthDelegates()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.RegisterAuthDelegates"));

	AAccessControl_RegisterAuthDelegates_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.InitAuthHooks
// (PreOperator, Net, Simulated, Operator, Static)

void AAccessControl::STATIC_InitAuthHooks()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.InitAuthHooks"));

	AAccessControl_InitAuthHooks_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.IsIDBanned
// (Defined, Iterator, Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// struct FUniqueNetId            NetId                          (Const, Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::STATIC_IsIDBanned(struct FUniqueNetId* NetId)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.IsIDBanned"));

	AAccessControl_IsIDBanned_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NetId != nullptr)
		*NetId = params.NetId;

	return params.ReturnValue;
}


// Function Engine.AccessControl.CheckIPPolicy
// (Final, PreOperator, Net, NetReliable, Exec, Native, Event, Operator)
// Parameters:
// struct FString                 Address                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::CheckIPPolicy(const struct FString& Address)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.CheckIPPolicy"));

	AAccessControl_CheckIPPolicy_Params params;
	params.Address = Address;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.ValidLogin
// (Final, Singular, Net, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FString                 UserName                       (Parm, NeedCtorLink)
// struct FString                 Password                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::ValidLogin(const struct FString& UserName, const struct FString& Password)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ValidLogin"));

	AAccessControl_ValidLogin_Params params;
	params.UserName = UserName;
	params.Password = Password;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.ParseAdminOptions
// (Final, Iterator, Latent, NetReliable, Exec, Native, Event, Operator, Static)
// Parameters:
// struct FString                 Options                        (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::STATIC_ParseAdminOptions(const struct FString& Options)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ParseAdminOptions"));

	AAccessControl_ParseAdminOptions_Params params;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.AdminExited
// (Iterator, Latent, PreOperator, Net, Operator)
// Parameters:
// class APlayerController*       P                              (Parm)

void AAccessControl::AdminExited(class APlayerController* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.AdminExited"));

	AAccessControl_AdminExited_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.AdminEntered
// (Final, Defined, Latent, PreOperator, Net, Operator)
// Parameters:
// class APlayerController*       P                              (Parm)

void AAccessControl::AdminEntered(class APlayerController* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.AdminEntered"));

	AAccessControl_AdminEntered_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.AdminLogout
// (Defined, Iterator, Latent, PreOperator, Net, Operator)
// Parameters:
// class APlayerController*       P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::AdminLogout(class APlayerController* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.AdminLogout"));

	AAccessControl_AdminLogout_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.AdminLogin
// (Final, Iterator, Latent, PreOperator, Net, Operator)
// Parameters:
// class APlayerController*       P                              (Parm)
// struct FString                 Password                       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::AdminLogin(class APlayerController* P, const struct FString& Password)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.AdminLogin"));

	AAccessControl_AdminLogin_Params params;
	params.P = P;
	params.Password = Password;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.KickPlayer
// (Defined, Iterator, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// class APlayerController*       C                              (Parm)
// struct FString                 KickReason                     (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::STATIC_KickPlayer(class APlayerController* C, const struct FString& KickReason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.KickPlayer"));

	AAccessControl_KickPlayer_Params params;
	params.C = C;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.ForceKickPlayer
// (Final, Defined, PreOperator, Singular, Net, Simulated, Native, HasOptionalParms)
// Parameters:
// class APlayerController*       C                              (Parm)
// struct FString                 KickReason                     (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::ForceKickPlayer(class APlayerController* C, const struct FString& KickReason)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.ForceKickPlayer"));

	AAccessControl_ForceKickPlayer_Params params;
	params.C = C;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.KickBan
// (Iterator, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 Target                         (Parm, NeedCtorLink)

void AAccessControl::STATIC_KickBan(const struct FString& Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.KickBan"));

	AAccessControl_KickBan_Params params;
	params.Target = Target;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.Kick
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 Target                         (Parm, NeedCtorLink)

void AAccessControl::STATIC_Kick(const struct FString& Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.Kick"));

	AAccessControl_Kick_Params params;
	params.Target = Target;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.GetControllerFromString
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 Target                         (Parm, NeedCtorLink)
// class AController*             ReturnValue                    (Parm, OutParm, ReturnParm)

class AController* AAccessControl::STATIC_GetControllerFromString(const struct FString& Target)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.GetControllerFromString"));

	AAccessControl_GetControllerFromString_Params params;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.RequiresPassword
// (Defined, Iterator, Latent, Singular, Net, Native, HasOptionalParms)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::RequiresPassword()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.RequiresPassword"));

	AAccessControl_RequiresPassword_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.SetGamePassword
// (Final, Defined, PreOperator, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 P                              (Parm, NeedCtorLink)

void AAccessControl::SetGamePassword(const struct FString& P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.SetGamePassword"));

	AAccessControl_SetGamePassword_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.SetAdminPassword
// (Final, Iterator, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 P                              (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::SetAdminPassword(const struct FString& P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.SetAdminPassword"));

	AAccessControl_SetAdminPassword_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.IsAdmin
// (Final, Latent, NetReliable, Exec, Operator, Static)
// Parameters:
// class APlayerController*       P                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool AAccessControl::STATIC_IsAdmin(class APlayerController* P)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.IsAdmin"));

	AAccessControl_IsAdmin_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AccessControl.Destroyed
// (Iterator, Latent, Singular, Simulated)

void AAccessControl::Destroyed()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.Destroyed"));

	AAccessControl_Destroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AccessControl.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AAccessControl::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AccessControl.PostBeginPlay"));

	AAccessControl_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.ServerSwitch
// (Final, Defined, Latent, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)

void AAdmin::ServerSwitch(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.ServerSwitch"));

	AAdmin_ServerSwitch_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.Switch
// (Latent, PreOperator, Singular, Net, Exec)
// Parameters:
// struct FString                 URL                            (Parm, NeedCtorLink)

void AAdmin::Switch(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.Switch"));

	AAdmin_Switch_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.ServerRestartMap
// (Final, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)

void AAdmin::ServerRestartMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.ServerRestartMap"));

	AAdmin_ServerRestartMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.RestartMap
// (Defined, Singular, NetReliable, Native, HasOptionalParms)

void AAdmin::RestartMap()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.RestartMap"));

	AAdmin_RestartMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.PlayerList
// (Final, Latent, PreOperator, Singular, Net, HasOptionalParms)

void AAdmin::PlayerList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.PlayerList"));

	AAdmin_PlayerList_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.ServerKick
// (Final, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AAdmin::ServerKick(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.ServerKick"));

	AAdmin_ServerKick_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.Kick
// (Final, Defined, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AAdmin::STATIC_Kick(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.Kick"));

	AAdmin_Kick_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.ServerKickBan
// (Defined, Iterator, Latent, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AAdmin::ServerKickBan(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.ServerKickBan"));

	AAdmin_ServerKickBan_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.KickBan
// (Iterator, Latent, Singular, Net, Simulated, Exec, Operator, Static)
// Parameters:
// struct FString                 S                              (Parm, NeedCtorLink)

void AAdmin::STATIC_KickBan(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.KickBan"));

	AAdmin_KickBan_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.ServerAdmin
// (Iterator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 CommandLine                    (Parm, NeedCtorLink)

void AAdmin::ServerAdmin(const struct FString& CommandLine)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.ServerAdmin"));

	AAdmin_ServerAdmin_Params params;
	params.CommandLine = CommandLine;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.Admin
// (Final, Latent, PreOperator, Net, Operator)
// Parameters:
// struct FString                 CommandLine                    (Parm, NeedCtorLink)

void AAdmin::Admin(const struct FString& CommandLine)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.Admin"));

	AAdmin_Admin_Params params;
	params.CommandLine = CommandLine;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Admin.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AAdmin::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Admin.PostBeginPlay"));

	AAdmin_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterSpawnable.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AEmitterSpawnable::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterSpawnable.ReplicatedEvent"));

	AEmitterSpawnable_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.EmitterSpawnable.SetTemplate
// (Final, Latent, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class UParticleSystem*         NewTemplate                    (Parm)
// bool                           bDestroyOnFinish               (OptionalParm, Parm)

void AEmitterSpawnable::SetTemplate(class UParticleSystem* NewTemplate, bool bDestroyOnFinish)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.EmitterSpawnable.SetTemplate"));

	AEmitterSpawnable_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;
	params.bDestroyOnFinish = bDestroyOnFinish;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_ControlMovieTexture.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_ControlMovieTexture::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ControlMovieTexture.Activated"));

	USeqAct_ControlMovieTexture_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ClientReceiveLinkDisabledState
// (Final, Latent, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// bool                           bLinkDisabled                  (Parm)

void ACoverReplicator::STATIC_ClientReceiveLinkDisabledState(int Index, class ACoverLink* Link, bool bLinkDisabled)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveLinkDisabledState"));

	ACoverReplicator_ClientReceiveLinkDisabledState_Params params;
	params.Index = Index;
	params.Link = Link;
	params.bLinkDisabled = bLinkDisabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendLinkDisabledState
// (Final, Iterator, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendLinkDisabledState(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendLinkDisabledState"));

	ACoverReplicator_ServerSendLinkDisabledState_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.NotifyLinkDisabledStateChange
// (Final, Iterator, Latent, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)

void ACoverReplicator::STATIC_NotifyLinkDisabledStateChange(class ACoverLink* Link)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.NotifyLinkDisabledStateChange"));

	ACoverReplicator_NotifyLinkDisabledStateChange_Params params;
	params.Link = Link;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ClientReceiveManualCoverTypeSlots
// (Defined, Latent, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// unsigned char                  NumCoverTypesChanged           (Parm)
// struct FManualCoverTypeInfo    SlotsCoverTypeChanged          (Parm)
// bool                           bDone                          (Parm)

void ACoverReplicator::STATIC_ClientReceiveManualCoverTypeSlots(int Index, class ACoverLink* Link, unsigned char NumCoverTypesChanged, const struct FManualCoverTypeInfo& SlotsCoverTypeChanged, bool bDone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveManualCoverTypeSlots"));

	ACoverReplicator_ClientReceiveManualCoverTypeSlots_Params params;
	params.Index = Index;
	params.Link = Link;
	params.NumCoverTypesChanged = NumCoverTypesChanged;
	params.SlotsCoverTypeChanged = SlotsCoverTypeChanged;
	params.bDone = bDone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendManualCoverTypeSlots
// (Defined, Iterator, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendManualCoverTypeSlots(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendManualCoverTypeSlots"));

	ACoverReplicator_ServerSendManualCoverTypeSlots_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.NotifySetManualCoverTypeForSlots
// (Final, Iterator, Latent, PreOperator, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// TArray<int>                    SlotIndices                    (Const, Parm, OutParm, NeedCtorLink)
// TEnumAsByte<ECoverType>        NewCoverType                   (Parm)

void ACoverReplicator::STATIC_NotifySetManualCoverTypeForSlots(class ACoverLink* Link, TEnumAsByte<ECoverType> NewCoverType, TArray<int>* SlotIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.NotifySetManualCoverTypeForSlots"));

	ACoverReplicator_NotifySetManualCoverTypeForSlots_Params params;
	params.Link = Link;
	params.NewCoverType = NewCoverType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SlotIndices != nullptr)
		*SlotIndices = params.SlotIndices;
}


// Function Engine.CoverReplicator.ClientReceiveAdjustedSlots
// (Final, Iterator, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// unsigned char                  NumSlotsAdjusted               (Parm)
// unsigned char                  SlotsAdjusted                  (Parm)
// bool                           bDone                          (Parm)

void ACoverReplicator::STATIC_ClientReceiveAdjustedSlots(int Index, class ACoverLink* Link, unsigned char NumSlotsAdjusted, unsigned char SlotsAdjusted, bool bDone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveAdjustedSlots"));

	ACoverReplicator_ClientReceiveAdjustedSlots_Params params;
	params.Index = Index;
	params.Link = Link;
	params.NumSlotsAdjusted = NumSlotsAdjusted;
	params.SlotsAdjusted = SlotsAdjusted;
	params.bDone = bDone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendAdjustedSlots
// (Final, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendAdjustedSlots(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendAdjustedSlots"));

	ACoverReplicator_ServerSendAdjustedSlots_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.NotifyAutoAdjustSlots
// (Defined, Iterator, PreOperator, Singular, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// TArray<int>                    SlotIndices                    (Const, Parm, OutParm, NeedCtorLink)

void ACoverReplicator::STATIC_NotifyAutoAdjustSlots(class ACoverLink* Link, TArray<int>* SlotIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.NotifyAutoAdjustSlots"));

	ACoverReplicator_NotifyAutoAdjustSlots_Params params;
	params.Link = Link;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SlotIndices != nullptr)
		*SlotIndices = params.SlotIndices;
}


// Function Engine.CoverReplicator.ClientReceiveDisabledSlots
// (Defined, Iterator, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// unsigned char                  NumSlotsDisabled               (Parm)
// unsigned char                  SlotsDisabled                  (Parm)
// bool                           bDone                          (Parm)

void ACoverReplicator::STATIC_ClientReceiveDisabledSlots(int Index, class ACoverLink* Link, unsigned char NumSlotsDisabled, unsigned char SlotsDisabled, bool bDone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveDisabledSlots"));

	ACoverReplicator_ClientReceiveDisabledSlots_Params params;
	params.Index = Index;
	params.Link = Link;
	params.NumSlotsDisabled = NumSlotsDisabled;
	params.SlotsDisabled = SlotsDisabled;
	params.bDone = bDone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendDisabledSlots
// (Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendDisabledSlots(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendDisabledSlots"));

	ACoverReplicator_ServerSendDisabledSlots_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.NotifyDisabledSlots
// (Final, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// TArray<int>                    SlotIndices                    (Const, Parm, OutParm, NeedCtorLink)

void ACoverReplicator::STATIC_NotifyDisabledSlots(class ACoverLink* Link, TArray<int>* SlotIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.NotifyDisabledSlots"));

	ACoverReplicator_NotifyDisabledSlots_Params params;
	params.Link = Link;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SlotIndices != nullptr)
		*SlotIndices = params.SlotIndices;
}


// Function Engine.CoverReplicator.ClientReceiveEnabledSlots
// (Final, Defined, Iterator, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// unsigned char                  NumSlotsEnabled                (Parm)
// unsigned char                  SlotsEnabled                   (Parm)
// bool                           bDone                          (Parm)

void ACoverReplicator::STATIC_ClientReceiveEnabledSlots(int Index, class ACoverLink* Link, unsigned char NumSlotsEnabled, unsigned char SlotsEnabled, bool bDone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveEnabledSlots"));

	ACoverReplicator_ClientReceiveEnabledSlots_Params params;
	params.Index = Index;
	params.Link = Link;
	params.NumSlotsEnabled = NumSlotsEnabled;
	params.SlotsEnabled = SlotsEnabled;
	params.bDone = bDone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendEnabledSlots
// (Final, Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendEnabledSlots(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendEnabledSlots"));

	ACoverReplicator_ServerSendEnabledSlots_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.NotifyEnabledSlots
// (Final, Defined, Net, Simulated, Exec, Event, Operator, Static)
// Parameters:
// class ACoverLink*              Link                           (Parm)
// TArray<int>                    SlotIndices                    (Const, Parm, OutParm, NeedCtorLink)

void ACoverReplicator::STATIC_NotifyEnabledSlots(class ACoverLink* Link, TArray<int>* SlotIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.NotifyEnabledSlots"));

	ACoverReplicator_NotifyEnabledSlots_Params params;
	params.Link = Link;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SlotIndices != nullptr)
		*SlotIndices = params.SlotIndices;
}


// Function Engine.CoverReplicator.ClientReceiveInitialCoverReplicationInfo
// (Latent, PreOperator, Static)
// Parameters:
// int                            Index                          (Parm)
// class ACoverLink*              Link                           (Parm)
// bool                           bLinkDisabled                  (Parm)
// unsigned char                  NumSlotsEnabled                (Parm)
// unsigned char                  SlotsEnabled                   (Parm)
// unsigned char                  NumSlotsDisabled               (Parm)
// unsigned char                  SlotsDisabled                  (Parm)
// unsigned char                  NumSlotsAdjusted               (Parm)
// unsigned char                  SlotsAdjusted                  (Parm)
// unsigned char                  NumCoverTypesChanged           (Parm)
// struct FManualCoverTypeInfo    SlotsCoverTypeChanged          (Parm)
// bool                           bDone                          (Parm)

void ACoverReplicator::STATIC_ClientReceiveInitialCoverReplicationInfo(int Index, class ACoverLink* Link, bool bLinkDisabled, unsigned char NumSlotsEnabled, unsigned char SlotsEnabled, unsigned char NumSlotsDisabled, unsigned char SlotsDisabled, unsigned char NumSlotsAdjusted, unsigned char SlotsAdjusted, unsigned char NumCoverTypesChanged, const struct FManualCoverTypeInfo& SlotsCoverTypeChanged, bool bDone)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientReceiveInitialCoverReplicationInfo"));

	ACoverReplicator_ClientReceiveInitialCoverReplicationInfo_Params params;
	params.Index = Index;
	params.Link = Link;
	params.bLinkDisabled = bLinkDisabled;
	params.NumSlotsEnabled = NumSlotsEnabled;
	params.SlotsEnabled = SlotsEnabled;
	params.NumSlotsDisabled = NumSlotsDisabled;
	params.SlotsDisabled = SlotsDisabled;
	params.NumSlotsAdjusted = NumSlotsAdjusted;
	params.SlotsAdjusted = SlotsAdjusted;
	params.NumCoverTypesChanged = NumCoverTypesChanged;
	params.SlotsCoverTypeChanged = SlotsCoverTypeChanged;
	params.bDone = bDone;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ServerSendInitialCoverReplicationInfo
// (Iterator, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            Index                          (Parm)

void ACoverReplicator::ServerSendInitialCoverReplicationInfo(int Index)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ServerSendInitialCoverReplicationInfo"));

	ACoverReplicator_ServerSendInitialCoverReplicationInfo_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ClientSetOwner
// (Final, Iterator, Singular, Static)
// Parameters:
// class APlayerController*       PC                             (Parm)

void ACoverReplicator::STATIC_ClientSetOwner(class APlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ClientSetOwner"));

	ACoverReplicator_ClientSetOwner_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.ReplicateInitialCoverInfo
// (Final, Defined, Iterator, Latent, Net, Native, HasOptionalParms)

void ACoverReplicator::ReplicateInitialCoverInfo()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.ReplicateInitialCoverInfo"));

	ACoverReplicator_ReplicateInitialCoverInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CoverReplicator.PurgeOldEntries
// (Defined, Latent, PreOperator, Net, Exec, HasOptionalParms)

void ACoverReplicator::PurgeOldEntries()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CoverReplicator.PurgeOldEntries"));

	ACoverReplicator_PurgeOldEntries_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMessage.GetString
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// bool                           bPRI1HUD                       (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UGameMessage::STATIC_GetString(int Switch, bool bPRI1HUD, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.GameMessage.GetString"));

	UGameMessage_GetString_Params params;
	params.Switch = Switch;
	params.bPRI1HUD = bPRI1HUD;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ToggleHUD.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ToggleHUD::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ToggleHUD.GetObjClassVersion"));

	USeqAct_ToggleHUD_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ToggleCinematicMode.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_ToggleCinematicMode::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ToggleCinematicMode.Activated"));

	USeqAct_ToggleCinematicMode_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_ConsoleCommand.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_ConsoleCommand::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ConsoleCommand.GetObjClassVersion"));

	USeqAct_ConsoleCommand_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_ConsoleCommand.VersionUpdated
// (Final, Defined, Iterator, Latent, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            OldVersion                     (Parm)
// int                            NewVersion                     (Parm)

void USeqAct_ConsoleCommand::VersionUpdated(int OldVersion, int NewVersion)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ConsoleCommand.VersionUpdated"));

	USeqAct_ConsoleCommand_VersionUpdated_Params params;
	params.OldVersion = OldVersion;
	params.NewVersion = NewVersion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_SetSoundMode.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetSoundMode::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetSoundMode.GetObjClassVersion"));

	USeqAct_SetSoundMode_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetSoundMode.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_SetSoundMode::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetSoundMode.Activated"));

	USeqAct_SetSoundMode_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimNotify_PlayFaceFXAnim.Notify
// (Final, Defined, Iterator, Latent, Singular, Net, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Owner                          (Parm)
// class UAnimNodeSequence*       AnimSeqInstigator              (Parm)

void UAnimNotify_PlayFaceFXAnim::Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.AnimNotify_PlayFaceFXAnim.Notify"));

	UAnimNotify_PlayFaceFXAnim_Notify_Params params;
	params.Owner = Owner;
	params.AnimSeqInstigator = AnimSeqInstigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.AllowBroadcastLocalizedTeam
// (Final, Latent, Singular, NetReliable, Operator)
// Parameters:
// int                            TeamIndex                      (Parm)
// class AActor*                  Sender                         (Parm)
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void ABroadcastHandler::AllowBroadcastLocalizedTeam(int TeamIndex, class AActor* Sender, class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.AllowBroadcastLocalizedTeam"));

	ABroadcastHandler_AllowBroadcastLocalizedTeam_Params params;
	params.TeamIndex = TeamIndex;
	params.Sender = Sender;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.AllowBroadcastLocalized
// (Latent, Singular, NetReliable, Operator)
// Parameters:
// class AActor*                  Sender                         (Parm)
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void ABroadcastHandler::AllowBroadcastLocalized(class AActor* Sender, class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.AllowBroadcastLocalized"));

	ABroadcastHandler_AllowBroadcastLocalized_Params params;
	params.Sender = Sender;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.BroadcastTeam
// (Latent, Singular, Net, NetReliable, Exec, Event, Operator)
// Parameters:
// class AController*             Sender                         (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void ABroadcastHandler::BroadcastTeam(class AController* Sender, const struct FString& msg, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.BroadcastTeam"));

	ABroadcastHandler_BroadcastTeam_Params params;
	params.Sender = Sender;
	params.msg = msg;
	params.Type = Type;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.Broadcast
// (Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Sender                         (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void ABroadcastHandler::Broadcast(class AActor* Sender, const struct FString& msg, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.Broadcast"));

	ABroadcastHandler_Broadcast_Params params;
	params.Sender = Sender;
	params.msg = msg;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.BroadcastLocalized
// (Final, Iterator, PreOperator, Simulated, Native, HasOptionalParms)
// Parameters:
// class AActor*                  Sender                         (Parm)
// class APlayerController*       Receiver                       (Parm)
// class UClass*                  Message                        (Parm)
// int                            Switch                         (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)

void ABroadcastHandler::BroadcastLocalized(class AActor* Sender, class APlayerController* Receiver, class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.BroadcastLocalized"));

	ABroadcastHandler_BroadcastLocalized_Params params;
	params.Sender = Sender;
	params.Receiver = Receiver;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.BroadcastText
// (Final, Latent, Singular, Net, NetReliable, Exec, Event, Operator)
// Parameters:
// class APlayerReplicationInfo*  SenderPRI                      (Parm)
// class APlayerController*       Receiver                       (Parm)
// struct FString                 msg                            (Parm, CoerceParm, NeedCtorLink)
// struct FName                   Type                           (OptionalParm, Parm)

void ABroadcastHandler::BroadcastText(class APlayerReplicationInfo* SenderPRI, class APlayerController* Receiver, const struct FString& msg, const struct FName& Type)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.BroadcastText"));

	ABroadcastHandler_BroadcastText_Params params;
	params.SenderPRI = SenderPRI;
	params.Receiver = Receiver;
	params.msg = msg;
	params.Type = Type;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BroadcastHandler.AllowsBroadcast
// (Latent, PreOperator, Singular, NetReliable, Operator)
// Parameters:
// class AActor*                  broadcaster                    (Parm)
// int                            InLen                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ABroadcastHandler::AllowsBroadcast(class AActor* broadcaster, int InLen)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.AllowsBroadcast"));

	ABroadcastHandler_AllowsBroadcast_Params params;
	params.broadcaster = broadcaster;
	params.InLen = InLen;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BroadcastHandler.UpdateSentText
// (Defined, PreOperator, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)

void ABroadcastHandler::UpdateSentText()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.BroadcastHandler.UpdateSentText"));

	ABroadcastHandler_UpdateSentText_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HttpFactory.CreateRequest
// (Final, Iterator, PreOperator, Exec, Static)
// Parameters:
// class UHttpRequestInterface*   ReturnValue                    (Parm, OutParm, ReturnParm)

class UHttpRequestInterface* UHttpFactory::STATIC_CreateRequest()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HttpFactory.CreateRequest"));

	UHttpFactory_CreateRequest_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystemKVSInterface.WriteKeyValue
// (Final, Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SaveSlotIndex                  (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// struct FPlatformInterfaceData  Value                          (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystemKVSInterface::WriteKeyValue(int SaveSlotIndex, const struct FString& KeyName, struct FPlatformInterfaceData* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemKVSInterface.WriteKeyValue"));

	UCloudSaveSystemKVSInterface_WriteKeyValue_Params params;
	params.SaveSlotIndex = SaveSlotIndex;
	params.KeyName = KeyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystemKVSInterface.ReadKeyValue
// (Final, Defined, Iterator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SaveSlotIndex                  (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// TEnumAsByte<EPlatformInterfaceDataType> Type                           (Parm)
// struct FPlatformInterfaceDelegateResult Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystemKVSInterface::ReadKeyValue(int SaveSlotIndex, const struct FString& KeyName, TEnumAsByte<EPlatformInterfaceDataType> Type, struct FPlatformInterfaceDelegateResult* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemKVSInterface.ReadKeyValue"));

	UCloudSaveSystemKVSInterface_ReadKeyValue_Params params;
	params.SaveSlotIndex = SaveSlotIndex;
	params.KeyName = KeyName;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.DeleteDataBlob
// (Final, Defined, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FScriptDelegate         InDeleteDataBlobCallback       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudSaveSystemDataBlobStoreInterface::STATIC_DeleteDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& InDeleteDataBlobCallback)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.DeleteDataBlob"));

	UCloudSaveSystemDataBlobStoreInterface_DeleteDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.InDeleteDataBlobCallback = InDeleteDataBlobCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.DeleteDataBlobCallbackDelegate
// (Final, Iterator, Latent, Singular, Net, Native, Static)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystemDataBlobStoreInterface::STATIC_DeleteDataBlobCallbackDelegate(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.DeleteDataBlobCallbackDelegate"));

	UCloudSaveSystemDataBlobStoreInterface_DeleteDataBlobCallbackDelegate_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.SetDataBlob
// (Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// TArray<unsigned char>          DataBlob                       (Const, Parm, OutParm, NeedCtorLink)
// struct FScriptDelegate         InSetDataBlobCallback          (Parm, NeedCtorLink)

void UCloudSaveSystemDataBlobStoreInterface::SetDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& InSetDataBlobCallback, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.SetDataBlob"));

	UCloudSaveSystemDataBlobStoreInterface_SetDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.InSetDataBlobCallback = InSetDataBlobCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.SetDataBlobCallbackDelegate
// (Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystemDataBlobStoreInterface::SetDataBlobCallbackDelegate(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.SetDataBlobCallbackDelegate"));

	UCloudSaveSystemDataBlobStoreInterface_SetDataBlobCallbackDelegate_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.GetDataBlob
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FScriptDelegate         OnGetDataBlobComplete          (Parm, NeedCtorLink)

void UCloudSaveSystemDataBlobStoreInterface::STATIC_GetDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& OnGetDataBlobComplete)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.GetDataBlob"));

	UCloudSaveSystemDataBlobStoreInterface_GetDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.OnGetDataBlobComplete = OnGetDataBlobComplete;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CloudSaveSystemDataBlobStoreInterface.GetDataBlobCallbackDelegate
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// TArray<unsigned char>          DataBlob                       (Const, Parm, OutParm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UCloudSaveSystemDataBlobStoreInterface::STATIC_GetDataBlobCallbackDelegate(bool bWasSuccessful, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudSaveSystemDataBlobStoreInterface.GetDataBlobCallbackDelegate"));

	UCloudSaveSystemDataBlobStoreInterface_GetDataBlobCallbackDelegate_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.CloudStorageBaseCloudSaveSystemKVS.GenerateKeyNameForSaveSlot
// (Defined, Latent, Singular, Simulated, Native, Event, Static)
// Parameters:
// int                            SaveSlotIndex                  (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UCloudStorageBaseCloudSaveSystemKVS::STATIC_GenerateKeyNameForSaveSlot(int SaveSlotIndex, const struct FString& KeyName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBaseCloudSaveSystemKVS.GenerateKeyNameForSaveSlot"));

	UCloudStorageBaseCloudSaveSystemKVS_GenerateKeyNameForSaveSlot_Params params;
	params.SaveSlotIndex = SaveSlotIndex;
	params.KeyName = KeyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBaseCloudSaveSystemKVS.WriteKeyValue
// (Final, Defined, PreOperator, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SaveSlotIndex                  (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// struct FPlatformInterfaceData  Value                          (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBaseCloudSaveSystemKVS::WriteKeyValue(int SaveSlotIndex, const struct FString& KeyName, struct FPlatformInterfaceData* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBaseCloudSaveSystemKVS.WriteKeyValue"));

	UCloudStorageBaseCloudSaveSystemKVS_WriteKeyValue_Params params;
	params.SaveSlotIndex = SaveSlotIndex;
	params.KeyName = KeyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBaseCloudSaveSystemKVS.ReadKeyValue
// (Final, Defined, Iterator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// int                            SaveSlotIndex                  (Parm)
// struct FString                 KeyName                        (Parm, NeedCtorLink)
// TEnumAsByte<EPlatformInterfaceDataType> Type                           (Parm)
// struct FPlatformInterfaceDelegateResult Value                          (Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UCloudStorageBaseCloudSaveSystemKVS::ReadKeyValue(int SaveSlotIndex, const struct FString& KeyName, TEnumAsByte<EPlatformInterfaceDataType> Type, struct FPlatformInterfaceDelegateResult* Value)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBaseCloudSaveSystemKVS.ReadKeyValue"));

	UCloudStorageBaseCloudSaveSystemKVS_ReadKeyValue_Params params;
	params.SaveSlotIndex = SaveSlotIndex;
	params.KeyName = KeyName;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.CloudStorageBaseCloudSaveSystemKVS.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// class UCloudStorageBase*       InCloudStorage                 (Parm)

void UCloudStorageBaseCloudSaveSystemKVS::Init(class UCloudStorageBase* InCloudStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.CloudStorageBaseCloudSaveSystemKVS.Init"));

	UCloudStorageBaseCloudSaveSystemKVS_Init_Params params;
	params.InCloudStorage = InCloudStorage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ColorScaleVolume.UnTouch
// (Final, Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AColorScaleVolume::UnTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ColorScaleVolume.UnTouch"));

	AColorScaleVolume_UnTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ColorScaleVolume.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AColorScaleVolume::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ColorScaleVolume.Touch"));

	AColorScaleVolume_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VolumeTimer.Timer
// (Defined, Latent, PreOperator, Singular, NetReliable, Native)

void AVolumeTimer::Timer()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.VolumeTimer.Timer"));

	AVolumeTimer_Timer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VolumeTimer.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AVolumeTimer::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.VolumeTimer.PostBeginPlay"));

	AVolumeTimer_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicPhysicsVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADynamicPhysicsVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicPhysicsVolume.PostBeginPlay"));

	ADynamicPhysicsVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DynamicTriggerVolume.PostBeginPlay
// (Final, Latent, Net, Simulated)

void ADynamicTriggerVolume::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.DynamicTriggerVolume.PostBeginPlay"));

	ADynamicTriggerVolume_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFog.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AExponentialHeightFog::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ExponentialHeightFog.OnToggle"));

	AExponentialHeightFog_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFog.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AExponentialHeightFog::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ExponentialHeightFog.ReplicatedEvent"));

	AExponentialHeightFog_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFog.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AExponentialHeightFog::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ExponentialHeightFog.PostBeginPlay"));

	AExponentialHeightFog_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FailedConnect.GetString
// (Final, Defined, PreOperator, Singular, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// int                            Switch                         (OptionalParm, Parm)
// bool                           bPRI1HUD                       (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_2                   (OptionalParm, Parm)
// class APlayerReplicationInfo*  RelatedPRI_3                   (OptionalParm, Parm)
// class UObject*                 OptionalObject                 (OptionalParm, Parm)
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString UFailedConnect::STATIC_GetString(int Switch, bool bPRI1HUD, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FailedConnect.GetString"));

	UFailedConnect_GetString_Params params;
	params.Switch = Switch;
	params.bPRI1HUD = bPRI1HUD;
	params.RelatedPRI_2 = RelatedPRI_2;
	params.RelatedPRI_3 = RelatedPRI_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.FailedConnect.GetFailSwitch
// (Final, Iterator, PreOperator, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 FailString                     (Parm, NeedCtorLink)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UFailedConnect::STATIC_GetFailSwitch(const struct FString& FailString)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.FailedConnect.GetFailSwitch"));

	UFailedConnect_GetFailSwitch_Params params;
	params.FailString = FailString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HeightFog.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AHeightFog::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HeightFog.OnToggle"));

	AHeightFog_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HeightFog.ReplicatedEvent
// (Iterator, Latent, PreOperator, Singular, Net, Exec, Native, HasOptionalParms)
// Parameters:
// struct FName                   VarName                        (Parm)

void AHeightFog::ReplicatedEvent(const struct FName& VarName)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HeightFog.ReplicatedEvent"));

	AHeightFog_ReplicatedEvent_Params params;
	params.VarName = VarName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HeightFog.PostBeginPlay
// (Final, Latent, Net, Simulated)

void AHeightFog::PostBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.HeightFog.PostBeginPlay"));

	AHeightFog_PostBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineEventsInterface.UpdatePlaylistPopulation
// (Final, Iterator, Latent, Singular, Net, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// int                            PlaylistId                     (Parm)
// int                            NumPlayers                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineEventsInterface::UpdatePlaylistPopulation(int PlaylistId, int NumPlayers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventsInterface.UpdatePlaylistPopulation"));

	UOnlineEventsInterface_UpdatePlaylistPopulation_Params params;
	params.PlaylistId = PlaylistId;
	params.NumPlayers = NumPlayers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineEventsInterface.UploadGameplayEventsData
// (Final, Iterator, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            UniqueId                       (Parm)
// TArray<unsigned char>          Payload                        (Const, Parm, OutParm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineEventsInterface::UploadGameplayEventsData(const struct FUniqueNetId& UniqueId, TArray<unsigned char>* Payload)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventsInterface.UploadGameplayEventsData"));

	UOnlineEventsInterface_UploadGameplayEventsData_Params params;
	params.UniqueId = UniqueId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Payload != nullptr)
		*Payload = params.Payload;

	return params.ReturnValue;
}


// Function Engine.OnlineEventsInterface.UploadPlayerData
// (Defined, Iterator, NetReliable, Simulated, Exec, Native, Event, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            UniqueId                       (Parm)
// struct FString                 PlayerNick                     (Parm, NeedCtorLink)
// class UOnlineProfileSettings*  ProfileSettings                (Parm)
// class UOnlinePlayerStorage*    PlayerStorage                  (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineEventsInterface::UploadPlayerData(const struct FUniqueNetId& UniqueId, const struct FString& PlayerNick, class UOnlineProfileSettings* ProfileSettings, class UOnlinePlayerStorage* PlayerStorage)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineEventsInterface.UploadPlayerData"));

	UOnlineEventsInterface_UploadPlayerData_Params params;
	params.UniqueId = UniqueId;
	params.PlayerNick = PlayerNick;
	params.ProfileSettings = ProfileSettings;
	params.PlayerStorage = PlayerStorage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.ClearOnChunkCompleteDelegate
// (PreOperator, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineGameDownloadInterface::ClearOnChunkCompleteDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.ClearOnChunkCompleteDelegate"));

	UOnlineGameDownloadInterface_ClearOnChunkCompleteDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.AddOnChunkCompleteDelegate
// (Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FScriptDelegate         InDelegate                     (Parm, NeedCtorLink)

void UOnlineGameDownloadInterface::AddOnChunkCompleteDelegate(const struct FScriptDelegate& InDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.AddOnChunkCompleteDelegate"));

	UOnlineGameDownloadInterface_AddOnChunkCompleteDelegate_Params params;
	params.InDelegate = InDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.OnChunkComplete
// (Latent, NetReliable, Native, Event, Operator, Static)
// Parameters:
// int                            ChunkIndex                     (Const, Parm)

void UOnlineGameDownloadInterface::STATIC_OnChunkComplete(int ChunkIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.OnChunkComplete"));

	UOnlineGameDownloadInterface_OnChunkComplete_Params params;
	params.ChunkIndex = ChunkIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.SetDownloadSpeed
// (Defined, PreOperator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TEnumAsByte<EDownloadSpeed>    InSpeed                        (Const, Parm)

void UOnlineGameDownloadInterface::SetDownloadSpeed(TEnumAsByte<EDownloadSpeed> InSpeed)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.SetDownloadSpeed"));

	UOnlineGameDownloadInterface_SetDownloadSpeed_Params params;
	params.InSpeed = InSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.SetChunksHighPriority
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<int>                    ChunkIndices                   (Const, Parm, NeedCtorLink)

void UOnlineGameDownloadInterface::SetChunksHighPriority(TArray<int> ChunkIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.SetChunksHighPriority"));

	UOnlineGameDownloadInterface_SetChunksHighPriority_Params params;
	params.ChunkIndices = ChunkIndices;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.GetTodoList
// (Final, Iterator, Latent, PreOperator, Simulated, Exec, Native, Event, Static)
// Parameters:
// TArray<int>                    ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

TArray<int> UOnlineGameDownloadInterface::STATIC_GetTodoList()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetTodoList"));

	UOnlineGameDownloadInterface_GetTodoList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.GetOverallProgress
// (Final, Defined, Iterator, Singular, Net, Exec, Native, Event, Static)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UOnlineGameDownloadInterface::STATIC_GetOverallProgress()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetOverallProgress"));

	UOnlineGameDownloadInterface_GetOverallProgress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.GetChunksProgress
// (Iterator, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<int>                    ChunkIndices                   (Const, Parm, NeedCtorLink)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UOnlineGameDownloadInterface::STATIC_GetChunksProgress(TArray<int> ChunkIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetChunksProgress"));

	UOnlineGameDownloadInterface_GetChunksProgress_Params params;
	params.ChunkIndices = ChunkIndices;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.GetChunkProgress
// (Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            InChunkIndex                   (Const, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UOnlineGameDownloadInterface::STATIC_GetChunkProgress(int InChunkIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetChunkProgress"));

	UOnlineGameDownloadInterface_GetChunkProgress_Params params;
	params.InChunkIndex = InChunkIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.GetChunksETA
// (Final, Defined, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// TArray<int>                    ChunkIndices                   (Const, Parm, NeedCtorLink)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UOnlineGameDownloadInterface::STATIC_GetChunksETA(TArray<int> ChunkIndices)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetChunksETA"));

	UOnlineGameDownloadInterface_GetChunksETA_Params params;
	params.ChunkIndices = ChunkIndices;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.GetChunkETA
// (Final, Latent, PreOperator, Singular, Net, Simulated, Native, Event, Static)
// Parameters:
// int                            InChunkIndex                   (Const, Parm)
// float                          ReturnValue                    (Parm, OutParm, ReturnParm)

float UOnlineGameDownloadInterface::STATIC_GetChunkETA(int InChunkIndex)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.GetChunkETA"));

	UOnlineGameDownloadInterface_GetChunkETA_Params params;
	params.InChunkIndex = InChunkIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.RefreshGame
// (Final, Defined, Iterator, Latent, Singular, NetReliable, Simulated, Exec, HasOptionalParms)

void UOnlineGameDownloadInterface::RefreshGame()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.RefreshGame"));

	UOnlineGameDownloadInterface_RefreshGame_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineGameDownloadInterface.DoesGameNeedRefresh
// (Final, Defined, Latent, PreOperator, Net, NetReliable, Simulated, Native, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDownloadInterface::STATIC_DoesGameNeedRefresh()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.DoesGameNeedRefresh"));

	UOnlineGameDownloadInterface_DoesGameNeedRefresh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.AreChunksComplete
// (Final, PreOperator, Net, NetReliable, Simulated, Operator)
// Parameters:
// TArray<int>                    ChunkIndices                   (Const, Parm, NeedCtorLink)
// bool                           bRequireFastAccess             (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDownloadInterface::AreChunksComplete(TArray<int> ChunkIndices, bool bRequireFastAccess)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.AreChunksComplete"));

	UOnlineGameDownloadInterface_AreChunksComplete_Params params;
	params.ChunkIndices = ChunkIndices;
	params.bRequireFastAccess = bRequireFastAccess;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.IsChunkComplete
// (Final, Defined, Iterator, PreOperator, NetReliable, Exec, Operator, Static)
// Parameters:
// int                            InChunkIndex                   (Const, Parm)
// bool                           bRequireFastAccess             (Const, Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDownloadInterface::STATIC_IsChunkComplete(int InChunkIndex, bool bRequireFastAccess)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.IsChunkComplete"));

	UOnlineGameDownloadInterface_IsChunkComplete_Params params;
	params.InChunkIndex = InChunkIndex;
	params.bRequireFastAccess = bRequireFastAccess;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineGameDownloadInterface.IsGameComplete
// (Latent, PreOperator, Singular, NetReliable, Exec, Operator, Static)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineGameDownloadInterface::STATIC_IsGameComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineGameDownloadInterface.IsGameComplete"));

	UOnlineGameDownloadInterface_IsGameComplete_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.GetCurrentPlayersListCount
// (Defined, Latent, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineRecentPlayersList::STATIC_GetCurrentPlayersListCount()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.GetCurrentPlayersListCount"));

	UOnlineRecentPlayersList_GetCurrentPlayersListCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.SetCurrentPlayersList
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// TArray<struct FCurrentPlayerMet> Players                        (Const, Parm, NeedCtorLink)

void UOnlineRecentPlayersList::SetCurrentPlayersList(TArray<struct FCurrentPlayerMet> Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.SetCurrentPlayersList"));

	UOnlineRecentPlayersList_SetCurrentPlayersList_Params params;
	params.Players = Players;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineRecentPlayersList.ShowCurrentPlayersList
// (Final, PreOperator, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Title                          (Parm, NeedCtorLink)
// struct FString                 Description                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineRecentPlayersList::ShowCurrentPlayersList(unsigned char LocalUserNum, const struct FString& Title, const struct FString& Description)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ShowCurrentPlayersList"));

	UOnlineRecentPlayersList_ShowCurrentPlayersList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Title = Title;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.ShowLastPartyPlayerList
// (Defined, Iterator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Title                          (Parm, NeedCtorLink)
// struct FString                 Description                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineRecentPlayersList::ShowLastPartyPlayerList(unsigned char LocalUserNum, const struct FString& Title, const struct FString& Description)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ShowLastPartyPlayerList"));

	UOnlineRecentPlayersList_ShowLastPartyPlayerList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Title = Title;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.ShowRecentPartiesPlayerList
// (Iterator, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Title                          (Parm, NeedCtorLink)
// struct FString                 Description                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineRecentPlayersList::ShowRecentPartiesPlayerList(unsigned char LocalUserNum, const struct FString& Title, const struct FString& Description)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ShowRecentPartiesPlayerList"));

	UOnlineRecentPlayersList_ShowRecentPartiesPlayerList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Title = Title;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.ShowRecentPlayerList
// (Final, Iterator, PreOperator, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  LocalUserNum                   (Parm)
// struct FString                 Title                          (Parm, NeedCtorLink)
// struct FString                 Description                    (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineRecentPlayersList::ShowRecentPlayerList(unsigned char LocalUserNum, const struct FString& Title, const struct FString& Description)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ShowRecentPlayerList"));

	UOnlineRecentPlayersList_ShowRecentPlayerList_Params params;
	params.LocalUserNum = LocalUserNum;
	params.Title = Title;
	params.Description = Description;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.SetLastParty
// (Final, Latent, Singular, Net, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FUniqueNetId            PartyLeader                    (Parm)
// TArray<struct FUniqueNetId>    PartyMembers                   (Const, Parm, OutParm, NeedCtorLink)

void UOnlineRecentPlayersList::SetLastParty(const struct FUniqueNetId& PartyLeader, TArray<struct FUniqueNetId>* PartyMembers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.SetLastParty"));

	UOnlineRecentPlayersList_SetLastParty_Params params;
	params.PartyLeader = PartyLeader;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PartyMembers != nullptr)
		*PartyMembers = params.PartyMembers;
}


// Function Engine.OnlineRecentPlayersList.GetTeamForCurrentPlayer
// (Iterator, Latent, Simulated, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineRecentPlayersList::STATIC_GetTeamForCurrentPlayer(const struct FUniqueNetId& Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.GetTeamForCurrentPlayer"));

	UOnlineRecentPlayersList_GetTeamForCurrentPlayer_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.GetSkillForCurrentPlayer
// (Final, Defined, Iterator, Latent, PreOperator, Net, NetReliable, Exec, Native, Event, Static)
// Parameters:
// struct FUniqueNetId            Player                         (Parm)
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int UOnlineRecentPlayersList::STATIC_GetSkillForCurrentPlayer(const struct FUniqueNetId& Player)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.GetSkillForCurrentPlayer"));

	UOnlineRecentPlayersList_GetSkillForCurrentPlayer_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineRecentPlayersList.GetPlayersFromCurrentPlayers
// (Final, Defined, Iterator, NetReliable, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FUniqueNetId>    Players                        (Parm, OutParm, NeedCtorLink)

void UOnlineRecentPlayersList::STATIC_GetPlayersFromCurrentPlayers(TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.GetPlayersFromCurrentPlayers"));

	UOnlineRecentPlayersList_GetPlayersFromCurrentPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;
}


// Function Engine.OnlineRecentPlayersList.GetPlayersFromRecentParties
// (Latent, NetReliable, Exec, Native, Event, Static)
// Parameters:
// TArray<struct FUniqueNetId>    Players                        (Parm, OutParm, NeedCtorLink)

void UOnlineRecentPlayersList::STATIC_GetPlayersFromRecentParties(TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.GetPlayersFromRecentParties"));

	UOnlineRecentPlayersList_GetPlayersFromRecentParties_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;
}


// Function Engine.OnlineRecentPlayersList.ClearRecentParties
// (Final, Defined, Iterator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)

void UOnlineRecentPlayersList::ClearRecentParties()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ClearRecentParties"));

	UOnlineRecentPlayersList_ClearRecentParties_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineRecentPlayersList.AddPartyToRecentParties
// (Final, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FUniqueNetId            PartyLeader                    (Parm)
// TArray<struct FUniqueNetId>    PartyMembers                   (Const, Parm, OutParm, NeedCtorLink)

void UOnlineRecentPlayersList::AddPartyToRecentParties(const struct FUniqueNetId& PartyLeader, TArray<struct FUniqueNetId>* PartyMembers)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.AddPartyToRecentParties"));

	UOnlineRecentPlayersList_AddPartyToRecentParties_Params params;
	params.PartyLeader = PartyLeader;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PartyMembers != nullptr)
		*PartyMembers = params.PartyMembers;
}


// Function Engine.OnlineRecentPlayersList.ClearRecentPlayers
// (Latent, Net, NetReliable, Simulated, Exec, Native, Event, Operator)

void UOnlineRecentPlayersList::ClearRecentPlayers()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.ClearRecentPlayers"));

	UOnlineRecentPlayersList_ClearRecentPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineRecentPlayersList.AddPlayerToRecentPlayers
// (Defined, Iterator, Singular, Net, NetReliable, Simulated, Exec, Native, Event)
// Parameters:
// struct FUniqueNetId            NewPlayer                      (Parm)

void UOnlineRecentPlayersList::AddPlayerToRecentPlayers(const struct FUniqueNetId& NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineRecentPlayersList.AddPlayerToRecentPlayers"));

	UOnlineRecentPlayersList_AddPlayerToRecentPlayers_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSuppliedUIInterface.ShowMatchmakingUI
// (Latent, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// unsigned char                  SearchingPlayerNum             (Parm)
// class UOnlineGameSearch*       SearchSettings                 (Parm)
// class UOnlineGameSettings*     GameSettings                   (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSuppliedUIInterface::ShowMatchmakingUI(unsigned char SearchingPlayerNum, class UOnlineGameSearch* SearchSettings, class UOnlineGameSettings* GameSettings)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSuppliedUIInterface.ShowMatchmakingUI"));

	UOnlineSuppliedUIInterface_ShowMatchmakingUI_Params params;
	params.SearchingPlayerNum = SearchingPlayerNum;
	params.SearchSettings = SearchSettings;
	params.GameSettings = GameSettings;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.OnlineSuppliedUIInterface.ClearShowOnlineStatsUICompleteDelegate
// (Iterator, Latent, PreOperator, Net, NetReliable, Simulated, Exec, Native, Event, Operator)
// Parameters:
// struct FScriptDelegate         ShowOnlineStatsUICompleteDelegate (Parm, NeedCtorLink)

void UOnlineSuppliedUIInterface::ClearShowOnlineStatsUICompleteDelegate(const struct FScriptDelegate& ShowOnlineStatsUICompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSuppliedUIInterface.ClearShowOnlineStatsUICompleteDelegate"));

	UOnlineSuppliedUIInterface_ClearShowOnlineStatsUICompleteDelegate_Params params;
	params.ShowOnlineStatsUICompleteDelegate = ShowOnlineStatsUICompleteDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSuppliedUIInterface.AddShowOnlineStatsUICompleteDelegate
// (Iterator, Latent, Singular, Operator)
// Parameters:
// struct FScriptDelegate         ShowOnlineStatsUICompleteDelegate (Parm, NeedCtorLink)

void UOnlineSuppliedUIInterface::AddShowOnlineStatsUICompleteDelegate(const struct FScriptDelegate& ShowOnlineStatsUICompleteDelegate)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSuppliedUIInterface.AddShowOnlineStatsUICompleteDelegate"));

	UOnlineSuppliedUIInterface_AddShowOnlineStatsUICompleteDelegate_Params params;
	params.ShowOnlineStatsUICompleteDelegate = ShowOnlineStatsUICompleteDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineSuppliedUIInterface.ShowOnlineStatsUI
// (Final, Iterator, Latent, Singular, Simulated, Event, HasOptionalParms)
// Parameters:
// TArray<struct FUniqueNetId>    Players                        (Const, Parm, OutParm, NeedCtorLink)
// class UOnlineStatsRead*        StatsRead                      (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UOnlineSuppliedUIInterface::ShowOnlineStatsUI(class UOnlineStatsRead* StatsRead, TArray<struct FUniqueNetId>* Players)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSuppliedUIInterface.ShowOnlineStatsUI"));

	UOnlineSuppliedUIInterface_ShowOnlineStatsUI_Params params;
	params.StatsRead = StatsRead;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Players != nullptr)
		*Players = params.Players;

	return params.ReturnValue;
}


// Function Engine.OnlineSuppliedUIInterface.OnShowOnlineStatsUIComplete
// (Defined, Iterator, Latent, Simulated, Native, Event, Operator, Static)

void UOnlineSuppliedUIInterface::STATIC_OnShowOnlineStatsUIComplete()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.OnlineSuppliedUIInterface.OnShowOnlineStatsUIComplete"));

	UOnlineSuppliedUIInterface_OnShowOnlineStatsUIComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PathNode_Dynamic.GetDebugAbbrev
// (Final, Defined, Latent, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ReturnParm, NeedCtorLink)

struct FString APathNode_Dynamic::GetDebugAbbrev()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.PathNode_Dynamic.GetDebugAbbrev"));

	APathNode_Dynamic_GetDebugAbbrev_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ReverbVolumeToggleable.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          Action                         (Parm)

void AReverbVolumeToggleable::STATIC_OnToggle(class USeqAct_Toggle* Action)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.ReverbVolumeToggleable.OnToggle"));

	AReverbVolumeToggleable_OnToggle_Params params;
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_ConcatenateStrings.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_ConcatenateStrings::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_ConcatenateStrings.Activated"));

	USeqAct_ConcatenateStrings_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_MITV_Activate.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_MITV_Activate::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_MITV_Activate.Activated"));

	USeqAct_MITV_Activate_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_MITV_Activate.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_MITV_Activate::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_MITV_Activate.GetObjClassVersion"));

	USeqAct_MITV_Activate_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetMatInstVectorParam.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_SetMatInstVectorParam::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetMatInstVectorParam.GetObjClassVersion"));

	USeqAct_SetMatInstVectorParam_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqAct_SetVector.Activated
// (Final, Defined, Latent, PreOperator, Singular, Net, NetReliable, Native, HasOptionalParms)

void USeqAct_SetVector::Activated()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_SetVector.Activated"));

	USeqAct_SetVector_Activated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SeqAct_UpdatePhysBonesFromAnim.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqAct_UpdatePhysBonesFromAnim::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqAct_UpdatePhysBonesFromAnim.GetObjClassVersion"));

	USeqAct_UpdatePhysBonesFromAnim_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SeqEvent_LOS.GetObjClassVersion
// (Final, Iterator, Latent, PreOperator, NetReliable, Simulated, Native, HasOptionalParms)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ReturnParm)

int USeqEvent_LOS::GetObjClassVersion()
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.SeqEvent_LOS.GetObjClassVersion"));

	USeqEvent_LOS_GetObjClassVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Trigger_LOS.Tick
// (Final, Iterator, Latent, PreOperator, Singular, Simulated)
// Parameters:
// float                          DeltaTime                      (Parm)

void ATrigger_LOS::Tick(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.Trigger_LOS.Tick"));

	ATrigger_LOS_Tick_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TriggeredPath.SuggestMovePreparation
// (Defined, Iterator, PreOperator, Singular, Net, NetReliable, Exec, Native, HasOptionalParms)
// Parameters:
// class APawn*                   Other                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool ATriggeredPath::SuggestMovePreparation(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggeredPath.SuggestMovePreparation"));

	ATriggeredPath_SuggestMovePreparation_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TriggeredPath.SpecialHandling
// (Final, Defined, Net, Simulated)
// Parameters:
// class APawn*                   Other                          (Parm)
// class AActor*                  ReturnValue                    (Parm, OutParm, ReturnParm)

class AActor* ATriggeredPath::SpecialHandling(class APawn* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggeredPath.SpecialHandling"));

	ATriggeredPath_SpecialHandling_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TriggeredPath.OnToggle
// (Final, Iterator, PreOperator, Simulated, Native, Event, Operator, Static)
// Parameters:
// class USeqAct_Toggle*          inAction                       (Parm)

void ATriggeredPath::STATIC_OnToggle(class USeqAct_Toggle* inAction)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggeredPath.OnToggle"));

	ATriggeredPath_OnToggle_Params params;
	params.inAction = inAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TriggerStreamingLevel.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void ATriggerStreamingLevel::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.TriggerStreamingLevel.Touch"));

	ATriggerStreamingLevel_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnDeleteUserFileComplete
// (Final, Singular, Net, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_OnDeleteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnDeleteUserFileComplete"));

	UUserCloudFileCloudSaveSystemDataBlobStore_OnDeleteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.DeleteDataBlob
// (Final, Defined, Latent, Singular, Net, Native, Static)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FScriptDelegate         InDeleteDataBlobCallback       (Parm, NeedCtorLink)
// bool                           ReturnValue                    (Parm, OutParm, ReturnParm)

bool UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_DeleteDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& InDeleteDataBlobCallback)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.DeleteDataBlob"));

	UUserCloudFileCloudSaveSystemDataBlobStore_DeleteDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.InDeleteDataBlobCallback = InDeleteDataBlobCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnWriteUserFileComplete
// (Final, Latent, PreOperator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_OnWriteUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnWriteUserFileComplete"));

	UUserCloudFileCloudSaveSystemDataBlobStore_OnWriteUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.SetDataBlob
// (Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// TArray<unsigned char>          DataBlob                       (Const, Parm, OutParm, NeedCtorLink)
// struct FScriptDelegate         InSetDataBlobCallback          (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::SetDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& InSetDataBlobCallback, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.SetDataBlob"));

	UUserCloudFileCloudSaveSystemDataBlobStore_SetDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.InSetDataBlobCallback = InSetDataBlobCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnReadUserFileComplete
// (Final, Iterator, Exec, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 UserId                         (Parm, NeedCtorLink)
// struct FString                 Filename                       (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_OnReadUserFileComplete(bool bWasSuccessful, const struct FString& UserId, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.OnReadUserFileComplete"));

	UUserCloudFileCloudSaveSystemDataBlobStore_OnReadUserFileComplete_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.UserId = UserId;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.GetDataBlob
// (Final, Defined, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FScriptDelegate         InGetDataBlobCallback          (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_GetDataBlob(const struct FString& StorageID, const struct FString& BlobName, const struct FScriptDelegate& InGetDataBlobCallback)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.GetDataBlob"));

	UUserCloudFileCloudSaveSystemDataBlobStore_GetDataBlob_Params params;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.InGetDataBlobCallback = InGetDataBlobCallback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.Init
// (Defined, Latent, PreOperator, Singular, Net, NetReliable, Exec)
// Parameters:
// TScriptInterface<class UUserCloudFileInterface> InUserCloudFile                (Parm)

void UUserCloudFileCloudSaveSystemDataBlobStore::Init(const TScriptInterface<class UUserCloudFileInterface>& InUserCloudFile)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.Init"));

	UUserCloudFileCloudSaveSystemDataBlobStore_Init_Params params;
	params.InUserCloudFile = InUserCloudFile;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.DeleteDataBlobCallbackDelegate
// (Final, Iterator, Latent, Singular, Net, Native, Static)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_DeleteDataBlobCallbackDelegate(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.DeleteDataBlobCallbackDelegate"));

	UUserCloudFileCloudSaveSystemDataBlobStore_DeleteDataBlobCallbackDelegate_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.SetDataBlobCallbackDelegate
// (Defined, Iterator, Singular, NetReliable, Simulated, Exec, Native, HasOptionalParms)
// Parameters:
// bool                           bWasSucessfull                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::SetDataBlobCallbackDelegate(bool bWasSucessfull, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.SetDataBlobCallbackDelegate"));

	UUserCloudFileCloudSaveSystemDataBlobStore_SetDataBlobCallbackDelegate_Params params;
	params.bWasSucessfull = bWasSucessfull;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.GetDataBlobCallbackDelegate
// (Final, Iterator, PreOperator, Singular, NetReliable, Simulated, Native, Event, Static)
// Parameters:
// bool                           bWasSuccessful                 (Parm)
// struct FString                 StorageID                      (Parm, NeedCtorLink)
// struct FString                 BlobName                       (Parm, NeedCtorLink)
// TArray<unsigned char>          DataBlob                       (Parm, OutParm, NeedCtorLink)
// struct FString                 Error                          (Parm, NeedCtorLink)

void UUserCloudFileCloudSaveSystemDataBlobStore::STATIC_GetDataBlobCallbackDelegate(bool bWasSuccessful, const struct FString& StorageID, const struct FString& BlobName, const struct FString& Error, TArray<unsigned char>* DataBlob)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.UserCloudFileCloudSaveSystemDataBlobStore.GetDataBlobCallbackDelegate"));

	UUserCloudFileCloudSaveSystemDataBlobStore_GetDataBlobCallbackDelegate_Params params;
	params.bWasSuccessful = bWasSuccessful;
	params.StorageID = StorageID;
	params.BlobName = BlobName;
	params.Error = Error;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DataBlob != nullptr)
		*DataBlob = params.DataBlob;
}


// Function Engine.WaterVolume.PlayExitSplash
// (Latent, PreOperator, NetReliable, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AWaterVolume::PlayExitSplash(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WaterVolume.PlayExitSplash"));

	AWaterVolume_PlayExitSplash_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WaterVolume.UnTouch
// (Final, Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)

void AWaterVolume::UnTouch(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WaterVolume.UnTouch"));

	AWaterVolume_UnTouch_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WaterVolume.PlayEntrySplash
// (PreOperator, Net, HasOptionalParms)
// Parameters:
// class AActor*                  Other                          (Parm)

void AWaterVolume::PlayEntrySplash(class AActor* Other)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WaterVolume.PlayEntrySplash"));

	AWaterVolume_PlayEntrySplash_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WaterVolume.Touch
// (Defined, PreOperator, Singular, Simulated)
// Parameters:
// class AActor*                  Other                          (Parm)
// class UPrimitiveComponent*     OtherComp                      (Parm, EditInline)
// struct FVector                 HitLocation                    (Parm)
// struct FVector                 HitNormal                      (Parm)

void AWaterVolume::Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static auto fn = UObject::FindObject<UFunction>(_xor_("Function Engine.WaterVolume.Touch"));

	AWaterVolume_Touch_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
